{
  "language": "go_test.go",
  "name": "HumanEval_19_sort_numbers",
  "results": [
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \",\")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp_va19c4t_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \"\\r\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpxt1ojepo_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]int, len(numbers))\n    for i, number := range numbers {\n        numbers[i] = int(number)\n    }\n    sort.Ints(numbers)\n    numbers := make([]string, len(numbers))\n    for i, number := range numbers {\n        numbers[i] = fmt.Sprintf(\"%d\", number)\n    }\n    return strings.Join(numbers, \" \")\n}\n</code>\n<|/ a tags=go |>\n<| a tags=go |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpha6phim3_test.go:26:1: expected declaration, found '<'\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxpew7rkm_test.go:14:15: undefined: strings\n/tmp/tmpxpew7rkm_test.go:15:13: no new variables on left side of :=\n/tmp/tmpxpew7rkm_test.go:15:16: undefined: strings\n/tmp/tmpxpew7rkm_test.go:16:5: undefined: sort\n/tmp/tmpxpew7rkm_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1d4e0idi_test.go:14:15: undefined: strings\n/tmp/tmp1d4e0idi_test.go:15:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:15:16: undefined: strings\n/tmp/tmp1d4e0idi_test.go:16:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmp1d4e0idi_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := append(numbers, numbers...)\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ijozzcl_test.go:14:13: no new variables on left side of :=\n/tmp/tmp6ijozzcl_test.go:14:16: undefined: strings\n/tmp/tmp6ijozzcl_test.go:15:13: no new variables on left side of :=\n/tmp/tmp6ijozzcl_test.go:15:23: first argument to append must be a slice; have numbers (variable of type string)\n/tmp/tmp6ijozzcl_test.go:16:5: undefined: sort\n/tmp/tmp6ijozzcl_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.TrimSpace(numbers)\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2caqar3g_test.go:14:13: no new variables on left side of :=\n/tmp/tmp2caqar3g_test.go:14:16: undefined: strings\n/tmp/tmp2caqar3g_test.go:15:13: no new variables on left side of :=\n/tmp/tmp2caqar3g_test.go:15:16: undefined: strings\n/tmp/tmp2caqar3g_test.go:16:13: no new variables on left side of :=\n/tmp/tmp2caqar3g_test.go:16:16: undefined: strings\n/tmp/tmp2caqar3g_test.go:17:13: no new variables on left side of :=\n/tmp/tmp2caqar3g_test.go:17:16: undefined: sort_numbers_test\n/tmp/tmp2caqar3g_test.go:18:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]int, len(numbers))\n    for i := range numbers {\n        numbers[i] = int(numbers[i])\n    }\n    sort.Ints(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7ipgwro1_test.go:14:13: no new variables on left side of :=\n/tmp/tmp7ipgwro1_test.go:14:16: undefined: strings\n/tmp/tmp7ipgwro1_test.go:15:13: no new variables on left side of :=\n/tmp/tmp7ipgwro1_test.go:15:16: cannot use make([]int, len(numbers)) (value of type []int) as type string in assignment\n/tmp/tmp7ipgwro1_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmp7ipgwro1_test.go:19:5: undefined: sort\n/tmp/tmp7ipgwro1_test.go:20:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6q9913am_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1d4e0idi_test.go:14:15: undefined: strings\n/tmp/tmp1d4e0idi_test.go:15:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:15:16: undefined: strings\n/tmp/tmp1d4e0idi_test.go:16:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmp1d4e0idi_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(number\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp23xx0gj1_test.go:68:29: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1d4e0idi_test.go:14:15: undefined: strings\n/tmp/tmp1d4e0idi_test.go:15:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:15:16: undefined: strings\n/tmp/tmp1d4e0idi_test.go:16:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmp1d4e0idi_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpw8r2hp9i_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpixbl9e4j_test.go:14:15: undefined: strings\n/tmp/tmpixbl9e4j_test.go:15:13: no new variables on left side of :=\n/tmp/tmpixbl9e4j_test.go:15:16: undefined: strings\n/tmp/tmpixbl9e4j_test.go:16:5: undefined: sort\n/tmp/tmpixbl9e4j_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]int, len(numbers))\n    for i := range numbers {\n        numbers[i] = int(numbers[i])\n    }\n    sort.Ints(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7ipgwro1_test.go:14:13: no new variables on left side of :=\n/tmp/tmp7ipgwro1_test.go:14:16: undefined: strings\n/tmp/tmp7ipgwro1_test.go:15:13: no new variables on left side of :=\n/tmp/tmp7ipgwro1_test.go:15:16: cannot use make([]int, len(numbers)) (value of type []int) as type string in assignment\n/tmp/tmp7ipgwro1_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmp7ipgwro1_test.go:19:5: undefined: sort\n/tmp/tmp7ipgwro1_test.go:20:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1d4e0idi_test.go:14:15: undefined: strings\n/tmp/tmp1d4e0idi_test.go:15:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:15:16: undefined: strings\n/tmp/tmp1d4e0idi_test.go:16:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmp1d4e0idi_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3yvca3m_test.go:14:15: undefined: strings\n/tmp/tmpv3yvca3m_test.go:15:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:15:16: undefined: strings\n/tmp/tmpv3yvca3m_test.go:16:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpv3yvca3m_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.TrimSpace(numbers)\n    numbers := strings.Replace(numbers, \" \", \"\", -1)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0q__2v77_test.go:14:13: no new variables on left side of :=\n/tmp/tmp0q__2v77_test.go:14:16: undefined: strings\n/tmp/tmp0q__2v77_test.go:15:13: no new variables on left side of :=\n/tmp/tmp0q__2v77_test.go:15:16: undefined: strings\n/tmp/tmp0q__2v77_test.go:16:13: no new variables on left side of :=\n/tmp/tmp0q__2v77_test.go:16:16: undefined: strings\n/tmp/tmp0q__2v77_test.go:17:13: no new variables on left side of :=\n/tmp/tmp0q__2v77_test.go:17:16: undefined: sort_numbers_test\n/tmp/tmp0q__2v77_test.go:18:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    number\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmposgyu2gg_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \",\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpyl654a4m_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpixbl9e4j_test.go:14:15: undefined: strings\n/tmp/tmpixbl9e4j_test.go:15:13: no new variables on left side of :=\n/tmp/tmpixbl9e4j_test.go:15:16: undefined: strings\n/tmp/tmpixbl9e4j_test.go:16:5: undefined: sort\n/tmp/tmpixbl9e4j_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \",\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\r\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\t\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\r\")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\t\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\r\")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\t\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\r\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\t\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\r\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\t\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\r\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\t\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\r\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\t\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\r\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\t\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\r\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\t\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\r\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\t\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\r\")\n    numbers = strings.Trim(numbers, \" \")\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp543wu4eg_test.go:64:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu419zbak_test.go:14:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:14:16: undefined: strings\n/tmp/tmpu419zbak_test.go:15:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:15:16: undefined: strings\n/tmp/tmpu419zbak_test.go:16:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpu419zbak_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    number\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3qurvw_f_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    number\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp8j15q8ri_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \"\\r\")\n    numbers = strings.Trim(numbers, \"\\t\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpsyd26j0h_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]string, len(numbers))\n    for i := range numbers {\n        numbers[i] = numbers[i] + \"0\"\n    }\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpliudt2wi_test.go:14:13: no new variables on left side of :=\n/tmp/tmpliudt2wi_test.go:14:16: undefined: strings\n/tmp/tmpliudt2wi_test.go:15:13: no new variables on left side of :=\n/tmp/tmpliudt2wi_test.go:15:16: cannot use make([]string, len(numbers)) (value of type []string) as type string in assignment\n/tmp/tmpliudt2wi_test.go:17:22: invalid operation: numbers[i] + \"0\" (mismatched types byte and untyped string)\n/tmp/tmpliudt2wi_test.go:19:5: undefined: sort\n/tmp/tmpliudt2wi_test.go:20:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpixbl9e4j_test.go:14:15: undefined: strings\n/tmp/tmpixbl9e4j_test.go:15:13: no new variables on left side of :=\n/tmp/tmpixbl9e4j_test.go:15:16: undefined: strings\n/tmp/tmpixbl9e4j_test.go:16:5: undefined: sort\n/tmp/tmpixbl9e4j_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \",\")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp_va19c4t_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.TrimSpace(numbers)\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2caqar3g_test.go:14:13: no new variables on left side of :=\n/tmp/tmp2caqar3g_test.go:14:16: undefined: strings\n/tmp/tmp2caqar3g_test.go:15:13: no new variables on left side of :=\n/tmp/tmp2caqar3g_test.go:15:16: undefined: strings\n/tmp/tmp2caqar3g_test.go:16:13: no new variables on left side of :=\n/tmp/tmp2caqar3g_test.go:16:16: undefined: strings\n/tmp/tmp2caqar3g_test.go:17:13: no new variables on left side of :=\n/tmp/tmp2caqar3g_test.go:17:16: undefined: sort_numbers_test\n/tmp/tmp2caqar3g_test.go:18:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu419zbak_test.go:14:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:14:16: undefined: strings\n/tmp/tmpu419zbak_test.go:15:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:15:16: undefined: strings\n/tmp/tmpu419zbak_test.go:16:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpu419zbak_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]string, len(numbers))\n    for i, number := range numbers {\n        numbers[i] = number\n    }\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppwkozwsv_test.go:14:13: no new variables on left side of :=\n/tmp/tmppwkozwsv_test.go:14:16: undefined: strings\n/tmp/tmppwkozwsv_test.go:15:13: no new variables on left side of :=\n/tmp/tmppwkozwsv_test.go:15:16: cannot use make([]string, len(numbers)) (value of type []string) as type string in assignment\n/tmp/tmppwkozwsv_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmppwkozwsv_test.go:19:5: undefined: sort\n/tmp/tmppwkozwsv_test.go:20:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3yvca3m_test.go:14:15: undefined: strings\n/tmp/tmpv3yvca3m_test.go:15:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:15:16: undefined: strings\n/tmp/tmpv3yvca3m_test.go:16:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpv3yvca3m_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpixbl9e4j_test.go:14:15: undefined: strings\n/tmp/tmpixbl9e4j_test.go:15:13: no new variables on left side of :=\n/tmp/tmpixbl9e4j_test.go:15:16: undefined: strings\n/tmp/tmpixbl9e4j_test.go:16:5: undefined: sort\n/tmp/tmpixbl9e4j_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1d4e0idi_test.go:14:15: undefined: strings\n/tmp/tmp1d4e0idi_test.go:15:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:15:16: undefined: strings\n/tmp/tmp1d4e0idi_test.go:16:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmp1d4e0idi_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3yvca3m_test.go:14:15: undefined: strings\n/tmp/tmpv3yvca3m_test.go:15:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:15:16: undefined: strings\n/tmp/tmpv3yvca3m_test.go:16:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpv3yvca3m_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]string, len(numbers))\n    for i, number := range numbers {\n        numbers[i] = number\n    }\n    sort.Strings(numbers)\n    numbers := strings.Join(numbers, \" \")\n    return numbers\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp29v5blkr_test.go:14:13: no new variables on left side of :=\n/tmp/tmp29v5blkr_test.go:14:16: undefined: strings\n/tmp/tmp29v5blkr_test.go:15:13: no new variables on left side of :=\n/tmp/tmp29v5blkr_test.go:15:16: undefined: strings\n/tmp/tmp29v5blkr_test.go:16:13: no new variables on left side of :=\n/tmp/tmp29v5blkr_test.go:16:16: cannot use make([]string, len(numbers)) (value of type []string) as type string in assignment\n/tmp/tmp29v5blkr_test.go:18:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmp29v5blkr_test.go:20:5: undefined: sort\n/tmp/tmp29v5blkr_test.go:21:13: no new variables on left side of :=\n/tmp/tmp29v5blkr_test.go:21:16: undefined: strings\n/tmp/tmp29v5blkr_test.go:21:13: too many errors\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]string, len(numbers))\n    for i, number := range numbers {\n        numbers[i] = number\n    }\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppwkozwsv_test.go:14:13: no new variables on left side of :=\n/tmp/tmppwkozwsv_test.go:14:16: undefined: strings\n/tmp/tmppwkozwsv_test.go:15:13: no new variables on left side of :=\n/tmp/tmppwkozwsv_test.go:15:16: cannot use make([]string, len(numbers)) (value of type []string) as type string in assignment\n/tmp/tmppwkozwsv_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmppwkozwsv_test.go:19:5: undefined: sort\n/tmp/tmppwkozwsv_test.go:20:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpw8r2hp9i_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3yvca3m_test.go:14:15: undefined: strings\n/tmp/tmpv3yvca3m_test.go:15:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:15:16: undefined: strings\n/tmp/tmpv3yvca3m_test.go:16:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpv3yvca3m_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \"\\r\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmps3whxtum_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(number\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpoxy9tf_0_test.go:56:40: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp6q9913am_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3yvca3m_test.go:14:15: undefined: strings\n/tmp/tmpv3yvca3m_test.go:15:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:15:16: undefined: strings\n/tmp/tmpv3yvca3m_test.go:16:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpv3yvca3m_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3yvca3m_test.go:14:15: undefined: strings\n/tmp/tmpv3yvca3m_test.go:15:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:15:16: undefined: strings\n/tmp/tmpv3yvca3m_test.go:16:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpv3yvca3m_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \",\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpyl654a4m_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \"\\r\")\n    numbers := strings.Trim(numbers, \"\\t\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpe703fa68_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \",\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpn7yso_j7_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu419zbak_test.go:14:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:14:16: undefined: strings\n/tmp/tmpu419zbak_test.go:15:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:15:16: undefined: strings\n/tmp/tmpu419zbak_test.go:16:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpu419zbak_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmppjaxkp4z_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpixbl9e4j_test.go:14:15: undefined: strings\n/tmp/tmpixbl9e4j_test.go:15:13: no new variables on left side of :=\n/tmp/tmpixbl9e4j_test.go:15:16: undefined: strings\n/tmp/tmpixbl9e4j_test.go:16:5: undefined: sort\n/tmp/tmpixbl9e4j_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmppjaxkp4z_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.TrimSpace(numbers)\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    numbers := strings.Join(numbers, \" \")\n    return numbers\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpka671rrr_test.go:14:13: no new variables on left side of :=\n/tmp/tmpka671rrr_test.go:14:16: undefined: strings\n/tmp/tmpka671rrr_test.go:15:13: no new variables on left side of :=\n/tmp/tmpka671rrr_test.go:15:16: undefined: strings\n/tmp/tmpka671rrr_test.go:16:13: no new variables on left side of :=\n/tmp/tmpka671rrr_test.go:16:16: undefined: strings\n/tmp/tmpka671rrr_test.go:17:13: no new variables on left side of :=\n/tmp/tmpka671rrr_test.go:17:16: undefined: sort_numbers_test\n/tmp/tmpka671rrr_test.go:18:13: no new variables on left side of :=\n/tmp/tmpka671rrr_test.go:18:16: undefined: strings\n/tmp/tmpka671rrr_test.go:18:13: too many errors\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]string, len(numbers))\n    for i := range numbers {\n        numbers[i] = numbers[i][:len(numbers[i])-1]\n    }\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpssfv0l_o_test.go:14:13: no new variables on left side of :=\n/tmp/tmpssfv0l_o_test.go:14:16: undefined: strings\n/tmp/tmpssfv0l_o_test.go:15:13: no new variables on left side of :=\n/tmp/tmpssfv0l_o_test.go:15:16: undefined: strings\n/tmp/tmpssfv0l_o_test.go:16:13: no new variables on left side of :=\n/tmp/tmpssfv0l_o_test.go:16:16: cannot use make([]string, len(numbers)) (value of type []string) as type string in assignment\n/tmp/tmpssfv0l_o_test.go:18:22: invalid operation: cannot slice numbers[i] (value of type byte)\n/tmp/tmpssfv0l_o_test.go:20:5: undefined: sort\n/tmp/tmpssfv0l_o_test.go:21:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1d4e0idi_test.go:14:15: undefined: strings\n/tmp/tmp1d4e0idi_test.go:15:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:15:16: undefined: strings\n/tmp/tmp1d4e0idi_test.go:16:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmp1d4e0idi_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \"\\r\")\n    numbers := strings.Trim(numbers, \"\\t\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpe703fa68_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]int, len(numbers))\n    for i, v := range numbers {\n        numbers[i] = int(v)\n    }\n    sort.Ints(numbers)\n    numbers := strings.Join(numbers, \" \")\n    return numbers\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe9zwo_tp_test.go:14:13: no new variables on left side of :=\n/tmp/tmpe9zwo_tp_test.go:14:16: undefined: strings\n/tmp/tmpe9zwo_tp_test.go:15:13: no new variables on left side of :=\n/tmp/tmpe9zwo_tp_test.go:15:16: cannot use make([]int, len(numbers)) (value of type []int) as type string in assignment\n/tmp/tmpe9zwo_tp_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmpe9zwo_tp_test.go:19:5: undefined: sort\n/tmp/tmpe9zwo_tp_test.go:20:13: no new variables on left side of :=\n/tmp/tmpe9zwo_tp_test.go:20:16: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := append(numbers, numbers...)\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ijozzcl_test.go:14:13: no new variables on left side of :=\n/tmp/tmp6ijozzcl_test.go:14:16: undefined: strings\n/tmp/tmp6ijozzcl_test.go:15:13: no new variables on left side of :=\n/tmp/tmp6ijozzcl_test.go:15:23: first argument to append must be a slice; have numbers (variable of type string)\n/tmp/tmp6ijozzcl_test.go:16:5: undefined: sort\n/tmp/tmp6ijozzcl_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(number\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpoxy9tf_0_test.go:56:40: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]string, len(numbers))\n    for i, number := range numbers {\n        numbers[i] = number\n    }\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppwkozwsv_test.go:14:13: no new variables on left side of :=\n/tmp/tmppwkozwsv_test.go:14:16: undefined: strings\n/tmp/tmppwkozwsv_test.go:15:13: no new variables on left side of :=\n/tmp/tmppwkozwsv_test.go:15:16: cannot use make([]string, len(numbers)) (value of type []string) as type string in assignment\n/tmp/tmppwkozwsv_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmppwkozwsv_test.go:19:5: undefined: sort\n/tmp/tmppwkozwsv_test.go:20:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu419zbak_test.go:14:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:14:16: undefined: strings\n/tmp/tmpu419zbak_test.go:15:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:15:16: undefined: strings\n/tmp/tmpu419zbak_test.go:16:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpu419zbak_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    number\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp8j15q8ri_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]int, len(numbers))\n    for i, number := range numbers {\n        numbers[i] = int(number)\n    }\n    sort.Ints(numbers)\n    numbers := make([]string, len(numbers))\n    for i, number := range numbers {\n        numbers[i] = strconv.Itoa(number)\n    }\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp30h1l1su_test.go:14:13: no new variables on left side of :=\n/tmp/tmp30h1l1su_test.go:14:16: undefined: strings\n/tmp/tmp30h1l1su_test.go:15:13: no new variables on left side of :=\n/tmp/tmp30h1l1su_test.go:15:16: cannot use make([]int, len(numbers)) (value of type []int) as type string in assignment\n/tmp/tmp30h1l1su_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmp30h1l1su_test.go:19:5: undefined: sort\n/tmp/tmp30h1l1su_test.go:20:13: no new variables on left side of :=\n/tmp/tmp30h1l1su_test.go:20:16: cannot use make([]string, len(numbers)) (value of type []string) as type string in assignment\n/tmp/tmp30h1l1su_test.go:22:22: undefined: strconv\n/tmp/tmp30h1l1su_test.go:24:12: undefined: strings\n/tmp/tmp30h1l1su_test.go:24:12: too many errors\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    number\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp8j15q8ri_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \"\\r\")\n    numbers := strings.Trim(numbers, \"\\t\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpe703fa68_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1d4e0idi_test.go:14:15: undefined: strings\n/tmp/tmp1d4e0idi_test.go:15:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:15:16: undefined: strings\n/tmp/tmp1d4e0idi_test.go:16:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmp1d4e0idi_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3yvca3m_test.go:14:15: undefined: strings\n/tmp/tmpv3yvca3m_test.go:15:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:15:16: undefined: strings\n/tmp/tmpv3yvca3m_test.go:16:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpv3yvca3m_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1d4e0idi_test.go:14:15: undefined: strings\n/tmp/tmp1d4e0idi_test.go:15:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:15:16: undefined: strings\n/tmp/tmp1d4e0idi_test.go:16:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmp1d4e0idi_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \",\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \".\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"-\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"0\")\n    numbers = strings.Trim(numbers, \"1\")\n    numbers = strings.Trim(numbers, \"2\")\n    numbers = strings.Trim(numbers, \"3\")\n    numbers = strings.Trim(numbers, \"4\")\n    numbers = strings.Trim(numbers, \"5\")\n    numbers = strings.Trim(numbers, \"6\")\n    numbers = strings.Trim(numbers, \"7\")\n    numbers = strings.Trim(numbers, \"8\")\n    numbers = strings.Trim(numbers, \"9\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpctmb7nr1_test.go:65:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.TrimSpace(numbers)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \" \", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \" \", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(numbers, \"-\", \"\", -1)\n    numbers := strings.Replace(number\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp2dnjm4gv_test.go:53:38: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3yvca3m_test.go:14:15: undefined: strings\n/tmp/tmpv3yvca3m_test.go:15:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:15:16: undefined: strings\n/tmp/tmpv3yvca3m_test.go:16:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpv3yvca3m_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9r2tgco6_test.go:14:13: no new variables on left side of :=\n/tmp/tmp9r2tgco6_test.go:14:16: undefined: strings\n/tmp/tmp9r2tgco6_test.go:15:13: no new variables on left side of :=\n/tmp/tmp9r2tgco6_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmp9r2tgco6_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmppjaxkp4z_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]string, len(numbers))\n    for i := range numbers {\n        numbers[i] = fmt.Sprintf(\"%v\", i)\n    }\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd9a8eerw_test.go:14:13: no new variables on left side of :=\n/tmp/tmpd9a8eerw_test.go:14:16: undefined: strings\n/tmp/tmpd9a8eerw_test.go:15:13: no new variables on left side of :=\n/tmp/tmpd9a8eerw_test.go:15:16: cannot use make([]string, len(numbers)) (value of type []string) as type string in assignment\n/tmp/tmpd9a8eerw_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmpd9a8eerw_test.go:19:5: undefined: sort\n/tmp/tmpd9a8eerw_test.go:20:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxpew7rkm_test.go:14:15: undefined: strings\n/tmp/tmpxpew7rkm_test.go:15:13: no new variables on left side of :=\n/tmp/tmpxpew7rkm_test.go:15:16: undefined: strings\n/tmp/tmpxpew7rkm_test.go:16:5: undefined: sort\n/tmp/tmpxpew7rkm_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \"\\r\")\n    numbers := strings.Trim(numbers, \"\\t\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpe703fa68_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]int, len(numbers))\n    for i := range numbers {\n        numbers[i] = int(numbers[i])\n    }\n    sort.Ints(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7ipgwro1_test.go:14:13: no new variables on left side of :=\n/tmp/tmp7ipgwro1_test.go:14:16: undefined: strings\n/tmp/tmp7ipgwro1_test.go:15:13: no new variables on left side of :=\n/tmp/tmp7ipgwro1_test.go:15:16: cannot use make([]int, len(numbers)) (value of type []int) as type string in assignment\n/tmp/tmp7ipgwro1_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmp7ipgwro1_test.go:19:5: undefined: sort\n/tmp/tmp7ipgwro1_test.go:20:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.TrimSpace(numbers)\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp0zyy_57i_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]int, len(numbers))\n    for i := range numbers {\n        numbers[i] = int(numbers[i])\n    }\n    sort.Ints(numbers)\n    numbers := strings.Join(numbers, \" \")\n    return numbers\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmmp3yxkx_test.go:14:13: no new variables on left side of :=\n/tmp/tmpmmp3yxkx_test.go:14:16: undefined: strings\n/tmp/tmpmmp3yxkx_test.go:15:13: no new variables on left side of :=\n/tmp/tmpmmp3yxkx_test.go:15:16: cannot use make([]int, len(numbers)) (value of type []int) as type string in assignment\n/tmp/tmpmmp3yxkx_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmpmmp3yxkx_test.go:19:5: undefined: sort\n/tmp/tmpmmp3yxkx_test.go:20:13: no new variables on left side of :=\n/tmp/tmpmmp3yxkx_test.go:20:16: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(number\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp23xx0gj1_test.go:68:29: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpixbl9e4j_test.go:14:15: undefined: strings\n/tmp/tmpixbl9e4j_test.go:15:13: no new variables on left side of :=\n/tmp/tmpixbl9e4j_test.go:15:16: undefined: strings\n/tmp/tmpixbl9e4j_test.go:16:5: undefined: sort\n/tmp/tmpixbl9e4j_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \",\")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmprbdd1n68_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \",\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpyl654a4m_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpixbl9e4j_test.go:14:15: undefined: strings\n/tmp/tmpixbl9e4j_test.go:15:13: no new variables on left side of :=\n/tmp/tmpixbl9e4j_test.go:15:16: undefined: strings\n/tmp/tmpixbl9e4j_test.go:16:5: undefined: sort\n/tmp/tmpixbl9e4j_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \",\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp2r6hog73_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpsnuwow20_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1d4e0idi_test.go:14:15: undefined: strings\n/tmp/tmp1d4e0idi_test.go:15:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:15:16: undefined: strings\n/tmp/tmp1d4e0idi_test.go:16:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmp1d4e0idi_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(numbers, \"three\")\n    numbers := append(numbers, \"four\")\n    numbers := append(numbers, \"five\")\n    numbers := append(numbers, \"six\")\n    numbers := append(numbers, \"seven\")\n    numbers := append(numbers, \"eight\")\n    numbers := append(numbers, \"nine\")\n    numbers := append(numbers, \"zero\")\n    numbers := append(numbers, \"one\")\n    numbers := append(numbers, \"two\")\n    numbers := append(number\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp23xx0gj1_test.go:68:29: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3yvca3m_test.go:14:15: undefined: strings\n/tmp/tmpv3yvca3m_test.go:15:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:15:16: undefined: strings\n/tmp/tmpv3yvca3m_test.go:16:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpv3yvca3m_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu419zbak_test.go:14:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:14:16: undefined: strings\n/tmp/tmpu419zbak_test.go:15:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:15:16: undefined: strings\n/tmp/tmpu419zbak_test.go:16:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpu419zbak_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    number\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3qurvw_f_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1d4e0idi_test.go:14:15: undefined: strings\n/tmp/tmp1d4e0idi_test.go:15:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:15:16: undefined: strings\n/tmp/tmp1d4e0idi_test.go:16:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmp1d4e0idi_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \",\")\n    numbers = strings.Split(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \".\")\n    numbers = strings.Split(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \":\")\n    numbers = strings.Split(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"-\")\n    numbers = strings.Split(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpg882vs7e_test.go:65:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu419zbak_test.go:14:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:14:16: undefined: strings\n/tmp/tmpu419zbak_test.go:15:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:15:16: undefined: strings\n/tmp/tmpu419zbak_test.go:16:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpu419zbak_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1d4e0idi_test.go:14:15: undefined: strings\n/tmp/tmp1d4e0idi_test.go:15:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:15:16: undefined: strings\n/tmp/tmp1d4e0idi_test.go:16:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmp1d4e0idi_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3yvca3m_test.go:14:15: undefined: strings\n/tmp/tmpv3yvca3m_test.go:15:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:15:16: undefined: strings\n/tmp/tmpv3yvca3m_test.go:16:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpv3yvca3m_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1d4e0idi_test.go:14:15: undefined: strings\n/tmp/tmp1d4e0idi_test.go:15:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:15:16: undefined: strings\n/tmp/tmp1d4e0idi_test.go:16:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmp1d4e0idi_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \"\\r\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmps3whxtum_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \"\\r\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmps3whxtum_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.TrimSpace(numbers)\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \",\")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmprw20cehf_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSpace(numbers)\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSpace(numbers)\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\n    numbers = strings.TrimSuffix(numbers, \" \")\n    numbers = strings.TrimPrefix(numbers, \" \")\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpq97wpvjg_test.go:57:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3yvca3m_test.go:14:15: undefined: strings\n/tmp/tmpv3yvca3m_test.go:15:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:15:16: undefined: strings\n/tmp/tmpv3yvca3m_test.go:16:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpv3yvca3m_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu419zbak_test.go:14:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:14:16: undefined: strings\n/tmp/tmpu419zbak_test.go:15:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:15:16: undefined: strings\n/tmp/tmpu419zbak_test.go:16:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpu419zbak_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpixbl9e4j_test.go:14:15: undefined: strings\n/tmp/tmpixbl9e4j_test.go:15:13: no new variables on left side of :=\n/tmp/tmpixbl9e4j_test.go:15:16: undefined: strings\n/tmp/tmpixbl9e4j_test.go:16:5: undefined: sort\n/tmp/tmpixbl9e4j_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]int, len(numbers))\n    for i := range numbers {\n        numbers[i] = int(numbers[i])\n    }\n    sort.Ints(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7ipgwro1_test.go:14:13: no new variables on left side of :=\n/tmp/tmp7ipgwro1_test.go:14:16: undefined: strings\n/tmp/tmp7ipgwro1_test.go:15:13: no new variables on left side of :=\n/tmp/tmp7ipgwro1_test.go:15:16: cannot use make([]int, len(numbers)) (value of type []int) as type string in assignment\n/tmp/tmp7ipgwro1_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmp7ipgwro1_test.go:19:5: undefined: sort\n/tmp/tmp7ipgwro1_test.go:20:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1d4e0idi_test.go:14:15: undefined: strings\n/tmp/tmp1d4e0idi_test.go:15:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:15:16: undefined: strings\n/tmp/tmp1d4e0idi_test.go:16:13: no new variables on left side of :=\n/tmp/tmp1d4e0idi_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmp1d4e0idi_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpsnuwow20_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu419zbak_test.go:14:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:14:16: undefined: strings\n/tmp/tmpu419zbak_test.go:15:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:15:16: undefined: strings\n/tmp/tmpu419zbak_test.go:16:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpu419zbak_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = int(numbers[i])\n    }\n    sort.Ints(numbers)\n    numbers := make([]string, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        numbers[i] = fmt.Sprintf(\"%d\", numbers[i])\n    }\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkngkd39__test.go:14:13: no new variables on left side of :=\n/tmp/tmpkngkd39__test.go:14:16: undefined: strings\n/tmp/tmpkngkd39__test.go:15:13: no new variables on left side of :=\n/tmp/tmpkngkd39__test.go:15:16: cannot use make([]int, len(numbers)) (value of type []int) as type string in assignment\n/tmp/tmpkngkd39__test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmpkngkd39__test.go:19:5: undefined: sort\n/tmp/tmpkngkd39__test.go:20:13: no new variables on left side of :=\n/tmp/tmpkngkd39__test.go:20:16: cannot use make([]string, len(numbers)) (value of type []string) as type string in assignment\n/tmp/tmpkngkd39__test.go:22:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmpkngkd39__test.go:24:12: undefined: strings\n/tmp/tmpkngkd39__test.go:24:12: too many errors\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \"\\r\")\n    numbers := strings.Trim(numbers, \"\\t\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpe703fa68_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3yvca3m_test.go:14:15: undefined: strings\n/tmp/tmpv3yvca3m_test.go:15:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:15:16: undefined: strings\n/tmp/tmpv3yvca3m_test.go:16:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpv3yvca3m_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \",\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \"\\n\")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    numbers = strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp21g8efpg_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv3yvca3m_test.go:14:15: undefined: strings\n/tmp/tmpv3yvca3m_test.go:15:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:15:16: undefined: strings\n/tmp/tmpv3yvca3m_test.go:16:13: no new variables on left side of :=\n/tmp/tmpv3yvca3m_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpv3yvca3m_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu419zbak_test.go:14:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:14:16: undefined: strings\n/tmp/tmpu419zbak_test.go:15:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:15:16: undefined: strings\n/tmp/tmpu419zbak_test.go:16:13: no new variables on left side of :=\n/tmp/tmpu419zbak_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpu419zbak_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \"\\r\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmps3whxtum_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers = strings.Trim(numbers, \" \")\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpixbl9e4j_test.go:14:15: undefined: strings\n/tmp/tmpixbl9e4j_test.go:15:13: no new variables on left side of :=\n/tmp/tmpixbl9e4j_test.go:15:16: undefined: strings\n/tmp/tmpixbl9e4j_test.go:16:5: undefined: sort\n/tmp/tmpixbl9e4j_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]int, len(numbers))\n    for i, number := range numbers {\n        numbers[i] = int(number)\n    }\n    sort.Ints(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeqzq0ru1_test.go:14:13: no new variables on left side of :=\n/tmp/tmpeqzq0ru1_test.go:14:16: undefined: strings\n/tmp/tmpeqzq0ru1_test.go:15:13: no new variables on left side of :=\n/tmp/tmpeqzq0ru1_test.go:15:16: cannot use make([]int, len(numbers)) (value of type []int) as type string in assignment\n/tmp/tmpeqzq0ru1_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmpeqzq0ru1_test.go:19:5: undefined: sort\n/tmp/tmpeqzq0ru1_test.go:20:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \"\\r\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmps3whxtum_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]int, len(numbers))\n    for i, number := range numbers {\n        numbers[i] = int(number)\n    }\n    sort.Ints(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeqzq0ru1_test.go:14:13: no new variables on left side of :=\n/tmp/tmpeqzq0ru1_test.go:14:16: undefined: strings\n/tmp/tmpeqzq0ru1_test.go:15:13: no new variables on left side of :=\n/tmp/tmpeqzq0ru1_test.go:15:16: cannot use make([]int, len(numbers)) (value of type []int) as type string in assignment\n/tmp/tmpeqzq0ru1_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmpeqzq0ru1_test.go:19:5: undefined: sort\n/tmp/tmpeqzq0ru1_test.go:20:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    sort.Strings(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1ssjh1__test.go:14:13: no new variables on left side of :=\n/tmp/tmpi1ssjh1__test.go:14:16: undefined: strings\n/tmp/tmpi1ssjh1__test.go:15:5: undefined: sort\n/tmp/tmpi1ssjh1__test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwuz2fft_test.go:14:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:14:16: undefined: strings\n/tmp/tmpkwuz2fft_test.go:15:13: no new variables on left side of :=\n/tmp/tmpkwuz2fft_test.go:15:16: undefined: sort_numbers_test\n/tmp/tmpkwuz2fft_test.go:16:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074305
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Split(numbers, \" \")\n    numbers := make([]int, len(numbers))\n    for i, number := range numbers {\n        numbers[i] = int(number)\n    }\n    sort.Ints(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeqzq0ru1_test.go:14:13: no new variables on left side of :=\n/tmp/tmpeqzq0ru1_test.go:14:16: undefined: strings\n/tmp/tmpeqzq0ru1_test.go:15:13: no new variables on left side of :=\n/tmp/tmpeqzq0ru1_test.go:15:16: cannot use make([]int, len(numbers)) (value of type []int) as type string in assignment\n/tmp/tmpeqzq0ru1_test.go:17:9: cannot assign to numbers[i] (value of type byte)\n/tmp/tmpeqzq0ru1_test.go:19:5: undefined: sort\n/tmp/tmpeqzq0ru1_test.go:20:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    },
    {
      "exit_code": 1,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \"\\n\")\n    numbers := strings.Trim(numbers, \"\\r\")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    numbers := strings.Trim(numbers, \" \")\n    \nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmps3whxtum_test.go:66:6: expected '(', found TestSort_Numbers\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074306
    },
    {
      "exit_code": 2,
      "program": "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers string) string {\n    numbers := strings.TrimSpace(numbers)\n    numbers := strings.Split(numbers, \" \")\n    numbers := sort_numbers_test.SortNumbers(numbers)\n    return strings.Join(numbers, \" \")\n}\n\nfunc TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n     { actual: candidate(\"six five four three two one zero\"), expected: \"zero one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpphdi96zm_test.go:14:13: no new variables on left side of :=\n/tmp/tmpphdi96zm_test.go:14:16: undefined: strings\n/tmp/tmpphdi96zm_test.go:15:13: no new variables on left side of :=\n/tmp/tmpphdi96zm_test.go:15:16: undefined: strings\n/tmp/tmpphdi96zm_test.go:16:13: no new variables on left side of :=\n/tmp/tmpphdi96zm_test.go:16:16: undefined: sort_numbers_test\n/tmp/tmpphdi96zm_test.go:17:12: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074307
    }
  ]
}