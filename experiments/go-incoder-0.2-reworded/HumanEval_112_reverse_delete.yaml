name: HumanEval_112_reverse_delete
language: go_test.go
prompt: "package reverse_delete_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
  \n// Task\n// We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n// then check if the result string\
  \ is palindrome.\n// A string is called palindrome if it reads the same backward\
  \ as forward.\n// You should return a list containing the result string and true/false\
  \ for the check.\n// Example\n// >>> reverse_delete(\"abcde\", \"ae\")\n// []interface{}{\"\
  bcd\", false}\n// >>> reverse_delete(\"abcdef\", \"b\")\n// []interface{}{\"acdef\"\
  , false}\n// >>> reverse_delete(\"abcdedcba\", \"ab\")\n// []interface{}{\"cdedc\"\
  , true}\nfunc reverse_delete(s string, c string) []interface{} {\n"
tests: "func TestReverse_Delete(t *testing.T) {\n  candidate := reverse_delete\n\t\
  type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n  \
  \ tests := []test{\n     { actual: candidate(\"abcde\", \"ae\"), expected: []interface{}{\"\
  bcd\", false} },\n     { actual: candidate(\"abcdef\", \"b\"), expected: []interface{}{\"\
  acdef\", false} },\n     { actual: candidate(\"abcdedcba\", \"ab\"), expected: []interface{}{\"\
  cdedc\", true} },\n     { actual: candidate(\"dwik\", \"w\"), expected: []interface{}{\"\
  dik\", false} },\n     { actual: candidate(\"a\", \"a\"), expected: []interface{}{\"\
  \", true} },\n     { actual: candidate(\"abcdedcba\", \"\"), expected: []interface{}{\"\
  abcdedcba\", true} },\n     { actual: candidate(\"abcdedcba\", \"v\"), expected:\
  \ []interface{}{\"abcdedcba\", true} },\n     { actual: candidate(\"vabba\", \"\
  v\"), expected: []interface{}{\"abba\", true} },\n     { actual: candidate(\"mamma\"\
  , \"mia\"), expected: []interface{}{\"\", true} },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    result := make([]interface{}, 0)\n    i := 0\n    for i < len(s)\
    \ {\n        if s[i] == c {\n            i++\n        } else {\n            result\
    \ = append(result, s[i])\n            i = 0\n        }\n    }\n    if i == 0 {\n\
    \        result = append(result, s[i])\n    }\n    return append(result, true)\n\
    }\n", "    // Your code here\n    result := make([]interface{}, 0)\n    i := 0\n\
    \    for i < len(s) {\n        if s[i] == c {\n            i++\n        }\n  \
    \      if i == len(s) {\n            break\n        }\n        if s[i] != c {\n\
    \            result = append(result, s[i])\n        }\n    }\n    if i == len(s)\
    \ {\n        result = append(result, s[i])\n    }\n    return append(result, true)\n\
    }\n", "    result := make([]interface{}, 0)\n    i := 0\n    j := len(s) - 1\n\
    \    for i < len(s) {\n        if s[i] != c {\n            result = append(result,\
    \ s[i])\n        }\n        i++\n    }\n    for j < len(s) {\n        if s[j]\
    \ != c {\n            result = append(result, s[j])\n        }\n        j--\n\
    \    }\n    return append(result, true)\n}\n", "    result := make([]interface{},\
    \ 0)\n    i := 0\n    for i < len(s) {\n        if s[i] == c {\n            i++\n\
    \        } else {\n            result = append(result, s[i])\n            i =\
    \ i + 1\n        }\n    }\n    if i == len(s) {\n        result = append(result,\
    \ s[i])\n    }\n    return append(result, true)\n}\n", "    result := make([]interface{},\
    \ 0)\n    i := 0\n    j := len(s) - 1\n    for i < len(c) && j < len(c) {\n  \
    \      if s[i] == c[j] {\n            i++\n            j--\n        } else {\n\
    \            result = append(result, s[i])\n            i++\n            j--\n\
    \        }\n    }\n    if i == len(s) {\n        result = append(result, s[i])\n\
    \    }\n    return append(result, false)\n}\n", "    // Write your code here\n\
    \    result := []interface{}{}\n    i := 0\n    j := len(s)\n    for i < j {\n\
    \        if s[i] == c {\n            i++\n            j--\n        } else {\n\
    \            result = append(result, s[i])\n            i++\n        }\n    }\n\
    \    if i == j {\n        result = append(result, s[i])\n    }\n    return result\n\
    }\n", "    result := []interface{}{}\n    i := 0\n    j := len(s) - 1\n    for\
    \ i < len(s) {\n        if s[i] != c[j] {\n            result = append(result,\
    \ s[i])\n        }\n        i++\n        j--\n    }\n    if i == len(s) {\n  \
    \      result = append(result, s[i])\n    }\n    return result\n}\n", "    result\
    \ := make([]interface{}, 0)\n    i := 0\n    j := len(s) - 1\n    for i < len(s)\
    \ && j < len(c) {\n        if s[i] == c[j] {\n            i++\n            j--\n\
    \        } else {\n            result = append(result, s[i])\n            i++\n\
    \        }\n    }\n    if i == len(s) {\n        result = append(result, s[i])\n\
    \    }\n    return append(result, false)\n}\n", "    result := make([]interface{},\
    \ 0)\n    i := 0\n    for i < len(s) {\n        if s[i] == c {\n            result\
    \ = append(result, s[i])\n            i++\n        }\n    }\n    if i == len(s)\
    \ {\n        result = append(result, s[i])\n    }\n    return append(result, true)\n\
    }\n", "    result := make([]interface{}, 0)\n    i := 0\n    for i < len(s) {\n\
    \        if s[i] == c {\n            result = append(result, s[i])\n         \
    \   i++\n        }\n    }\n    if i == len(s) {\n        return append(result,\
    \ s[len(s)-1])\n    }\n    return append(result, s[len(s)-1], reverse_delete(s,\
    \ c))\n}\n", "    result := make([]interface{}, 0)\n    i := 0\n    j := len(s)\
    \ - 1\n    for i < len(s) && j < len(c) {\n        if s[i] == c[j] {\n       \
    \     i++\n            j--\n        } else {\n            result = append(result,\
    \ s[i])\n            i++\n            j--\n        }\n    }\n    if i == len(s)\
    \ {\n        result = append(result, s[i])\n    }\n    return append(result, false)\n\
    }\n", "    result := make([]interface{}, 0)\n    i := 0\n    for i < len(s) {\n\
    \        if s[i] == c {\n            result = append(result, s[i])\n         \
    \   i++\n        }\n    }\n    if i == len(s) {\n        result = append(result,\
    \ s[i])\n    }\n    return append(result, true)\n}\n", "    result := make([]interface{},\
    \ 0)\n    i := 0\n    for i < len(s) {\n        if s[i] == c {\n            i++\n\
    \        } else {\n            result = append(result, s[i])\n            i =\
    \ 0\n        }\n    }\n    if i == 0 {\n        result = append(result, c)\n \
    \   }\n    return append(result, false)\n}\n", "    result := make([]interface{},\
    \ 0)\n    i := 0\n    for i < len(s) {\n        if s[i] == c {\n            i++\n\
    \        } else {\n            result = append(result, s[i])\n            i =\
    \ 0\n        }\n    }\n    if i == 0 {\n        result = append(result, s[i])\n\
    \    }\n    return append(result, true)\n}\n", "    result := make([]interface{},\
    \ 0)\n    i := 0\n    for i < len(s) {\n        if s[i] == c {\n            result\
    \ = append(result, s[i])\n            i++\n        }\n    }\n    if i == len(s)\
    \ {\n        result = append(result, s[i])\n    }\n    return append(result, true)\n\
    }\n", "    var result []interface{}\n    var i int\n    var j int\n    var k int\n\
    \    var l int\n    for i = len(s) - 1; i >= 0; i-- {\n        for j = len(c)\
    \ - 1; j >= 0; j-- {\n            if s[i] != c[j] {\n                break\n \
    \           }\n        }\n        if j == 0 {\n            result = append(result,\
    \ s[i])\n        }\n    }\n    for k = len(c) - 1; k >= 0; k-- {\n        for\
    \ l = len(s) - 1; l >= 0; l-- {\n            if s[k] != s[l] {\n             \
    \   break\n            }\n        }\n        if l == 0 {\n            result =\
    \ append(result, s[k])\n        }\n    }\n    return append(result, true)\n}\n",
  "    result := make([]interface{}, 0)\n    i := 0\n    j := len(s) - 1\n    for\
    \ i < len(s) {\n        if s[i] == c {\n            result = append(result, s[i])\n\
    \            i++\n            j--\n        }\n        if j >= 0 {\n          \
    \  if s[i] == s[j] {\n                j--\n            } else {\n            \
    \    j++\n            }\n        }\n    }\n    if i == len(s) {\n        result\
    \ = append(result, s[i])\n    }\n    return append(result, true)\n}\n", "    result\
    \ := []interface{}{}\n    for i := 0; i < len(s); i++ {\n        if s[i] == c\
    \ {\n            result = append(result, s[:i])\n            s = s[i+1:]\n   \
    \     }\n    }\n    if s == \"\" {\n        result = append(result, s)\n    }\n\
    \    return result\n}\n", "    // Your code here\n    result := make([]interface{},\
    \ 0)\n    i := 0\n    for i < len(s) {\n        if s[i] == c {\n            i++\n\
    \        } else {\n            result = append(result, s[i])\n            i++\n\
    \        }\n    }\n    if i == len(s) {\n        result = append(result, s[i])\n\
    \    }\n    return []interface{}{result, true}\n}\n", "    result := []interface{}{}\n\
    \    for i := 0; i < len(s); i++ {\n        if s[i] != c {\n            result\
    \ = append(result, s[i])\n        }\n    }\n    if result == []interface{}{c}\
    \ {\n        return nil\n    }\n    return append(result, c)\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
