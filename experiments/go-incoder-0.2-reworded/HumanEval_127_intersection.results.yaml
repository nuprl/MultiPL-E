language: go_test.go
name: HumanEval_127_intersection
results:
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    \n    if intersection <= 0 {\n        return \"NO\"\n  \
    \  }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n  \
    \  \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2wl81vbj_test.go:50:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075397
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionEnd = interval1End\n       \
    \ }\n        if interval1Start <= intersectionStart && interval1End >= intersectionEnd\
    \ {\n            intersectionStart = interval1Start\n        }\n    }\n    \n\
    \    if intersectionEnd <= intersectionStart {\n        return \"NO\"\n    }\n\
    \    \n    if isPrime(intersectionEnd - intersectionStart) {\n        return \"\
    YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7wjq6zkb_test.go:70:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075397
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start > interval1End\
    \ {\n            return \"NO\"\n        }\n        \n        if interval2Start\
    \ > interval2End {\n            return \"NO\"\n        }\n        \n        if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \     intersectionStart = interval1Start\n            intersectionEnd = interval1End\n\
    \        }\n        \n        if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n            intersectionStart = interval1End\n        \
    \    intersectionEnd = interval1End\n        }\n        \n        if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n        }\n  \
    \  }\n    \n    if intersectionStart > intersectionEnd {\n        return \"NO\"\
    \n    }\n    \n    if intersectionStart <= intersectionEnd {\n        return \"\
    YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpur5z3eob_test.go:32 +0x25b\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpur5z3eob_test.go:86 +0xe7\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075398
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for interval1Start < interval1End\
    \ && interval2Start < interval2End {\n        if interval1Start <= interval2Start\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        }\n        if interval1End <= interval2End {\n     \
    \       intersectionEnd = interval1End\n        }\n        interval1Start += interval1Step\n\
    \        interval2Start += interval2Step\n    }\n    \n    if interval1Start <\
    \ interval1End {\n        intersectionStart = interval1Start\n        intersectionEnd\
    \ = interval1End\n    }\n    if interval2Start < interval2End {\n        intersectionEnd\
    \ = interval2Start\n        intersectionStart = interval2End\n    }\n    \n  \
    \  if intersectionStart > intersectionEnd {\n        return \"NO\"\n    }\n  \
    \  \n    if intersectionStart < interval1Start || intersectionEnd > interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionStart <= intersectionEnd\
    \ {\n        if intersectionStart <= interval1Start {\n            return \"YES\"\
    \n        }\n        if intersectionEnd <= interval2End {\n            return\
    \ \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxvngc98y_test.go:48:27: undefined: interval1Step

    /tmp/tmpxvngc98y_test.go:49:27: undefined: interval2Step

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075397
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var intersectionLength int\n    var isPrime bool\n\n \
    \   if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\n  \
    \  for i := 0; i < len(interval1); i++ {\n        interval1Start = interval1[i].(int)\n\
    \        interval1End = interval1Start + interval1[i].(int)\n        interval2Start\
    \ = interval2[i].(int)\n        interval2End = interval2Start + interval2[i].(int)\n\
    \n        if interval1Start > interval1End {\n            return \"NO\"\n    \
    \    }\n\n        if interval2Start > interval2End {\n            return \"NO\"\
    \n        }\n\n        if interval1Start <= interval2Start && interval1End >=\
    \ interval2End {\n            intersectionLength = interval1End - interval1Start\n\
    \            if isPrime(intersectionLength) {\n                return \"YES\"\n\
    \            }\n        }\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcift0u7v_test.go:30:9: intersectionLength declared but not used

    /tmp/tmpcift0u7v_test.go:53:16: invalid operation: cannot call non-function isPrime
    (variable of type bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075397
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start > interval1End\
    \ {\n            return \"NO\"\n        }\n        \n        if interval2Start\
    \ > interval2End {\n            return \"NO\"\n        }\n        \n        if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \     intersectionStart = interval1Start\n            intersectionEnd = interval1End\n\
    \        }\n        \n        if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n            intersectionStart = interval1End\n        \
    \    intersectionEnd = interval1End\n        }\n        \n        if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n        }\n  \
    \      \n        if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        }\n        \n        if interval1Start >= interval2Start\
    \ && interval1End >= interval2End {\n            intersectionStart = interval1Start\n\
    \            intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        return \"YES\"\n    }\n    \n    return \"NO\"\
    \n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpnyzl59m3_test.go:32 +0x27d\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpnyzl59m3_test.go:92 +0xe7\ntesting.tRunner(0xc0001201a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075398
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    \n    if interval1End < interval2Start {\n        return \"NO\"\n    }\n\
    \    \n    interval1Length := interval1End - interval1Start\n    interval2Length\
    \ := interval2End - interval2Start\n    \n    if interval1Length == 0 || interval2Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length\
    \ {\n        if interval1Start <= interval2Start {\n            return \"NO\"\n\
    \        }\n        return \"YES\"\n    }\n    \n    if interval1Length < interval2Length\
    \ {\n        interval1Start += interval1Length\n        interval1End += interval1Length\n\
    \    }\n    \n    if interval1Length > interval2Length {\n        interval2Start\
    \ += interval2Length\n        interval2End += interval2Length\n    }\n    \n \
    \   if interval1Start > interval2End {\n        return \"NO\"\n    }\n    \n \
    \   if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n \
    \   if interval1Start <= interval2Start {\n        return \"YES\"\n    }\n   \
    \ \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp9d_w4w9t_test.go:104: expected 'YES', got 'NO'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075398
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1_start := interval1[0].(float64)\n    interval1_end\
    \ := interval1[1].(float64)\n    interval2_start := interval2[0].(float64)\n \
    \   interval2_end := interval2[1].(float64)\n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy5a4zlz0_test.go:267:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := make([]int, len(interval1))\n    interval2 := make([]int,\
    \ len(interval2))\n    \n    for i := range interval1 {\n        interval1[i]\
    \ = int(interval1[i])\n    }\n    for i := range interval2 {\n        interval2[i]\
    \ = int(interval2[i])\n    }\n    \n    result := make([]int, len(interval1))\n\
    \    \n    for i := range interval1 {\n        for j := range interval2 {\n  \
    \          if interval1[i] < interval2[j] {\n                result[i] = interval1[i]\n\
    \                break\n            }\n            if interval1[i] > interval2[j]\
    \ {\n                result[i] = interval2[j]\n                break\n       \
    \     }\n        }\n    }\n    \n    if len(result) == 0 {\n        return \"\
    NO\"\n    }\n    \n    for i := range result {\n        if result[i] == 0 {\n\
    \            return \"NO\"\n        }\n    }\n    \n    if isPrime(result[0])\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjeqi86mk_test.go:32:15:\
    \ no new variables on left side of :=\n/tmp/tmpjeqi86mk_test.go:32:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmpjeqi86mk_test.go:33:15: no new variables on left side\
    \ of :=\n/tmp/tmpjeqi86mk_test.go:33:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmpjeqi86mk_test.go:36:28:\
    \ cannot convert interval1[i] (variable of type interface{}) to type int:\n\t\
    need type assertion\n/tmp/tmpjeqi86mk_test.go:39:28: cannot convert interval2[i]\
    \ (variable of type interface{}) to type int:\n\tneed type assertion\n/tmp/tmpjeqi86mk_test.go:46:16:\
    \ invalid operation: interval1[i] < interval2[j] (operator < not defined on interface)\n\
    /tmp/tmpjeqi86mk_test.go:47:29: cannot use interval1[i] (variable of type interface{})\
    \ as type int in assignment:\n\tneed type assertion\n/tmp/tmpjeqi86mk_test.go:50:16:\
    \ invalid operation: interval1[i] > interval2[j] (operator > not defined on interface)\n\
    /tmp/tmpjeqi86mk_test.go:51:29: cannot use interval2[j] (variable of type interface{})\
    \ as type int in assignment:\n\tneed type assertion\n/tmp/tmpjeqi86mk_test.go:51:29:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075397
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End || interval2Start\
    \ > interval2End {\n        return \"NO\"\n    }\n    \n    interval1Length :=\
    \ interval1End - interval1Start\n    interval2Length := interval2End - interval2Start\n\
    \    \n    if interval1Length == 0 || interval2Length == 0 {\n        return \"\
    NO\"\n    }\n    \n    intersectionLength := interval1Length * interval2Length\n\
    \    \n    if intersectionLength == 0 {\n        return \"NO\"\n    }\n    \n\
    \    if isPrime(intersectionLength) {\n        return \"YES\"\n    }\n    \n \
    \   return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8o1bu54g_test.go:54:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075397
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    if len(interval1) > len(interval2) {\n\
    \        result = intersection(interval2, interval1)\n    } else {\n        result\
    \ = intersection(interval1, interval2)\n    }\n    if result == \"YES\" {\n  \
    \      return \"YES\"\n    }\n    if result == \"NO\" {\n        return \"NO\"\
    \n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0370\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52034d?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x2?, 0x2?}, {0xc0401dfca0?, 0x2?, 0x2?})\n\t/tmp/tmp9_ii05i0_test.go:27 +0xd4\
    \ fp=0xc0201e0380 sp=0xc0201e0378 pc=0x4ef734\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp9_ii05i0_test.go:32 +0x4e\
    \ fp=0xc0201e03c0 sp=0xc0201e0380 pc=0x4ef6ae\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp9_ii05i0_test.go:32 +0x4e\
    \ fp=0xc0201e0400 sp=0xc0201e03c0 pc=0x4ef6ae\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp9_ii05i0_test.go:32 +0x4e\
    \ fp=0xc0201e0440 sp=0xc0201e0400 pc=0x4ef6ae\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp9_ii05i0_test.go:32 +0x4e\
    \ fp=0xc0201e0480 sp=0xc0201e0440 pc=0x4ef6ae\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp9_ii05i0_test.go:32 +0x4e\
    \ fp=0xc0201e04c0 sp=0xc0201e0480 pc=0x4ef6ae\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp9_ii05i0_test.go:32 +0x4e\
    \ fp=0xc0201e0500 sp=0xc0201e04c0 pc=0x4ef6ae\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp9_ii05i0_test.go:32 +0x4e\
    \ fp=0xc0201e0540 sp=0xc0201e0500 pc=0x4ef6ae\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp9_ii05i0_test.go:32 +0x4e\
    \ fp=0xc0201e0580 sp"
  timestamp: 1660075398
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    result := 0\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1Start <= interval1[i].([]interface{})[1]\
    \ && interval1[i].([]interface{})[1] < interval1End {\n            result += interval1[i].([]interface{})[1]\
    \ - interval1[i].([]interface{})[0]\n        }\n    }\n    \n    for i := 0; i\
    \ < len(interval2); i++ {\n        if interval2Start <= interval2[i].([]interface{})[1]\
    \ && interval2[i].([]interface{})[1] < interval2End {\n            result += interval2[i].([]interface{})[1]\
    \ - interval2[i].([]interface{})[0]\n        }\n    }\n    \n    if result % 2\
    \ == 0 {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgcdl0jmk_test.go:35:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpgcdl0jmk_test.go:38:8: invalid operation: interval1End < interval2Start
    (operator < not defined on interface)

    /tmp/tmpgcdl0jmk_test.go:45:12: invalid operation: interval1Start <= interval1[i].([]interface{})[1]
    (operator <= not defined on interface)

    /tmp/tmpgcdl0jmk_test.go:45:65: invalid operation: interval1[i].([]interface{})[1]
    < interval1End (operator < not defined on interface)

    /tmp/tmpgcdl0jmk_test.go:46:23: invalid operation: operator - not defined on interval1[i].([]interface{})[1]
    (variable of type interface{})

    /tmp/tmpgcdl0jmk_test.go:51:12: invalid operation: interval2Start <= interval2[i].([]interface{})[1]
    (operator <= not defined on interface)

    /tmp/tmpgcdl0jmk_test.go:51:65: invalid operation: interval2[i].([]interface{})[1]
    < interval2End (operator < not defined on interface)

    /tmp/tmpgcdl0jmk_test.go:52:23: invalid operation: operator - not defined on interval2[i].([]interface{})[1]
    (variable of type interface{})

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075397
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    interval1Length := interval1End\
    \ - interval1Start\n    interval2Length := interval2End - interval2Start\n   \
    \ \n    if interval1Length == 0 || interval2Length == 0 {\n        return \"NO\"\
    \n    }\n    \n    intersectionLength := interval1Length * interval2Length\n \
    \   \n    if intersectionLength == 0 {\n        return \"NO\"\n    }\n    \n \
    \   if interval1Length == interval2Length {\n        if interval1Start <= interval2Start\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n   \
    \ \n    if interval1Length > interval2Length {\n        interval1Length, interval2Length\
    \ = interval2Length, interval1Length\n    }\n    \n    if interval1Length % 2\
    \ == 0 {\n        interval1Length /= 2\n    }\n    if interval2Length % 2 == 0\
    \ {\n        interval2Length /= 2\n    }\n    \n    if interval1Length == interval2Length\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length > interval2Length\
    \ {\n        interval1Length, interval2Length = interval2Length, interval1Length\n\
    \    }\n    \n    if interval1Length == 0 {\n        return \"NO\"\n    }\n  \
    \  \n    if interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Length == interval2Length {\n        if interval1Start <= interval2Start\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n   \
    \ \n    if interval1Length > interval2Length {\n        interval1Length, interval2Length\
    \ = interval2Length, interval1Length\n    }\n    \n    if interval1Length == 0\
    \ {\n        return \"NO\"\n    }\n    \n    if interval2Length == 0 {\n     \
    \   return \"NO\"\n    }\n    \n    if interval1Length == interval2Length {\n\
    \        if interval1Start <= interval2Start {\n            return \"YES\"\n \
    \       }\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmper8n1d9x_test.go:117:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Your code here\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp39vg6js4_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: null
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for intersectionStart <= interval2End {\n        if interval1Start\
    \ <= intersectionEnd && intersectionEnd <= interval2End {\n            if interval1Start\
    \ <= intersectionStart && intersectionStart <= interval2Start {\n            \
    \    intersectionEnd = intersectionEnd\n            } else {\n               \
    \ intersectionStart = intersectionStart\n            }\n        } else {\n   \
    \         break\n        }\n    }\n    \n    if intersectionStart <= interval2End\
    \ {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660075410
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionLength := interval1End\
    \ - interval1Start\n    \n    if interval2Start <= interval2End && interval1Start\
    \ <= interval1End {\n        if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n            if interval2Start <= interval1Start && interval2End\
    \ >= interval1End {\n                if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n                    if interval2Start <= interval1Start &&\
    \ interval2End >= interval1End {\n                        if interval1Start <=\
    \ interval2Start && interval1End >= interval2End {\n                         \
    \   if interval2Start <= interval1Start && interval2End >= interval1End {\n  \
    \                              return \"YES\"\n                            }\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp03ya140k_test.go:44:5: intersectionLength declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075397
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n\n    interval1Start, interval1End := interval1[0], interval1[1]\n   \
    \ interval2Start, interval2End := interval2[0], interval2[1]\n\n    if interval1Start\
    \ > interval2End {\n        return \"NO\"\n    }\n\n    if interval1End < interval2Start\
    \ {\n        return \"NO\"\n    }\n\n    if interval1Start > interval2Start {\n\
    \        return \"NO\"\n    }\n\n    if interval1Start > interval2End {\n    \
    \    return \"NO\"\n    }\n\n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start <=\
    \ interval2End && interval1End >= interval2Start {\n        return \"YES\"\n \
    \   }\n\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start <= interval2End &&\
    \ interval1End >= interval2Start {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpviazgbns_test.go:116:16: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"NO\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc000187cc0?, 0x2?, 0x2?},\
    \ {0xc000187ca0?, 0x2?, 0x2?})\n\t/tmp/tmplg847z9u_test.go:32 +0x1bc\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmplg847z9u_test.go:67 +0xe7\ntesting.tRunner(0xc000199040, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075398
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if intersectionStart > interval2End {\n   \
    \         return \"NO\"\n        }\n        if intersectionEnd < interval2Start\
    \ {\n            return \"NO\"\n        }\n        \n        if intersectionStart\
    \ <= intersectionEnd {\n            intersectionStart = interval1Start\n     \
    \       intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc000187cc0?, 0x2?, 0x2?},\
    \ {0xc000187ca0?, 0x2?, 0x2?})\n\t/tmp/tmpp6l8dfvl_test.go:32 +0x288\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpp6l8dfvl_test.go:84 +0xe7\ntesting.tRunner(0xc0001991e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075398
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval2End {\n      \
    \  return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start +\
    \ 1\n    interval2Length := interval2End - interval2Start + 1\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ == interval2Length {\n        \n        if interval1Start <= interval2Start\
    \ {\n            return \"NO\"\n        }\n        if interval1End >= interval2End\
    \ {\n            return \"NO\"\n        }\n        \n        interval1Start +=\
    \ interval1Length\n        interval1End += interval1Length\n        interval2Start\
    \ += interval2Length\n        interval2End += interval2Length\n        \n    \
    \    if interval1Start > interval2End {\n            return \"NO\"\n        }\n\
    \        if interval1End < interval2Start {\n            return \"NO\"\n     \
    \   }\n        \n        if interval1Start <= interval2Start {\n            return\
    \ \"NO\"\n        }\n        if interval1End >= interval2End {\n            return\
    \ \"NO\"\n        }\n        \n        if interval1Start <= interval2Start {\n\
    \            return \"NO\"\n        }\n        if interval1End >= interval2End\
    \ {\n            return \"NO\"\n        }\n        \n        if interval1Start\
    \ <= interval2Start {\n            return \"NO\"\n        }\n        if interval1End\
    \ >= interval2End {\n            return \"NO\"\n        }\n        \n        if\
    \ interval1Start <= interval2Start {\n            return \"NO\"\n        }\n \
    \       if interval1End >= interval2End {\n            return \"NO\"\n       \
    \ }\n        \n        if interval1Start <= interval2Start {\n            return\
    \ \"NO\"\n        }\n        if interval1End >= interval2End {\n            return\
    \ \"NO\"\n        }\n        \n        if interval1Start <= interval2Start {\n\
    \            return \"NO\"\n        }\n        if interval1End >= interval2End\
    \ {\n            return \"NO\"\n        }\n        \n        if interval1Start\
    \ <= interval2Start {\n            return \"NO\"\n        }\n        if interval1End\
    \ >= interval2End {\n            return \"NO\"\n        }\n        \n        if\
    \ interval1Start <= interval2Start {\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzdjrfd7k_test.go:123:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1Start := interval1[0].(int)\n    interval1End :=\
    \ interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval1End {\n      \
    \  fmt.Println(\"interval1Start > interval1End\")\n        return \"NO\"\n   \
    \ }\n    if interval2Start > interval2End {\n        fmt.Println(\"interval2Start\
    \ > interval2End\")\n        return \"NO\"\n    }\n    \n    \n    if interval1Start\
    \ < interval2Start {\n        fmt.Println(\"interval1Start < interval2Start\"\
    )\n        return \"NO\"\n    }\n    if interval1End > interval2End {\n      \
    \  fmt.Println(\"interval1End > interval2End\")\n        return \"NO\"\n    }\n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnospa1v8_test.go:227:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n\n    interval1Start, interval1End = interval1[0].(int), interval1[1].(int)\n\
    \    interval2Start, interval2End = interval2[0].(int), interval2[1].(int)\n\n\
    \    if interval1Start > interval1End {\n        interval1Start, interval1End\
    \ = interval1End, interval1Start\n    }\n    if interval2Start > interval2End\
    \ {\n        interval2Start, interval2End = interval2End, interval2Start\n   \
    \ }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2End &&\
    \ interval1End >= interval2Start {\n        return \"NO\"\n    }\n\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpcin8637__test.go:92: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpcin8637__test.go:92: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075399
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n\n    interval1Start, interval1End := interval1[0], interval1[1]\n\
    \    interval2Start, interval2End := interval2[0], interval2[1]\n\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"NO\"\n\
    \    }\n\n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy5kx4zqb_test.go:35:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpy5kx4zqb_test.go:35:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmpy5kx4zqb_test.go:39:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpy5kx4zqb_test.go:39:42: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpy5kx4zqb_test.go:43:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpy5kx4zqb_test.go:43:44: invalid operation: interval1End <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpy5kx4zqb_test.go:47:8: invalid operation: interval1Start >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpy5kx4zqb_test.go:47:44: invalid operation: interval1End <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpy5kx4zqb_test.go:51:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpy5kx4zqb_test.go:51:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmpy5kx4zqb_test.go:51:44: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075398
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    if intersection <= 0 {\n        return \"NO\"\n    }\n \
    \   \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf6mk4jeo_test.go:49:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075398
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for interval1Start <= interval1End && interval2Start\
    \ <= interval2End {\n        if interval1Start <= interval2Start {\n         \
    \   intersectionStart = interval1Start\n            intersectionEnd = interval1End\n\
    \        }\n        if interval1End <= interval2End {\n            intersectionEnd\
    \ = interval1End\n        }\n        \n        if intersectionStart > intersectionEnd\
    \ {\n            return \"NO\"\n        }\n        \n        intersectionStart\
    \ = intersectionStart + 1\n        intersectionEnd = intersectionEnd + 1\n   \
    \ }\n    \n    if intersectionStart > intersectionEnd {\n        return \"NO\"\
    \n    }\n    \n    if intersectionStart <= intersectionEnd {\n        return \"\
    YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpobefes4x_test.go:32 +0x205\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpobefes4x_test.go:82 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075399
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for interval1Start <= interval1End && interval2Start\
    \ <= interval2End {\n        if interval1Start <= interval2Start {\n         \
    \   intersectionStart = interval1Start\n            intersectionEnd = interval1End\n\
    \        }\n        if interval1End <= interval2End {\n            intersectionEnd\
    \ = interval1End\n        }\n        \n        if intersectionStart <= intersectionEnd\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        }\n    }\n    \n    if intersectionStart <= intersectionEnd\
    \ {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp7pqr9qwk_test.go:32 +0x1d9\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp7pqr9qwk_test.go:75 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075399
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n         \
    \   result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if isPrime(interval1[0].(float64)\
    \ + interval1[1].(float64)) && isPrime(interval2[0].(float64) + interval2[1].(float64))\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph9rtq7_x_test.go:45:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075398
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for interval1Start < interval1End {\n        for\
    \ interval2Start < interval2End {\n            if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n                intersectionStart = interval1Start\n\
    \                intersectionEnd = interval1End\n                break\n     \
    \       }\n            if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n                intersectionStart = interval1End\n                intersectionEnd\
    \ = interval1End\n                break\n            }\n            if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n                intersectionStart\
    \ = interval1Start\n                intersectionEnd = interval1End\n         \
    \       break\n            }\n            if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n                intersectionStart = interval1Start\n\
    \                intersectionEnd = interval1End\n                break\n     \
    \       }\n            if interval1Start >= interval2Start && interval1End >=\
    \ interval2End {\n                intersectionStart = interval1Start\n       \
    \         intersectionEnd = interval1End\n                break\n            }\n\
    \        }\n    }\n    \n    if intersectionStart > intersectionEnd {\n      \
    \  return \"NO\"\n    }\n    if intersectionStart < intersectionEnd {\n      \
    \  return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0001223c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0001223c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc00011bcc0?, 0x2?, 0x2?},\
    \ {0xc00011bca0?, 0x2?, 0x2?})\n\t/tmp/tmp2gmlkf3c_test.go:32 +0x23e\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp2gmlkf3c_test.go:94 +0xe7\ntesting.tRunner(0xc000103380, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075399
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for intersectionStart <= interval2End\
    \ {\n        if intersectionEnd > interval2Start {\n            intersectionEnd\
    \ = interval2End\n        }\n        \n        if intersectionEnd > interval1End\
    \ {\n            intersectionEnd = interval1End\n        }\n        \n       \
    \ if intersectionStart <= intersectionEnd {\n            if intersectionEnd >\
    \ interval1Start {\n                intersectionEnd = interval1End\n         \
    \   }\n            \n            if intersectionStart <= intersectionEnd {\n \
    \               intersectionStart += interval1Start\n                intersectionEnd\
    \ += interval1Start\n            }\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        if intersectionEnd > interval1Start {\n      \
    \      intersectionEnd = interval1End\n        }\n        \n        if intersectionStart\
    \ <= intersectionEnd {\n            intersectionStart += interval1Start\n    \
    \        intersectionEnd += interval1Start\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        if intersectionEnd > interval1Start {\n      \
    \      intersectionEnd = interval1End\n        }\n        \n        if intersectionStart\
    \ <= intersectionEnd {\n            intersectionStart += interval1Start\n    \
    \        intersectionEnd += interval1Start\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        if intersectionEnd > interval1Start {\n      \
    \      intersectionEnd = interval1End\n        }\n        \n        if intersectionStart\
    \ <= intersectionEnd {\n            intersectionStart += interval1Start\n    \
    \        intersectionEnd += interval1Start\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        if intersectionEnd > interval1Start {\n      \
    \      intersectionEnd = interval1End\n        }\n        \n        if intersectionStart\
    \ <= intersectionEnd {\n            intersectionStart += interval1Start\n    \
    \        intersectionEnd += interval1Start\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        if intersectionEnd > interval1Start {\n      \
    \      intersectionEnd = interval1End\n        }\n        \n        if intersectionStart\
    \ <= intersectionEnd {\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsjcf6lk1_test.go:118:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075398
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if intersectionLength == 0 {\n        return \"NO\"\n    }\n    \n\
    \    if interval1Start <= interval2Start && interval1End >= interval2End {\n \
    \       return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0001223c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0001223c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc00011bcc0?, 0x2?, 0x2?},\
    \ {0xc00011bca0?, 0x2?, 0x2?})\n\t/tmp/tmprt_2lep5_test.go:32 +0x217\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmprt_2lep5_test.go:73 +0xe7\ntesting.tRunner(0xc000103520, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075399
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    var interval1Start int\n    var interval1End\
    \ int\n    var interval2Start int\n    var interval2End int\n    var interval1Length\
    \ int\n    var interval2Length int\n    var primeLength bool\n    \n    interval1Start\
    \ = interval1[0].(int)\n    interval1End = interval1[1].(int)\n    interval2Start\
    \ = interval2[0].(int)\n    interval2End = interval2[1].(int)\n    interval1Length\
    \ = interval1End - interval1Start + 1\n    interval2Length = interval2End - interval2Start\
    \ + 1\n    \n    if interval1Length == 0 || interval2Length == 0 {\n        result\
    \ = \"NO\"\n    } else {\n        primeLength = true\n        for i := 2; i <=\
    \ interval1Length && i <= interval2Length; i++ {\n            if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n                if interval1Start\
    \ <= interval2Start {\n                    interval1Start = interval1Start + 1\n\
    \                }\n                if interval1End >= interval2End {\n      \
    \              interval1End = interval1End - 1\n                }\n          \
    \      if interval1Start <= interval2End {\n                    interval1Length\
    \ = interval1End - interval1Start + 1\n                }\n                if interval1Length\
    \ == i {\n                    primeLength = false\n                }\n       \
    \     }\n            if interval1Start <= interval2Start {\n                interval1Start\
    \ = interval1Start + 1\n            }\n            if interval1End >= interval2End\
    \ {\n                interval1End = interval1End - 1\n            }\n        \
    \    if interval1Start <= interval2End {\n                interval1Length = interval1End\
    \ - interval1Start + 1\n            }\n            if interval1Length == i {\n\
    \                primeLength = false\n            }\n        }\n        if primeLength\
    \ {\n            result = \"YES\"\n        } else {\n            result = \"NO\"\
    \n        }\n    }\n    return result\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpwy5z8vv7_test.go:105: expected 'NO', got 'YES'\n    ---\
    \ FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpwy5z8vv7_test.go:105:\
    \ expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpwy5z8vv7_test.go:105: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpwy5z8vv7_test.go:105: expected 'NO', got 'YES'\n    ---\
    \ FAIL: TestIntersection/test_num__5 (0.00s)\n        tmpwy5z8vv7_test.go:105:\
    \ expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n\
    \        tmpwy5z8vv7_test.go:105: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpwy5z8vv7_test.go:105: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075399
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n\n    interval1Start, interval1End := interval1[0], interval1[1]\n   \
    \ interval2Start, interval2End := interval2[0], interval2[1]\n\n    if interval1Start\
    \ > interval2End {\n        return \"NO\"\n    }\n\n    if interval1End < interval2Start\
    \ {\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2Start &&\
    \ interval1End >= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdup9e9ro_test.go:35:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpdup9e9ro_test.go:39:8: invalid operation: interval1End < interval2Start
    (operator < not defined on interface)

    /tmp/tmpdup9e9ro_test.go:43:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpdup9e9ro_test.go:43:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmpdup9e9ro_test.go:47:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpdup9e9ro_test.go:47:42: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpdup9e9ro_test.go:51:8: invalid operation: interval1Start >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpdup9e9ro_test.go:51:44: invalid operation: interval1End <= interval2End
    (operator <= not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075399
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        if intersectionLength == 0 {\n            return \"NO\"\n       \
    \ }\n        \n        if isPrime(intersectionLength) {\n            return \"\
    YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        if intersectionLength\
    \ == 0 {\n            return \"NO\"\n        }\n        \n        if isPrime(intersectionLength)\
    \ {\n            return \"YES\"\n        }\n        \n        return \"NO\"\n\
    \    }\n    \n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        if intersectionLength == 0 {\n            return \"NO\"\n       \
    \ }\n        \n        if isPrime(intersectionLength) {\n            return \"\
    YES\"\n        }\n        \n        return \"NO\"\n    }\n    \n    return \"\
    NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpat213emq_test.go:51:12: undefined: isPrime

    /tmp/tmpat213emq_test.go:63:12: undefined: isPrime

    /tmp/tmpat213emq_test.go:75:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075399
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    if intersection <= 0 {\n        return \"NO\"\n    }\n \
    \   \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf6mk4jeo_test.go:49:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075398
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start, interval1End := interval1[0], interval1[1]\n \
    \   interval2Start, interval2End := interval2[0], interval2[1]\n    if interval1Start\
    \ > interval2End {\n        interval1Start, interval1End = interval2End, interval1Start\n\
    \    }\n    if interval2Start > interval1End {\n        interval2Start, interval2End\
    \ = interval1End, interval2Start\n    }\n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval2Start > interval1End {\n  \
    \      return \"NO\"\n    }\n    if interval1Start < interval2Start {\n      \
    \  return \"NO\"\n    }\n    if interval2Start < interval1Start {\n        return\
    \ \"NO\"\n    }\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2Start &&\
    \ interval1End < interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End >= interval2End {\n        return \"NO\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End < interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start < interval2Start && interval1End\
    \ >= interval2End {\n        return \"NO\"\n    }\n    if interval1Start < interval2Start\
    \ && interval1End < interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End >= interval2End {\n        return \"NO\"\n\
    \    }\n    if interval1Start < interval2Start && interval1End <= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start < interval2Start && interval1End\
    \ >= interval2End {\n        return \"NO\"\n    }\n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End >= interval2End {\n        return \"NO\"\n\
    \    }\n    if interval1Start < interval2Start && interval1End <= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start \nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm5cl3o4j_test.go:94:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075398
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1End <= interval2End\
    \ {\n        if interval1End < interval2Start {\n            break\n        }\n\
    \        \n        if interval1End > intersectionEnd {\n            intersectionStart\
    \ = interval1End\n            intersectionEnd = interval1End\n        }\n    \
    \    \n        if interval1End < intersectionEnd {\n            intersectionEnd\
    \ = interval1End\n        }\n    }\n    \n    if intersectionEnd < interval2Start\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionStart > interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionStart < intersectionEnd\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc000187cc0?, 0x2?, 0x2?},\
    \ {0xc000187ca0?, 0x2?, 0x2?})\n\t/tmp/tmpvaqxjw7s_test.go:32 +0x1c5\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpvaqxjw7s_test.go:84 +0xe7\ntesting.tRunner(0xc0001991e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075399
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    interval1Length := interval1End - interval1Start\n    interval2Length :=\
    \ interval2End - interval2Start\n    \n    if interval1Length == 0 || interval2Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length < interval2Length\
    \ {\n        interval1Start += interval1Length\n        interval1End += interval1Length\n\
    \    }\n    \n    if interval1Start <= interval2Start {\n        return \"YES\"\
    \n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpgkjomk_g_test.go:89: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmpgkjomk_g_test.go:89: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpgkjomk_g_test.go:89: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpgkjomk_g_test.go:89: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075399
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) < interval2[i].(float64) {\n          \
    \  result = \"NO\"\n            break\n        }\n    }\n    \n    if result ==\
    \ \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n     \
    \       result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"\" {\n \
    \       return \"YES\"\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0001903c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0001903c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc000189cc0?, 0x2?, 0x2?},\
    \ {0xc000189ca0?, 0x2?, 0x2?})\n\t/tmp/tmp6ty97cu__test.go:35 +0x1bb\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp6ty97cu__test.go:70 +0xe7\ntesting.tRunner(0xc00019b040, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075399
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersection := interval1Start <= interval2Start && interval1End >= interval2End\n\
    \    if intersection {\n        return \"YES\"\n    }\n    \n    intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n    if\
    \ intersection {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp652nw9uo_test.go:49:18: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075399
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i] > interval2[i] {\n            result = \"NO\"\n \
    \           break\n        }\n    }\n    \n    if result == \"NO\" {\n       \
    \ return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n    \
    \    if interval1[i] < interval2[i] {\n            result = \"NO\"\n         \
    \   break\n        }\n    }\n    \n    if result == \"NO\" {\n        return \"\
    NO\"\n    }\n    \n    if result == \"YES\" {\n        return \"YES\"\n    }\n\
    \    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp79ua2rc4_test.go:35:12: invalid operation: interval1[i] > interval2[i]
    (operator > not defined on interface)

    /tmp/tmp79ua2rc4_test.go:46:12: invalid operation: interval1[i] < interval2[i]
    (operator < not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075399
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for intersectionStart <= interval2End {\n        if interval1Start\
    \ <= intersectionStart && intersectionStart <= interval2End {\n            if\
    \ interval1End <= intersectionEnd && intersectionEnd <= interval2End {\n     \
    \           intersectionEnd = intersectionEnd + 1\n            } else {\n    \
    \            return \"NO\"\n            }\n        } else {\n            return\
    \ \"NO\"\n        }\n    }\n    \n    if interval1Start <= intersectionStart &&\
    \ intersectionStart <= interval2End {\n        return \"YES\"\n    } else {\n\
    \        return \"NO\"\n    }\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmprlexfnba_test.go:86: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmprlexfnba_test.go:86: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075400
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Your code here\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp39vg6js4_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) < len(interval2) {\n        interval1, interval2\
    \ = interval2, interval1\n    }\n    \n    interval1 := interval1[:len(interval2)]\n\
    \    interval2 := interval2[:len(interval1)]\n    \n    result := make([]interface{},\
    \ len(interval1))\n    \n    for i := 0; i < len(interval1); i++ {\n        if\
    \ interval1[i] > interval2[i] {\n            result[i] = interval1[i]\n      \
    \  } else {\n            result[i] = interval2[i]\n        }\n    }\n    \n  \
    \  result := result[:len(interval1)]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := result[:len(result)/2]\n    \n    result := result[:len(result)/2]\n\
    \    \n    result := \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplv6tchye_test.go:114:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075399
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) <= interval2[i].(float64) {\n         \
    \   result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n     \
    \       result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n\
    \        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpz4knjgu8_test.go:35 +0x1ca\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpz4knjgu8_test.go:70 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075400
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        return \"NO\"\n    }\n    if interval2Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    interval1Prime\
    \ := true\n    interval2Prime := true\n    \n    if interval1Length == interval2Length\
    \ {\n        \n        for i := 0; i < interval1Length; i++ {\n            \n\
    \            if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n                interval1Prime = false\n            }\n            \n   \
    \         if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n                interval1Prime = false\n            }\n            \n   \
    \         if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n                interval1Prime = false\n            }\n            \n   \
    \         if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n                interval1Prime = false\n            }\n            \n   \
    \         if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n                interval1Prime = false\n            }\n            \n   \
    \         if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n                interval1Prime = false\n            }\n            \n   \
    \         if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n                interval1Prime = false\n            }\n            \n   \
    \         if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n                interval1Prime = false\n            }\n            \n   \
    \         if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n                interval1Prime = false\n            }\n            \n   \
    \         if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n                interval1Prime = false\n            }\n            \n   \
    \         if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n                interval1Prime = false\n            }\n            \n   \
    \         if \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp90xrwksj_test.go:104:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075399
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var interval1Length, interval2Length int\n    var isIntersecting\
    \ bool\n\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n \
    \   }\n\n    for i := 0; i < len(interval1); i++ {\n        interval1Start = interval1[i].(int)\n\
    \        interval1End = interval1Start + interval1[i].(int)\n        interval1Length\
    \ = interval1End - interval1Start\n\n        interval2Start = interval2[i].(int)\n\
    \        interval2End = interval2Start + interval2[i].(int)\n        interval2Length\
    \ = interval2End - interval2Start\n\n        if interval1Length == 0 || interval2Length\
    \ == 0 {\n            continue\n        }\n\n        if interval1Start > interval2End\
    \ {\n            isIntersecting = false\n            break\n        } else if\
    \ interval1Start < interval2Start {\n            isIntersecting = false\n    \
    \        break\n        } else if interval1End > interval2End {\n            isIntersecting\
    \ = false\n            break\n        }\n    }\n\n    if isIntersecting {\n  \
    \      return \"YES\"\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpnzo8q0m7_test.go:89: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpnzo8q0m7_test.go:89: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075401
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    if intersection <= 0 {\n        return \"NO\"\n    }\n \
    \   \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n    \n  \
    \  return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0l__isva_test.go:49:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075400
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End || interval2Start\
    \ > interval2End {\n        return \"NO\"\n    }\n    \n    intersection := interval1Start\
    \ <= interval2Start && interval1End >= interval2End\n    \n    if intersection\
    \ {\n        if interval1Start <= interval2Start {\n            interval1Start\
    \ += interval1End - interval2Start\n            interval1End -= interval2End -\
    \ interval1Start\n        }\n        if interval1End >= interval2End {\n     \
    \       interval1End -= interval2End - interval1Start\n            interval1Start\
    \ += interval2Start - interval1End\n        }\n    }\n    \n    if interval1Start\
    \ <= interval1End && interval1Start <= interval2Start {\n        if interval1Start\
    \ <= interval2End {\n            interval1Start += interval1End - interval2Start\n\
    \            interval1End -= interval2End - interval1Start\n        }\n      \
    \  if interval1End >= interval2End {\n            interval1End -= interval2End\
    \ - interval1Start\n            interval1Start += interval2Start - interval1End\n\
    \        }\n    }\n    \n    if interval1Start <= interval1End && interval1Start\
    \ <= interval2End {\n        if interval1Start <= interval2End {\n           \
    \ interval1Start += interval1End - interval2Start\n            interval1End -=\
    \ interval2End - interval1Start\n        }\n        if interval1End >= interval2End\
    \ {\n            interval1End -= interval2End - interval1Start\n            interval1Start\
    \ += interval2Start - interval1End\n        }\n    }\n    \n    if interval1Start\
    \ <= interval1End && interval1Start > interval2Start {\n        if interval1Start\
    \ <= interval2End {\n            interval1Start += interval1End - interval2Start\n\
    \            interval1End -= interval2End - interval1Start\n        }\n      \
    \  if interval1End >= interval2End {\n            interval1End -= interval2End\
    \ - interval1Start\n            interval1Start += interval2Start - interval1End\n\
    \        }\n    }\n    \n    if interval1Start <= interval1End && interval1Start\
    \ > interval2End {\n        if interval1Start <= interval\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpytvk8o05_test.go:89:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075400
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    interval1Length := interval1End - interval1Start\n    interval2Length :=\
    \ interval2End - interval2Start\n    \n    if interval1Length == 0 || interval2Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    interval1PrimeLength := interval1Length\
    \ - 1\n    interval2PrimeLength := interval2Length - 1\n    \n    if interval1PrimeLength\
    \ == 0 || interval2PrimeLength == 0 {\n        return \"NO\"\n    }\n    \n  \
    \  if interval1PrimeLength == interval2PrimeLength {\n        if interval1Start\
    \ <= interval2Start {\n            return \"NO\"\n        }\n        if interval1End\
    \ >= interval2End {\n            return \"NO\"\n        }\n        if interval1Start\
    \ <= interval2End {\n            return \"NO\"\n        }\n        if interval1End\
    \ >= interval2Start {\n            return \"NO\"\n        }\n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            return \"YES\"\
    \n        }\n        if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n            return \"YES\"\n        }\n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            return \"YES\"\n        }\n \
    \       if interval1Start >= interval2Start && interval1End <= interval2End {\n\
    \            return \"YES\"\n        }\n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            return \"YES\"\n        }\n \
    \       if interval1Start >= interval2Start && interval1End <= interval2End {\n\
    \            return \"YES\"\n        }\n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            return \"YES\"\n        }\n \
    \       if interval1Start >= interval2Start && interval1End <= interval2End {\n\
    \            return \"YES\"\n        }\n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            return \"YES\"\n        }\n \
    \       if interval1Start >= interval2Start && interval1End <= interval2End {\n\
    \            return \"YES\"\n        }\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo2k2d_5d_test.go:102:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075400
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start > interval1End\
    \ {\n        fmt.Println(\"interval1Start > interval1End\")\n        return \"\
    NO\"\n    }\n    if interval2Start > interval2End {\n        fmt.Println(\"interval2Start\
    \ > interval2End\")\n        return \"NO\"\n    }\n    if interval1Start >= interval2Start\
    \ {\n        fmt.Println(\"interval1Start >= interval2Start\")\n        return\
    \ \"NO\"\n    }\n    if interval1End <= interval2End {\n        fmt.Println(\"\
    interval1End <= interval2End\")\n        return \"NO\"\n    }\n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpok2eloek_test.go:220:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075400
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"NO\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpl4y3q2of_test.go:32 +0x1cc\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpl4y3q2of_test.go:67 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075401
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    intersectionLength\
    \ := interval1Length * interval2Length\n    \n    if intersectionLength == 0 {\n\
    \        return \"NO\"\n    }\n    \n    if isPrime(intersectionLength) {\n  \
    \      return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp36tnccew_test.go:57:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075401
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    if len(interval1) > len(interval2) {\n\
    \        result = intersection(interval2, interval1)\n    } else {\n        result\
    \ = intersection(interval1, interval2)\n    }\n    return result\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0370\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52034d?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x2?, 0x2?}, {0xc0401dfca0?, 0x2?, 0x2?})\n\t/tmp/tmp_g02umi3_test.go:27 +0x79\
    \ fp=0xc0201e0380 sp=0xc0201e0378 pc=0x4ef6d9\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp_g02umi3_test.go:32 +0x4c\
    \ fp=0xc0201e03c0 sp=0xc0201e0380 pc=0x4ef6ac\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp_g02umi3_test.go:32 +0x4c\
    \ fp=0xc0201e0400 sp=0xc0201e03c0 pc=0x4ef6ac\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp_g02umi3_test.go:32 +0x4c\
    \ fp=0xc0201e0440 sp=0xc0201e0400 pc=0x4ef6ac\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp_g02umi3_test.go:32 +0x4c\
    \ fp=0xc0201e0480 sp=0xc0201e0440 pc=0x4ef6ac\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp_g02umi3_test.go:32 +0x4c\
    \ fp=0xc0201e04c0 sp=0xc0201e0480 pc=0x4ef6ac\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp_g02umi3_test.go:32 +0x4c\
    \ fp=0xc0201e0500 sp=0xc0201e04c0 pc=0x4ef6ac\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp_g02umi3_test.go:32 +0x4c\
    \ fp=0xc0201e0540 sp=0xc0201e0500 pc=0x4ef6ac\ncommand-line-arguments_test.intersection({0xc0401dfcc0?,\
    \ 0x0?, 0x0?}, {0xc0401dfca0?, 0x0?, 0x0?})\n\t/tmp/tmp_g02umi3_test.go:32 +0x4c\
    \ fp=0xc0201e0580 sp"
  timestamp: 1660075402
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End + interval2Start\
    \ + interval2End\n    \n    if intersection <= 1 {\n        return \"NO\"\n  \
    \  }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n  \
    \  \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm0x3fkct_test.go:50:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075401
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    \n    if intersection <= 0 {\n        return \"NO\"\n  \
    \  }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n  \
    \  \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2wl81vbj_test.go:50:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075397
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1Start := interval1[0].(int)\n    interval1End :=\
    \ interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval1End {\n      \
    \  fmt.Println(\"interval1Start > interval1End\")\n        return \"NO\"\n   \
    \ }\n    if interval2Start > interval2End {\n        fmt.Println(\"interval2Start\
    \ > interval2End\")\n        return \"NO\"\n    }\n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmi5afwdj_test.go:248:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075400
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        interval1Start, interval1End\
    \ = interval1End, interval1Start\n    }\n    if interval2Start > interval2End\
    \ {\n        interval2Start, interval2End = interval2End, interval2Start\n   \
    \ }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        if interval1Start <= interval2End {\n            interval1Start,\
    \ interval1End = interval2Start, interval2End\n        }\n        if interval1End\
    \ >= interval2Start {\n            interval1End, interval1Start = interval2End,\
    \ interval2Start\n        }\n        \n        if interval1Start <= interval1End\
    \ && interval1Start <= interval2Start && interval1End <= interval2End {\n    \
    \        \n            interval1Start += interval1End - interval1Start\n     \
    \       interval1End -= interval1End - interval1Start\n            interval2Start\
    \ += interval2End - interval2Start\n            interval2End -= interval2End -\
    \ interval2Start\n            \n            if interval1Start <= interval1End\
    \ && interval2Start <= interval2End {\n                \n                if interval1Start\
    \ <= interval2Start {\n                    interval1Start += interval2Start -\
    \ interval1Start\n                    interval1End -= interval2Start - interval1Start\n\
    \                }\n                if interval1End >= interval2End {\n      \
    \              interval1End -= interval2End - interval1End\n                }\n\
    \                \n                if interval1Start <= interval1End && interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n                    \n\
    \                    if interval1Start <= interval2End {\n                   \
    \     interval1Start += interval2End - interval1Start\n                      \
    \  interval1End -= interval2End - interval1Start\n                    }\n    \
    \                if interval1End >= interval2Start {\n                       \
    \ interval1End -= interval2Start - interval1End\n                    }\n     \
    \               \n                    if interval1Start <= interval1End && interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n                      \
    \  \n                        if interval1Start <= interval2End {\n           \
    \                 interval1Start += interval2End - interval1Start\n          \
    \                  interval1End -= interval2End - interval1Start\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwg5baztq_test.go:85:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075400
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End || interval2Start\
    \ > interval2End {\n        return \"NO\"\n    }\n    \n    interval1Start +=\
    \ 0.5\n    interval1End += 0.5\n    interval2Start += 0.5\n    interval2End +=\
    \ 0.5\n    \n    interval1Start := int(interval1Start)\n    interval1End := int(interval1End)\n\
    \    interval2Start := int(interval2Start)\n    interval2End := int(interval2End)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start < interval2Start {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start < interval2Start {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start == interval2Start {\n        if interval1End > interval2End\
    \ {\n            return \"NO\"\n        }\n    }\n    \n    if interval1Start\
    \ == interval2Start {\n        if interval1End > interval2End {\n            return\
    \ \"NO\"\n        }\n    }\n    \n    if interval1Start == interval2Start {\n\
    \        if interval1End > interval2End {\n            return \"NO\"\n       \
    \ }\n    }\n    \n    if interval1Start == interval2Start {\n        if interval1End\
    \ > interval2End {\n            return \"NO\"\n        }\n    }\n    \n    if\
    \ interval1Start == interval2Start {\n        if interval1End > interval2End {\n\
    \            return \"NO\"\n        }\n    }\n    \n    if interval1Start == interval2Start\
    \ {\n        if interval1End > interval2End {\n            return \"NO\"\n   \
    \     }\n    }\n    \n    if interval1Start == interval2Start {\n        if interval1End\
    \ > interval2End {\n            return \"NO\"\n        }\n    }\n    \n    if\
    \ interval1Start == interval2Start {\n        if interval1End > interval2End {\n\
    \            return \"NO\"\n        }\n    }\n    \n    if interval1Start == interval2Start\
    \ {\n        if interval1End > interval2End {\n            return \"NO\"\n   \
    \     }\n    }\n    \n    if interval1Start == interval\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpauf13gzq_test.go:122:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075400
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval1End {\n      \
    \  return \"NO\"\n    }\n    \n    if interval2Start > interval2End {\n      \
    \  return \"NO\"\n    }\n    \n    if interval1Start >= interval2Start {\n   \
    \     interval1Start = interval1Start + 1\n    }\n    \n    if interval1End <=\
    \ interval2End {\n        interval1End = interval1End + 1\n    }\n    \n    if\
    \ interval1Start > interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start {\n        interval1Start = interval1Start\
    \ + 1\n    }\n    \n    if interval1End >= interval2End {\n        interval1End\
    \ = interval1End + 1\n    }\n    \n    if interval1Start < interval2Start {\n\
    \        return \"NO\"\n    }\n    \n    if interval1End > interval2End {\n  \
    \      return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start &&\
    \ interval1End >= interval2End {\n        return \"YES\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start && interval1End < interval2End {\n        return\
    \ \"NO\"\n    }\n    \n    if interval1Start >= interval2Start && interval1End\
    \ > interval2End {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ < interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start > interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start > interval2Start\
    \ && interval1End < interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start && interval1End > interval2End {\n        return\
    \ \"NO\"\n    }\n    \n    if interval1Start < interval2Start && interval1End\
    \ <= interval2End {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ > interval2Start && interval1End < interval2End {\n        return \"NO\"\n \
    \   }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start < interval2Start\
    \ && interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjxnwk6ge_test.go:115:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075400
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    var length int\n    var start int\n   \
    \ var end int\n    var i int\n    var j int\n    var k int\n    var l int\n  \
    \  var m int\n    var n int\n    var o int\n    var p int\n    var q int\n   \
    \ var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var\
    \ w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b\
    \ int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n\
    \    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n \
    \   var m int\n    var n int\n    var o int\n    var p int\n    var q int\n  \
    \  var r int\n    var s int\n    var t int\n    var u int\n    var v int\n   \
    \ var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var\
    \ b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g\
    \ int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n\
    \    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n \
    \   var r int\n    var s int\n    var t int\n    var u int\n    var v int\n  \
    \  var w int\n    var x int\n    var y int\n    var z int\n    var a int\n   \
    \ var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var\
    \ g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l\
    \ int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n\
    \    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n \
    \   var w int\n    var x int\n    var y int\n    var z int\n    var a int\n  \
    \  var b int\n    var c int\n    var d int\n    var e int\n    var f int\n   \
    \ var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var\
    \ l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q\
    \ int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n\
    \    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n \
    \   var b int\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppe0hqtly_test.go:157:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075401
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if intersectionStart <= interval1Start && intersectionEnd\
    \ >= interval1End {\n            intersectionStart = interval1Start\n        \
    \    intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc000187cc0?, 0x2?, 0x2?},\
    \ {0xc000187ca0?, 0x2?, 0x2?})\n\t/tmp/tmpbykqfes6_test.go:32 +0x24f\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpbykqfes6_test.go:77 +0xe7\ntesting.tRunner(0xc000199040, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075402
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) < len(interval2) {\n        interval1, interval2\
    \ = interval2, interval1\n    }\n    \n    interval1Start := interval1[0].(int)\n\
    \    interval1End := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n\
    \    interval2End := interval2[1].(int)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    interval1PrimeLength\
    \ := interval1Length - 1\n    interval2PrimeLength := interval2Length - 1\n  \
    \  \n    if interval1PrimeLength == 0 || interval2PrimeLength == 0 {\n       \
    \ return \"NO\"\n    }\n    \n    if interval1PrimeLength == interval2PrimeLength\
    \ {\n        interval1PrimeLength--\n        interval2PrimeLength--\n    }\n \
    \   \n    if interval1PrimeLength == 0 {\n        return \"NO\"\n    }\n    \n\
    \    if interval2PrimeLength == 0 {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1PrimeLength == interval2PrimeLength {\n        interval1PrimeLength--\n\
    \        interval2PrimeLength--\n    }\n    \n    if interval1PrimeLength == 0\
    \ {\n        return \"NO\"\n    }\n    \n    if interval2PrimeLength == 0 {\n\
    \        return \"NO\"\n    }\n    \n    if interval1PrimeLength == interval2PrimeLength\
    \ {\n        interval1PrimeLength--\n        interval2PrimeLength--\n    }\n \
    \   \n    if interval1PrimeLength == 0 {\n        return \"NO\"\n    }\n    \n\
    \    if interval2PrimeLength == 0 {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1PrimeLength == interval2PrimeLength {\n        interval1PrimeLength--\n\
    \        interval2PrimeLength--\n    }\n    \n    if interval1PrimeLength == 0\
    \ {\n        return \"NO\"\n    }\n    \n    if interval2PrimeLength == 0 {\n\
    \        return \"NO\"\n    }\n    \n    if interval1PrimeLength == interval2PrimeLength\
    \ {\n        interval1PrimeLength--\n        interval2PrimeLength--\n    }\n \
    \   \n    if interval1PrimeLength\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqc0e4xl6_test.go:116:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075401
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1Start := interval1[0].(int)\n    interval1End :=\
    \ interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval1End {\n      \
    \  fmt.Println(\"interval1Start > interval1End\")\n        return \"NO\"\n   \
    \ }\n    if interval2Start > interval2End {\n        fmt.Println(\"interval2Start\
    \ > interval2End\")\n        return \"NO\"\n    }\n    \n    \n    if interval1Start\
    \ < interval2Start {\n        fmt.Println(\"interval1Start < interval2Start\"\
    )\n        return \"NO\"\n    }\n    if interval1End > interval2End {\n      \
    \  fmt.Println(\"interval1End > interval2End\")\n        return \"NO\"\n    }\n\
    \    \n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"YES\"\n    }\n    if interval1Start <= interval2Start\
    \ && interval1End < interval2End {\n        fmt.Println(\"interval1Start <= interval2Start\
    \ && interval1End < interval2End\")\n        return \"NO\"\n    }\n    if interval1Start\
    \ < interval2Start && interval1End <= interval2End {\n        fmt.Println(\"interval1Start\
    \ < interval2Start && interval1End <= interval2End\")\n        return \"NO\"\n\
    \    }\n    if interval1Start > interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start > interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n    if interval1Start > interval2Start\
    \ && interval1End < interval2End {\n        fmt.Println(\"interval1Start > interval2Start\
    \ && interval1End < interval2End\")\n        return \"NO\"\n    }\n    \n    \n\
    \    if interval1Start <= interval2Start && interval1End >= interval2End {\n \
    \       fmt.Println(\"interval1Start <= interval2Start && interval1End >= interval2End\"\
    )\n        return \"YES\"\n    }\n    if interval1Start <= interval2Start && interval1End\
    \ < interval2End {\n        fmt.Println(\"interval1Start <= interval2Start &&\
    \ interval1End < interval2End\")\n        return \"NO\"\n    }\n    if interval1Start\
    \ < interval2Start && interval1End <= interval2End {\n        fmt.Println(\"interval1Start\
    \ \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplmksqdb0_test.go:85:21: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075401
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Your code here\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp39vg6js4_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := make([]int, len(interval1))\n    interval2 := make([]int,\
    \ len(interval2))\n    \n    for i := 0; i < len(interval1); i++ {\n        interval1[i]\
    \ = int(interval1[i])\n    }\n    for i := 0; i < len(interval2); i++ {\n    \
    \    interval2[i] = int(interval2[i])\n    }\n    \n    result := make([]int,\
    \ len(interval1))\n    \n    for i := 0; i < len(interval1); i++ {\n        for\
    \ j := 0; j < len(interval2); j++ {\n            if interval1[i] < interval2[j]\
    \ {\n                result[i] = interval1[i]\n                break\n       \
    \     }\n        }\n    }\n    \n    if len(result) == 0 {\n        return \"\
    NO\"\n    }\n    \n    for i := 0; i < len(result); i++ {\n        if result[i]\
    \ == interval1[i] {\n            continue\n        }\n        if result[i] ==\
    \ interval2[i] {\n            continue\n        }\n        if result[i] > interval1[i]\
    \ && result[i] < interval2[i] {\n            return \"YES\"\n        }\n    }\n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbf1t59an_test.go:32:15:\
    \ no new variables on left side of :=\n/tmp/tmpbf1t59an_test.go:32:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmpbf1t59an_test.go:33:15: no new variables on left side\
    \ of :=\n/tmp/tmpbf1t59an_test.go:33:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmpbf1t59an_test.go:36:28:\
    \ cannot convert interval1[i] (variable of type interface{}) to type int:\n\t\
    need type assertion\n/tmp/tmpbf1t59an_test.go:39:28: cannot convert interval2[i]\
    \ (variable of type interface{}) to type int:\n\tneed type assertion\n/tmp/tmpbf1t59an_test.go:46:16:\
    \ invalid operation: interval1[i] < interval2[j] (operator < not defined on interface)\n\
    /tmp/tmpbf1t59an_test.go:47:29: cannot use interval1[i] (variable of type interface{})\
    \ as type int in assignment:\n\tneed type assertion\n/tmp/tmpbf1t59an_test.go:64:24:\
    \ invalid operation: result[i] > interval1[i] (operator > not defined on interface)\n\
    /tmp/tmpbf1t59an_test.go:64:52: invalid operation: result[i] < interval2[i] (operator\
    \ < not defined on interface)\n/tmp/tmpbf1t59an_test.go:64:52: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075401
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start > interval1End\
    \ {\n            return \"NO\"\n        }\n        \n        if interval2Start\
    \ > interval2End {\n            return \"NO\"\n        }\n        \n        if\
    \ interval1Start < interval2Start {\n            intersectionStart = interval1Start\n\
    \            intersectionEnd = interval1End\n        }\n        \n        if interval1End\
    \ > interval2End {\n            intersectionStart = interval1End\n           \
    \ intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ > intersectionEnd {\n        return \"NO\"\n    }\n    \n    if intersectionStart\
    \ < intersectionEnd {\n        return \"YES\"\n    }\n    \n    if intersectionStart\
    \ == intersectionEnd {\n        return \"YES\"\n    }\n    \n    if intersectionStart\
    \ < intersectionEnd {\n        return \"NO\"\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpqbh1p2ae_test.go:32 +0x26c\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpqbh1p2ae_test.go:89 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075402
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start {\n\
    \        interval1Start += interval1End - interval2Start\n        interval1End\
    \ -= interval1End - interval2Start\n    }\n    if interval1End >= interval2End\
    \ {\n        interval1End += interval1Start - interval2End\n        interval1Start\
    \ -= interval1Start - interval2End\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start {\n\
    \        interval1Start += interval1End - interval2Start\n        interval1End\
    \ -= interval1End - interval2Start\n    }\n    if interval1End >= interval2End\
    \ {\n        interval1End += interval1Start - interval2End\n        interval1Start\
    \ -= interval1Start - interval2End\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start {\n\
    \        interval1Start += interval1End - interval2Start\n        interval1End\
    \ -= interval1End - interval2Start\n    }\n    if interval1End >= interval2End\
    \ {\n        interval1End += interval1Start - interval2End\n        interval1Start\
    \ -= interval1Start - interval2End\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start {\n\
    \        interval1Start += interval1End - interval2Start\n        interval1End\
    \ -= interval1End - interval2Start\n    }\n    if interval1End >= interval2End\
    \ {\n        interval1End += interval1Start - interval2End\n        interval1Start\
    \ -= interval1Start - interval2End\n    }\n    \n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbus4z8iq_test.go:102:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075401
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start, interval1End := interval1[0].(int), interval1[1].(int)\n\
    \    interval2Start, interval2End := interval2[0].(int), interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        fmt.Println(\"interval1Start\
    \ > interval1End\")\n        return \"NO\"\n    }\n    if interval2Start > interval2End\
    \ {\n        fmt.Println(\"interval2Start > interval2End\")\n        return \"\
    NO\"\n    }\n    \n    if interval1Start < interval2Start {\n        fmt.Println(\"\
    interval1Start < interval2Start\")\n        return \"NO\"\n    }\n    if interval1End\
    \ > interval2End {\n        fmt.Println(\"interval1End > interval2End\")\n   \
    \     return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        fmt.Println(\"interval1Start <= interval2Start &&\
    \ interval1End >= interval2End\")\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2Start && interval1End < interval2End {\n        fmt.Println(\"interval1Start\
    \ <= interval2Start && interval1End < interval2End\")\n        return \"NO\"\n\
    \    }\n    if interval1Start < interval2Start && interval1End <= interval2End\
    \ {\n        fmt.Println(\"interval1Start < interval2Start && interval1End <=\
    \ interval2End\")\n        return \"NO\"\n    }\n    \n    if interval1Start <=\
    \ interval2Start && interval1End >= interval2End {\n        fmt.Println(\"interval1Start\
    \ <= interval2Start && interval1End >= interval2End\")\n        return \"YES\"\
    \n    }\n    if interval1Start < interval2Start && interval1End <= interval2End\
    \ {\n        fmt.Println(\"interval1Start < interval2Start && interval1End <=\
    \ interval2End\")\n        return \"NO\"\n    }\n    \n    if interval1Start <=\
    \ interval2Start && interval1End < interval2End {\n        fmt.Println(\"interval1Start\
    \ <= interval2Start && interval1End < interval2End\")\n        return \"NO\"\n\
    \    }\n    if interval1Start < interval2Start && interval1End <= interval2End\
    \ {\n        fmt.Println(\"interval1Start < interval2Start && interval1End <=\
    \ interval2End\")\n        return \"NO\"\n    }\n    \n    if interval1Start <=\
    \ interval2Start && interval1End >= interval2End {\n        fmt.Println(\"interval1Start\
    \ <= interval2Start && interval1End \nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkki0pixg_test.go:81:21: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075401
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    interval1Length := interval1End\
    \ - interval1Start\n    interval2Length := interval2End - interval2Start\n   \
    \ \n    if interval1Length == 0 || interval2Length == 0 {\n        return \"NO\"\
    \n    }\n    \n    intersectionLength := interval1Length * interval2Length\n \
    \   \n    if intersectionLength == 0 {\n        return \"NO\"\n    }\n    \n \
    \   if interval1Length == interval2Length {\n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            return \"YES\"\n        }\n \
    \       return \"NO\"\n    }\n    \n    if interval1Length > interval2Length {\n\
    \        interval1Length, interval2Length = interval2Length, interval1Length\n\
    \    }\n    \n    if interval1Length == 1 {\n        if interval1Start <= interval2Start\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n   \
    \ \n    if interval2Length == 1 {\n        if interval2Start <= interval1Start\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n   \
    \ \n    if interval1Length == interval2Length {\n        if interval1Start <=\
    \ interval2Start {\n            return \"YES\"\n        }\n        if interval1End\
    \ >= interval2End {\n            return \"YES\"\n        }\n        return \"\
    NO\"\n    }\n    \n    if interval1Length > interval2Length {\n        interval1Length,\
    \ interval2Length = interval2Length, interval1Length\n    }\n    \n    if interval1Length\
    \ == 1 {\n        if interval1Start <= interval2Start {\n            return \"\
    YES\"\n        }\n        if interval1End >= interval2End {\n            return\
    \ \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if interval2Length\
    \ == 1 {\n        if interval2Start <= interval1Start {\n            return \"\
    YES\"\n        }\n        if interval2End >= interval1End {\n            return\
    \ \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ == interval2\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqxwqe8wg_test.go:117:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075401
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    interval1Start += interval2Start\n\
    \    interval1End += interval2Start\n    \n    if interval1Start < interval1End\
    \ {\n        interval1Start += interval1End\n        interval1End += interval1End\n\
    \    }\n    if interval2Start < interval2End {\n        interval2Start += interval2End\n\
    \        interval2End += interval2End\n    }\n    \n    if interval1Start > interval1End\
    \ {\n        return \"NO\"\n    }\n    if interval2Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    \n    if interval1Start < interval2Start {\n\
    \        return \"NO\"\n    }\n    if interval1Start > interval2End {\n      \
    \  return \"NO\"\n    }\n    \n    if interval2Start < interval1End {\n      \
    \  return \"NO\"\n    }\n    if interval2Start > interval1End {\n        return\
    \ \"NO\"\n    }\n    \n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        return \"YES\"\n    }\n    if interval2Start <= interval1Start\
    \ && interval2End >= interval1End {\n        return \"YES\"\n    }\n    \n   \
    \ return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp0yqgmtwj_test.go:32 +0x257\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp0yqgmtwj_test.go:94 +0xe7\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075402
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Your code here\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp39vg6js4_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start < interval2Start {\n\
    \        return \"NO\"\n    }\n    \n    intersectionLength := interval1End -\
    \ interval1Start\n    if interval1Start <= interval2Start {\n        intersectionLength\
    \ += interval2End - interval2Start\n    }\n    \n    if intersectionLength ==\
    \ 0 {\n        return \"NO\"\n    }\n    \n    if isPrime(intersectionLength)\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3uthh0k5_test.go:60:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075402
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := make([]int, len(interval1))\n    interval2 := make([]int,\
    \ len(interval2))\n    \n    for i := range interval1 {\n        interval1[i]\
    \ = int(interval1[i])\n    }\n    for i := range interval2 {\n        interval2[i]\
    \ = int(interval2[i])\n    }\n    \n    result := make([]int, len(interval1))\n\
    \    \n    for i := range interval1 {\n        for j := range interval2 {\n  \
    \          if interval1[i] <= interval2[j] {\n                result[i] = interval1[i]\n\
    \                break\n            }\n        }\n    }\n    \n    if len(result)\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    result := make([]int, len(result))\n\
    \    \n    for i := range result {\n        if result[i] == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    \n    if isPrime(result[0]) {\n        return\
    \ \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz81yv0i2_test.go:32:15:\
    \ no new variables on left side of :=\n/tmp/tmpz81yv0i2_test.go:32:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmpz81yv0i2_test.go:33:15: no new variables on left side\
    \ of :=\n/tmp/tmpz81yv0i2_test.go:33:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmpz81yv0i2_test.go:36:28:\
    \ cannot convert interval1[i] (variable of type interface{}) to type int:\n\t\
    need type assertion\n/tmp/tmpz81yv0i2_test.go:39:28: cannot convert interval2[i]\
    \ (variable of type interface{}) to type int:\n\tneed type assertion\n/tmp/tmpz81yv0i2_test.go:46:16:\
    \ invalid operation: interval1[i] <= interval2[j] (operator <= not defined on\
    \ interface)\n/tmp/tmpz81yv0i2_test.go:47:29: cannot use interval1[i] (variable\
    \ of type interface{}) as type int in assignment:\n\tneed type assertion\n/tmp/tmpz81yv0i2_test.go:57:12:\
    \ no new variables on left side of :=\n/tmp/tmpz81yv0i2_test.go:65:8: undefined:\
    \ isPrime\n/tmp/tmpz81yv0i2_test.go:65:8: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075402
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n\n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\n   \
    \ if interval1End < interval2Start {\n        return \"NO\"\n    }\n\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return \"YES\"\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp6ev04iew_test.go:76: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp6ev04iew_test.go:76: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp6ev04iew_test.go:76: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp6ev04iew_test.go:76: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp6ev04iew_test.go:76: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075402
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    interval1Length := interval1End - interval1Start\n    interval2Length :=\
    \ interval2End - interval2Start\n    \n    if interval1Length == 0 || interval2Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length-1\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length-2\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length-3\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length-4\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length-5\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length-6\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length-7\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length-8\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length-9\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length-10\
    \ {\n        if interval1Start <= interval2Start {\n            return \"\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5qa6tjh3_test.go:123:20: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075401
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) < interval2[i].(float64) {\n          \
    \  result = \"NO\"\n            break\n        }\n    }\n    \n    if result ==\
    \ \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n     \
    \       result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if isPrime(interval1[0].(float64)\
    \ + interval1[1].(float64)) {\n        result = \"YES\"\n    }\n    \n    return\
    \ result\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpothi3kxq_test.go:56:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075402
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start > interval1End\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n            continue\n        }\n        \n        if interval2Start\
    \ > interval2End {\n            intersectionStart = interval2Start\n         \
    \   intersectionEnd = interval2End\n            continue\n        }\n        \n\
    \        if interval1Start <= interval2Start && interval1End >= interval2End {\n\
    \            intersectionStart = interval1Start\n            intersectionEnd =\
    \ interval1End\n            continue\n        }\n        \n        if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n            continue\n\
    \        }\n        \n        if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n            intersectionStart = interval1Start\n        \
    \    intersectionEnd = interval1End\n            continue\n        }\n       \
    \ \n        if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n            continue\n        }\n        \n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n            continue\n\
    \        }\n        \n        if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n            intersectionStart = interval1Start\n        \
    \    intersectionEnd = interval1End\n            continue\n        }\n       \
    \ \n        if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n            continue\n        }\n        \n        if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n            continue\n\
    \        }\n        \n        if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n            intersectionStart = interval1Start\n        \
    \    intersectionEnd = interval1End\nfunc TestIntersection(t *testing.T) {\n \
    \ candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjm39gl9p_test.go:107:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075401
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := make([]int, len(interval1))\n    interval2 := make([]int,\
    \ len(interval2))\n    \n    for i, v := range interval1 {\n        interval1[i]\
    \ = v.(int)\n    }\n    for i, v := range interval2 {\n        interval2[i] =\
    \ v.(int)\n    }\n    \n    result := make([]int, len(interval1))\n    \n    for\
    \ i, v := range interval1 {\n        for _, v2 := range interval2 {\n        \
    \    if v >= v2 {\n                result[i] = v\n                break\n    \
    \        }\n        }\n    }\n    \n    if len(result) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    result := make([]int, len(result))\n    \n    for i,\
    \ v := range result {\n        if v%2 == 0 {\n            return \"NO\"\n    \
    \    }\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnj8xqks__test.go:32:15:\
    \ no new variables on left side of :=\n/tmp/tmpnj8xqks__test.go:32:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmpnj8xqks__test.go:33:15: no new variables on left side\
    \ of :=\n/tmp/tmpnj8xqks__test.go:33:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmpnj8xqks__test.go:46:16:\
    \ invalid operation: v >= v2 (operator >= not defined on interface)\n/tmp/tmpnj8xqks__test.go:47:29:\
    \ cannot use v (variable of type interface{}) as type int in assignment:\n\tneed\
    \ type assertion\n/tmp/tmpnj8xqks__test.go:57:12: no new variables on left side\
    \ of :=\n/tmp/tmpnj8xqks__test.go:59:9: i declared but not used\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075402
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) < interval2[i].(float64) {\n          \
    \  result = \"NO\"\n            break\n        }\n    }\n    \n    if result ==\
    \ \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n     \
    \       result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n\
    \        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc000187cc0?, 0x2?, 0x2?},\
    \ {0xc000187ca0?, 0x2?, 0x2?})\n\t/tmp/tmp6i2tvarn_test.go:35 +0x1ca\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp6i2tvarn_test.go:70 +0xe7\ntesting.tRunner(0xc000198ea0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075403
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start > interval1End\
    \ {\n            return \"NO\"\n        }\n        \n        if interval2Start\
    \ > interval2End {\n            return \"NO\"\n        }\n        \n        if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \     intersectionStart = interval1Start\n            intersectionEnd = interval1End\n\
    \        }\n        \n        if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n            intersectionEnd = interval1End\n        }\n\
    \    }\n    \n    if intersectionStart <= intersectionEnd {\n        length :=\
    \ float64(intersectionEnd - intersectionStart)\n        if length == 2 {\n   \
    \         return \"YES\"\n        }\n        if length == 3 {\n            return\
    \ \"YES\"\n        }\n        if length == 4 {\n            return \"YES\"\n \
    \       }\n        if length == 5 {\n            return \"YES\"\n        }\n \
    \       if length == 6 {\n            return \"YES\"\n        }\n        if length\
    \ == 7 {\n            return \"YES\"\n        }\n        if length == 8 {\n  \
    \          return \"YES\"\n        }\n        if length == 9 {\n            return\
    \ \"YES\"\n        }\n        if length == 10 {\n            return \"YES\"\n\
    \        }\n        if length == 11 {\n            return \"YES\"\n        }\n\
    \        if length == 12 {\n            return \"YES\"\n        }\n        if\
    \ length == 13 {\n            return \"YES\"\n        }\n        if length ==\
    \ 14 {\n            return \"YES\"\n        }\n        if length == 15 {\n   \
    \         return \"YES\"\n        }\n        if length == 16 {\n            return\
    \ \"YES\"\n        }\n        if length == 17 {\n            return \"YES\"\n\
    \        }\n        if length == 18 {\n            return \"YES\"\n        }\n\
    \        if length == 19 {\n            return \"YES\"\n        }\n        if\
    \ length == 20 {\n            return \"YES\"\n        }\n        if length ==\
    \ 21 {\n            return \"YES\"\n        }\n        if length == 22 {\n   \
    \         return \"YES\"\n        }\n        if length == 100 {\n            return\
    \ \"YES\"\n        }\n        if length == 200 {\n            return \"YES\"\n\
    \        }\n        if length == 300 {\n            return \"YES\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkb_ri61q_test.go:134:20: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075402
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if intersectionLength == 0 {\n        return \"NO\"\n    }\n    \n\
    \    if interval1Start <= interval2Start && interval1End >= interval2End {\n \
    \       return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n \
    \ candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp7zg9u7gm_test.go:32 +0x1e8\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp7zg9u7gm_test.go:70 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075403
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    if intersection <= 0 {\n        return \"NO\"\n    }\n \
    \   \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n    \n  \
    \  return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0l__isva_test.go:49:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075400
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if intersectionStart <= interval1Start && intersectionEnd\
    \ >= interval1End {\n            intersectionEnd = interval1End\n        } else\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        }\n    }\n    \n    if intersectionEnd < interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionStart <= interval2Start\
    \ && intersectionEnd >= interval2End {\n        return \"YES\"\n    }\n    \n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0001283c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0001283c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc000123cc0?, 0x2?, 0x2?},\
    \ {0xc000123ca0?, 0x2?, 0x2?})\n\t/tmp/tmpvcdyxytp_test.go:32 +0x26f\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpvcdyxytp_test.go:84 +0xe7\ntesting.tRunner(0xc000103860, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075403
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval1End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval1Start {\n            return \"\
    NO\"\n        }\n        \n        if intersectionStart > interval1End {\n   \
    \         return \"NO\"\n        }\n        if intersectionEnd < interval1Start\
    \ {\n            return \"NO\"\n        }\n        \n        intersectionStart\
    \ = interval1Start\n        intersectionEnd = interval1End\n    }\n    \n    if\
    \ intersectionStart > intersectionEnd {\n        return \"NO\"\n    }\n    if\
    \ intersectionEnd < intersectionStart {\n        return \"NO\"\n    }\n    \n\
    \    if intersectionStart < intersectionEnd {\n        intersectionStart += interval1Start\n\
    \        intersectionEnd += interval1End\n    }\n    \n    if intersectionStart\
    \ > interval2End {\n        return \"NO\"\n    }\n    if intersectionEnd < interval2Start\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionStart > interval2End\
    \ {\n        return \"NO\"\n    }\n    if intersectionEnd < interval2Start {\n\
    \        return \"NO\"\n    }\n    \n    if intersectionStart > interval2End {\n\
    \        return \"NO\"\n    }\n    if intersectionEnd < interval2Start {\n   \
    \     return \"NO\"\n    }\n    \n    if intersectionStart > interval2End {\n\
    \        return \"NO\"\n    }\n    if intersectionEnd < interval2Start {\n   \
    \     return \"NO\"\n    }\n    \n    if intersectionStart > interval2End {\n\
    \        return \"NO\"\n    }\n    if intersectionEnd < interval2Start {\n   \
    \     return \"NO\"\n    }\n    \n    if intersectionStart > interval2End {\n\
    \        return \"NO\"\n    }\n    if intersectionEnd < interval2Start {\n   \
    \     return \"NO\"\n    }\n    \n    if intersectionStart > interval2End {\n\
    \        return \"NO\"\n    }\n    if intersectionEnd < interval2Start {\n   \
    \     return \"NO\"\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu2l76zf5_test.go:128:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075402
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjbvn0uj2_test.go:267:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075402
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionEnd = interval1End\n       \
    \ }\n        if interval1Start <= intersectionStart && interval1End >= intersectionEnd\
    \ {\n            intersectionStart = interval1Start\n        }\n    }\n    \n\
    \    if intersectionStart <= intersectionEnd {\n        return \"YES\"\n    }\n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0001223c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0001223c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc00011bcc0?, 0x2?, 0x2?},\
    \ {0xc00011bca0?, 0x2?, 0x2?})\n\t/tmp/tmprkwpm2ib_test.go:32 +0x26c\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmprkwpm2ib_test.go:79 +0xe7\ntesting.tRunner(0xc000103520, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075403
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start <=\
    \ interval2Start && interval2Start <= interval1End\n    intersectionEnd := interval1Start\
    \ <= interval2End && interval2End <= interval1End\n    \n    if intersectionStart\
    \ && intersectionEnd {\n        intersectionLength := interval1End - interval1Start\n\
    \        if isPrime(intersectionLength) {\n            return \"YES\"\n      \
    \  }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n \
    \ candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqokzw6zs_test.go:42:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075403
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start <= interval1End\
    \ && interval2Start <= interval2End {\n            intersectionStart = min(intersectionStart,\
    \ interval1Start)\n            intersectionEnd = max(intersectionEnd, interval1End)\n\
    \        }\n    }\n    \n    for i := 1; i < len(interval2); i++ {\n        interval2Start\
    \ := interval2[i].(float64)\n        interval2End := interval2[i+1].(float64)\n\
    \        \n        if interval1Start <= interval1End && interval2Start <= interval2End\
    \ {\n            intersectionStart = min(intersectionStart, interval2Start)\n\
    \            intersectionEnd = max(intersectionEnd, interval2End)\n        }\n\
    \    }\n    \n    if intersectionStart <= intersectionEnd {\n        if intersectionEnd\
    \ - intersectionStart > 1 {\n            isPrime := true\n            for i :=\
    \ 2; i <= (intersectionEnd - intersectionStart)/2; i++ {\n                if i*i\
    \ == (intersectionEnd - intersectionStart) {\n                    isPrime = false\n\
    \                    break\n                }\n            }\n            if isPrime\
    \ {\n                return \"YES\"\n            }\n        }\n    }\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyus3qy4p_test.go:45:33: undefined: min

    /tmp/tmpyus3qy4p_test.go:46:31: undefined: max

    /tmp/tmpyus3qy4p_test.go:55:33: undefined: min

    /tmp/tmpyus3qy4p_test.go:56:31: undefined: max

    /tmp/tmpyus3qy4p_test.go:63:30: invalid operation: i <= (intersectionEnd - intersectionStart)
    / 2 (mismatched types int and float64)

    /tmp/tmpyus3qy4p_test.go:64:27: invalid operation: i * i == (intersectionEnd -
    intersectionStart) (mismatched types int and float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075403
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    intersection := interval1Start <= interval2Start && interval1End >= interval2End\n\
    \    if intersection {\n        intersection := interval1Start <= interval2End\
    \ && interval1End >= interval2Start\n        if intersection {\n            intersection\
    \ := interval1Start <= interval2Start && interval1End >= interval2End\n      \
    \      if intersection {\n                intersection := interval1Start <= interval2End\
    \ && interval1End >= interval2Start\n                if intersection {\n     \
    \               intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                    if intersection {\n                 \
    \       intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \                        if intersection {\n                            intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n      \
    \                      if intersection {\n                                intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n      \
    \                          if intersection {\n                               \
    \     intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \                                    if intersection {\n                     \
    \                   intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                                        if intersection {\n\
    \                                            intersection := interval1Start <=\
    \ interval2End && interval1End >= interval2Start\n                           \
    \                 if intersection {\n                                        \
    \        intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \                                                if intersection {\n         \
    \                                           intersection := interval1Start <=\
    \ interval2End && interval1End >= interval2Start\n                           \
    \                         if intersection {\n                                \
    \                        intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                                                        if\
    \ intersection {\n                                                           \
    \ intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \                                                            if intersection {\n\
    \                                                                intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n      \
    \                                                          if intersection {\n\
    \                                                                    intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n      \
    \                                                              if intersection\
    \ {\n                                \nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgozxn2eu_test.go:79:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075402
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start, interval1End := interval1[0], interval1[1]\n \
    \   interval2Start, interval2End := interval2[0], interval2[1]\n    if interval1Start\
    \ > interval2End {\n        interval1Start, interval1End = interval2End, interval1Start\n\
    \    }\n    if interval2Start > interval1End {\n        interval2Start, interval2End\
    \ = interval1End, interval2Start\n    }\n    if interval1Start >= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval2Start >= interval1End {\n \
    \       return \"NO\"\n    }\n    if interval1Start <= interval2Start {\n    \
    \    return \"NO\"\n    }\n    if interval2Start <= interval1Start {\n       \
    \ return \"NO\"\n    }\n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        return \"YES\"\n    }\n    if interval2Start <= interval1Start\
    \ && interval2End >= interval1End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval2Start <= interval1Start && interval2End >= interval1End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"YES\"\n    }\n    if interval2Start\
    \ <= interval1Start && interval2End <= interval1End {\n        return \"YES\"\n\
    \    }\n    if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval2Start <= interval1Start &&\
    \ interval2End <= interval1End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval2Start <= interval1Start && interval2End <= interval1End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"YES\"\n    }\n    if interval2Start\
    \ <= interval1Start && interval2End <= interval1End {\n        return \"YES\"\n\
    \    }\n    if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval2Start <= interval1Start &&\
    \ interval2End <= interval1End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval2Start \nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpar876v_l_test.go:94:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075402
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := make([]int, len(interval1))\n    interval2 := make([]int,\
    \ len(interval2))\n    \n    for i, val := range interval1 {\n        interval1[i]\
    \ = val.(int)\n    }\n    for i, val := range interval2 {\n        interval2[i]\
    \ = val.(int)\n    }\n    \n    result := make([]int, len(interval1))\n    \n\
    \    for i, val := range interval1 {\n        for j, val2 := range interval2 {\n\
    \            if val >= val2 {\n                result[i] = val\n             \
    \   break\n            }\n        }\n    }\n    \n    if len(result) == 0 {\n\
    \        return \"NO\"\n    }\n    \n    length := len(result)\n    \n    if length\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    if length == 2 && result[0]\
    \ > result[1] {\n        return \"YES\"\n    }\n    \n    if length == 2 && result[0]\
    \ == result[1] {\n        return \"YES\"\n    }\n    \n    if length == 3 && result[0]\
    \ > result[1] && result[1] > result[2] {\n        return \"YES\"\n    }\n    \n\
    \    if length == 3 && result[0] == result[1] && result[1] == result[2] {\n  \
    \      return \"YES\"\n    }\n    \n    if length == 4 && result[0] > result[1]\
    \ && result[1] > result[2] && result[2] > result[3] {\n        return \"YES\"\n\
    \    }\n    \n    if length == 4 && result[0] == result[1] && result[1] == result[2]\
    \ && result[2] == result[3] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 5 && result[0] > result[1] && result[1] > result[2] && result[2] > result[3]\
    \ && result[3] > result[4] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 5 && result[0] == result[1] && result[1] == result[2] && result[2] == result[3]\
    \ && result[3] == result[4] {\n        return \"YES\"\n    }\n    \n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg_hlykul_test.go:32:15:\
    \ no new variables on left side of :=\n/tmp/tmpg_hlykul_test.go:32:18: cannot\
    \ use make([]int, len(interval1)) (value of type []int) as type []interface{}\
    \ in assignment\n/tmp/tmpg_hlykul_test.go:33:15: no new variables on left side\
    \ of :=\n/tmp/tmpg_hlykul_test.go:33:18: cannot use make([]int, len(interval2))\
    \ (value of type []int) as type []interface{} in assignment\n/tmp/tmpg_hlykul_test.go:45:13:\
    \ j declared but not used\n/tmp/tmpg_hlykul_test.go:46:16: invalid operation:\
    \ val >= val2 (operator >= not defined on interface)\n/tmp/tmpg_hlykul_test.go:47:29:\
    \ cannot use val (variable of type interface{}) as type int in assignment:\n\t\
    need type assertion\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075403
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1End <= interval2End\
    \ {\n        if interval1End < intersectionEnd {\n            intersectionEnd\
    \ = interval1End\n        }\n    }\n    \n    for interval2Start <= interval1Start\
    \ {\n        if interval2Start < intersectionStart {\n            intersectionStart\
    \ = interval2Start\n        }\n    }\n    \n    if intersectionStart <= intersectionEnd\
    \ {\n        if intersectionEnd % 2 == 0 {\n            return \"YES\"\n     \
    \   } else {\n            return \"NO\"\n        }\n    } else {\n        return\
    \ \"NO\"\n    }\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprz65fqij_test.go:60:12: invalid operation: operator % not defined on intersectionEnd
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075403
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionLength := interval1End\
    \ - interval1Start\n    \n    if interval2Start <= interval2End {\n        if\
    \ interval1Start <= interval2Start {\n            if interval1End <= interval2End\
    \ {\n                return \"YES\"\n            }\n            if interval1End\
    \ > interval2End {\n                return \"NO\"\n            }\n        }\n\
    \        if interval1Start > interval2Start {\n            if interval1End <=\
    \ interval2End {\n                return \"NO\"\n            }\n            if\
    \ interval1End > interval2End {\n                return \"YES\"\n            }\n\
    \        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv7z79qz3_test.go:44:5: intersectionLength declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075403
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if intersectionLength == 0 {\n        return \"NO\"\n    }\n    \n\
    \    if interval2Start > interval1End {\n        return \"NO\"\n    }\n    if\
    \ interval2End < interval1Start {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp95o1mdvk_test.go:32 +0x217\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp95o1mdvk_test.go:80 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1End < interval2Start\
    \ {\n        interval1End += 1\n    }\n    for interval2End < interval1Start {\n\
    \        interval2End += 1\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        intersectionStart = interval1Start\n\
    \        intersectionEnd = interval1End\n    }\n    if interval2Start <= interval1Start\
    \ && interval2End >= interval1End {\n        intersectionStart = interval2Start\n\
    \        intersectionEnd = interval2End\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        intersectionStart += 1\n        intersectionEnd\
    \ += 1\n    }\n    \n    if intersectionStart <= interval1Start && intersectionEnd\
    \ >= interval1End {\n        return \"YES\"\n    }\n    if intersectionStart <=\
    \ interval2Start && intersectionEnd >= interval2End {\n        return \"YES\"\n\
    \    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmp50qg_47t_test.go:32 +0x1e5\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp50qg_47t_test.go:84 +0xe7\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start < interval2Start\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1End < interval2End {\n\
    \        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start &&\
    \ interval1End >= interval2End {\n        return \"YES\"\n    }\n    \n    if\
    \ interval1Start <= interval2End && interval1End >= interval2Start {\n       \
    \ return \"YES\"\n    }\n    \n    if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ >= interval2End && interval1End <= interval2Start {\n        return \"YES\"\n\
    \    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpy5n1wzru_test.go:32 +0x225\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpy5n1wzru_test.go:82 +0xe7\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionStart = interval1Start\n   \
    \         intersectionEnd = interval1End\n        } else {\n            return\
    \ \"NO\"\n        }\n    }\n    \n    if intersectionEnd <= interval2Start {\n\
    \        return \"NO\"\n    }\n    if intersectionStart >= interval2End {\n  \
    \      return \"NO\"\n    }\n    \n    if intersectionStart <= intersectionEnd\
    \ {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpevajlxlu_test.go:32 +0x29a\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpevajlxlu_test.go:86 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Your code here\n    \n    \n    return \"\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmplwb4t2rf_test.go:55: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmplwb4t2rf_test.go:55: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmplwb4t2rf_test.go:55:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmplwb4t2rf_test.go:55: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmplwb4t2rf_test.go:55: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmplwb4t2rf_test.go:55: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmplwb4t2rf_test.go:55:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmplwb4t2rf_test.go:55: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return fmt.Sprintf(\"YES\")\n   \
    \ }\n    \n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return fmt.Sprintf(\"NO\")\n    }\n    \n    if interval1Start >=\
    \ interval2Start && interval1Start <= interval2End {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    if interval1Start >= interval2End && interval1End <=\
    \ interval2Start {\n        return fmt.Sprintf(\"NO\")\n    }\n    \n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpqa_7f6q4_test.go:32 +0x1f8\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpqa_7f6q4_test.go:70 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Your code here\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp39vg6js4_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var intersectionLength int\n    var isPrime bool\n\n \
    \   if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\n  \
    \  for i := 0; i < len(interval1); i++ {\n        interval1Start = interval1[i].(int)\n\
    \        interval1End = interval1Start + interval1[i].(int)\n    }\n\n    for\
    \ i := 0; i < len(interval2); i++ {\n        interval2Start = interval2[i].(int)\n\
    \        interval2End = interval2Start + interval2[i].(int)\n    }\n\n    intersectionLength\
    \ = interval1End - interval2Start\n\n    if intersectionLength == 0 {\n      \
    \  return \"NO\"\n    }\n\n    isPrime = true\n\n    for i := 0; i < intersectionLength;\
    \ i++ {\n        if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n            isPrime = false\n            break\n        }\n    }\n\n    if\
    \ isPrime {\n        return \"YES\"\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpt7anpmk0_test.go:89: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpt7anpmk0_test.go:89: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpt7anpmk0_test.go:89: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__5\
    \ (0.00s)\n        tmpt7anpmk0_test.go:89: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpt7anpmk0_test.go:89: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075404
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval2Start > interval1End {\n  \
    \      return \"NO\"\n    }\n    \n    intersection := interval1Start + interval2End\
    \ - interval1End - interval2Start\n    if intersection <= 0 {\n        return\
    \ \"NO\"\n    }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n\
    \    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4a1g6scb_test.go:56:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n\n    for _, val := range interval1 {\n        interval1Start\
    \ = val.(int)\n    }\n\n    for _, val := range interval2 {\n        interval2Start\
    \ = val.(int)\n    }\n\n    if interval1Start <= interval2Start {\n        interval1End\
    \ = interval1Start + interval1End - interval2Start\n    } else {\n        interval1End\
    \ = interval1Start + interval2End - interval2Start\n    }\n\n    if interval1End\
    \ <= interval2End {\n        return \"NO\"\n    }\n\n    if interval1Start <=\
    \ interval2End {\n        return \"YES\"\n    }\n\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpdjhaj8h1_test.go:76: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpdjhaj8h1_test.go:76: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1_start := interval1[0].(int)\n    interval1_end\
    \ := interval1[1].(int)\n    interval2_start := interval2[0].(int)\n    interval2_end\
    \ := interval2[1].(int)\n    \n    if interval1_start > interval1_end {\n    \
    \    fmt.Println(\"interval1 start is greater than interval1 end\")\n        return\
    \ \"NO\"\n    }\n    if interval2_start > interval2_end {\n        fmt.Println(\"\
    interval2 start is greater than interval2 end\")\n        return \"NO\"\n    }\n\
    \    \n    if interval1_start < interval2_start {\n        fmt.Println(\"interval1\
    \ start is less than interval2 start\")\n        return \"NO\"\n    }\n    if\
    \ interval1_end > interval2_end {\n        fmt.Println(\"interval1 end is greater\
    \ than interval2 end\")\n        return \"NO\"\n    }\n    \n    if interval1_start\
    \ == interval1_end {\n        fmt.Println(\"interval1 start is equal to interval1\
    \ end\")\n        return \"NO\"\n    }\n    \n    if interval2_start == interval2_end\
    \ {\n        fmt.Println(\"interval2 start is equal to interval2 end\")\n    \
    \    return \"NO\"\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbgtav5ke_test.go:203:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075403
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    interval1Length := interval1End - interval1Start + 1\n    interval2Length\
    \ := interval2End - interval2Start + 1\n    \n    if interval1Length == 0 || interval2Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    intersectionLength := interval1Length\
    \ * interval2Length\n    \n    if intersectionLength == 1 {\n        return \"\
    YES\"\n    }\n    \n    if intersectionLength == 2 && interval1Length == interval2Length\
    \ {\n        return \"YES\"\n    }\n    \n    if intersectionLength == 2 && interval1Length\
    \ != interval2Length {\n        return \"NO\"\n    }\n    \n    if intersectionLength\
    \ == 3 && interval1Length == interval2Length {\n        return \"YES\"\n    }\n\
    \    \n    if intersectionLength == 3 && interval1Length != interval2Length {\n\
    \        return \"NO\"\n    }\n    \n    if intersectionLength == 4 && interval1Length\
    \ == interval2Length {\n        return \"YES\"\n    }\n    \n    if intersectionLength\
    \ == 4 && interval1Length != interval2Length {\n        return \"NO\"\n    }\n\
    \    \n    if intersectionLength == 5 && interval1Length == interval2Length {\n\
    \        return \"YES\"\n    }\n    \n    if intersectionLength == 5 && interval1Length\
    \ != interval2Length {\n        return \"NO\"\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpete9abg5_test.go:112: expected 'NO', got 'YES'\n    ---\
    \ FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpete9abg5_test.go:112:\
    \ expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpete9abg5_test.go:112: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpete9abg5_test.go:112: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075405
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1_start := interval1[0].(float64)\n    interval1_end\
    \ := interval1[1].(float64)\n    interval2_start := interval2[0].(float64)\n \
    \   interval2_end := interval2[1].(float64)\n    \n    \n    if interval1_start\
    \ > interval1_end {\n        interval1_start, interval1_end = interval1_end, interval1_start\n\
    \    }\n    if interval2_start > interval2_end {\n        interval2_start, interval2_end\
    \ = interval2_end, interval2_start\n    }\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpillh_d8j_test.go:247:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075404
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start, interval1End := interval1[0], interval1[1]\n \
    \   interval2Start, interval2End := interval2[0], interval2[1]\n\n    if interval1Start\
    \ > interval1End {\n        fmt.Println(\"interval1Start > interval1End\")\n \
    \       return \"NO\"\n    }\n    if interval2Start > interval2End {\n       \
    \ fmt.Println(\"interval2Start > interval2End\")\n        return \"NO\"\n    }\n\
    \n    if interval1Start < interval2Start {\n        fmt.Println(\"interval1Start\
    \ < interval2Start\")\n        return \"NO\"\n    }\n    if interval1End > interval2End\
    \ {\n        fmt.Println(\"interval1End > interval2End\")\n        return \"NO\"\
    \n    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"YES\"\n    }\n\n    if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n        fmt.Println(\"interval1Start <=\
    \ interval2End && interval1End >= interval2Start\")\n        return \"YES\"\n\
    \    }\n\n    if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End <=\
    \ interval2End\")\n        return \"YES\"\n    }\n\n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        fmt.Println(\"interval1Start >= interval2Start\
    \ && interval1End <= interval2End\")\n        return \"YES\"\n    }\n\n    if\
    \ interval1Start >= interval2Start && interval1End >= interval2End {\n       \
    \ fmt.Println(\"interval1Start >= interval2Start && interval1End >= interval2End\"\
    )\n        return \"YES\"\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzw8825p__test.go:31:8: invalid operation: interval1Start > interval1End
    (operator > not defined on interface)

    /tmp/tmpzw8825p__test.go:35:8: invalid operation: interval2Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpzw8825p__test.go:40:8: invalid operation: interval1Start < interval2Start
    (operator < not defined on interface)

    /tmp/tmpzw8825p__test.go:44:8: invalid operation: interval1End > interval2End
    (operator > not defined on interface)

    /tmp/tmpzw8825p__test.go:49:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpzw8825p__test.go:49:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmpzw8825p__test.go:54:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpzw8825p__test.go:54:42: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpzw8825p__test.go:59:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpzw8825p__test.go:59:44: invalid operation: interval1End <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpzw8825p__test.go:59:44: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075404
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End || interval2Start\
    \ > interval2End {\n        return \"NO\"\n    }\n    \n    interval1Length :=\
    \ interval1End - interval1Start\n    interval2Length := interval2End - interval2Start\n\
    \    \n    if interval1Length == 0 || interval2Length == 0 {\n        return \"\
    NO\"\n    }\n    \n    intersection := interval1Start + interval2Start - interval1Length\
    \ * interval2Length\n    \n    if intersection <= 0 {\n        return \"NO\"\n\
    \    }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n\
    \    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5igle2bc_test.go:54:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        fmt.Println(\"interval1Start > interval1End\")\n        return \"\
    NO\"\n    }\n    if interval2Start > interval2End {\n        fmt.Println(\"interval2Start\
    \ > interval2End\")\n        return \"NO\"\n    }\n    \n    intersectionStart\
    \ := interval1Start\n    intersectionEnd := interval1End\n    \n    if interval2Start\
    \ < interval2End {\n        intersectionStart = interval2Start\n        intersectionEnd\
    \ = interval2End\n    }\n    \n    if intersectionStart > intersectionEnd {\n\
    \        fmt.Println(\"intersectionStart > intersectionEnd\")\n        return\
    \ \"NO\"\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfexxvod8_test.go:222:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        if interval1[i] > interval1End {\n            interval1End =\
    \ interval1[i]\n        }\n        if interval2[i] > interval2End {\n        \
    \    interval2End = interval2[i]\n        }\n    }\n    \n    for i := 1; i <\
    \ len(interval1); i++ {\n        if interval1[i] < interval1Start {\n        \
    \    interval1Start = interval1[i]\n        }\n        if interval2[i] < interval2Start\
    \ {\n            interval2Start = interval2[i]\n        }\n    }\n    \n    if\
    \ interval1Start > interval2Start {\n        intersectionStart = interval1Start\n\
    \        intersectionEnd = interval1End\n    } else {\n        intersectionStart\
    \ = interval2Start\n        intersectionEnd = interval2End\n    }\n    \n    if\
    \ intersectionStart > intersectionEnd {\n        return \"NO\"\n    }\n    \n\
    \    intersectionLength := intersectionEnd - intersectionStart\n    \n    if intersectionLength\
    \ == 2 {\n        return \"YES\"\n    }\n    \n    if intersectionLength % 2 ==\
    \ 0 {\n        return \"NO\"\n    }\n    \n    if intersectionLength == 1 {\n\
    \        return \"YES\"\n    }\n    \n    if intersectionLength == 3 {\n     \
    \   return \"YES\"\n    }\n    \n    if intersectionLength == 5 {\n        return\
    \ \"YES\"\n    }\n    \n    if intersectionLength == 7 {\n        return \"YES\"\
    \n    }\n    \n    if intersectionLength == 9 {\n        return \"YES\"\n    }\n\
    \    \n    if intersectionLength == 11 {\n        return \"YES\"\n    }\n    \n\
    \    if intersectionLength == 13 {\n        return \"YES\"\n    }\n    \n    if\
    \ intersectionLength == 17 {\n        return \"YES\"\n    }\n    \n    if intersectionLength\
    \ == 19 {\n        return \"YES\"\n    }\n    \n    if intersectionLength == 31\
    \ {\n        return \"YES\"\n    }\n    \n    if intersectionLength == 37 {\n\
    \        return \"YES\"\n    }\n    \n    if intersectionLength == \nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxhlxvsmh_test.go:132:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ == interval2Length {\n        if interval1Start <= interval2Start {\n      \
    \      return \"YES\"\n        }\n        if interval1End >= interval2End {\n\
    \            return \"YES\"\n        }\n    }\n    \n    if interval1Length >\
    \ interval2Length {\n        interval1Length -= interval2Length\n    }\n    if\
    \ interval1Length < interval2Length {\n        interval2Length -= interval1Length\n\
    \    }\n    \n    if interval1Length == 0 {\n        return \"NO\"\n    }\n  \
    \  if interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ == interval2Length {\n        if interval1Start <= interval2Start {\n      \
    \      return \"YES\"\n        }\n        if interval1End >= interval2End {\n\
    \            return \"YES\"\n        }\n    }\n    \n    if interval1Length >\
    \ interval2Length {\n        interval1Length -= interval2Length\n    }\n    if\
    \ interval1Length < interval2Length {\n        interval2Length -= interval1Length\n\
    \    }\n    \n    if interval1Length == 0 {\n        return \"NO\"\n    }\n  \
    \  if interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ == interval2Length {\n        if interval1Start <= interval2Start {\n      \
    \      return \"YES\"\n        }\n        if interval1End >= interval2End {\n\
    \            return \"YES\"\n        }\n    }\n    \n    if interval1Length >\
    \ interval2Length {\n        interval1Length -= interval2Length\n    }\n    if\
    \ interval1Length < interval2Length {\n        interval2Length -= interval1Length\n\
    \    }\n    \n    if interval1Length == 0 {\n        return \"NO\"\n    }\n  \
    \  if interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ == interval2Length {\n        if interval\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpna8t01kf_test.go:122:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0], interval1[1]\n\
    \    interval2Start, interval2End := interval2[0], interval2[1]\n    \n    if\
    \ interval1Start > interval2End {\n        return \"NO\"\n    }\n    if interval1End\
    \ < interval2Start {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ >= interval2End && interval1End <= interval2Start {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ >= interval2End && interval1End <= interval2Start {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start \nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9fcyxntx_test.go:102:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval1End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval1Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionStart = interval1Start\n   \
    \         intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd && intersectionEnd <= interval2End {\n        return \"YES\"\
    \n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f4cc0?, 0x2?, 0x2?},\
    \ {0xc0000f4ca0?, 0x2?, 0x2?})\n\t/tmp/tmps2fg8duv_test.go:32 +0x228\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmps2fg8duv_test.go:78 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075405
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1Start <= interval1End\
    \ && interval2Start <= interval2End {\n        if interval1Start <= interval2Start\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n            interval1Start++\n        } else {\n           \
    \ intersectionStart = interval2Start\n            intersectionEnd = interval2End\n\
    \            interval2Start++\n        }\n    }\n    \n    if interval1Start <=\
    \ interval1End {\n        intersectionStart = interval1Start\n        intersectionEnd\
    \ = interval1End\n    }\n    if interval2Start <= interval2End {\n        intersectionStart\
    \ = interval2Start\n        intersectionEnd = interval2End\n    }\n    \n    if\
    \ intersectionStart > intersectionEnd {\n        return \"NO\"\n    }\n    \n\
    \    if intersectionStart < interval1Start || intersectionEnd > interval1End {\n\
    \        return \"NO\"\n    }\n    \n    if intersectionStart < interval2Start\
    \ || intersectionEnd > interval2End {\n        return \"NO\"\n    }\n    \n  \
    \  if intersectionStart <= interval1Start && intersectionEnd >= interval1End {\n\
    \        return \"YES\"\n    }\n    \n    if intersectionStart <= interval2Start\
    \ && intersectionEnd >= interval2End {\n        return \"YES\"\n    }\n    \n\
    \    if intersectionStart >= interval1Start && intersectionEnd <= interval1End\
    \ {\n        return \"YES\"\n    }\n    \n    if intersectionStart >= interval2Start\
    \ && intersectionEnd <= interval2End {\n        return \"YES\"\n    }\n    \n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpz7la36f8_test.go:32 +0x2d7\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpz7la36f8_test.go:106 +0xe7\ntesting.tRunner(0xc0001124e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075405
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    interval1Length := interval1End - interval1Start\n    interval2Length :=\
    \ interval2End - interval2Start\n    \n    if interval1Length == 0 || interval2Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length > interval2Length\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        if interval1Length == 2 {\n            return \"YES\"\n        }\n\
    \        return \"NO\"\n    }\n    \n    if interval1Start <= interval2End {\n\
    \        if interval1Length == 2 {\n            return \"YES\"\n        }\n  \
    \      return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start &&\
    \ interval1End >= interval2End {\n        if interval1Length == 2 {\n        \
    \    return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        if interval1Length\
    \ == 2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start >= interval2Start && interval1End >= interval2End\
    \ {\n        if interval1Length == 2 {\n            return \"YES\"\n        }\n\
    \        return \"NO\"\n    }\n    \n    if interval1Start >= interval2Start &&\
    \ interval1End <= interval2End {\n        if interval1Length == 2 {\n        \
    \    return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        if interval1Length\
    \ == 2 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n        if interval1Length == 2 {\n            return \"YES\"\n        }\n\
    \        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start &&\
    \ interval1End >= interval2End {\n        if interval1Length\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9tq05j1c_test.go:120:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075404
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) < len(interval2) {\n        interval1, interval2\
    \ = interval2, interval1\n    }\n    \n    interval1Start := interval1[0].(int)\n\
    \    interval1End := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n\
    \    interval2End := interval2[1].(int)\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1Start <= interval1End\
    \ && interval2Start <= interval2End {\n        if interval1Start <= interval2Start\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        }\n        \n        if interval1End <= interval2End\
    \ {\n            intersectionEnd = interval1End\n        }\n        \n       \
    \ if intersectionStart <= intersectionEnd {\n            intersectionStart = interval1Start\n\
    \            intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        if intersectionStart <= interval1Start {\n   \
    \         return \"NO\"\n        }\n        \n        if intersectionEnd <= interval1End\
    \ {\n            return \"NO\"\n        }\n        \n        if intersectionStart\
    \ <= interval2Start {\n            return \"NO\"\n        }\n        \n      \
    \  if intersectionEnd <= interval2End {\n            return \"NO\"\n        }\n\
    \        \n        if interval1Start <= interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1End <= interval2End {\n       \
    \     return \"NO\"\n        }\n        \n        if interval1Start <= intersectionEnd\
    \ {\n            return \"NO\"\n        }\n        \n        if interval1End <=\
    \ intersectionEnd {\n            return \"NO\"\n        }\n        \n        if\
    \ interval2Start <= intersectionEnd {\n            return \"NO\"\n        }\n\
    \        \n        if interval2End <= intersectionEnd {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= interval2Start {\n   \
    \         return \"NO\"\n        }\n        \n        if interval1End <= interval2End\
    \ {\n            return \"NO\"\n        }\n        \n        if interval2Start\
    \ <= interval1Start {\n            return \"NO\"\n        }\n        \n      \
    \  if interval2End <= interval1End {\n            return \"NO\"\n        }\n \
    \       \n        if interval1Start <= intersectionEnd {\n            return \"\
    NO\"\n        }\n        \n        if interval1End <= intersectionEnd {\n    \
    \        return \"NO\"\n        }\n        \n        if interval2Start <= intersectionEnd\
    \ {\n            return \"NO\"\n        }\n        \n        if interval2End <=\
    \ intersectionEnd {\n            return \"NO\"\n        }\n        \n        if\
    \ interval1Start <= interval2Start {\n            return \"NO\"\n        }\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp64_uhjyj_test.go:132:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075404
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n\n    interval1Start, interval1End := interval1[0], interval1[1]\n\
    \    interval2Start, interval2End := interval2[0], interval2[1]\n\n    if interval1Start\
    \ > interval2End {\n        interval1Start, interval1End = interval2End, interval1Start\n\
    \    }\n    if interval2Start > interval1End {\n        interval2Start, interval2End\
    \ = interval1End, interval2Start\n    }\n\n    interval1Start += 1\n    interval1End\
    \ -= 1\n    interval2Start += 1\n    interval2End -= 1\n\n    result := 0\n  \
    \  for i := interval1Start; i <= interval1End; i++ {\n        for j := interval2Start;\
    \ j <= interval2End; j++ {\n            result ^= i&j\n        }\n    }\n\n  \
    \  if result != 0 {\n        return \"NO\"\n    }\n\n    return \"YES\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9a024m_l_test.go:35:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmp9a024m_l_test.go:38:8: invalid operation: interval2Start > interval1End
    (operator > not defined on interface)

    /tmp/tmp9a024m_l_test.go:42:5: invalid operation: interval1Start += 1 (mismatched
    types interface{} and int)

    /tmp/tmp9a024m_l_test.go:43:5: invalid operation: interval1End -= 1 (mismatched
    types interface{} and int)

    /tmp/tmp9a024m_l_test.go:44:5: invalid operation: interval2Start += 1 (mismatched
    types interface{} and int)

    /tmp/tmp9a024m_l_test.go:45:5: invalid operation: interval2End -= 1 (mismatched
    types interface{} and int)

    /tmp/tmp9a024m_l_test.go:48:30: invalid operation: i <= interval1End (operator
    <= not defined on interface)

    /tmp/tmp9a024m_l_test.go:48:49: invalid operation: i++ (non-numeric type interface{})

    /tmp/tmp9a024m_l_test.go:49:34: invalid operation: j <= interval2End (operator
    <= not defined on interface)

    /tmp/tmp9a024m_l_test.go:49:53: invalid operation: j++ (non-numeric type interface{})

    /tmp/tmp9a024m_l_test.go:49:53: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075405
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval1End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval1Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionStart = interval1Start\n   \
    \         intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd && intersectionEnd <= interval2End {\n        return \"YES\"\
    \n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmppsu9xwdx_test.go:32 +0x228\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmppsu9xwdx_test.go:77 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075406
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval1End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval1Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionEnd = interval1End\n       \
    \ }\n        if interval1Start <= intersectionStart && interval1End >= intersectionEnd\
    \ {\n            intersectionStart = interval1Start\n        }\n    }\n    \n\
    \    if intersectionEnd <= intersectionStart {\n        return \"NO\"\n    }\n\
    \    \n    if isPrime(intersectionEnd - intersectionStart) {\n        return \"\
    YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprd85e8zo_test.go:70:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075405
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for intersectionStart <= interval2End {\n        if interval1Start\
    \ <= intersectionEnd && intersectionEnd <= interval2End {\n            if interval1Start\
    \ <= intersectionStart && intersectionStart <= interval2Start {\n            \
    \    intersectionEnd = intersectionEnd + 1\n            } else {\n           \
    \     intersectionStart = intersectionStart + 1\n            }\n        } else\
    \ {\n            break\n        }\n    }\n    \n    if intersectionStart <= interval2End\
    \ {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp_7gifmkb_test.go:86: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp_7gifmkb_test.go:86: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n      \
    \  tmp_7gifmkb_test.go:86: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp_7gifmkb_test.go:86: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmp_7gifmkb_test.go:86: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075406
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := make([]int, len(interval1))\n    interval2 := make([]int,\
    \ len(interval2))\n    \n    for i, v := range interval1 {\n        interval1[i]\
    \ = v.(int)\n    }\n    for i, v := range interval2 {\n        interval2[i] =\
    \ v.(int)\n    }\n    \n    result := make([]int, len(interval1))\n    \n    for\
    \ i, v := range interval1 {\n        for j, v2 := range interval2 {\n        \
    \    if v == v2 {\n                result[i] = result[i] + 1\n            }\n\
    \        }\n    }\n    \n    if result[len(result)-1] == len(interval1) {\n  \
    \      return \"NO\"\n    }\n    \n    if result[len(result)-1] == len(interval2)\
    \ {\n        return \"YES\"\n    }\n    \n    for i, v := range result {\n   \
    \     if v == 2 {\n            return \"YES\"\n        }\n    }\n    return \"\
    NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpglp5kxpo_test.go:32:15: no new variables on left side of :=

    /tmp/tmpglp5kxpo_test.go:32:18: cannot use make([]int, len(interval1)) (value
    of type []int) as type []interface{} in assignment

    /tmp/tmpglp5kxpo_test.go:33:15: no new variables on left side of :=

    /tmp/tmpglp5kxpo_test.go:33:18: cannot use make([]int, len(interval2)) (value
    of type []int) as type []interface{} in assignment

    /tmp/tmpglp5kxpo_test.go:45:13: j declared but not used

    /tmp/tmpglp5kxpo_test.go:60:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075406
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for intersectionStart <= interval2End {\n        if interval1Start\
    \ <= intersectionStart && intersectionStart <= interval2End {\n            if\
    \ interval1End <= intersectionEnd && intersectionEnd <= interval2End {\n     \
    \           intersectionEnd = intersectionEnd + 1\n            } else {\n    \
    \            return \"NO\"\n            }\n        } else {\n            return\
    \ \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmphggy5e0q_test.go:81: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmphggy5e0q_test.go:81: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075406
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1_start, interval1_end int\n    var interval2_start,\
    \ interval2_end int\n    var interval1_length int\n    var interval2_length int\n\
    \    var interval1_prime bool\n    var interval2_prime bool\n\n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n\n    for i := 0; i < len(interval1);\
    \ i++ {\n        interval1_start = interval1[i].(int)\n        interval1_end =\
    \ interval1[i].(int)\n        interval1_length = interval1_end - interval1_start\n\
    \n        for j := 0; j < len(interval2); j++ {\n            interval2_start =\
    \ interval2[j].(int)\n            interval2_end = interval2[j].(int)\n       \
    \     interval2_length = interval2_end - interval2_start\n\n            if interval1_length\
    \ == interval2_length {\n                if interval1_start <= interval2_start\
    \ {\n                    interval1_prime = true\n                } else {\n  \
    \                  interval1_prime = false\n                }\n            } else\
    \ {\n                if interval1_length < interval2_length {\n              \
    \      interval1_prime = true\n                } else {\n                    interval1_prime\
    \ = false\n                }\n            }\n        }\n    }\n\n    if interval1_prime\
    \ == true {\n        return \"YES\"\n    } else {\n        return \"NO\"\n   \
    \ }\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpszcdtkbo_test.go:33:9: interval2_prime declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075406
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var interval1Length int\n    var interval2Length int\n\
    \    var primeLength int\n    var primeLength2 int\n    var primeLength3 int\n\
    \    var primeLength4 int\n    var primeLength5 int\n    var primeLength6 int\n\
    \    var primeLength7 int\n    var primeLength8 int\n    var primeLength9 int\n\
    \    var primeLength10 int\n    var primeLength11 int\n    var primeLength12 int\n\
    \    var primeLength13 int\n    var primeLength14 int\n    var primeLength15 int\n\
    \    var primeLength16 int\n    var primeLength17 int\n    var primeLength18 int\n\
    \    var primeLength19 int\n    var primeLength20 int\n    var primeLength21 int\n\
    \    var primeLength22 int\n    var primeLength23 int\n    var primeLength24 int\n\
    \    var primeLength25 int\n    var primeLength26 int\n    var primeLength27 int\n\
    \    var primeLength28 int\n    var primeLength29 int\n    var primeLength30 int\n\
    \    var primeLength31 int\n    var primeLength32 int\n    var primeLength33 int\n\
    \    var primeLength34 int\n    var primeLength35 int\n    var primeLength36 int\n\
    \    var primeLength37 int\n    var primeLength38 int\n    var primeLength39 int\n\
    \    var primeLength40 int\n    var primeLength41 int\n    var primeLength42 int\n\
    \    var primeLength43 int\n    var primeLength44 int\n    var primeLength45 int\n\
    \    var primeLength46 int\n    var primeLength47 int\n    var primeLength48 int\n\
    \    var primeLength49 int\n    var primeLength50 int\n    var primeLength51 int\n\
    \    var primeLength52 int\n    var primeLength53 int\n    var primeLength54 int\n\
    \    var primeLength55 int\n    var primeLength56 int\n    var primeLength57 int\n\
    \    var primeLength58 int\n    var primeLength59 int\n    var primeLength60 int\n\
    \    var primeLength61 int\n    var primeLength62 int\n    var primeLength63 int\n\
    \    var primeLength64 int\n    var primeLength65 int\n    var primeLength66 int\n\
    \    var primeLength67 int\n    var primeLength68 int\n    var primeLength69 int\n\
    \    var primeLength70 int\n    var primeLength71 int\n    var primeLength72 int\n\
    \    var primeLength73 int\n    var primeLength74 int\n    var primeLength75 \n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdyrasmog_test.go:106:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075405
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n    if\
    \ interval1End < interval2Start {\n        return \"NO\"\n    }\n\n    intersectionStart\
    \ := interval1Start\n    intersectionEnd := interval1End\n    \n    for intersectionStart\
    \ < interval2End {\n        if interval1Start <= intersectionEnd && intersectionEnd\
    \ <= interval2Start {\n            intersectionEnd = intersectionEnd + 1\n   \
    \     } else {\n            return \"NO\"\n        }\n    }\n    \n    if intersectionEnd\
    \ > interval2End {\n        return \"NO\"\n    }\n    \n    if intersectionStart\
    \ <= interval2Start {\n        return \"NO\"\n    }\n    \n    if intersectionStart\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp8ulgfxk3_test.go:90: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp8ulgfxk3_test.go:90: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmp8ulgfxk3_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075406
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    interval1Length := interval1End\
    \ - interval1Start\n    interval2Length := interval2End - interval2Start\n   \
    \ \n    if interval1Length == 0 || interval2Length == 0 {\n        return \"NO\"\
    \n    }\n    \n    if interval1Length == interval2Length {\n        if interval1Start\
    \ <= interval2Start {\n            return \"YES\"\n        } else {\n        \
    \    return \"NO\"\n        }\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        interval1Start += interval1Length\n        interval1End -= interval1Length\n\
    \    } else {\n        interval2Start += interval2Length\n        interval2End\
    \ -= interval2Length\n    }\n    \n    if interval1Start <= interval2Start {\n\
    \        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc00012a3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc00012a3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc000125cc0?, 0x2?, 0x2?},\
    \ {0xc000125ca0?, 0x2?, 0x2?})\n\t/tmp/tmpgwzjptgr_test.go:32 +0x1c8\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpgwzjptgr_test.go:81 +0xe7\ntesting.tRunner(0xc0001036c0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075406
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End || interval2Start\
    \ > interval2End {\n        return \"NO\"\n    }\n    \n    intersection := interval1Start\
    \ + interval2Start\n    \n    if intersection <= interval1End && intersection\
    \ <= interval2End {\n        if isPrime(intersection) {\n            return \"\
    YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1diz8z2d_test.go:44:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075406
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for intersectionEnd <= interval2End {\n        if interval1[intersectionStart].(int)\
    \ == interval2[intersectionEnd].(int) {\n            intersectionStart += 1\n\
    \            intersectionEnd += 1\n        } else {\n            break\n     \
    \   }\n    }\n    \n    if intersectionEnd > interval2End {\n        return \"\
    NO\"\n    }\n    \n    if intersectionStart < interval1Start {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionStart > interval1End {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionEnd < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionEnd > interval2End {\n        return\
    \ \"NO\"\n    }\n    \n    if intersectionStart <= intersectionEnd {\n       \
    \ return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: runtime error: index out of\
    \ range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range\
    \ [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001c4000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001c4000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f0cc0?, 0x2?, 0x2?},\
    \ {0xc0000f0ca0?, 0x2?, 0x2?})\n\t/tmp/tmpqh_hyqsj_test.go:48 +0x21a\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpqh_hyqsj_test.go:90 +0xe7\ntesting.tRunner(0xc0001851e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075406
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n\n    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n\n    for _, interval := range interval1 {\n        interval1Start,\
    \ interval1End = interval.(int64)\n    }\n\n    for _, interval := range interval2\
    \ {\n        interval2Start, interval2End = interval.(int64)\n    }\n\n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ if interval1Start <= interval2End {\n            return fmt.Sprintf(\"YES\"\
    )\n        }\n        if interval1End >= interval2Start {\n            return\
    \ fmt.Sprintf(\"NO\")\n        }\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpguugxbom_test.go:36:40: cannot use interval.(int64) (value of type int64)
    as type int in assignment

    /tmp/tmpguugxbom_test.go:36:40: cannot use interval.(int64) (untyped bool value)
    as int value in assignment

    /tmp/tmpguugxbom_test.go:40:40: cannot use interval.(int64) (value of type int64)
    as type int in assignment

    /tmp/tmpguugxbom_test.go:40:40: cannot use interval.(int64) (untyped bool value)
    as int value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075406
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) < interval2[i].(float64) {\n          \
    \  result = \"NO\"\n            break\n        }\n    }\n    \n    if result ==\
    \ \"NO\" {\n        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ > interval2[i].(float64) {\n                result = \"NO\"\n              \
    \  break\n            }\n        }\n    }\n    \n    if result == \"NO\" {\n \
    \       for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ == interval2[i].(float64) {\n                result = \"NO\"\n             \
    \   break\n            }\n        }\n    }\n    \n    if result == \"NO\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ > interval2[i].(float64) {\n                result = \"NO\"\n              \
    \  break\n            }\n        }\n    }\n    \n    if result == \"NO\" {\n \
    \       for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ < interval2[i].(float64) {\n                result = \"NO\"\n              \
    \  break\n            }\n        }\n    }\n    \n    if result == \"NO\" {\n \
    \       for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ == interval2[i].(float64) {\n                result = \"NO\"\n             \
    \   break\n            }\n        }\n    }\n    \n    if result == \"NO\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ > interval2[i].(float64) {\n                result = \"NO\"\n              \
    \  break\n            }\n        }\n    }\n    \n    if result == \"NO\" {\n \
    \       for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ < interval2[i].(float64) {\n                result = \"NO\"\n              \
    \  break\n            }\n        }\n    }\n    \n    if result == \"NO\" {\n \
    \       for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ == interval2[i].(float64) {\n                result = \"NO\"\n             \
    \   break\n            }\n        }\n    }\n    \n    if result == \"NO\" {\n\
    \        for i := 0; i < len(interval1); i++ {\n            if interval1[i].(float64)\
    \ > interval2[i].(float64) {\n                result = \"NO\"\n              \
    \  break\n            }\n        }\n    }\n    \n    if result == \"NO\" {\n \
    \       for i := 0; i < len(interval1); i++ {\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphqdj9u_e_test.go:125:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075405
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionStart = interval1Start\n   \
    \         intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd && intersectionEnd <= interval1End {\n        return \"YES\"\
    \n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpnyvv03hd_test.go:32 +0x25a\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpnyvv03hd_test.go:78 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075406
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1End < interval2Start\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start > interval2Start\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start < interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ if interval1Start <= interval2End && interval1End >= interval2Start {\n    \
    \    return \"YES\"\n    }\n    \n    if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ >= interval2End && interval1End <= interval2Start {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ if interval1Start <= interval2Start && interval1End >= interval2End {\n    \
    \    return \"YES\"\n    }\n    \n    if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ if interval1Start >= interval2Start && interval1End <= interval2End {\n    \
    \    return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End \nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1tim68gk_test.go:110:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075405
- exit_code: null
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for intersectionStart <= interval2End {\n        if interval2Start\
    \ < intersectionEnd {\n            break\n        }\n        \n        if interval2Start\
    \ <= intersectionEnd && intersectionEnd <= interval2End {\n            if interval1Start\
    \ <= intersectionStart && intersectionStart <= interval1End {\n              \
    \  intersectionEnd = intersectionStart + 1\n            } else {\n           \
    \     intersectionEnd = interval1End\n            }\n        } else {\n      \
    \      break\n        }\n    }\n    \n    if intersectionEnd > interval1End {\n\
    \        return \"NO\"\n    }\n    \n    if intersectionEnd > interval2End {\n\
    \        return \"NO\"\n    }\n    \n    if intersectionStart <= interval2Start\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionStart <= interval1Start\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionStart <= interval1End\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionEnd <= interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionEnd <= interval1End\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionEnd <= interval1Start\
    \ {\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660075419
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    if len(interval1) != len(interval2) {\n\
    \        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n\
    \        if interval1[i] < interval2[i] {\n            result += \"NO\"\n    \
    \        break\n        }\n    }\n    \n    if result == \"NO\" {\n        return\
    \ \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i]\
    \ > interval2[i] {\n            result += \"NO\"\n            break\n        }\n\
    \    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n\
    \    if result == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"\
    NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr5e4lmhk_test.go:34:12: invalid operation: interval1[i] < interval2[i]
    (operator < not defined on interface)

    /tmp/tmpr5e4lmhk_test.go:45:12: invalid operation: interval1[i] > interval2[i]
    (operator > not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075406
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start\
    \ := interval1[i].(float64)\n        interval1End := interval1[i+1].(float64)\n\
    \        \n        if interval1Start > interval2End {\n            return \"NO\"\
    \n        }\n        if interval1End < interval2Start {\n            return \"\
    NO\"\n        }\n        \n        if interval1Start <= intersectionEnd && interval1End\
    \ >= intersectionStart {\n            intersectionEnd = interval1End\n       \
    \ } else {\n            return \"NO\"\n        }\n    }\n    \n    if intersectionEnd\
    \ <= interval2Start {\n        return \"NO\"\n    }\n    \n    if intersectionStart\
    \ >= interval2End {\n        return \"NO\"\n    }\n    \n    if intersectionEnd\
    \ <= intersectionStart {\n        return \"NO\"\n    }\n    \n    if isPrime(intersectionEnd\
    \ - intersectionStart) {\n        return \"YES\"\n    }\n    \n    return \"NO\"\
    \n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv6anhby2_test.go:77:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075406
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) < interval2[i].(float64) {\n          \
    \  result = \"NO\"\n            break\n        }\n    }\n    \n    if result ==\
    \ \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n     \
    \       result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n\
    \        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc000187cc0?, 0x2?, 0x2?},\
    \ {0xc000187ca0?, 0x2?, 0x2?})\n\t/tmp/tmp6i2tvarn_test.go:35 +0x1ca\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp6i2tvarn_test.go:70 +0xe7\ntesting.tRunner(0xc000198ea0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075403
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start, interval1End := interval1[0], interval1[1]\n\
    \    interval2Start, interval2End := interval2[0], interval2[1]\n    \n    if\
    \ interval1Start > interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ return \"YES\"\n    }\n    \n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuhi7j2tv_test.go:35:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:39:8: invalid operation: interval1End < interval2Start
    (operator < not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:43:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:43:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:47:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:47:42: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:51:8: invalid operation: interval1Start >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:51:44: invalid operation: interval1End <= interval2End
    (operator <= not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075406
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    if len(interval1) != len(interval2) {\n\
    \        return \"NO\"\n    }\n    for _, interval1 := range interval1 {\n   \
    \     for _, interval2 := range interval2 {\n            if interval1 == interval2\
    \ {\n                continue\n            }\n            if interval1 > interval2\
    \ {\n                interval1, interval2 = interval2, interval1\n           \
    \ }\n            if interval1 > interval2 {\n                interval1, interval2\
    \ = interval2, interval1\n            }\n            if interval1 == interval2\
    \ {\n                continue\n            }\n            if interval1 > interval2\
    \ {\n                interval1, interval2 = interval2, interval1\n           \
    \ }\n            if interval1 == interval2 {\n                continue\n     \
    \       }\n            if interval1 > interval2 {\n                interval1,\
    \ interval2 = interval2, interval1\n            }\n            if interval1 ==\
    \ interval2 {\n                continue\n            }\n            if interval1\
    \ > interval2 {\n                interval1, interval2 = interval2, interval1\n\
    \            }\n            if interval1 == interval2 {\n                continue\n\
    \            }\n            if interval1 > interval2 {\n                interval1,\
    \ interval2 = interval2, interval1\n            }\n            if interval1 ==\
    \ interval2 {\n                continue\n            }\n            if interval1\
    \ > interval2 {\n                interval1, interval2 = interval2, interval1\n\
    \            }\n            if interval1 == interval2 {\n                continue\n\
    \            }\n            if interval1 > interval2 {\n                interval1,\
    \ interval2 = interval2, interval1\n            }\n            if interval1 ==\
    \ interval2 {\n                continue\n            }\n            if interval1\
    \ > interval2 {\n                interval1, interval2 = interval2, interval1\n\
    \            }\n            if interval1 == interval2 {\n                continue\n\
    \            }\n            if interval1 > interval2 {\n                interval1,\
    \ interval2 = interval2, interval1\n            }\n            if interval1 ==\
    \ interval2 {\n                continue\n            }\n            if interval1\
    \ > interval2 {\n                interval1, interval2 = interval2, interval1\n\
    \            }\n            if interval1 == interval2 {\n                continue\n\
    \            }\n            if interval1 > interval2 {\n                interval1,\
    \ interval2 = interval2, interval1\n            }\n            if interval1 ==\
    \ interval2 {\n                continue\n            }\n            if interval1\
    \ > interval2 {\n                interval1, interval2 = interval2, interval1\n\
    \            }\n            if interval1 == interval2 {\n                continue\n\
    \            }\n            if interval1 > interval2 {\n                interval1,\
    \ interval2 = interval2, interval1\n            }\n            if interval1 ==\
    \ interval2 {\n                continue\n            }\n            if interval1\
    \ > interval2 {\n                interval1, interval2 = interval2, interval1\n\
    \            }\n            if interval1 == interval2 {\n                continue\n\
    \            }\n            if interval1 > interval2 {\n                interval1,\
    \ interval2 = interval2, interval1\n            }\n            if interval1 ==\
    \ interval2 {\n                continue\n            }\n            if interval1\
    \ > interval2 {\n                interval1, interval2 = interval2, interval1\n\
    \            }\n            if interval1 == interval2 {\n                continue\n\
    \            }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6upnfgzy_test.go:137:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075406
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start <= interval2Start\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        } else {\n            intersectionStart = interval2Start\n\
    \            intersectionEnd = interval2End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        return \"YES\"\n    } else {\n        return \"\
    NO\"\n    }\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpcqo3lrg7_test.go:32 +0x1c5\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpcqo3lrg7_test.go:67 +0xe7\ntesting.tRunner(0xc0001924e0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: null
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for intersectionStart <= interval2End {\n        if interval1Start\
    \ <= intersectionStart && intersectionStart <= interval2End {\n            intersectionEnd\
    \ = intersectionEnd\n        } else if intersectionStart <= interval1End && intersectionStart\
    \ <= interval2End {\n            intersectionEnd = intersectionEnd\n        }\
    \ else {\n            return \"NO\"\n        }\n    }\n    \n    if intersectionStart\
    \ <= interval1End && intersectionStart <= interval2End {\n        return \"YES\"\
    \n    } else {\n        return \"NO\"\n    }\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660075420
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start, interval1End := interval1[0], interval1[1]\n\
    \    interval2Start, interval2End := interval2[0], interval2[1]\n    \n    if\
    \ interval1Start > interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ return \"YES\"\n    }\n    \n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuhi7j2tv_test.go:35:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:39:8: invalid operation: interval1End < interval2Start
    (operator < not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:43:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:43:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:47:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:47:42: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:51:8: invalid operation: interval1Start >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpuhi7j2tv_test.go:51:44: invalid operation: interval1End <= interval2End
    (operator <= not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075406
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ == interval2Length {\n        if interval1Start <= interval2Start {\n      \
    \      return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if interval1Length\
    \ < interval2Length {\n        interval1Start += interval1Length / 2\n       \
    \ interval1End -= interval1Length / 2\n    } else {\n        interval2Start +=\
    \ interval2Length / 2\n        interval2End -= interval2Length / 2\n    }\n  \
    \  \n    if interval1Start <= interval2Start {\n        return \"YES\"\n    }\n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f4cc0?, 0x2?, 0x2?},\
    \ {0xc0000f4ca0?, 0x2?, 0x2?})\n\t/tmp/tmp3upx2ezw_test.go:32 +0x208\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmp3upx2ezw_test.go:79 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if interval2Start > interval2End {\n        interval2Start := interval2End\
    \ + interval1Start\n    }\n    \n    if interval2Start > interval1End {\n    \
    \    interval2Start := interval1End + interval2Start\n    }\n    \n    if interval1Start\
    \ > interval2End {\n        interval1Start := interval2End + interval1Start\n\
    \    }\n    \n    if interval1Start > interval2Start {\n        interval1Start\
    \ := interval2Start + interval1Start\n    }\n    \n    if interval1Start > interval2Start\
    \ {\n        interval1Start := interval2Start + interval1Start\n    }\n    \n\
    \    if interval1Start > interval2Start {\n        interval1Start := interval2Start\
    \ + interval1Start\n    }\n    \n    if interval1Start > interval2Start {\n  \
    \      interval1Start := interval2Start + interval1Start\n    }\n    \n    if\
    \ interval1Start > interval2Start {\n        interval1Start := interval2Start\
    \ + interval1Start\n    }\n    \n    if interval1Start > interval2Start {\n  \
    \      interval1Start := interval2Start + interval1Start\n    }\n    \n    if\
    \ interval1Start > interval2Start {\n        interval1Start := interval2Start\
    \ + interval1Start\n    }\n    \n    if interval1Start > interval2Start {\n  \
    \      interval1Start := interval2Start + interval1Start\n    }\n    \n    if\
    \ interval1Start > interval2Start {\n        interval1Start := interval2Start\
    \ + interval1Start\n    }\n    \n    if interval1Start > interval2Start {\n  \
    \      interval1Start := interval2Start + interval1Start\n    }\n    \n    if\
    \ interval1Start > interval2Start {\n        interval1Start := interval2Start\
    \ + interval1Start\n    }\n    \n    if interval1Start > interval2Start {\n  \
    \      interval1Start := interval2Start + interval1Start\n    }\n    \n    if\
    \ interval1Start > interval2Start {\n        interval1Start := interval2Start\
    \ + interval1Start\n    }\n    \n    if interval1\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwtagvd0n_test.go:104:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075406
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if interval2Start >= interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2End >= interval1End {\n        return \"NO\"\n    }\n    \n \
    \   if interval2Start <= interval1Start {\n        return \"NO\"\n    }\n    if\
    \ interval2End <= interval1Start {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ return \"YES\"\n    }\n    if interval1Start <= interval2Start && interval1End\
    \ <= interval2End {\n        return \"NO\"\n    }\n    if interval1Start >= interval2Start\
    \ && interval1End >= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"NO\"\n\
    \    }\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwzuafh08_test.go:37:5: intersectionLength declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        interval1Start = interval1[i].(int)\n        interval1End = interval1Start\
    \ + interval1[i].(int)\n        \n        for j := 0; j < len(interval2); j++\
    \ {\n            interval2Start = interval2[j].(int)\n            interval2End\
    \ = interval2Start + interval2[j].(int)\n            \n            if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n                result\
    \ += \"YES\"\n                break\n            }\n        }\n    }\n    \n \
    \   if result == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"\
    NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpjeo8hq3c_test.go:78: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmpjeo8hq3c_test.go:78: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpjeo8hq3c_test.go:78: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \    if intersection {\n        intersection := interval1Start <= interval2Start\
    \ && interval1End >= interval2End\n        if intersection {\n            intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n      \
    \      if intersection {\n                intersection := interval1Start <= interval2Start\
    \ && interval1End >= interval2End\n                if intersection {\n       \
    \             intersection := interval1Start <= interval2End && interval1End >=\
    \ interval2Start\n                    if intersection {\n                    \
    \    intersection := interval1Start <= interval2Start && interval1End >= interval2End\n\
    \                        if intersection {\n                            intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n      \
    \                      if intersection {\n                                intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n      \
    \                          if intersection {\n                               \
    \     intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \                                    if intersection {\n                     \
    \                   intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                                        if intersection {\n\
    \                                            intersection := interval1Start <=\
    \ interval2End && interval1End >= interval2Start\n                           \
    \                 if intersection {\n                                        \
    \        intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \                                                if intersection {\n         \
    \                                           intersection := interval1Start <=\
    \ interval2End && interval1End >= interval2Start\n                           \
    \                         if intersection {\n                                \
    \                        intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                                                        if\
    \ intersection {\n                                                           \
    \ intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \                                                            if intersection {\n\
    \                                                                intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n      \
    \                                                          if intersection {\n\
    \                                                                    intersection\
    \ := interval1Start <= interval2End && interval1End >= interval2Start\n      \
    \                                                              if intersection\
    \ {\n                                \nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzxyj7xrl_test.go:79:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"NO\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc00018e3c0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc000187cc0?, 0x2?, 0x2?},\
    \ {0xc000187ca0?, 0x2?, 0x2?})\n\t/tmp/tmplg847z9u_test.go:32 +0x1bc\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmplg847z9u_test.go:67 +0xe7\ntesting.tRunner(0xc000199040, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075398
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var interval1Start, interval1End int\n    var interval2Start,\
    \ interval2End int\n    var lengthOfIntersection int\n\n    // Your code here\n\
    \    interval1Start, interval1End = interval1[0].(int), interval1[1].(int)\n \
    \   interval2Start, interval2End = interval2[0].(int), interval2[1].(int)\n  \
    \  lengthOfIntersection = interval1End - interval1Start + interval2End - interval2Start\n\
    \    if lengthOfIntersection == 0 {\n        return \"NO\"\n    }\n    if lengthOfIntersection\
    \ == 1 {\n        return \"YES\"\n    }\n    if lengthOfIntersection == 2 {\n\
    \        if interval1Start <= interval2Start && interval1End >= interval2End {\n\
    \            return \"YES\"\n        }\n        if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n            return \"YES\"\n        }\n\
    \        if interval1Start >= interval2Start && interval1End <= interval2End {\n\
    \            return \"YES\"\n        }\n        if interval1Start >= interval2End\
    \ && interval1End <= interval2Start {\n            return \"YES\"\n        }\n\
    \    }\n    if lengthOfIntersection == 3 {\n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            return \"YES\"\n        }\n \
    \       if interval1Start <= interval2End && interval1End >= interval2Start {\n\
    \            return \"YES\"\n        }\n        if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n            return \"YES\"\n        }\n \
    \       if interval1Start >= interval2End && interval1End <= interval2Start {\n\
    \            return \"YES\"\n        }\n    }\n    if lengthOfIntersection ==\
    \ 4 {\n        if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n            return \"YES\"\n        }\n        if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n            return \"YES\"\n        }\n\
    \        if interval1Start >= interval2Start && interval1End <= interval2End {\n\
    \            return \"YES\"\n        }\n        if interval1Start >= interval2End\
    \ && interval1End <= interval2Start {\n            return \"YES\"\n        }\n\
    \    }\n    if lengthOfIntersection == 5 {\n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            return \"YES\"\n        }\n \
    \       if interval1Start <= interval2End && interval1End >= interval2Start {\n\
    \            return \"YES\"\n        }\n        if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n            return \"YES\"\n        }\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgvl59002_test.go:95:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1 := interval1[0].([]interface{})\n    interval2 :=\
    \ interval2[0].([]interface{})\n    \n    result := make([]interface{}, len(interval1))\n\
    \    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i] > interval2[i]\
    \ {\n            result[i] = interval1[i]\n        } else {\n            result[i]\
    \ = interval2[i]\n        }\n    }\n    \n    result := result[:len(interval1)]\n\
    \    \n    result := append(result, interval1[len(interval1):]...)\n    result\
    \ := append(result, interval2[len(interval2):]...)\n    \n    result := append(result,\
    \ interval1[:len(interval1)]...)\n    result := append(result, interval2[:len(interval2)]...)\n\
    \    \n    result := append(result, interval1[:len(interval1)]...)\n    result\
    \ := append(result, interval2[:len(interval2)]...)\n    \n    result := append(result,\
    \ interval1[:len(interval1)]...)\n    result := append(result, interval2[:len(interval2)]...)\n\
    \    \n    result := append(result, interval1[:len(interval1)]...)\n    result\
    \ := append(result, interval2[:len(interval2)]...)\n    \n    result := append(result,\
    \ interval1[:len(interval1)]...)\n    result := append(result, interval2[:len(interval2)]...)\n\
    \    \n    result := append(result, interval1[:len(interval1)]...)\n    result\
    \ := append(result, interval2[:len(interval2)]...)\n    \n    result := append(result,\
    \ interval1[:len(interval1)]...)\n    result := append(result, interval2[:len(interval2)]...)\n\
    \    \n    result := append(result, interval1[:len(interval1)]...)\n    result\
    \ := append(result, interval2[:len(interval2)]...)\n    \n    result := append(result,\
    \ interval1[:len(interval1)]...)\n    result := append(result, interval2[:len(interval2)]...)\n\
    \    \n    result := append(result, interval1[:len(interval1)]...)\n    result\
    \ := append(result, interval2[:len(interval2)]...)\n    \n    result := append(result,\
    \ interval1[:len(interval1)]...)\n    result := append(result, interval2[:len(interval2)]...)\n\
    \    \n    result := append(result, interval1[:len(interval1)]...)\n    result\
    \ := append(result, interval2[:len(interval2)]...)\n    \n    result := append(result,\
    \ interval1[:len(interval1)]...)\n    result := append(result, interval2[:len(interval2)]...)\n\
    \    \n    result := append(result, interval1[:len(interval1)]\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5fzciyfe_test.go:89:56: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Write your code here\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbz11ina1_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersection := interval1Start\
    \ <= interval2End && interval2Start <= interval1End\n    \n    if intersection\
    \ {\n        if interval1Start <= interval2Start {\n            interval1Start,\
    \ interval2Start = interval2Start, interval1Start\n        }\n        if interval1End\
    \ >= interval2End {\n            interval1End, interval2End = interval2End, interval1End\n\
    \        }\n        \n        if interval1Start <= interval2Start {\n        \
    \    interval1Start, interval2Start = interval2Start, interval1Start\n       \
    \ }\n        if interval1End >= interval2End {\n            interval1End, interval2End\
    \ = interval2End, interval1End\n        }\n        \n        if interval1Start\
    \ <= interval2Start {\n            interval1Start, interval2Start = interval2Start,\
    \ interval1Start\n        }\n        if interval1End >= interval2End {\n     \
    \       interval1End, interval2End = interval2End, interval1End\n        }\n \
    \       \n        if interval1Start <= interval2Start {\n            interval1Start,\
    \ interval2Start = interval2Start, interval1Start\n        }\n        if interval1End\
    \ >= interval2End {\n            interval1End, interval2End = interval2End, interval1End\n\
    \        }\n        \n        if interval1Start <= interval2Start {\n        \
    \    interval1Start, interval2Start = interval2Start, interval1Start\n       \
    \ }\n        if interval1End >= interval2End {\n            interval1End, interval2End\
    \ = interval2End, interval1End\n        }\n        \n        if interval1Start\
    \ <= interval2Start {\n            interval1Start, interval2Start = interval2Start,\
    \ interval1Start\n        }\n        if interval1End >= interval2End {\n     \
    \       interval1End, interval2End = interval2End, interval1End\n        }\n \
    \       \n        if interval1Start <= interval2Start {\n            interval1Start,\
    \ interval2Start = interval2Start, interval1Start\n        }\n        if interval1End\
    \ >= interval\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe688mjh7_test.go:93:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    interval1PrimeLength\
    \ := interval1Length / 2\n    interval2PrimeLength := interval2Length / 2\n  \
    \  \n    if interval1PrimeLength == 0 || interval2PrimeLength == 0 {\n       \
    \ return \"NO\"\n    }\n    \n    if interval1PrimeLength == interval2PrimeLength\
    \ {\n        \n        if interval1Start <= interval2Start {\n            \n \
    \           if interval1Start < interval2End {\n                \n           \
    \     if interval1End <= interval2Start {\n                    \n            \
    \        if interval1Start <= interval2End {\n                        \n     \
    \                   if interval1Start <= interval2End {\n                    \
    \        \n                            if interval1Start <= interval2End {\n \
    \                               \n                                if interval1Start\
    \ <= interval2End {\n                                    \n                  \
    \                  if interval1Start <= interval2End {\n                     \
    \                   return \"YES\"\n                                    }\n  \
    \                              }\n                            }\n            \
    \            }\n                    }\n                }\n            }\n    \
    \    }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpyhfrn2_z_test.go:32 +0x1fa\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpyhfrn2_z_test.go:95 +0xe7\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075407
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1Start < interval1End\
    \ {\n        interval1End += 1\n        for interval2Start < interval2End {\n\
    \            interval2End += 1\n            if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n                intersectionStart = interval1Start\n\
    \                intersectionEnd = interval1End\n            }\n        }\n  \
    \  }\n    \n    if intersectionStart <= intersectionEnd && intersectionStart <=\
    \ interval1End && intersectionEnd <= interval2End {\n        if isPrime(intersectionStart,\
    \ intersectionEnd, interval1Start, interval1End) && isPrime(intersectionStart,\
    \ intersectionEnd, interval2Start, interval2End) {\n            return \"YES\"\
    \n        }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpga_cpro4_test.go:59:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for intersectionEnd <= interval2End {\n        if interval1Start <=\
    \ intersectionEnd && intersectionEnd <= interval2End {\n            intersectionEnd\
    \ = intersectionEnd + 1\n        }\n    }\n    \n    if intersectionEnd > interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionStart <= interval2Start\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionStart <= interval1Start\
    \ {\n        return \"YES\"\n    }\n    \n    if intersectionEnd <= interval1End\
    \ {\n        return \"YES\"\n    }\n    \n    if intersectionStart <= interval2Start\
    \ && intersectionEnd <= interval2End {\n        return \"YES\"\n    }\n    \n\
    \    if intersectionStart <= interval1Start && intersectionEnd <= interval1End\
    \ {\n        return \"YES\"\n    }\n    \n    if intersectionStart <= interval2Start\
    \ && intersectionEnd <= interval2End {\n        return \"YES\"\n    }\n    \n\
    \    if intersectionStart <= interval1Start && intersectionEnd <= interval1End\
    \ {\n        return \"YES\"\n    }\n    \n    if intersectionStart <= interval2Start\
    \ && intersectionEnd <= interval2End {\n        return \"YES\"\n    }\n    \n\
    \    if intersectionStart <= interval1Start && intersectionEnd <= interval1End\
    \ {\n        return \"YES\"\n    }\n    \n    if intersectionStart <= interval2Start\
    \ && intersectionEnd <= interval2End {\n        return \"YES\"\n    }\n    \n\
    \    if intersectionStart <= interval1Start && intersectionEnd <= interval1End\
    \ {\n        return \"YES\"\n    }\n    \n    if intersectionStart <= interval2Start\
    \ && intersectionEnd <= interval2End {\n        return \"YES\"\n    }\n    \n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpfzebb1rd_test.go:121: expected 'YES', got 'NO'\n    ---\
    \ FAIL: TestIntersection/test_num__3 (0.00s)\n        tmpfzebb1rd_test.go:121:\
    \ expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Your code here\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp39vg6js4_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n\n    interval1Start, interval1End := interval1[0], interval1[1]\n   \
    \ interval2Start, interval2End := interval2[0], interval2[1]\n\n    if interval1Start\
    \ > interval2End {\n        return \"NO\"\n    }\n\n    if interval1End < interval2Start\
    \ {\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2Start &&\
    \ interval1End >= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdup9e9ro_test.go:35:8: invalid operation: interval1Start > interval2End
    (operator > not defined on interface)

    /tmp/tmpdup9e9ro_test.go:39:8: invalid operation: interval1End < interval2Start
    (operator < not defined on interface)

    /tmp/tmpdup9e9ro_test.go:43:8: invalid operation: interval1Start <= interval2Start
    (operator <= not defined on interface)

    /tmp/tmpdup9e9ro_test.go:43:44: invalid operation: interval1End >= interval2End
    (operator >= not defined on interface)

    /tmp/tmpdup9e9ro_test.go:47:8: invalid operation: interval1Start <= interval2End
    (operator <= not defined on interface)

    /tmp/tmpdup9e9ro_test.go:47:42: invalid operation: interval1End >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpdup9e9ro_test.go:51:8: invalid operation: interval1Start >= interval2Start
    (operator >= not defined on interface)

    /tmp/tmpdup9e9ro_test.go:51:44: invalid operation: interval1End <= interval2End
    (operator <= not defined on interface)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075399
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    // Your code here\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp39vg6js4_test.go:283:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n    intersectionEnd\
    \ := interval1End\n    \n    for interval2Start < interval2End {\n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n            break\n\
    \        }\n        \n        if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n            intersectionStart = interval1End\n        \
    \    intersectionEnd = interval1End\n            break\n        }\n        \n\
    \        if interval1Start <= interval2Start && interval1End <= interval2End {\n\
    \            intersectionStart = interval1Start\n            intersectionEnd =\
    \ interval1End\n            break\n        }\n        \n        if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n            intersectionStart\
    \ = interval1End\n            intersectionEnd = interval1End\n            break\n\
    \        }\n        \n        if interval1Start >= interval2Start && interval1End\
    \ >= interval2End {\n            intersectionStart = interval1Start\n        \
    \    intersectionEnd = interval1Start\n            break\n        }\n        \n\
    \        if interval1Start <= interval2Start && interval1End >= interval2End {\n\
    \            intersectionStart = interval1Start\n            intersectionEnd =\
    \ interval1Start\n            break\n        }\n        \n        if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1Start\n           \
    \ break\n        }\n        \n        if interval1Start >= interval2Start && interval1End\
    \ >= interval2End {\n            intersectionStart = interval1Start\n        \
    \    intersectionEnd = interval1Start\n            break\n        }\n        \n\
    \        if interval1Start <= interval2Start && interval1End <= interval2End {\n\
    \            intersectionStart = interval1Start\n            intersectionEnd =\
    \ interval1Start\n            break\n        }\n        \n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1Start\n           \
    \ break\n        }\n        \n        if interval1Start >= interval2Start \nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwms9q9qq_test.go:109:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) <= interval2[i].(float64) {\n         \
    \   result += \"YES\"\n        } else {\n            result += \"NO\"\n      \
    \  }\n    }\n    \n    return result\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection(...)\n\t/tmp/tmpeua9bn8g_test.go:35\n\
    command-line-arguments_test.TestIntersection(0x0?)\n\t/tmp/tmpeua9bn8g_test.go:52\
    \ +0x1131\ntesting.tRunner(0xc000192680, 0x528f48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) <= interval2[i].(float64) {\n         \
    \   result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n     \
    \       result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n\
    \        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpz4knjgu8_test.go:35 +0x1ca\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpz4knjgu8_test.go:70 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075400
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1End <= interval2End\
    \ {\n        if interval1End < intersectionEnd {\n            intersectionEnd\
    \ = interval1End\n        }\n    }\n    \n    for interval2Start <= interval1Start\
    \ {\n        if interval2Start < intersectionStart {\n            intersectionStart\
    \ = interval2Start\n        }\n    }\n    \n    if intersectionStart <= intersectionEnd\
    \ {\n        if intersectionEnd % 2 == 0 {\n            if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n                return \"YES\"\n        \
    \    }\n            if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n                return \"YES\"\n            }\n            if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n                return\
    \ \"YES\"\n            }\n            if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n                return \"YES\"\n            }\n       \
    \ }\n        if intersectionEnd % 2 == 1 {\n            if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n                return \"YES\"\n        \
    \    }\n            if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n                return \"YES\"\n            }\n            if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n                return\
    \ \"YES\"\n            }\n            if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n                return \"YES\"\n            }\n       \
    \ }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1500lomi_test.go:60:12: invalid operation: operator % not defined on intersectionEnd
    (variable of type float64)

    /tmp/tmp1500lomi_test.go:74:12: invalid operation: operator % not defined on intersectionEnd
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ if interval1Start <= interval2End && interval1End >= interval2Start {\n    \
    \    return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ >= interval2Start && interval1End >= interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f4cc0?, 0x2?, 0x2?},\
    \ {0xc0000f4ca0?, 0x2?, 0x2?})\n\t/tmp/tmpn89q1lhs_test.go:32 +0x217\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpn89q1lhs_test.go:78 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start, interval1End := interval1[0], interval1[1]\n\
    \    interval2Start, interval2End := interval2[0], interval2[1]\n    \n    if\
    \ interval1Start > interval2End {\n        return \"NO\"\n    }\n    if interval2Start\
    \ > interval1End {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ < interval2Start {\n        return \"NO\"\n    }\n    if interval2Start < interval1Start\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1End < interval2End {\n\
    \        return \"NO\"\n    }\n    if interval2End < interval1End {\n        return\
    \ \"NO\"\n    }\n    \n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        return \"YES\"\n    }\n    if interval2Start <= interval1Start\
    \ && interval2End >= interval1End {\n        return \"YES\"\n    }\n    \n   \
    \ if interval1Start <= interval2Start && interval1End <= interval2End {\n    \
    \    return \"YES\"\n    }\n    if interval2Start <= interval1Start && interval2End\
    \ <= interval1End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval2Start <= interval1Start && interval2End >= interval1End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n    if interval2Start\
    \ <= interval1Start && interval2End <= interval1End {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval2Start >= interval1Start &&\
    \ interval2End <= interval1End {\n        return \"YES\"\n    }\n    \n    if\
    \ interval1Start >= interval2Start && interval1End >= interval2End {\n       \
    \ return \"YES\"\n    }\n    if interval2Start >= interval1Start && interval2End\
    \ >= interval1End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval2Start >= interval1Start && interval2End <= interval1End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start >= interval2Start\
    \ && interval1End \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_aai_dk3_test.go:106:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfypebohj_test.go:285:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075396
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for interval2Start < interval2End {\n        if interval2Start < interval2End\
    \ {\n            intersectionEnd = interval2Start\n        }\n        \n     \
    \   if interval2Start < interval2End && interval2Start <= intersectionEnd {\n\
    \            intersectionEnd = interval2Start\n        }\n        \n        if\
    \ interval2Start < interval2End && interval2Start > intersectionEnd {\n      \
    \      intersectionEnd = interval2Start\n        }\n        \n        if interval2Start\
    \ <= intersectionEnd && interval2End <= intersectionEnd {\n            intersectionEnd\
    \ = interval2End\n        }\n        \n        if interval2Start <= intersectionEnd\
    \ && interval2End > intersectionEnd {\n            intersectionEnd = interval2End\n\
    \        }\n        \n        if interval2Start > intersectionEnd {\n        \
    \    intersectionEnd = interval2Start\n        }\n        \n        if interval2Start\
    \ > intersectionEnd {\n            intersectionEnd = interval2Start\n        }\n\
    \        \n        if interval2Start > intersectionEnd {\n            intersectionEnd\
    \ = interval2Start\n        }\n        \n        if interval2Start <= intersectionEnd\
    \ && interval2End > intersectionEnd {\n            intersectionEnd = interval2End\n\
    \        }\n        \n        if interval2Start <= intersectionEnd && interval2End\
    \ <= intersectionEnd {\n            intersectionEnd = interval2End\n        }\n\
    \        \n        if interval2Start <= intersectionEnd && interval2End > intersectionEnd\
    \ {\n            intersectionEnd = interval2End\n        }\n        \n       \
    \ if interval2Start > intersectionEnd {\n            intersectionEnd = interval2Start\n\
    \        }\n        \n        if interval2Start > intersectionEnd {\n        \
    \    intersectionEnd = interval2Start\n        }\n        \n        if interval2Start\
    \ > intersectionEnd {\n            intersectionEnd = interval2Start\n        }\n\
    \        \n        if interval2Start <= intersectionEnd && interval2End <= intersectionEnd\
    \ {\n            intersectionEnd = interval2End\n        }\n        \n       \
    \ if interval2Start <= intersectionEnd && interval2End > intersectionEnd {\n \
    \           intersectionEnd = interval2End\n        }\n        \n        if interval2Start\
    \ <= intersection\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpllpg7rlu_test.go:113:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval1End {\n  \
    \      interval1Start, interval1End = interval1End, interval1Start\n    }\n  \
    \  if interval2Start > interval2End {\n        interval2Start, interval2End =\
    \ interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1Start <= interval1End\
    \ && interval2Start <= interval2End {\n        if interval1Start <= interval2Start\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        } else {\n            intersectionStart = interval2Start\n\
    \            intersectionEnd = interval2End\n        }\n        \n        if intersectionEnd\
    \ > interval1End {\n            intersectionEnd = interval1End\n        }\n  \
    \      if intersectionEnd > interval2End {\n            intersectionEnd = interval2End\n\
    \        }\n    }\n    \n    if intersectionStart > intersectionEnd {\n      \
    \  return \"NO\"\n    }\n    \n    if intersectionStart <= intersectionEnd {\n\
    \        if intersectionStart % 2 == 0 {\n            if intersectionEnd % 2 ==\
    \ 0 {\n                return \"YES\"\n            }\n            return \"NO\"\
    \n        }\n        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptj_72ol__test.go:69:12: invalid operation: operator % not defined on intersectionStart
    (variable of type float64)

    /tmp/tmptj_72ol__test.go:70:16: invalid operation: operator % not defined on intersectionEnd
    (variable of type float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    \n    if interval1Start >\
    \ interval1End {\n        fmt.Println(\"interval1Start > interval1End\")\n   \
    \     return \"NO\"\n    }\n    if interval2Start > interval2End {\n        fmt.Println(\"\
    interval2Start > interval2End\")\n        return \"NO\"\n    }\n    \n    \n \
    \   if interval1Start <= interval2End && interval2Start <= interval1End {\n  \
    \      \n        \n        if interval1Start <= interval2Start && interval2Start\
    \ <= interval1End {\n            \n            \n            if interval1Start\
    \ <= interval2End && interval2End <= interval1End {\n                \n      \
    \          \n                if interval1Start <= interval2End && interval2End\
    \ <= interval1End {\n                    \n                    \n            \
    \        if interval1Start <= interval2End && interval2End <= interval1End {\n\
    \                        \n                        \n                        if\
    \ interval1Start <= interval2End && interval2End <= interval1End {\n         \
    \                   \n                            \n                         \
    \   if interval1Start <= interval2End && interval2End <= interval1End {\n    \
    \                            \n                                \n            \
    \                    if interval1Start <= interval2End && interval2End <= interval1End\
    \ {\n                                    \n                                  \
    \  \n                                    if interval1Start <= interval2End &&\
    \ interval2End <= interval1End {\n                                        \n \
    \                                       \n                                   \
    \     if interval1Start <= interval2End && interval2End <= interval1End {\n  \
    \                                          \n                                \
    \            \n                                            if interval1Start <=\
    \ interval2End && interval2End <= interval1End {\n                           \
    \                     \n                                                \n   \
    \                                             if interval1Start <= interval2End\
    \ && interval2End <= interval1End {\n                                        \
    \            \n                                                    \n        \
    \                                            if interval1Start <= interval2End\
    \ && interval2End <= interval1End {\n                                        \
    \                \n                                                        \n\
    \                                                        if interval1Start <=\
    \ interval2End && interval2End <= interval1End {\n                           \
    \                                 \n                                         \
    \                   \n                                                       \
    \     if interval1Start <= interval2End && interval2End <= interval1End {\n  \
    \                                                              \n            \
    \                                                    \n                      \
    \                                          if interval1Start <= interval2End &&\
    \ interval2End <= interval1End {\n                                           \
    \                         \n                                                 \
    \                   \n                                                       \
    \             if interval1Start <= interval2End && interval2End <= interval1End\
    \ {\n                                                                        \n\
    \                                                                        \n  \
    \                                                                      if interval1Start\
    \ <= interval2End && interval\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4bnzm6pb_test.go:97:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075407
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    intersectionStart := interval1Start <=\
    \ interval2Start && interval1End >= interval2End\n    intersectionEnd := interval1Start\
    \ <= interval2End && interval1End >= interval2Start\n    \n    if intersectionStart\
    \ && intersectionEnd {\n        intersectionLength := interval1End - interval1Start\n\
    \        if isPrime(intersectionLength) {\n            return \"YES\"\n      \
    \  }\n    }\n    \n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnq1s6ttu_test.go:42:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075407
