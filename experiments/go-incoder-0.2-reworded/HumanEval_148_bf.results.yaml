language: go_test.go
name: HumanEval_148_bf
results:
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for i := 0; i < len(planet1Orbit);\
    \ i++ {\n        if planet1Orbit[i] == planet2Orbit[i] {\n            result =\
    \ append(result, planet1Orbit[i])\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj53hdezo_test.go:25:21: undefined: orbit

    /tmp/tmpj53hdezo_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074372
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9bwiz3hm_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    var planets []interface{}\n    \n    planets\
    \ = append(planets, planet1)\n    planets = append(planets, planet2)\n    \n \
    \   planet1 := planet1\n    planet2 := planet2\n    \n    var planet1 string\n\
    \    var planet2 string\n    \n    for planet1 != planet2 {\n        planet1 =\
    \ planet1\n        planet2 = planet2\n        \n        if planet1 == \"Mercury\"\
    \ {\n            planet1 = \"Venus\"\n        }\n        if planet1 == \"Venus\"\
    \ {\n            planet1 = \"Earth\"\n        }\n        if planet1 == \"Earth\"\
    \ {\n            planet1 = \"Mars\"\n        }\n        if planet1 == \"Mars\"\
    \ {\n            planet1 = \"Jupiter\"\n        }\n        if planet1 == \"Jupiter\"\
    \ {\n            planet1 = \"Saturn\"\n        }\n        if planet1 == \"Saturn\"\
    \ {\n            planet1 = \"Uranus\"\n        }\n        if planet1 == \"Uranus\"\
    \ {\n            planet1 = \"Neptune\"\n        }\n        if planet1 == \"Neptune\"\
    \ {\n            planet1 = \"Mercury\"\n        }\n        if planet2 == \"Mercury\"\
    \ {\n            planet2 = \"Venus\"\n        }\n        if planet2 == \"Venus\"\
    \ {\n            planet2 = \"Earth\"\n        }\n        if planet2 == \"Earth\"\
    \ {\n            planet2 = \"Mars\"\n        }\n        if planet2 == \"Mars\"\
    \ {\n            planet2 = \"Jupiter\"\n        }\n        if planet2 == \"Jupiter\"\
    \ {\n            planet2 = \"Saturn\"\n        }\n        if planet2 == \"Saturn\"\
    \ {\n            planet2 = \"Uranus\"\n        }\n        if planet2 == \"Uranus\"\
    \ {\n            planet2 = \"Neptune\"\n        }\n        if planet2 == \"Neptune\"\
    \ {\n            planet2 = \"Mercury\"\n        }\n        \n        if planet1\
    \ == planet2 {\n            planets = append(planets, planet1)\n            planets\
    \ = append(planets, planet2)\n            planet1 = planet1\n            planet2\
    \ = planet2\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzmjg9pym_test.go:98:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n\
    \    planet2 := planet2[:len(planet2)-1]\n    planet1 := planet1[:\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1ym33mvv_test.go:61:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9bwiz3hm_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = strings.ToLower(planet1), strings.ToLower(planet2)\n    planet1, planet2 =\
    \ planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphxsm9qfl_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n   \
    \ planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n   \
    \ \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa_qk4z5a_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet2Orbit := []string{\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    planet1OrbitIndex\
    \ := planet1Orbit.Index(planet1)\n    planet2OrbitIndex := planet2Orbit.Index(planet2)\n\
    \    planet1OrbitIndex2 := planet1OrbitIndex + 1\n    planet2OrbitIndex2 := planet2OrbitIndex\
    \ + 1\n    planet1OrbitIndex3 := planet1OrbitIndex + 2\n    planet2OrbitIndex3\
    \ := planet2OrbitIndex + 2\n    planet1OrbitIndex4 := planet1OrbitIndex + 3\n\
    \    planet2OrbitIndex4 := planet2OrbitIndex + 3\n    planet1OrbitIndex5 := planet1OrbitIndex\
    \ + 4\n    planet2OrbitIndex5 := planet2OrbitIndex + 4\n    planet1OrbitIndex6\
    \ := planet1OrbitIndex + 5\n    planet2OrbitIndex6 := planet2OrbitIndex + 5\n\
    \    planet1OrbitIndex7 := planet1OrbitIndex + 6\n    planet2OrbitIndex7 := planet2OrbitIndex\
    \ + 6\n    planet1OrbitIndex8 := planet1OrbitIndex + 7\n    planet2OrbitIndex8\
    \ := planet2OrbitIndex + 7\n    planet1OrbitIndex9 := planet1OrbitIndex + 8\n\
    \    planet2OrbitIndex9 := planet2OrbitIndex + 8\n    planet1OrbitIndex10 := planet1OrbitIndex\
    \ + 9\n    planet2OrbitIndex10 := planet2OrbitIndex + 9\n    planet1OrbitIndex11\
    \ := planet1OrbitIndex + 10\n    planet2OrbitIndex11 := planet2OrbitIndex + 10\n\
    \    planet1OrbitIndex12 := planet1OrbitIndex + 11\n    \nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplf09xpez_test.go:54:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n        return []interface{}{}\n\
    \    }\n    \n    planet2Orbit, err := getPlanetOrbit(planet2)\n    if err !=\
    \ nil {\n        fmt.Println(err)\n        return []interface{}{}\n    }\n   \
    \ \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n    \
    \    fmt.Println(err)\n        return []interface{}{}\n    }\n    \n    planet2Sun,\
    \ err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n        fmt.Println(err)\n\
    \        return []interface{}{}\n    }\n    \n    planet1SunDistance := getDistance(planet1Orbit,\
    \ planet1Sun)\n    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n\
    \    \n    planet1OrbitDistance := getDistance(planet1Orbit, planet2Orbit)\n \
    \   planet2OrbitDistance := getDistance(planet2Orbit, planet1Orbit)\n    \n  \
    \  planet1SunDistance += planet1OrbitDistance\n    planet2SunDistance += planet2OrbitDistance\n\
    \    \n    if planet1SunDistance < planet2SunDistance {\n        return []interface{}{planet1}\n\
    \    }\n    \n    if planet1SunDistance > planet2SunDistance {\n        return\
    \ []interface{}{planet2}\n    }\n    \n    planet1SunDistance -= planet2SunDistance\n\
    \    planet2SunDistance -= planet1SunDistance\n    \n    if planet1SunDistance\
    \ < planet2SunDistance {\n        return []interface{}{planet1, planet2}\n   \
    \ }\n    \n    if planet1SunDistance > planet2SunDistance {\n        return []interface{}{planet2,\
    \ planet1}\n    }\n    \n    planet1SunDistance -= planet2SunDistance\n    planet2SunDistance\
    \ -= planet1SunDistance\n    \n    if planet1SunDistance < planet2SunDistance\
    \ {\n        return []interface{}{planet1, planet2, planet1}\n    }\n    \n  \
    \  if planet1SunDistance > plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ps5ds19_test.go:88:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet2Sun)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Sun)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    planet2Sun\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp00i0dxef_test.go:72:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1Orbit(planet1)\n\
    \    planet2Orbit := planet2Orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := make([]interface{}, 0)\n    \n    for _, planet1OrbitElement\
    \ := range planet1Orbit {\n        for _, planet2OrbitElement := range planet2Orbit\
    \ {\n            if planet1OrbitElement == planet2OrbitElement {\n           \
    \     continue \n            }\n            if planet1OrbitElement < planet2OrbitElement\
    \ {\n                result <- planet1OrbitElement\n            } else {\n   \
    \             result <- planet2OrbitElement\n            }\n        }\n    }\n\
    \    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp04yjrimf_test.go:25:21: undefined: planet1Orbit

    /tmp/tmp04yjrimf_test.go:26:21: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074372
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortPlanets(planet1Orbit,\
    \ planet2Orbit)\n    planet1Orbit, planet2Orbit = removeDuplicates(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp77v6l5om_test.go:25:35: undefined: getOrbits

    /tmp/tmp77v6l5om_test.go:26:34: undefined: sortPlanets

    /tmp/tmp77v6l5om_test.go:27:34: undefined: removeDuplicates

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074372
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2tj0o883_test.go:54:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1Orbit(planet1)\n\
    \    planet2Orbit := planet2Orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet1 := range planet1Orbit\
    \ {\n        for _, planet2 := range planet2Orbit {\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n            if planet1.distance\
    \ < planet2.distance {\n                planet1.distance += 1\n            } else\
    \ {\n                planet2.distance += 1\n            }\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxct5xrcd_test.go:105:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1Orbit\n    planet2OrbitOrbit\
    \ := planet2Orbit\n    \n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n   \
    \ planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbit\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOr\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppxxthlwt_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1SunDistance\n    planet2OrbitDistance /= planet2SunDistance\n    \n\
    \    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance *=\
    \ planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmog5rugd_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := getDistance(planet1Sun, planet1Orbit)\n\
    \    planet2SunDistance := getDistance(planet2Sun, planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := getDistance(planet1Orbit, planet1Sun)\n    planet2OrbitDistance := getDistance(planet2Orbit,\
    \ planet2Sun)\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1Orbit\n  \
    \  planet2OrbitDistance *= planet2Orbit\n    \n    planet1OrbitDistance /= planet1SunDistance\n\
    \    planet2OrbitDistance /= planet2SunDistance\n    \n    planet1OrbitDistance\
    \ *= planet1SunDistance\n    planet2OrbitDistance *= planet2SunDistance\n    \n\
    \    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /=\
    \ planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1Orbit\n    planet2OrbitDistance\
    \ *= planet2Orbit\n    \n    planet1OrbitDistance /= planet1SunDistance\n    planet2OrbitDistance\
    \ /= planet2SunDistance\n    \n    planet1OrbitDistance *= planet1SunDistance\n\
    \    planet2OrbitDistance *= planet2SunDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance *= \nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4g051r70_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Or\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7zdbhjb1_test.go:34:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074370
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n        return []interface{}{}\n\
    \    }\n    planet2Orbit, err := getPlanetOrbit(planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n        return []interface{}{}\n    }\n    \n    planet1Orbit.Orbit.Add(planet2Orbit.Orbit)\n\
    \    planet2Orbit.Orbit.Add(planet1Orbit.Orbit)\n    \n    planet1Orbit.Orbit.Remove(planet2Orbit.Orbit)\n\
    \    planet2Orbit.Orbit.Remove(planet1Orbit.Orbit)\n    \n    planet1Orbit.Orbit.Remove(planet2Orbit.Orbit)\n\
    \    planet2Orbit.Orbit.Remove(planet1Orbit.Orbit)\n    \n    planet1Orbit.Orbit.Remove(planet2Orbit.Orbit)\n\
    \    planet2Orbit.Orbit.Remove(planet1Orbit.Orbit)\n    \n    planet1Orbit.Orbit.Remove(planet2Orbit.Orbit)\n\
    \    planet2Orbit.Orbit.Remove(planet1Orbit.Orbit)\n    \n    planet1Orbit.Orbit.Remove(planet2Orbit.Orbit)\n\
    \    planet2Orbit.Orbit.Remove(planet1Orbit.Orbit)\n    \n    planet1Orbit.Orbit.Remove(planet2Orbit.Orbit)\n\
    \    planet2Orbit.Orbit.Remove(planet1Orbit.Orbit)\n    \n    planet1Orbit.Orbit.Remove(planet2Orbit.Orbit)\n\
    \    planet2Orbit.Orbit.Remove(planet1Orbit.Orbit)\n    \n    planet1Orbit.Orbit.Remove(planet2Orbit.Orbit)\n\
    \    planet2Orbit.Orbit.Remove(planet1Orbit.Orbit\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqo_rb_ii_test.go:64:49: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9bwiz3hm_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit, planet2Orbit\
    \ = planet1, planet2\n    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit,\
    \ planet2Orbit = planet1, planet2\n    planet1Orbit, planet2Orbit = planet1, planet2\n\
    \    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit, planet2Orbit\
    \ = planet1, planet2\n    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit,\
    \ planet2Orbit = planet1, planet2\n    planet1Orbit, planet2Orbit = planet1, planet2\n\
    \    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit, planet2Orbit\
    \ = planet1, planet2\n    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit,\
    \ planet2Orbit = planet1, planet2\n    planet1Orbit, planet2Orbit = planet1, planet2\n\
    \    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit, planet2Orbit\
    \ = planet1, planet2\n    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit,\
    \ planet2Orbit = planet1, planet2\n    planet1Orbit, planet2Orbit = planet1, planet2\n\
    \    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit, planet2Orbit\
    \ = planet1, planet2\n    planet1Orbit, planet2Orbit = planet1, planet2\n    planet1Orbit,\
    \ planet2Orbit = plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9lr2w8b_test.go:52:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq3fklk_1_test.go:102:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun.Set(\"position\", planet1Orbit)\n    planet2Sun.Set(\"\
    position\", planet2Orbit)\n    planet1Sun.Set(\"velocity\", planet1Orbit.Velocity())\n\
    \    planet2Sun.Set(\"velocity\", planet2Orbit.Velocity())\n    planet1Sun.Set(\"\
    mass\", planet1Orbit.Mass())\n    planet2Sun.Set(\"mass\", planet2Orbit.Mass())\n\
    \    planet1Sun.Set(\"radius\", planet1Orbit.Radius())\n    planet2Sun.Set(\"\
    radius\", planet2Orbit.Radius())\n    planet1Sun.Set(\"orbit\", planet1Orbit)\n\
    \    planet2Sun.Set(\"orbit\", planet2Orbit)\n    planet1Sun.Set(\"name\", planet1)\n\
    \    planet2Sun.Set(\"name\", planet2)\n    planet1Sun.Set(\"distance\", planet1Orbit.Distance(planet2Sun))\n\
    \    planet2Sun.Set(\"distance\", planet2Orbit.Distance(planet1Sun))\n    planet1Sun.Set(\"\
    distance\", planet1Orbit.Distance(planet2Sun))\n    planet2Sun.Set(\"distance\"\
    , planet2Orbit.Distance(planet1Sun))\n    planet1Sun.Set(\"distance\", planet1Orbit.Distance(planet2Sun))\n\
    \    planet2Sun.Set(\"distance\", planet2Orbit.Distance(planet1Sun))\n    planet1Sun.Set(\"\
    distance\", planet1Orbit.Distance(planet2Sun))\n    planet2Sun.Set(\"distance\"\
    , planet2Orbit.Distance(planet1Sun))\n    plan\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbddkyu0p_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    var planets []interface{}\n    \n    if planet1\
    \ == planet2 {\n        return planets\n    }\n    \n    planets = append(planets,\
    \ planet1)\n    \n    for i := 2; i < len(planets); i++ {\n        planets = append(planets,\
    \ planets[i])\n    }\n    \n    planets = append(planets, planet2)\n    \n   \
    \ for i := 2; i < len(planets); i++ {\n        planets = append(planets, planets[i])\n\
    \    }\n    \n    planets = append(planets, planet1)\n    \n    for i := 2; i\
    \ < len(planets); i++ {\n        planets = append(planets, planets[i])\n    }\n\
    \    \n    planets = append(planets, planet2)\n    \n    for i := 2; i < len(planets);\
    \ i++ {\n        planets = append(planets, planets[i])\n    }\n    \n    planets\
    \ = append(planets, planet1)\n    \n    for i := 2; i < len(planets); i++ {\n\
    \        planets = append(planets, planets[i])\n    }\n    \n    planets = append(planets,\
    \ planet2)\n    \n    for i := 2; i < len(planets); i++ {\n        planets = append(planets,\
    \ planets[i])\n    }\n    \n    planets = append(planets, planet1)\n    \n   \
    \ for i := 2; i < len(planets); i++ {\n        planets = append(planets, planets[i])\n\
    \    }\n    \n    planets = append(planets, planet2)\n    \n    for i := 2; i\
    \ < len(planets); i++ {\n        planets = append(planets, planets[i])\n    }\n\
    \    \n    planets = append(planets, planet1)\n    \n    for i := 2; i < len(planets);\
    \ i++ {\n        planets = append(planets, planets[i])\n    }\n    \n    planets\
    \ = append(planets, planet2)\n    \n    for i := 2; i < len(planets); i++ {\n\
    \        planets = append(planets, planets[i])\n    }\n    \n    planets = append(planets,\
    \ planet1)\n    \n    for i := 2; i < len(planets); i++ {\n        planets = append(planets,\
    \ \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6kraf4tc_test.go:98:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq3fklk_1_test.go:102:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, err := getOrbit(planet1)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err := getOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Sun, err :=\
    \ getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance\
    \ := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Sun)\n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptob5jgr9_test.go:61:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1SunDistance += plan\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbsl3_89y_test.go:71:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\"\
    )\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunProximity\
    \ := planet1Orbit - planet1Sun\n    planet2SunProximity := planet2Orbit - planet2Sun\n\
    \    \n    planet1OrbitProximity := planet1Orbit - planet2Orbit\n    planet2OrbitProximity\
    \ := planet2Orbit - planet1Orbit\n    \n    planet1OrbitProximityProximity :=\
    \ planet1OrbitProximity / planet1Orbit\n    planet2OrbitProximityProximity :=\
    \ planet2OrbitProximity / planet2Orbit\n    \n    planet1OrbitProximityProximityProximityProximity\
    \ := planet1OrbitProximityProximityProximity / planet1OrbitProximityProximity\n\
    \    planet2OrbitProximityProximityProximityProximity := planet2OrbitProximityProximityProximity\
    \ / planet2OrbitProximityProximityProximity\n    \n    planet1OrbitProximityProximityProximityProximityProximityProximity\
    \ := planet1OrbitProximityProximityProximityProximityProximityProximity / planet1OrbitProximityProximityProximityProximityProximityProximity\n\
    \    planet2OrbitProximityProximityProximityProximityProximityProximity := planet2OrbitProximityProximityProximityProximityProximity\
    \ / planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvcqwixej_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwz4ca_pt_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwz4ca_pt_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf1pqmhp4_test.go:38:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-2]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-2]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-2]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-2]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-2]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-2]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-3]\n    \n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpexvi1_s7_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1\n\
    \    planet2Orbit := planet2\n    planet1OrbitOrbit := planet1Orbit\n    planet2OrbitOrbit\
    \ := planet2Orbit\n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n    planet2OrbitOrbitOrbit\
    \ := planet2OrbitOrbit\n    planet1OrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvds9cpz_test.go:42:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    planet1Orbit.insert(0, \"Sun\")\n    planet2Orbit.insert(0, \"Sun\")\n  \
    \  planet1Orbit.insert(0, \"Sun\")\n    planet2Orbit.insert(0, \"Sun\")\n    planet1Orbit.insert(0,\
    \ \"Sun\")\n    planet2Orbit.insert(0, \"Sun\")\n    planet1Orbit.insert(0, \"\
    Sun\")\n    planet2Orbit.insert(0, \"Sun\")\n    planet1Orbit.insert(0, \"Sun\"\
    )\n    planet2Orbit.insert(0, \"Sun\")\n    planet1Orbit.insert(0, \"Sun\")\n\
    \    planet2Orbit.insert(0, \"Sun\")\n    planet1Orbit.insert(0, \"Sun\")\n  \
    \  planet2Orbit.insert(0, \"Sun\")\n    planet1Orbit.insert(0, \"Sun\")\n    planet2Orbit.insert(0,\
    \ \"Sun\")\n    planet1Orbit.insert(0, \"Sun\")\n    planet2Orbit.insert(0, \"\
    Sun\")\n    planet1Orbit.insert(0, \"Sun\")\n    planet2Orbit.insert(0, \"Sun\"\
    )\n    planet1Orbit.insert(0, \"Sun\")\n    planet2Orbit.insert(0, \"Sun\")\n\
    \    planet1Orbit.insert(0, \"Sun\")\n    planet2Orbit.insert(0, \"Sun\")\n  \
    \  planet1Orbit.insert(0, \"Sun\")\n    planet2Orbit.insert(0, \"Sun\")\n    planet1Orbit.insert(0,\
    \ \"Sun\")\n    planet2Orbit.insert(0, \"Sun\")\n    planet1Orbit.insert(0, \"\
    Sun\")\n    planet2Orbit.insert(0, \"Sun\")\n    planet1Orbit.insert(0, \"Sun\"\
    )\n    planet2Orbit.insert(0, \"Sun\")\n    planet1Orbit.insert(0, \"Sun\")\n\
    \    planet2Orbit.insert(0, \"Sun\")\n    planet1Orbit.insert(0, \"Sun\")\n  \
    \  planet2Orbit.insert(0, \"Sun\")\n    planet1Orbit.insert(0, \"Sun\")\n    planet2Orbit.insert(0,\
    \ \"Sun\")\n    planet1Orbit.insert(0, \"Sun\")\n    plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpny8w7bc1_test.go:68:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq3fklk_1_test.go:102:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit = planet1Orbit[0:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[0:len(planet2Orbit)-3]\n    \n    planet1Orbit = planet1Orbit\
    \ + \"Orbit\"\n    planet2Orbit = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit\
    \ = planet1Orbit + \"Orbit\"\n    planet2Orbit = planet2Orbit + \"Orbit\"\n  \
    \  \n    planet1Orbit = planet1Orbit + \"Orbit\"\n    planet2Orbit = planet2Orbit\
    \ + \"Orbit\"\n    \n    planet1Orbit = planet1Orbit + \"Orbit\"\n    planet2Orbit\
    \ = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit = planet1Orbit + \"Orbit\"\
    \n    planet2Orbit = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit = planet1Orbit\
    \ + \"Orbit\"\n    planet2Orbit = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit\
    \ = planet1Orbit + \"Orbit\"\n    planet2Orbit = planet2Orbit + \"Orbit\"\n  \
    \  \n    planet1Orbit = planet1Orbit + \"Orbit\"\n    planet2Orbit = planet2Orbit\
    \ + \"Orbit\"\n    \n    planet1Orbit = planet1Orbit + \"Orbit\"\n    planet2Orbit\
    \ = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit = planet1Orbit + \"Orbit\"\
    \n    planet2Orbit = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit = planet1Orbit\
    \ + \"Orbit\"\n    planet2Orbit = planet2Orbit + \"Orbit\"\n    \n    planet1Orbit\
    \ = planet1Orbit + \"Orbit\"\n    planet2Orbit = \nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmjivi_kr_test.go:69:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := planetOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    planet2Orbit, err := planetOrbit(planet2)\n    if err != nil {\n    \
    \    fmt.Println(err)\n    }\n    planet1Sun, err := planetOrbit(\"Sun\")\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun, err := planetOrbit(\"\
    Sun\")\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunProximity\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2SunProximity := planet2Orbit.Distance(planet2Sun)\n\
    \    planet1OrbitProximity := planet1Orbit.Distance(planet2Orbit)\n    planet2OrbitProximity\
    \ := planet2Orbit.Distance(planet1Orbit)\n    planet1Proximity := planet1OrbitProximity\
    \ + planet2OrbitProximity\n    planet2Proximity := planet1OrbitProximity - planet2OrbitProximity\n\
    \    planet1ProximityList := []interface{}{}\n    if planet1Proximity < planet1SunProximity\
    \ {\n        planet1ProximityList = append(planet1ProximityList, planet1)\n  \
    \  }\n    if planet2Proximity < planet2SunProximity {\n        planet2ProximityList\
    \ = append(planet2ProximityList, planet2)\n    }\n    if planet1Proximity > planet2Proximity\
    \ {\n        planet1ProximityList = append(planet1ProximityList, planet2)\n  \
    \  }\n    if planet2Proximity > planet1Proximity {\n        planet2ProximityList\
    \ = append(planet2ProximityList, planet1)\n    }\n    return planet1ProximityList\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj5ec2ht5_test.go:25:26: undefined: planetOrbit

    /tmp/tmpj5ec2ht5_test.go:29:26: undefined: planetOrbit

    /tmp/tmpj5ec2ht5_test.go:33:24: undefined: planetOrbit

    /tmp/tmpj5ec2ht5_test.go:37:24: undefined: planetOrbit

    /tmp/tmpj5ec2ht5_test.go:52:39: undefined: planet2ProximityList

    /tmp/tmpj5ec2ht5_test.go:58:39: undefined: planet2ProximityList

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwz4ca_pt_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit := planet1\n    planet2Orbit := planet2\n    planet1Orbit, planet2Orbit\
    \ = planet2Orbit, planet1Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz4_wufnb_test.go:47:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Or\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7zdbhjb1_test.go:34:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074370
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, err := getOrbit(planet1)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err := getOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Sun, err :=\
    \ getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance\
    \ := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n\
    \    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance *=\
    \ planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n   \
    \ planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance *=\
    \ planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n   \
    \ planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    planet1OrbitDistance /=\
    \ planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n   \
    \ planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /=\
    \ planet2OrbitDistance\n    planet1OrbitDistance *= planet1OrbitDistance\n   \
    \ planet2OrbitDistance *= planet2Orbit\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvhm7xq4l_test.go:67:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq3fklk_1_test.go:102:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    planet\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbmw3j745_test.go:72:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1OrbitSun, err := getSunOrbit(planet1)\n    if err != nil {\n \
    \       fmt.Println(err)\n    }\n    planet2OrbitSun, err := getSunOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance\
    \ := getDistance(planet1OrbitSun, planet2OrbitSun)\n    planet2SunDistance :=\
    \ getDistance(planet1OrbitSun, planet2OrbitSun)\n    \n    planet1OrbitSunDistance,\
    \ err := getDistance(planet1OrbitSun, planet2OrbitSun)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1OrbitSunDistance, err := getDistance(planet1OrbitSun,\
    \ planet2OrbitSun)\n    if err != nil {\n        fmt.Println(err)\n    }\n   \
    \ \n    planet1OrbitSunDistance, err := getDistance(planet1OrbitSun, planet2OrbitSun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1OrbitSunDistance,\
    \ err := getDistance(planet1OrbitSun, planet2OrbitSun)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1OrbitSunDistance, err := getDistance(planet1OrbitSun,\
    \ planet2OrbitSun)\n    if err != nil {\n        fmt.Println(err)\n    }\n   \
    \ \n    planet1OrbitSunDistance, err := getDistance(planet1OrbitSun, planet2OrbitSun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1OrbitSunDistance,\
    \ err := getDistance(planet1OrbitSun, planet2OrbitSun)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo8x41mdi_test.go:85:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := strings.ToLower(planet1)\n    planet2 := strings.ToLower(planet2)\n\
    \    planet1Orbit, planet2Orbit := planet1, planet2\n    planet1Orbit = strings.Replace(planet1Orbit,\
    \ \"-\", \" \", -1)\n    planet2Orbit = strings.Replace(planet2Orbit, \"-\", \"\
    \ \", -1)\n    planet1Orbit = strings.Replace(planet1Orbit, \"_\", \" \", -1)\n\
    \    planet2Orbit = strings.Replace(planet2Orbit, \"_\", \" \", -1)\n    planet1Orbit\
    \ = strings.Replace(planet1Orbit, \" \", \" \", -1)\n    planet2Orbit = strings.Replace(planet2Orbit,\
    \ \" \", \" \", -1)\n    planet1Orbit = strings.Replace(planet1Orbit, \"'\", \"\
    \ \", -1)\n    planet2Orbit = strings.Replace(planet2Orbit, \"'\", \" \", -1)\n\
    \    planet1Orbit = strings.Replace(planet1Orbit, \"'\", \" \", -1)\n    planet2Orbit\
    \ = strings.Replace(planet2Orbit, \"'\", \" \", -1)\n    planet1Orbit = strings.Replace(planet1Orbit,\
    \ \"'\", \" \", -1)\n    planet2Orbit = strings.Replace(planet2Orbit, \"'\", \"\
    \ \", -1)\n    planet1Orbit = strings.Replace(planet1Orbit, \"'\", \" \", -1)\n\
    \    planet2Orbit = strings.Replace(planet2Orbit, \"'\", \" \", -1)\n    planet1Orbit\
    \ = strings.Replace(planet1Orbit, \"'\", \" \", -1)\n    planet2Orbit = strings.Replace(planet2Orbit,\
    \ \"'\", \" \", -1)\n    planet1Orbit = strings.Replace(planet1Orbit, \"'\", \"\
    \ \", -1)\n    planet2Orbit = strings.Replace(planet2Orbit, \"'\", \" \", -1)\n\
    \    planet1Orbit = strings.Replace(planet1Orbit, \"'\", \" \", -1)\n    planet2Orbit\
    \ = strings.Replace(planet2Orbit, \"'\", \" \", -1)\n    planet1Orbit = strings.Replace(planet1Orbit,\
    \ \"'\", \" \", -1)\n    planet2Orbit = strings.Replace(planet2Or\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0sy2dtri_test.go:50:45: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    var planets []interface{}\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"sun\" {\n        return planets\n    }\n    \n    if planet2 ==\
    \ \"sun\" {\n        return planets\n    }\n    \n    if planet1 == \"earth\"\
    \ {\n        return planets\n    }\n    \n    if planet2 == \"earth\" {\n    \
    \    return planets\n    }\n    \n    if planet1 == \"mars\" {\n        return\
    \ planets\n    }\n    \n    if planet2 == \"mars\" {\n        return planets\n\
    \    }\n    \n    if planet1 == \"jupiter\" {\n        return planets\n    }\n\
    \    \n    if planet2 == \"jupiter\" {\n        return planets\n    }\n    \n\
    \    if planet1 == \"saturn\" {\n        return planets\n    }\n    \n    if planet2\
    \ == \"saturn\" {\n        return planets\n    }\n    \n    if planet1 == \"uranus\"\
    \ {\n        return planets\n    }\n    \n    if planet2 == \"uranus\" {\n   \
    \     return planets\n    }\n    \n    if planet1 == \"neptune\" {\n        return\
    \ planets\n    }\n    \n    if planet2 == \"neptune\" {\n        return planets\n\
    \    }\n    \n    if planet1 == \"venus\" {\n        return planets\n    }\n \
    \   \n    if planet2 == \"venus\" {\n        return planets\n    }\n    \n   \
    \ if planet1 == \"mercury\" {\n        return planets\n    }\n    \n    if planet2\
    \ == \"mercury\" {\n        return planets\n    }\n    \n    if planet1 == \"\
    mars\" {\n        return planets\n    }\n    \n    if planet2 == \"mars\" {\n\
    \        return planets\n    }\n    \n    if planet1 == \"jupiter\" {\n      \
    \  return planets\n    }\n    \n    if planet2 == \"jupiter\" {\n        return\
    \ planets\n    }\n    \n    if planet1 == \"saturn\" {\n        return planets\n\
    \    }\n    \n    if planet2 == \"saturn\" {\n        return planets\n    }\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7arc_exc_test.go:129:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgkqq530y_test.go:40:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps3r746jv_test.go:65:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for i := 0; i < len(planet1Orbit)-1;\
    \ i++ {\n        if planet1Orbit[i] < planet2Orbit[i+1] {\n            result\
    \ = append(result, planet1Orbit[i])\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpivvjmwez_test.go:25:21: undefined: orbit

    /tmp/tmpivvjmwez_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit, err := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n    \
    \    fmt.Println(err)\n    }\n    planet1Sun, err := getSun()\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    planet2Sun, err := getSun()\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n\
    \    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    if planet1OrbitDistance < planet2OrbitDistance {\n        planet1Orbit, planet2Orbit\
    \ = planet2Orbit, planet1Orbit\n    }\n    if planet1SunDistance < planet2SunDistance\
    \ {\n        planet1Sun, planet2Sun = planet2Sun, planet1Sun\n    }\n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    if planet1OrbitDistance < planet2OrbitDistance {\n        planet1Orbit, planet2Orbit\
    \ = planet2Orbit, planet1Orbit\n    }\n    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n    if planet1OrbitDistance\
    \ < planet2OrbitDistance {\n        planet1Orbit, planet2Orbit = planet2Orbit,\
    \ planet1Orbit\n    }\n    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n    if planet1OrbitDistance\
    \ < planet2Orbit\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2nigqkyq_test.go:65:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n   \
    \ planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n   \
    \ \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9gzh7ch8_test.go:53:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v3klkis_test.go:65:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := planet1Orbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ planet2Orbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    \n    planet1OrbitList := []interface{}{planet1Orbit}\n    planet2OrbitList\
    \ := []interface{}{planet2Orbit}\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet2Orbit)\n    \n    planet1OrbitList = append(planet1OrbitList, planet1Orbit)\n\
    \    \n    planet1OrbitList = append(planet1OrbitList, planet2Orbit)\n    \n \
    \   planet1OrbitList = append(planet1OrbitList, planet1Orbit)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet2Orbit)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1Orbit)\n    \n    planet1OrbitList = append(planet1OrbitList, planet2Orbit)\n\
    \    \n    planet1OrbitList = append(planet1OrbitList, planet1Orbit)\n    \n \
    \   planet1OrbitList = append(planet1OrbitList, planet2Orbit)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1Orbit)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet2Orbit)\n    \n    planet1OrbitList = append(planet1OrbitList, planet1Orbit)\n\
    \    \n    planet1OrbitList = append(planet1OrbitList, planet2Orbit)\n    \n \
    \   planet1OrbitList = append(planet1OrbitList, planet1Orbit)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet2Orbit)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1Orbit)\n    \n    planet1OrbitList = append(planet1OrbitList, planet2Or\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp47fttgvs_test.go:72:58: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074374
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    \n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnyciyaro_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1.(string), planet2.(string)\n\
    \    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n    planet1, planet2\
    \ = planet1.ToUpper(), planet2.ToUpper()\n    planet1, planet2 = planet1.Replace(\"\
    _\", \" \"), planet2.Replace(\"_\", \" \")\n    planet1, planet2 = planet1.Replace(\"\
    \  \", \" \"), planet2.Replace(\"  \", \" \")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwpypx2ra_test.go:46:45: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwz4ca_pt_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v3klkis_test.go:65:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n   \
    \ planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n   \
    \ \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9gzh7ch8_test.go:53:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    planet1SunDistance += plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplbavx2mm_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1OrbitList := []interface{}{}\n    planet2OrbitList\
    \ := []interface{}{}\n    \n    planet1OrbitList = append(planet1OrbitList, planet1Orbit)\n\
    \    planet2OrbitList = append(planet2OrbitList, planet2Orbit)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet2OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet1OrbitList...)\n    \n    planet1OrbitList\
    \ = append(planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcx7ph_0q_test.go:68:37: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1.(string), planet2.(string)\n\
    \    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n    planet1, planet2\
    \ = planet1.ToUpper(), planet2.ToUpper()\n    planet1, planet2 = planet1.Replace(\"\
    _\", \" \"), planet2.Replace(\"_\", \" \")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    _\", \" \"), planet2.Replace(\"_\", \" \")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    _\", \" \"), planet2.Replace(\"_\", \" \")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    _\", \" \"), planet2.Replace(\"_\", \" \")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    _\", \" \"), planet2.Replace(\"_\", \" \")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    _\", \" \"), planet2.Replace(\"_\", \" \")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    _\", \" \"), planet2.Replace(\"_\", \" \")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    _\", \" \"), planet2.Replace(\"_\", \" \")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\"), planet2.Replace(\" \", \"_\")\n    planet1, planet2 = planet1.Replace(\"\
    _\", \" \"), planet2.Replace(\"_\", \" \")\n    planet1, planet2 = planet1.Replace(\"\
    \ \", \"_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ys9z58h_test.go:46:45: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit := planet1\n    planet2Orbit := planet2\n\
    \    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n    planet1OrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvv330uvi_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  planet1Orbit.Set(\"Sun\")\n    planet2Orbit.Set(\"Sun\")\n    planet1Orbit.Set(\"\
    Earth\")\n    planet2Orbit.Set(\"Earth\")\n    planet1Orbit.Set(\"Mars\")\n  \
    \  planet2Orbit.Set(\"Mars\")\n    planet1Orbit.Set(\"Venus\")\n    planet2Orbit.Set(\"\
    Venus\")\n    planet1Orbit.Set(\"Mercury\")\n    planet2Orbit.Set(\"Mercury\"\
    )\n    planet1Orbit.Set(\"Jupiter\")\n    planet2Orbit.Set(\"Jupiter\")\n    planet1Orbit.Set(\"\
    Saturn\")\n    planet2Orbit.Set(\"Saturn\")\n    planet1Orbit.Set(\"Uranus\")\n\
    \    planet2Orbit.Set(\"Uranus\")\n    planet1Orbit.Set(\"Neptune\")\n    planet2Orbit.Set(\"\
    Neptune\")\n    planet1Orbit.Set(\"Pluto\")\n    planet2Orbit.Set(\"Pluto\")\n\
    \    planet1Orbit.Set(\"Ceres\")\n    planet2Orbit.Set(\"Ceres\")\n    planet1Orbit.Set(\"\
    Asteroids\")\n    planet2Orbit.Set(\"Asteroids\")\n    planet1Orbit.Set(\"Phobos\"\
    )\n    planet2Orbit.Set(\"Phobos\")\n    planet1Orbit.Set(\"Europa\")\n    planet2Orbit.Set(\"\
    Europa\")\n    planet1Orbit.Set(\"Iapetus\")\n    planet2Orbit.Set(\"Iapetus\"\
    )\n    planet1Orbit.Set(\"Callisto\")\n    planet2Orbit.Set(\"\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg3m7wnt6_test.go:67:22: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit = planet1Orbit[0:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[0:len(planet2Orbit)-3]\n    \n    planet1Orbit = planet1Orbit[0:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[0:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[0:len(planet1Orbit)-2]\n    planet2Orbit = planet2Orbit[0:len(planet2Orbit)-2]\n\
    \    \n    planet1Orbit = planet1Orbit[0:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[0:len(planet2Orbit)-3]\n    \n    planet1Orbit = planet1Orbit[0:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[0:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[0:len(planet1Orbit)-2]\n    planet2Orbit = planet2Orbit[0:len(planet2Orbit)-2]\n\
    \    \n    planet1Orbit = planet1Orbit[0:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[0:len(planet2Orbit)-3]\n    \n    planet1Orbit = planet1Orbit[0:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[0:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[0:len(planet1Orbit)-2]\n    planet2Orbit = planet2Orbit[0:len(planet2Orbit)-2]\n\
    \    \n    planet1Orbit = planet1Orbit[0:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[0:len(planet2Orbit)-3]\n    \n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpngpl3dfp_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    if planet1 == \"Mercury\" {\n        planet1Orbit =\
    \ \"Venus\"\n    }\n    if planet2 == \"Mercury\" {\n        planet2Orbit = \"\
    Venus\"\n    }\n    planet1OrbitOrbit, planet2OrbitOrbit := planet1Orbit, planet2Orbit\n\
    \    planet1OrbitOrbitOrbit, planet2OrbitOrbitOrbit := planet1OrbitOrbit, planet2OrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbit, planet2OrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbit,\
    \ planet2OrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbit, planet2OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit, planet2OrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbit,\
    \ planet2OrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbit, planet2OrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbit, planet2OrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbit,\
    \ planet2OrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbit, planet2OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit, planet2OrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbit,\
    \ planet2OrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbit, planet2OrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbit, planet2OrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbit,\
    \ planet2OrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbit, planet2OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit, planet2OrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9sk2taik_test.go:43:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1SunDistance\n    planet2OrbitDistance\
    \ /= planet2SunDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1Orbit.Distance(planet2Orbit)\n    planet2OrbitDistance /= planet2Orbit.Distance(planet1Orbit)\n\
    \    \n    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance\
    \ *= planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2OrbitDistance /= planet2Orbit.Distance(planet1Orbit)\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet2Orbit)\n    planet2OrbitDistance\
    \ /= planet2Orbit.Distance(planet1Orbit)\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbbzlu_nr_test.go:75:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit, planet2Orbit = orbit(planet1, planet2)\n  \
    \  \n    planet1Orbit, planet2Orbit = sortByProximity(planet1Orbit, planet2Orbit)\n\
    \    \n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9wdy2q4o_test.go:25:13: no new variables on left side of :=

    /tmp/tmp9wdy2q4o_test.go:26:13: no new variables on left side of :=

    /tmp/tmp9wdy2q4o_test.go:31:34: undefined: orbit

    /tmp/tmp9wdy2q4o_test.go:33:34: undefined: sortByProximity

    /tmp/tmp9wdy2q4o_test.go:35:12: cannot use planet1Orbit (variable of type string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074376
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := getOrbits(planet1,\
    \ planet2)\n    \n    planet1Sun, planet2Sun := getSun(planet1, planet2)\n   \
    \ \n    planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n    planet2SunDistance\
    \ := getDistance(planet2Orbit, planet2Sun)\n    \n    planet1SunDistance += planet1Orbit.DistanceTo(planet1Sun)\n\
    \    planet2SunDistance += planet2Orbit.DistanceTo(planet2Sun)\n    \n    if planet1SunDistance\
    \ < planet2SunDistance {\n        planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n        planet1Sun, planet2Sun = getSun(planet2, planet1)\n      \
    \  planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n        planet2SunDistance\
    \ := getDistance(planet2Orbit, planet2Sun)\n        planet1SunDistance += planet1Orbit.DistanceTo(planet1Sun)\n\
    \        planet2SunDistance += planet2Orbit.DistanceTo(planet2Sun)\n    }\n  \
    \  \n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    \n    planet1Sun,\
    \ planet2Sun = getSun(planet1, planet2)\n    \n    planet1SunDistance := getDistance(planet1Orbit,\
    \ planet1Sun)\n    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.DistanceTo(planet1Sun)\n    planet2SunDistance\
    \ += planet2Orbit.DistanceTo(planet2Sun)\n    \n    if planet1SunDistance < planet2SunDistance\
    \ {\n        planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n      \
    \  planet1Sun, planet2Sun = getSun(planet2, planet1)\n        planet1SunDistance\
    \ := getDistance(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9ls_t87y_test.go:60:47: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4qc9nwnd_test.go:83:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = strings.ToLower(planet1), strings.ToLower(planet2)\n    planet1, planet2 =\
    \ planet1[0 : len(planet1)-1], planet2[0 : len(planet2)-1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:len(planet1)-1],\
    \ planet2[:len(planet2)-1]\n    planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n\
    \    planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n \
    \   planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n  \
    \  planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n   \
    \ planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1,\
    \ planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1, planet2\
    \ = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1, planet2 =\
    \ planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1, planet2 = planet1[:len(planet1)-1],\
    \ planet2[:len(planet2)-1]\n    planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n\
    \    planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n \
    \   planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n  \
    \  planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n   \
    \ planet1, planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1,\
    \ planet2 = planet1[:len(planet1)-1], planet2[:len(planet2)-1]\n    planet1, planet2\
    \ = planet1[:len(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5ocs_3rg_test.go:44:41: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwz4ca_pt_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1Planet, planet2Planet := planet1, planet2\n \
    \   planet1Planet, planet2Planet = planet1Planet, planet2Planet\n    planet1Planet,\
    \ planet2Planet = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet\
    \ = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet = planet1Planet,\
    \ planet2Planet\n    planet1Planet, planet2Planet = planet1Planet, planet2Planet\n\
    \    planet1Planet, planet2Planet = planet1Planet, planet2Planet\n    planet1Planet,\
    \ planet2Planet = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet\
    \ = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet = planet1Planet,\
    \ planet2Planet\n    planet1Planet, planet2Planet = planet1Planet, planet2Planet\n\
    \    planet1Planet, planet2Planet = planet1Planet, planet2Planet\n    planet1Planet,\
    \ planet2Planet = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet\
    \ = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet = planet1Planet,\
    \ planet2Planet\n    planet1Planet, planet2Planet = planet1Planet, planet2Planet\n\
    \    planet1Planet, planet2Planet = planet1Planet, planet2Planet\n    planet1Planet,\
    \ planet2Planet = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet\
    \ = planet1Planet, planet2Planet\n    planet1Planet, planet2Planet = planet1Planet,\
    \ planet2Planet\n    planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp56i7x0a1_test.go:47:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwz4ca_pt_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    planet1Orbit.insert(0, \"Sun\")\n    planet2Orbit.insert(0, \"Sun\")\n  \
    \  return planet1Orbit.intersection(planet2Orbit)\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphe10u3ul_test.go:25:35: undefined: getOrbits

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074376
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunDistance := planet1Orbit - planet1Sun\n    planet2SunDistance\
    \ := planet2Orbit - planet2Sun\n    planet1SunDistance /= 15\n    planet2SunDistance\
    \ /= 15\n    planet1SunDistance *= 15\n    planet2SunDistance *= 15\n    planet1OrbitDistance\
    \ := planet1Orbit - planet2Orbit\n    planet1OrbitDistance /= 15\n    planet2OrbitDistance\
    \ /= 15\n    planet1OrbitDistance *= 15\n    planet2OrbitDistance *= 15\n    planet1OrbitDistance\
    \ += planet1SunDistance\n    planet2OrbitDistance += planet2SunDistance\n    planet1OrbitDistance\
    \ /= 15\n    planet2OrbitDistance /= 15\n    planet1OrbitDistance *= 15\n    planet2OrbitDistance\
    \ *= 15\n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    planet1OrbitDistance /= 15\n    planet2OrbitDistance\
    \ /= 15\n    planet1OrbitDistance *= 15\n    planet2OrbitDistance *= 15\n    planet1OrbitDistance\
    \ += planet1SunDistance\n    planet2OrbitDistance += planet2SunDistance\n    planet1OrbitDistance\
    \ /= 15\n    planet2OrbitDistance /= 15\n    planet1OrbitDistance *= 15\n    planet2OrbitDistance\
    \ *= 15\n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    planet1OrbitDistance /= 15\n    planet2OrbitDistance\
    \ /= 15\n    planet1OrbitDistance *= 15\n    planet2OrbitDistance *= \nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp849_n9om_test.go:76:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    planet1orbit := planet1\n    planet2orbit\
    \ := planet2\n    planet1orbit := planet1orbit\n    planet2orbit := planet2orbit\n\
    \    planet1orbit := planet1orbit\n    planet2orbit := planet2orbit\n    planet1orbit\
    \ := planet1orbit\n    planet2orbit := planet2orbit\n    planet1orbit := planet1orbit\n\
    \    planet2orbit := planet2orbit\n    planet1orbit := planet1orbit\n    planet2orbit\
    \ := planet2orbit\n    planet1orbit := planet1orbit\n    planet2orbit := planet2orbit\n\
    \    planet1orbit := planet1orbit\n    planet2orbit := planet2orbit\n    planet1orbit\
    \ := planet1orbit\n    planet2orbit := planet2orbit\n    planet1orbit := planet1orbit\n\
    \    planet2orbit := planet2orbit\n    planet1orbit := planet1orbit\n    planet2orbit\
    \ := planet2orbit\n    planet1orbit := planet1orbit\n    planet2orbit := planet2orbit\n\
    \    planet1orbit := planet1orbit\n    planet2orbit := planet2orbit\n    planet1orbit\
    \ := planet1orbit\n    planet2orbit := planet2orbit\n    planet1orbit := planet1orbit\n\
    \    planet2orbit := planet2orbit\n    planet1orbit := planet1orbit\n    planet2orbit\
    \ := planet2orbit\n    planet1orbit := planet1orbit\n    planet2orbit := planet2orbit\n\
    \    planet1orbit := planet1orbit\n    planet2orbit := planet2orbit\n    planet1orbit\
    \ := planet1orbit\n    planet2orbit := planet2orbit\n    planet1orbit := planet1orbit\n\
    \    planet2orbit := planet2orbit\n    planet1orbit := plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsqzgw049_test.go:68:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    var planets []interface{}\n    \n    planets\
    \ = append(planets, planet1)\n    planets = append(planets, planet2)\n    \n \
    \   planets = append(planets, planet2)\n    planets = append(planets, planet1)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planets = append(planets, planet1)\n    plan\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2sjtjbht_test.go:86:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    planet1OrbitDistance := planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2OrbitDistance := planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1OrbitDistance\n    planet2SunDistance += planet2OrbitDistance\n  \
    \  planet1SunDistance += planet1SunDistance\n    planet2SunDistance += planet2SunDistance\n\
    \    planet1SunDistance /= 2\n    planet2SunDistance /= 2\n    planet1SunDistance\
    \ += planet1SunDistance\n    planet2SunDistance += planet2SunDistance\n    planet1SunDistance\
    \ /= 2\n    planet2SunDistance /= 2\n    planet1SunDistance += planet1SunDistance\n\
    \    planet2SunDistance += planet2SunDistance\n    planet1SunDistance /= 2\n \
    \   planet2SunDistance /= 2\n    planet1SunDistance += planet1SunDistance\n  \
    \  planet2SunDistance += planet2SunDistance\n    planet1SunDistance /= 2\n   \
    \ planet2SunDistance /= 2\n    planet1SunDistance += planet1SunDistance\n    planet2SunDistance\
    \ += planet2SunDistance\n    planet1SunDistance /= 2\n    planet2SunDistance /=\
    \ 2\n    planet1SunDistance += planet1SunDistance\n    planet2SunDistance += planet2SunDistance\n\
    \    planet1SunDistance /= 2\n    planet2SunDistance /= 2\n    planet1SunDistance\
    \ += planet1SunDistance\n    planet2SunDistance += planet\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1m9125uk_test.go:73:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoeiogft8_test.go:71:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n   \
    \ planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n   \
    \ \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOr\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4gq42eoz_test.go:57:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1OrbitSun, err := getSunOrbit(planet1)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2OrbitSun, err := getSunOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunDistance,\
    \ err := getSunDistance(planet1OrbitSun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunDistance, err := getSunDistance(planet2OrbitSun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunDistance,\
    \ err := getSunDistance(planet1OrbitSun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunDistance, err := getSunDistance(planet2OrbitSun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunDistance,\
    \ err := getSunDistance(planet1OrbitSun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunDistance, err := getSunDistance(planet2OrbitSun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunDistance,\
    \ err := getSunDistance(planet1OrbitSun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunDistance, err := getSunDistance(planet2OrbitSun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunDistance,\
    \ err := getSunDistance(planet1OrbitSun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSunDistance, err := getSunDistance(planet2OrbitSun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSunDistance,\
    \ err := getSunDistance(planet1OrbitSun)\n    if err != nil {\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6h_ay6kc_test.go:84:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074376
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\"\
    )\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance\
    \ := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptug5eksp_test.go:71:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074376
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    \n    planet1Orbit := planet1\n    planet2Orbit := planet2\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit.(string), planet2Orbit.(string)\n    \n    \nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx1mzyfw6_test.go:61:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-3]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-3]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-3]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-3]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-3]\n    planet2Orbit\
    \ = planet2Orbit[:\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuwgo2a7j_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps3r746jv_test.go:65:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1OrbitSun, err := getOrbitSun(planet1)\n    if err != nil {\n \
    \       fmt.Println(err)\n    }\n    planet2OrbitSun, err := getOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance,\
    \ err := getDistance(planet1OrbitSun, planet2OrbitSun)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet2SunDistance, err := getDistance(planet1OrbitSun,\
    \ planet2OrbitSun)\n    if err != nil {\n        fmt.Println(err)\n    }\n   \
    \ \n    planet1OrbitSun, planet2OrbitSun, planet1SunDistance, planet2SunDistance\
    \ := \n        planet1OrbitSun, planet2OrbitSun, planet1SunDistance, planet2SunDistance\n\
    \    \n    planet1OrbitSun, planet2OrbitSun, planet1SunDistance, planet2SunDistance\
    \ := \n        planet1OrbitSun, planet2OrbitSun, planet1SunDistance, planet2SunDistance\n\
    \    \n    planet1OrbitSun, planet2OrbitSun, planet1SunDistance, planet2SunDistance\
    \ := \n        planet1OrbitSun, planet2OrbitSun, planet1SunDistance, planet2SunDistance\n\
    \    \n    planet1OrbitSun, planet2OrbitSun, planet1SunDistance, planet2SunDistance\
    \ := \n        planet1OrbitSun, planet2OrbitSun, planet1SunDistance, planet2SunDistance\n\
    \    \n    planet1OrbitSun, planet2OrbitSun, planet1SunDistance, planet2SunDistance\
    \ := \n        planet1OrbitSun, planet2OrbitSun, planet1SunDistance, planet2\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzs4djezy_test.go:70:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp807x8bhu_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet1OrbitRadius := getOrbit(planet1)\n\
    \    planet2Orbit, planet2OrbitRadius := getOrbit(planet2)\n    \n    planet1Distance\
    \ := getDistance(planet1Orbit, planet2Orbit)\n    planet2Distance := getDistance(planet2Orbit,\
    \ planet1Orbit)\n    \n    planet1Radius := planet1OrbitRadius\n    planet2Radius\
    \ := planet2OrbitRadius\n    \n    planet1Radius += planet2Radius\n    planet2Radius\
    \ += planet1Radius\n    \n    if planet1Distance < planet2Distance {\n       \
    \ planet1Distance = planet2Distance\n    }\n    \n    if planet1Distance < planet2Radius\
    \ {\n        planet1Radius = planet2Radius\n    }\n    \n    if planet1Radius\
    \ < planet2Radius {\n        planet1Radius = planet2Radius\n    }\n    \n    if\
    \ planet1Distance > planet2Distance {\n        planet1Distance = planet2Distance\n\
    \    }\n    \n    if planet1Distance > planet2Radius {\n        planet1Radius\
    \ = planet2Radius\n    }\n    \n    if planet1Radius > planet2Radius {\n     \
    \   planet1Radius = planet2Radius\n    }\n    \n    planet1OrbitRadius += planet2Radius\n\
    \    planet2OrbitRadius += planet1Radius\n    \n    if planet1OrbitRadius < planet2OrbitRadius\
    \ {\n        planet1OrbitRadius = planet2OrbitRadius\n    }\n    \n    if planet1OrbitRadius\
    \ < planet2OrbitRadius {\n        planet1OrbitRadius = planet2OrbitRadius\n  \
    \  }\n    \n    if planet1OrbitRadius > planet2OrbitRadius {\n        planet1OrbitRadius\
    \ = planet2OrbitRadius\n    }\n    \n    if planet1OrbitRadius > planet2OrbitRadius\
    \ {\n        planet1OrbitRadius = planet2OrbitRadius\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxja524r__test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit := planet1\n    planet2Orbit := planet2\n\
    \    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n    planet1OrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvv330uvi_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    planet1Orbits, planet2Orbits\
    \ := orbits(planet1, planet2)\n    \n    planet1Sun := orbit(planet1, planet1Orbits)\n\
    \    planet2Sun := orbit(planet2, planet2Orbits)\n    \n    planet1SunProximity\
    \ := distance(planet1Sun, planet2)\n    planet2SunProximity := distance(planet2Sun,\
    \ planet1)\n    \n    planet1OrbitsProximity := distance(planet1Orbits, planet2)\n\
    \    planet2OrbitsProximity := distance(planet2Orbits, planet1)\n    \n    planet1OrbitsProximitySorted\
    \ := sortByProximity(planet1OrbitsProximity)\n    planet2OrbitsProximitySorted\
    \ := sortByProximity(planet2OrbitsProximity)\n    \n    planet1OrbitsSortedProximity\
    \ := distance(planet1OrbitsSorted, planet2)\n    planet2OrbitsSortedProximity\
    \ := distance(planet2OrbitsSorted, planet1)\n    \n    planet1OrbitsSortedProximitySorted\
    \ := sortByProximity(planet1OrbitsSortedProximity)\n    planet2OrbitsSortedProximitySorted\
    \ := sortByProximity(planet2OrbitsSortedProximity)\n    \n    planet1OrbitsSortedProximitySortedSorted\
    \ := distance(planet1OrbitsSortedSortedSorted, planet2)\n    planet2OrbitsSortedSortedProximitySortedSorted\
    \ := distance(planet2OrbitsSortedSortedSorted, planet1)\n    \n    planet1OrbitsSortedSortedProximitySortedSortedSorted\
    \ := sortByProximity(planet1OrbitsSortedSortedProximitySortedSorted)\n    planet2OrbitsSortedSortedProximitySortedSortedSorted\
    \ := sortByProximity(planet2OrbitsSortedSortedProximitySortedSorted)\n    \n \
    \   planet1OrbitsSortedSortedProximitySortedSortedSortedSorted := distance(planet1OrbitsSortedSortedSortedSorted,\
    \ planet2)\n    planet2Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8_h5ad14_test.go:56:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, err := getOrbit(planet1)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err := getOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Sun, err :=\
    \ getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance\
    \ := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n\
    \    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance /=\
    \ planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n   \
    \ planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /=\
    \ planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n   \
    \ planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance /=\
    \ planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n   \
    \ planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /=\
    \ planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n   \
    \ planet2OrbitDistance /= planet2Orbit\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzia0pvrk_test.go:67:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n      \
    \  return []interface{}{}\n    }\n    planet2Orbit, err := getOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n        return []interface{}{}\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \        return []interface{}{}\n    }\n    planet2Sun, err := getSun()\n    if\
    \ err != nil {\n        fmt.Println(err)\n        return []interface{}{}\n   \
    \ }\n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoyemfa5e_test.go:63:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := getOrbit(planet1)\n\
    \    planet2Orbit := getOrbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    result := []interface{}{}\n    for _, planet := range planet1Orbit {\n  \
    \      if planet == planet2 {\n            result = append(result, planet)\n \
    \       }\n    }\n    for _, planet := range planet2Orbit {\n        if planet\
    \ == planet1 {\n            result = append(result, planet)\n        }\n    }\n\
    \    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgyagsbxd_test.go:25:21: undefined: getOrbit

    /tmp/tmpgyagsbxd_test.go:26:21: undefined: getOrbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074378
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\"\
    )\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance\
    \ := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n\
    \    \n    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance += planet1OrbitDistance\n\
    \    planet2SunDistance += planet2OrbitDistance\n    \n    if planet1SunDistance\
    \ < planet2SunDistance {\n        planet1Orbit, planet2Orbit = planet2Orbit, planet1Orbit\n\
    \        planet1Sun, planet2Sun = planet2Sun, planet1Sun\n    }\n    \n    planet1Orbit.AddOrbit(planet1Sun)\n\
    \    planet2Orbit.AddOrbit(planet2Sun)\n    \n    planet1OrbitList := []interface{}{}\n\
    \    planet2OrbitList := []interface{}{}\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1Orbit)\n    planet2OrbitList = append(planet2OrbitList, planet2Orbit)\n\
    \    \n    planet1OrbitList = append(planet1OrbitList, planet1Orbit)\n    planet2OrbitList\
    \ = append(planet2OrbitList, planet2Orbit)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1Orbit)\n    planet2OrbitList = \nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt2u6r5sc_test.go:74:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance\
    \ := planet2Sun.Distance(planet2Orbit)\n    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n\
    \    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance *=\
    \ planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n   \
    \ planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    planet1OrbitDistance /=\
    \ planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n   \
    \ planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /=\
    \ planet2OrbitDistance\n    planet1OrbitDistance *= planet1OrbitDistance\n   \
    \ planet2OrbitDistance *= planet2OrbitDistance\n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    planet1OrbitDistance *=\
    \ planet1OrbitDistance\n    planet2OrbitDistance *= \nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2fenmz23_test.go:68:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit := planet1\n    planet2Orbit := planet2\n    planet1Orbit, planet2Orbit\
    \ = planet2Orbit, planet1Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz4_wufnb_test.go:47:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n   \
    \ planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo05bf32m_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Sun, planet2Sun := getSun(planet1,\
    \ planet2)\n    planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n\
    \    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    planet1SunDistance += get\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiog2h26r_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1\n\
    \    planet2Orbit := planet2\n    \n    planet1Orbit, planet2Orbit = planet2Orbit,\
    \ planet1Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    plan\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp11ou7b9h_test.go:65:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = strings.ToLower(planet1), strings.ToLower(planet2)\n    planet1, planet2 =\
    \ planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9r7vlp7r_test.go:53:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1Orbit\n    planet2OrbitOrbit\
    \ := planet2Orbit\n    \n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n   \
    \ planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3ikkhl71_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, err := getOrbit(planet1)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err := getOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1Sun, err :=\
    \ getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance\
    \ := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n\
    \    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    if planet1OrbitDistance < planet2OrbitDistance\
    \ {\n        planet1OrbitDistance = planet2OrbitDistance\n    }\n    if planet1OrbitDistance\
    \ < planet1SunDistance {\n        planet1OrbitDistance = planet1SunDistance\n\
    \    }\n    if planet2OrbitDistance < planet2SunDistance {\n        planet2OrbitDistance\
    \ = planet2SunDistance\n    }\n    planet1OrbitDistance /= 1000\n    planet2OrbitDistance\
    \ /= 1000\n    planet1OrbitDistance += planet1Orbit\n    planet2OrbitDistance\
    \ += planet2Orbit\n    planet1OrbitDistance /= 1000\n    planet2OrbitDistance\
    \ /= 1000\n    planet1OrbitDistance += planet1Orbit\n    planet2OrbitDistance\
    \ += planet2Orbit\n    planet1OrbitDistance /= 1000\n    planet2OrbitDistance\
    \ /= 1000\n    planet1OrbitDistance += planet1Orbit\n    planet2OrbitDistance\
    \ += planet2Orbit\n    planet1OrbitDistance /= 1000\n    planet2OrbitDistance\
    \ /= 1000\n    planet1OrbitDistance += planet1Orbit\n    planet2OrbitDistance\
    \ += planet2Orbit\n    planet1OrbitDistance /= 1000\n    \nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplvv8kkgo_test.go:74:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = strings.ToLower(planet1), strings.ToLower(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = strings.TrimSpace(planet1Orbit),\
    \ strings.TrimSpace(planet2Orbit)\n    planet1Orbit, planet2Orbit = strings.TrimPrefix(planet1Orbit,\
    \ planet1), strings.TrimPrefix(planet2Orbit, planet2)\n    planet1Orbit, planet2Orbit\
    \ = strings.TrimSuffix(planet1Orbit, planet1), strings.TrimSuffix(planet2Orbit,\
    \ planet2)\n    planet1Orbit, planet2Orbit = strings.ToUpper(planet1Orbit), strings.ToUpper(planet2Orbit)\n\
    \    planet1Orbit, planet2Orbit = strings.Replace(planet1Orbit, \"-\", \"\"),\
    \ strings.Replace(planet2Orbit, \"-\", \"\")\n    planet1Orbit, planet2Orbit =\
    \ strings.Replace(planet1Orbit, \"_\", \"\"), strings.Replace(planet2Orbit, \"\
    _\", \"\")\n    planet1Orbit, planet2Orbit = strings.Replace(planet1Orbit, \"\
    .\", \"\"), strings.Replace(planet2Orbit, \".\", \"\")\n    planet1Orbit, planet2Orbit\
    \ = strings.Replace(planet1Orbit, \"/\", \"\"), strings.Replace(planet2Orbit,\
    \ \"/\", \"\")\n    planet1Orbit, planet2Orbit = strings.Replace(planet1Orbit,\
    \ \"\\\\\", \"\"), strings.Replace(planet2Orbit, \"\\\\\", \"\")\n    planet1Orbit,\
    \ planet2Orbit = strings.Replace(planet1Orbit, \"'\", \"\"), strings.Replace(planet2Orbit,\
    \ \"'\", \"\")\n    planet1Orbit, planet2Orbit = strings.Replace(planet1Orbit,\
    \ \"-\", \"\"), strings.Replace(planet2Orbit, \"-\", \"\")\n    planet1Orbit,\
    \ planet2Orbit = strings.Replace(planet1Orbit, \"_\", \"\"), strings.Replace(planet2Orbit,\
    \ \"_\", \"\")\n    planet1Orbit, planet2Orbit = strings.Replace(planet1Or\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp761k9bzi_test.go:39:59: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun.Name = \"Sun\"\n    planet2Sun.Name = \"Sun\"\n    planet1Orbit.Name\
    \ = \"Sun\"\n    planet2Orbit.Name = \"Sun\"\n    planet1Orbit.Name = \"Sun\"\n\
    \    planet2Orbit.Name = \"Sun\"\n    planet1Orbit.Name = \"Sun\"\n    planet2Orbit.Name\
    \ = \"Sun\"\n    planet1Orbit.Name = \"Sun\"\n    planet2Orbit.Name = \"Sun\"\n\
    \    planet1Orbit.Name = \"Sun\"\n    planet2Orbit.Name = \"Sun\"\n    planet1Orbit.Name\
    \ = \"Sun\"\n    planet2Orbit.Name = \"Sun\"\n    planet1Orbit.Name = \"Sun\"\n\
    \    planet2Orbit.Name = \"Sun\"\n    planet1Orbit.Name = \"Sun\"\n    planet2Orbit.Name\
    \ = \"Sun\"\n    planet1Orbit.Name = \"Sun\"\n    planet2Orbit.Name = \"Sun\"\n\
    \    planet1Orbit.Name = \"Sun\"\n    planet2Orbit.Name = \"Sun\"\n    planet1Orbit.Name\
    \ = \"Sun\"\n    planet2Orbit.Name = \"Sun\"\n    planet1Orbit.Name = \"Sun\"\n\
    \    planet2Orbit.Name = \"Sun\"\n    planet1Orbit.Name = \"Sun\"\n    planet2Orbit.Name\
    \ = \"Sun\"\n    planet1Orbit.Name = \"Sun\"\n    planet2Orbit.Name = \"Sun\"\n\
    \    planet1Orbit.Name = \"Sun\"\n    planet2Orbit.Name = \"Sun\"\n    planet1Orbit.Name\
    \ = \"Sun\"\n    planet2Orbit.Name = \"Sun\"\n    planet1Orbit.Name = \"Sun\"\n\
    \    planet2Orbit.Name = \"Sun\"\n    planet1Orbit.Name = \"\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp08xfhb9d_test.go:77:25: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.insert(planet2Orbit)\n    planet2Orbit.insert(planet1Orbit)\n\
    \    \n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmhupkm_v_test.go:25:35: undefined: getOrbits

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074378
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1OrbitSun, err := getPlanetOrbitSun(planet1)\n    if err\
    \ != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSun, err := getPlanetOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance\
    \ := planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2SunDistance := planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    \n    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    \n    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    \n    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    \n    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    \n    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    \n    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    \n    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    \n    planet1OrbitSun.Distance(planet2OrbitSun)\n    planet2OrbitSun.Distance(planet1OrbitSun)\n\
    \    \n    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6wkz8qzb_test.go:74:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074378
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1OrbitDistance\n    planet2SunDistance\
    \ += planet2OrbitDistance\n    \n    if planet1SunDistance < planet2SunDistance\
    \ {\n        planet1SunDistance = planet2SunDistance\n        planet1Orbit = planet2Orbit\n\
    \        planet2Orbit = planet1Orbit\n    }\n    \n    planet1Orbit.Orbit = planet1Orbit\n\
    \    planet2Orbit.Orbit = planet2Orbit\n    \n    planet1Orbit.Sun = planet1Sun\n\
    \    planet2Orbit.Sun = planet2Sun\n    \n    planet1Orbit.Distance(planet1Sun)\n\
    \    planet2Orbit.Distance(planet2Sun)\n    \n    planet1Orbit.Distance(planet1Sun)\n\
    \    planet2Orbit.Distance(planet2Sun)\n    \n    planet1Orbit.Distance(planet1Sun)\n\
    \    planet2Orbit.Distance(planet2Sun)\n    \n    planet1Orbit.Distance(planet1Sun)\n\
    \    planet2Orbit.Distance(planet2Sun)\n    \n    planet1Orbit.Distance(\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1terxary_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074378
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1OrbitDistance\n    planet2SunDistance\
    \ += planet2OrbitDistance\n    \n    if planet1SunDistance < planet2SunDistance\
    \ {\n        return append(planet1Orbit, planet2Orbit)\n    } else {\n       \
    \ return append(planet2Orbit, planet1Orbit)\n    }\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl1tsgkgz_test.go:25:13: no new variables on left side of :=

    /tmp/tmpl1tsgkgz_test.go:25:16: undefined: strings

    /tmp/tmpl1tsgkgz_test.go:26:13: no new variables on left side of :=

    /tmp/tmpl1tsgkgz_test.go:26:16: undefined: strings

    /tmp/tmpl1tsgkgz_test.go:28:26: undefined: getOrbit

    /tmp/tmpl1tsgkgz_test.go:32:26: undefined: getOrbit

    /tmp/tmpl1tsgkgz_test.go:37:24: undefined: getSun

    /tmp/tmpl1tsgkgz_test.go:41:24: undefined: getSun

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074378
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgkqq530y_test.go:40:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := getOrbit(planet1)\n\
    \    planet2Orbit := getOrbit(planet2)\n    planet1Sun := getSunPosition(planet1)\n\
    \    planet2Sun := getSunPosition(planet2)\n    planet1SunDistance := getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2SunDistance := getDistance(planet2Sun, planet2Orbit)\n\
    \    planet1OrbitDistance := getDistance(planet1Orbit, planet1Sun)\n    planet2OrbitDistance\
    \ := getDistance(planet2Orbit, planet2Sun)\n    planet1OrbitDistance /= getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n\
    \    planet1OrbitDistance /= getDistance(planet1Orbit, planet1Sun)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Orbit, planet2Sun)\n    planet1OrbitDistance /= getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n\
    \    planet1OrbitDistance /= getDistance(planet1Orbit, planet1Sun)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Orbit, planet2Sun)\n    planet1OrbitDistance /= getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n\
    \    planet1OrbitDistance /= getDistance(planet1Orbit, planet1Sun)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Sun, planet2Orbit)\n    planet1OrbitDistance /= getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n\
    \    planet1OrbitDistance /= getDistance(planet1Orbit, planet1Sun)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Sun, planet2\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1vvf8dyf_test.go:48:60: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := orbit(planet1, planet2)\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    planet1Orbit, planet2Orbit =\
    \ planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy318qhsy_test.go:46:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074378
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1OrbitSun, err := getOrbitSun(planet1)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2OrbitSun, err := getOrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance,\
    \ err := getDistance(planet1OrbitSun, planet2OrbitSun)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2SunDistance, err := getDistance(planet2OrbitSun,\
    \ planet1OrbitSun)\n    if err != nil {\n        fmt.Println(err)\n    }\n   \
    \ planet1OrbitSun, planet2OrbitSun, planet1SunDistance, planet2SunDistance \n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbq3txoru_test.go:49:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074378
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortPlanets(planet1Orbit,\
    \ planet2Orbit)\n    planet1Orbit, planet2Orbit = removePlanets(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeiu3nxef_test.go:25:35: undefined: getOrbits

    /tmp/tmpeiu3nxef_test.go:26:34: undefined: sortPlanets

    /tmp/tmpeiu3nxef_test.go:27:34: undefined: removePlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, planet2Orbit := orbit(planet1,\
    \ planet2)\n    \n    planet1OrbitList := []interface{}{planet1}\n    planet2OrbitList\
    \ := []interface{}{planet2}\n    \n    planet1OrbitListSorted := []interface{}{}\n\
    \    planet2OrbitListSorted := []interface{}{}\n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp_cs3xrp_test.go:238:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074378
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, err := getPlanetOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n   \
    \     fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\")\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance,\
    \ err := getPlanetOrbitDistance(planet1Sun, planet1Orbit)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2SunDistance, err := getPlanetOrbitDistance(planet2Sun,\
    \ planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet1SunDistance,\
    \ err := getPlanetOrbitDistance(planet1Sun, planet1Orbit)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2SunDistance, err := getPlanetOrbitDistance(planet2Sun,\
    \ planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n    }\n    if\
    \ planet1SunDistance < planet2SunDistance {\n        planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \        if err != nil {\n            fmt.Println(err)\n        }\n        planet2Orbit,\
    \ err := getPlanetOrbit(planet2)\n        if err != nil {\n            fmt.Println(err)\n\
    \        }\n        planet1Sun, err := getPlanetOrbit(\"Sun\")\n        if err\
    \ != nil {\n            fmt.Println(err)\n        }\n        planet2Sun, err :=\
    \ getPlanetOrbit(\"Sun\")\n        if err != nil {\n            fmt.Println(err)\n\
    \        }\n        planet1SunDistance, err := getPlanetOrbitDistance(planet1Sun,\
    \ planet1Orbit)\n        if err != nil {\n            fmt.Println(err)\n     \
    \   }\n        planet2SunDistance, err := getPlanetOrbitDistance(planet2Sun, planet2Orbit)\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp20kvs01f_test.go:81:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = strings.ToLower(planet1), strings.ToLower(planet2)\n    planet1, planet2 =\
    \ strings.TrimSpace(planet1), strings.TrimSpace(planet2)\n    planet1, planet2\
    \ = strings.ToUpper(planet1), strings.ToUpper(planet2)\n    planet1, planet2 =\
    \ strings.Replace(planet1, \"-\", \" \", -1), strings.Replace(planet2, \"-\",\
    \ \" \", -1)\n    planet1, planet2 = strings.Replace(planet1, \" \", \"-\", -1),\
    \ strings.Replace(planet2, \" \", \"-\", -1)\n    planet1, planet2 = strings.Replace(planet1,\
    \ \"-\", \" \", -1), strings.Replace(planet2, \" \", \"-\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \" \", \"-\", -1), strings.Replace(planet2,\
    \ \" \", \"-\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"-\", \"\
    \ \", -1), strings.Replace(planet2, \" \", \"-\", -1)\n    planet1, planet2 =\
    \ strings.Replace(planet1, \" \", \"-\", -1), strings.Replace(planet2, \" \",\
    \ \"-\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"-\", \" \", -1),\
    \ strings.Replace(planet2, \" \", \"-\", -1)\n    planet1, planet2 = strings.Replace(planet1,\
    \ \" \", \"-\", -1), strings.Replace(planet2, \" \", \"-\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \"-\", \" \", -1), strings.Replace(planet2,\
    \ \" \", \"-\", -1)\n    planet1, planet2 = strings.Replace(planet1, \" \", \"\
    -\", -1), strings.Replace(planet2, \" \", \"-\", -1)\n    planet1, planet2 = strings.Replace(planet1,\
    \ \"-\", \" \", -1), strings.Replace(planet2, \" \", \"-\", -1)\n    planet1,\
    \ planet2 = strings.Replace(planet1, \" \", \"-\", -1), strings.Replace(planet2,\
    \ \" \", \"-\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"-\", \"\
    \ \", -1), strings.Replace(planet2, \" \", \"-\", -1)\n    planet1, planet2 =\
    \ strings.Replace(planet1, \" \", \"-\", -1), strings.Replace(planet2, \" \",\
    \ \"-\", -1)\n    planet1, planet2 = strings.Replace(planet1, \"-\", \" \", -1),\
    \ strings.Replace(planet2, \" \", \"-\", -1)\n    planet1, planet2 = strings.Replace(planet1,\
    \ \" \", \"-\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzry0emgc_test.go:43:54: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortPlanets(planet1Orbit,\
    \ planet2Orbit)\n    planet1Orbit, planet2Orbit = removeDuplicates(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp77v6l5om_test.go:25:35: undefined: getOrbits

    /tmp/tmp77v6l5om_test.go:26:34: undefined: sortPlanets

    /tmp/tmp77v6l5om_test.go:27:34: undefined: removeDuplicates

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074372
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq3fklk_1_test.go:102:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    planet1OrbitDistance := planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2OrbitDistance := planet2Orbit.Distance(planet1Orbit)\n    if planet1OrbitDistance\
    \ < planet2OrbitDistance {\n        planet1OrbitDistance = planet2OrbitDistance\n\
    \    }\n    if planet1OrbitDistance < planet1SunDistance {\n        planet1OrbitDistance\
    \ = planet1SunDistance\n    }\n    if planet2OrbitDistance < planet2SunDistance\
    \ {\n        planet2OrbitDistance = planet2SunDistance\n    }\n    if planet1OrbitDistance\
    \ < planet2OrbitDistance {\n        planet1OrbitDistance = planet2OrbitDistance\n\
    \    }\n    if planet1OrbitDistance < planet1SunDistance {\n        planet1OrbitDistance\
    \ = planet1SunDistance\n    }\n    if planet2OrbitDistance < planet2SunDistance\
    \ {\n        planet2OrbitDistance = planet2SunDistance\n    }\n    if planet1OrbitDistance\
    \ < planet2OrbitDistance {\n        planet1OrbitDistance = planet2OrbitDistance\n\
    \    }\n    if planet1OrbitDistance < planet1SunDistance {\n        planet1OrbitDistance\
    \ = planet1SunDistance\n    }\n    if planet2OrbitDistance < planet2SunDistance\
    \ {\n        planet2OrbitDistance = planet2SunDistance\n    }\n    if planet1OrbitDistance\
    \ < planet2OrbitDistance {\n        planet1OrbitDistance = planet2Orbit\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpokquf8w2_test.go:74:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet := range planet1Orbit\
    \ {\n        if planet == planet2 {\n            result = append(result, planet)\n\
    \        }\n    }\n    \n    for _, planet := range planet2Orbit {\n        if\
    \ planet == planet1 {\n            result = append(result, planet)\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqug1ekt2_test.go:25:21: undefined: orbit

    /tmp/tmpqug1ekt2_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v3klkis_test.go:65:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Orbit.Or\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7zdbhjb1_test.go:34:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074370
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n\
    \    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n  \
    \  \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n\
    \    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n  \
    \  planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit,\
    \ planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit\
    \ = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit =\
    \ orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit,\
    \ planet2Orbit)\n    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n\
    \    \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n  \
    \  \n    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n\
    \    planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n  \
    \  planet1Orbit, planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit,\
    \ planet2Orbit = orbit(planet1Orbit, planet2Orbit)\n    \n    planet1Orbit, planet2Orbit\
    \ = orbit(planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi9078xv9_test.go:61:47: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := strings.ToLower(planet1)\n    planet2 := strings.ToLower(planet2)\n\
    \    planet1Orbit, err := planet1orbit(planet1)\n    if err != nil {\n       \
    \ fmt.Println(err)\n    }\n    planet2Orbit, err := planet2orbit(planet2)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet1Orbit.sort()\n\
    \    planet2Orbit.sort()\n    result := []interface{}{}\n    for i := 0; i < len(planet1Orbit);\
    \ i++ {\n        for j := 0; j < len(planet2Orbit); j++ {\n            if planet1Orbit[i].distance(planet2Orbit[j])\
    \ < 1 {\n                result = append(result, planet1Orbit[i])\n          \
    \      break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy0x79gyr_test.go:26:13: no new variables on left side of :=

    /tmp/tmpy0x79gyr_test.go:26:16: undefined: strings

    /tmp/tmpy0x79gyr_test.go:27:13: no new variables on left side of :=

    /tmp/tmpy0x79gyr_test.go:27:16: undefined: strings

    /tmp/tmpy0x79gyr_test.go:28:26: undefined: planet1orbit

    /tmp/tmpy0x79gyr_test.go:32:26: undefined: planet2orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n      \
    \  return nil\n    }\n    planet2Orbit, err := getOrbit(planet2)\n    if err !=\
    \ nil {\n        fmt.Println(err)\n        return nil\n    }\n    planet1Sun,\
    \ err := getSun()\n    if err != nil {\n        fmt.Println(err)\n        return\
    \ nil\n    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \        return nil\n    }\n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance := planet2Orbit.Distance(planet2Sun)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet1Sun)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnu3ec8q1_test.go:62:61: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := getDistance(planet1Sun, planet1Orbit)\n\
    \    planet2SunDistance := getDistance(planet2Sun, planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := getDistance(planet1Orbit, planet1Sun)\n    planet2OrbitDistance := getDistance(planet2Orbit,\
    \ planet2Sun)\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    \nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpinr25e2k_test.go:84:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n\
    \    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n    \n    planet1OrbitDistance\
    \ := getDistance(planet1Orbit, planet1Orbit)\n    planet2OrbitDistance := getDistance(planet2Orbit,\
    \ planet2Orbit)\n    \n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl99loyul_test.go:83:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    planet1Sun := sun(planet1)\n    planet2Sun\
    \ := sun(planet2)\n    planet1OrbitSun := orbit(planet1, planet1Sun)\n    planet2OrbitSun\
    \ := orbit(planet2, planet2Sun)\n    planet1OrbitSunOrbit := orbit(planet1, planet1Sun,\
    \ planet2OrbitSun)\n    planet2OrbitSunOrbit := orbit(planet2, planet2Sun, planet1OrbitSun)\n\
    \    planet1OrbitSunOrbitSun := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun)\n\
    \    planet2OrbitSunOrbitSun := orbit(planet2, planet2Sun, planet1OrbitSun, planet2OrbitSun)\n\
    \    planet1OrbitSunOrbitSunOrbit := orbit(planet1, planet1Sun, planet2OrbitSun,\
    \ planet1OrbitSun, planet2OrbitSun)\n    planet2OrbitSunOrbitSunOrbitSun := orbit(planet2,\
    \ planet2Sun, planet1OrbitSun, planet2OrbitSun, planet1OrbitSun)\n    planet1OrbitSunOrbitSunOrbitSun\
    \ := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun,\
    \ planet1OrbitSun)\n    planet2OrbitSunOrbitSunOrbitSun := orbit(planet2, planet2Sun,\
    \ planet1OrbitSun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSunOrbitSunOrbitSunOrbitSun\
    \ := orbit(planet1, planet1Sun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun,\
    \ planet1OrbitSun, planet2OrbitSun)\n    planet2OrbitSunOrbitSunOrbitSunOrbitSun\
    \ := orbit(planet2, planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0s1gecv3_test.go:40:70: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1Orbit(planet1)\n\
    \    planet2Orbit := planet2Orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit.list\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzg9cts7x_test.go:25:21: undefined: planet1Orbit

    /tmp/tmpzg9cts7x_test.go:26:21: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\"\
    )\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl6_rhy4f_test.go:70:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n   \
    \ planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n   \
    \ \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9gzh7ch8_test.go:53:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = sortPlanets(planet1Orbit,\
    \ planet2Orbit)\n    planet1Orbit, planet2Orbit = removeDuplicates(planet1Orbit,\
    \ planet2Orbit)\n    return planet1Orbit\n}\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp77v6l5om_test.go:25:35: undefined: getOrbits

    /tmp/tmp77v6l5om_test.go:26:34: undefined: sortPlanets

    /tmp/tmp77v6l5om_test.go:27:34: undefined: removeDuplicates

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074372
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1SunDistance\n    planet2OrbitDistance /= planet2SunDistance\n    \n\
    \    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance *=\
    \ planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1SunDistance\n\
    \    planet2OrbitDistance /= planet2SunDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1SunDistance\n    planet2OrbitDistance\
    \ /= planet2SunDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1SunDistance\n    planet2OrbitDistance /= planet2SunDistance\n    \n\
    \    planet1OrbitDistance *= \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwkvbysyw_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmhdx7dfd_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1SunDistance\n    planet2OrbitDistance\
    \ /= planet2SunDistance\n    \n    planet1OrbitDistance *= -1\n    planet2OrbitDistance\
    \ *= -1\n    \n    planet1OrbitDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2OrbitDistance += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1OrbitDistance\
    \ /= planet1Orbit.Distance(planet2Orbit)\n    planet2OrbitDistance /= planet2Orbit.Distance(planet1Orbit)\n\
    \    \n    planet1OrbitDistance *= -1\n    planet2OrbitDistance *= -1\n    \n\
    \    planet1OrbitDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2OrbitDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1OrbitDistance /= planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2OrbitDistance /= planet2Orbit.Distance(planet1Orbit)\n    \n    planet1OrbitDistance\
    \ *= -1\n    planet2Orbit\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv1ajg5jk_test.go:75:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzj79zxjt_test.go:25:21: undefined: orbit

    /tmp/tmpzj79zxjt_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp807x8bhu_test.go:48:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp09nombwe_test.go:61:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    planet\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbmw3j745_test.go:72:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwz4ca_pt_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6v3klkis_test.go:65:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    var planets []interface{}\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    planets\
    \ = append(planets, planet1)\n    planets = append(planets, planet2)\n    \n \
    \   planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := strings.Replace(planet1,\
    \ \"_\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"_\", \" \", -1)\n\
    \    \n    planet1 := strings.Replace(planet1, \" \", \"_\", -1)\n    planet2\
    \ := strings.Replace(planet2, \" \", \"_\", -1)\n    \n    planet1 := strings.Replace(planet1,\
    \ \" \", \"_\", -1)\n    planet2 := strings.Replace(planet2, \" \", \"_\", -1)\n\
    \    \n    planet1 := strings.Replace(planet1, \"-\", \" \", -1)\n    planet2\
    \ := strings.Replace(planet2, \"-\", \" \", -1)\n    \n    planet1 := strings.Replace(planet1,\
    \ \"-\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"-\", \" \", -1)\n\
    \    \n    planet1 := strings.Replace(planet1, \"-\", \" \", -1)\n    planet2\
    \ := strings.Replace(planet2, \"-\", \" \", -1)\n    \n    planet1 := strings.Replace(planet1,\
    \ \"-\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"-\", \" \", -1)\n\
    \    \n    planet1 := strings.Replace(planet1, \"-\", \" \", -1)\n    planet2\
    \ := strings.Replace(planet2, \"-\", \" \", -1)\n    \n    planet1 := strings.Replace(planet1,\
    \ \"-\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"-\", \" \", -1)\n\
    \    \n    planet1 := strings.Replace(planet1, \"-\", \" \", -1)\n    planet2\
    \ := strings.Replace(planet2, \"-\", \" \", -1)\n    \n    planet1 := strings.Replace(planet1,\
    \ \"-\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"-\", \" \", -1)\n\
    \    \n    planet1 := strings.Replace(planet1, \"-\", \" \", \nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmfszw6ui_test.go:74:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance\
    \ *= planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuu8vxgbg_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1[:len(planet1)-3]\n    planet2\
    \ := planet2[:len(planet2)-3]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpob2lnikk_test.go:59:35: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\"\
    )\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance\
    \ := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet1Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpretsd93s_test.go:70:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1.ToUpper(), planet2.ToUpper()\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:1], planet2Orbit[:1]\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit[1:], planet2Orbit[1:]\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit[0], planet2Orbit[0]\n    planet1Orbit, planet2Orbit = planet1Orbit[1:],\
    \ planet2Orbit[1:]\n    planet1Orbit, planet2Orbit = planet1Orbit[0], planet2Orbit[0]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[1:], planet2Orbit[1:]\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit[0], planet2Orbit[0]\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit[1:], planet2Orbit[1:]\n    planet1Orbit, planet2Orbit = planet1Orbit[0],\
    \ planet2Orbit[0]\n    planet1Orbit, planet2Orbit = planet1Orbit[1:], planet2Orbit[1:]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[0], planet2Orbit[0]\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit[1:], planet2Orbit[1:]\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit[0], planet2Orbit[0]\n    planet1Orbit, planet2Orbit = planet1Orbit[1:],\
    \ planet2Orbit[1:]\n    planet1Orbit, planet2Orbit = planet1Orbit[0], planet2Orbit[0]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[1:], planet2Orbit[1:]\n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit[0], planet2Orbit[0]\n    planet1Orbit, planet2Orbit\
    \ = plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmposk_hmss_test.go:45:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance, err := getDistance(planet1Sun, planet1Orbit)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2SunDistance,\
    \ err := getDistance(planet2Sun, planet2Orbit)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1OrbitDistance, err := getDistance(planet1Orbit, planet1Sun)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitDistance,\
    \ err := getDistance(planet2Orbit, planet2Sun)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance\
    \ += planet2SunDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance\
    \ /= 2\n    \n    planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplsxdvru4_test.go:89:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    \n    var planets []interface{}\n\
    \    \n    planets = append(planets, planet1)\n    planets = append(planets, planet2)\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8pac71c5_test.go:253:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n      \
    \  return []interface{}{}\n    }\n    planet2Orbit, err := getOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n        return []interface{}{}\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \        return []interface{}{}\n    }\n    planet2Sun, err := getSun()\n    if\
    \ err != nil {\n        fmt.Println(err)\n        return []interface{}{}\n   \
    \ }\n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    if planet1SunDistance < planet2SunDistance\
    \ {\n        planet1Orbit.Next(planet1Sun)\n        planet2Orbit.Next(planet2Sun)\n\
    \    }\n    planet1Orbit.Next(planet1Sun)\n    planet2Orbit.Next(planet2Sun)\n\
    \    planet1Orbit.Next(planet1Sun)\n    planet2Orbit.Next(planet2Sun)\n    planet1Orbit.Next(planet1Sun)\n\
    \    planet2Orbit.Next(planet2Sun)\n    planet1Orbit.Next(planet1Sun)\n    planet2Orbit.Next(planet2Sun)\n\
    \    planet1Orbit.Next(planet1Sun)\n    planet2Orbit.Next(planet2Sun)\n    planet1Orbit.Next(planet1Sun)\n\
    \    planet2Orbit.Next(planet2Sun)\n    planet1Orbit.Next(planet1Sun)\n    planet2Orbit.Next(planet2Sun)\n\
    \    planet1Orbit.Next(planet1Sun)\n    planet2Orbit.Next(planet2Sun)\n    planet1Orbit.Next(planet1Sun)\n\
    \    planet2Orbit.Next(planet2Sun)\n    planet1Orbit.Next(planet1Sun)\n    planet2Orbit.Next(planet2Sun)\n\
    \    planet1Orbit.Next(planet1Sun)\n    plan\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpir90_0m4_test.go:73:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = plan\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphaa79s4h_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2,\
    \ planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit = getOrbits(planet1,\
    \ planet2)\n    planet1Orbit, planet2Orbit = getOrbits(planet2, planet1)\n   \
    \ planet1Orbit, planet2Orbit = getOrbits(planet1, planet2)\n    planet1Orbit,\
    \ planet2Orbit = getOrbits(planet2, planet1)\n    planet1Orbit, planet2Orbit =\
    \ getOrbits(planet1, planet2)\n    planet1Or\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_ukbaq9n_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1 := strings.ToLower(planet1)\n    planet2 :=\
    \ strings.ToLower(planet2)\n    planet1 := strings.TrimSpace(planet1)\n    planet2\
    \ := strings.TrimSpace(planet2)\n    planet1 := strings.ToUpper(planet1)\n   \
    \ planet2 := strings.ToUpper(planet2)\n    planet1 := strings.Replace(planet1,\
    \ \" \", \"\", -1)\n    planet2 := strings.Replace(planet2, \" \", \"\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"-\", \"\", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"-\", \"\", -1)\n    planet1 := strings.Replace(planet1, \"_\", \"\", -1)\n\
    \    planet2 := strings.Replace(planet2, \"_\", \"\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"/\", \"\", -1)\n    planet2 := strings.Replace(planet2, \"/\", \"\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"\\\\\", \"\", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"\\\\\", \"\", -1)\n    planet1 := strings.Replace(planet1, \"+\", \"\", -1)\n\
    \    planet2 := strings.Replace(planet2, \"+\", \"\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"*\", \"\", -1)\n    planet2 := strings.Replace(planet2, \"*\", \"\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"?\", \"\", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"?\", \"\", -1)\n    planet1 := strings.Replace(planet1, \"!\", \"\", -1)\n\
    \    planet2 := strings.Replace(planet2, \"!\", \"\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"-\", \"\", -1)\n    planet2 := strings.Replace(planet2, \"-\", \"\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"=\", \"\", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"=\", \"\", -1)\n    planet1 := strings.Replace(planet1, \"<\", \"\", -1)\n\
    \    planet2 := strings.Replace(planet2, \"<\", \"\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \">\", \"\", -1)\n    planet2 := strings.Replace(planet2, \">\", \"\", -1)\n\
    \    plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6vd8o_28_test.go:59:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := strings.ToLower(planet1)\n    planet2\
    \ := strings.ToLower(planet2)\n    planet1 := strings.Trim(planet1, \" \")\n \
    \   planet2 := strings.Trim(planet2, \" \")\n    planet1 := strings.ToUpper(planet1)\n\
    \    planet2 := strings.ToUpper(planet2)\n    planet1 := strings.Replace(planet1,\
    \ \" \", \"_\", -1)\n    planet2 := strings.Replace(planet2, \" \", \"_\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"_\", \" \", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"_\", \" \", -1)\n    planet1 := strings.Replace(planet1, \" \", \"_\", -1)\n\
    \    planet2 := strings.Replace(planet2, \" \", \"_\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"_\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"_\", \" \", -1)\n\
    \    planet1 := strings.Replace(planet1, \" \", \"_\", -1)\n    planet2 := strings.Replace(planet2,\
    \ \" \", \"_\", -1)\n    planet1 := strings.Replace(planet1, \"_\", \" \", -1)\n\
    \    planet2 := strings.Replace(planet2, \"_\", \" \", -1)\n    planet1 := strings.Replace(planet1,\
    \ \" \", \"_\", -1)\n    planet2 := strings.Replace(planet2, \" \", \"_\", -1)\n\
    \    planet1 := strings.Replace(planet1, \"_\", \" \", -1)\n    planet2 := strings.Replace(planet2,\
    \ \"_\", \" \", -1)\n    planet1 := strings.Replace(planet1, \" \", \"_\", -1)\n\
    \    planet2 := strings.Replace(planet2, \" \", \"_\", -1)\n    planet1 := strings.Replace(planet1,\
    \ \"_\", \" \", -1)\n    planet2 := strings.Replace(planet2, \"_\", \" \", -1)\n\
    \    planet1 := strings.Replace(planet1, \" \", \"_\", -1)\n    planet2 := strings.Replace(planet2,\
    \ \" \", \"_\", -1)\n    planet1 := strings.Replace(planet1, \"_\", \" \", -1)\n\
    \    planet2 := strings.Replace(planet2, \"_\", \" \", -1)\n    planet1 := strings.Replace(\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyen4lwbl_test.go:58:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Sun, planet2Sun := getSun(planet1,\
    \ planet2)\n    planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n\
    \    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n    planet1SunDistance\
    \ += planet1SunDistance\n    planet2SunDistance += planet2SunDistance\n    planet1OrbitDistance\
    \ := getDistance(planet1Orbit, planet1Orbit)\n    planet2OrbitDistance := getDistance(planet2Orbit,\
    \ planet2Orbit)\n    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance\
    \ += planet2OrbitDistance\n    planet1OrbitDistance += planet1OrbitDistance\n\
    \    planet2OrbitDistance += planet2OrbitDistance\n    planet1OrbitDistance +=\
    \ planet1OrbitDistance\n    planet2OrbitDistance += planet2OrbitDistance\n   \
    \ planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance += planet2OrbitDistance\n\
    \    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance +=\
    \ planet2OrbitDistance\n    planet1OrbitDistance += planet1OrbitDistance\n   \
    \ planet2OrbitDistance += planet2OrbitDistance\n    planet1OrbitDistance += planet1OrbitDistance\n\
    \    planet2OrbitDistance += planet2OrbitDistance\n    planet1OrbitDistance +=\
    \ planet1OrbitDistance\n    planet2OrbitDistance += planet2OrbitDistance\n   \
    \ planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance += planet2OrbitDistance\n\
    \    planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance +=\
    \ planet2OrbitDistance\n    planet1OrbitDistance += planet1OrbitDistance\n   \
    \ planet2OrbitDistance += planet2OrbitDistance\n    planet1OrbitDistance += planet1OrbitDistance\n\
    \    planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmeyvnv3k_test.go:57:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := planet1Orbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ planet2Orbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    \n    planet1OrbitList := []interface{}{planet1Orbit}\n    planet2OrbitList\
    \ := []interface{}{planet2Orbit}\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet2OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    planet1OrbitList = append(planet1OrbitList,\
    \ planet1OrbitList...)\n    \n    plan\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplerbgu0y_test.go:73:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\"\
    )\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance\
    \ := getDistance(planet1Orbit, planet1Sun)\n    planet2SunDistance := getDistance(planet2Orbit,\
    \ planet2Sun)\n    \n    planet1OrbitDistance := getDistance(planet1Orbit, planet1Orbit)\n\
    \    planet2OrbitDistance := getDistance(planet2Orbit, planet2Orbit)\n    \n \
    \   planet1OrbitDistance += planet1SunDistance\n    planet2OrbitDistance += planet2SunDistance\n\
    \    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance /= 2\n    \n  \
    \  planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance += planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance /= 2\n    \n  \
    \  planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance += planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance /= 2\n    \n  \
    \  planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance += planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance /= 2\n    \n  \
    \  planet1OrbitDistance += planet1OrbitDistance\n    planet2OrbitDistance += planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= 2\n    planet2OrbitDistance /= 2\n    \n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp32uusgnw_test.go:83:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := planetOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n   \
    \     return []interface{}{}\n    }\n    planet2Orbit, err := planetOrbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n        return []interface{}{}\n\
    \    }\n    planet1Sun, err := sunOrbit()\n    if err != nil {\n        fmt.Println(err)\n\
    \        return []interface{}{}\n    }\n    planet2Sun, err := sunOrbit()\n  \
    \  if err != nil {\n        fmt.Println(err)\n        return []interface{}{}\n\
    \    }\n    planet1Sun.Sub(planet1Orbit)\n    planet2Sun.Sub(planet2Orbit)\n \
    \   planet1Sun.Sub(planet1Orbit)\n    planet2Sun.Sub(planet2Orbit)\n    planet1Sun.Sub(planet1Orbit)\n\
    \    planet2Sun.Sub(planet2Orbit)\n    planet1Sun.Sub(planet1Orbit)\n    planet2Sun.Sub(planet2Orbit)\n\
    \    planet1Sun.Sub(planet1Orbit)\n    planet2Sun.Sub(planet2Orbit)\n    planet1Sun.Sub(planet1Orbit)\n\
    \    planet2Sun.Sub(planet2Orbit)\n    planet1Sun.Sub(planet1Orbit)\n    planet2Sun.Sub(planet2Orbit)\n\
    \    planet1Sun.Sub(planet1Orbit)\n    planet2Sun.Sub(planet2Orbit)\n    planet1Sun.Sub(planet1Orbit)\n\
    \    planet2Sun.Sub(planet2Orbit)\n    planet1Sun.Sub(planet1Orbit)\n    planet2Sun.Sub(planet2Orbit)\n\
    \    planet1Sun.Sub(planet1Orbit)\n    planet2Sun.Sub(planet2Orbit)\n    planet1Sun.Sub(planet1Orbit)\n\
    \    planet2Sun.Sub(planet2Orbit)\n    planet1Sun.Sub(planet1Orbit)\n    planet\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmsyia9fx_test.go:71:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    planet1orbit := planet1\n    planet2orbit\
    \ := planet2\n    planet1orbit := planet1orbit[:len(planet1orbit)-3]\n    planet2orbit\
    \ := planet2orbit[:len(planet2orbit)-3]\n    planet1orbit := planet1orbit[:len(planet1orbit)-3]\n\
    \    planet2orbit := planet2orbit[:len(planet2orbit)-3]\n    planet1orbit := planet1orbit[:len(planet1orbit)-3]\n\
    \    planet2orbit := planet2orbit[:len(planet2orbit)-3]\n    planet1orbit := planet1orbit[:len(planet1orbit)-3]\n\
    \    planet2orbit := planet2orbit[:len(planet2orbit)-3]\n    planet1orbit := planet1orbit[:len(planet1orbit)-3]\n\
    \    planet2orbit := planet2orbit[:len(planet2orbit)-3]\n    planet1orbit := planet1orbit[:len(planet1orbit)-3]\n\
    \    planet2orbit := planet2orbit[:len(planet2orbit)-3]\n    planet1orbit := planet1orbit[:len(planet1orbit)-3]\n\
    \    planet2orbit := planet2orbit[:len(planet2orbit)-3]\n    planet1orbit := planet1orbit[:len(planet1orbit)-3]\n\
    \    planet2orbit := planet2orbit[:len(planet2orbit)-3]\n    planet1orbit := planet1orbit[:len(planet1orbit)-3]\n\
    \    planet2orbit := planet2orbit[:len(planet2orbit)-3]\n    planet1orbit := planet1orbit[:len(planet1orbit)-3]\n\
    \    planet2orbit := planet2orbit[:len(planet2orbit)-3]\n    planet1orbit := planet1orbit[:len(planet1orbit)-3]\n\
    \    planet2orbit := planet2orbit[:len(planet2orbit)-3]\n    plan\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpho6w9n5w_test.go:52:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Orbit)\n    planet2SunDistance += planet2Orbit.Distance(planet2Orbit)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet2Orbit)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet1Orbit)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet2Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet1Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n\
    \    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n    \n    planet1SunDistance\
    \ += planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance += planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1SunDistance += planet1Orbit.Distance(planet1Sun)\n    \nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6os6iybq_test.go:72:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwz4ca_pt_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n\
    \    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n    \n    planet1SunDistance\
    \ += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    \n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    \n   \
    \ planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    \n    planet1SunDistance +=\
    \ getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit)\n    \n    planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n\
    \    planet2SunDistance += getDistance(planet2Orbit, planet1Orbit)\n    \n   \
    \ planet1SunDistance += getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance\
    \ += getDistance(planet2Orbit, planet1Orbit)\n    \n    planet1SunDistance +=\
    \ getDistance(planet1Orbit, planet2Orbit)\n    planet2SunDistance += getDistance(planet2Orbit,\
    \ planet1Orbit\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzgr_60_n_test.go:68:65: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet := range planet1Orbit\
    \ {\n        if planet == planet2 {\n            result = append(result, planet)\n\
    \        }\n    }\n    \n    for _, planet := range planet2Orbit {\n        if\
    \ planet == planet1 {\n            result = append(result, planet)\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9g3wjzr0_test.go:25:13: no new variables on left side of :=

    /tmp/tmp9g3wjzr0_test.go:25:16: undefined: strings

    /tmp/tmp9g3wjzr0_test.go:26:13: no new variables on left side of :=

    /tmp/tmp9g3wjzr0_test.go:26:16: undefined: strings

    /tmp/tmp9g3wjzr0_test.go:28:35: undefined: getOrbits

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    planet1Sun := sun(planet1)\n    planet2Sun\
    \ := sun(planet2)\n    planet1OrbitSun := orbit(planet1, planet1Sun)\n    planet2OrbitSun\
    \ := orbit(planet2, planet2Sun)\n    planet1OrbitSunOrbit := orbit(planet1, planet1Sun,\
    \ planet2Sun)\n    planet2OrbitSunOrbit := orbit(planet2, planet2Sun, planet1Sun)\n\
    \    planet1OrbitSunOrbitSun := orbit(planet1, planet1Sun, planet2Sun, planet1OrbitSun)\n\
    \    planet2OrbitSunOrbitSun := orbit(planet2, planet2Sun, planet1Sun, planet2OrbitSun)\n\
    \    planet1OrbitSunOrbitSunOrbit := orbit(planet1, planet1Sun, planet2Sun, planet1OrbitSun,\
    \ planet2OrbitSun)\n    planet2OrbitSunOrbitSunOrbit := orbit(planet2, planet2Sun,\
    \ planet1Sun, planet2OrbitSun, planet1OrbitSun)\n    planet1OrbitSunOrbitSunOrbitSun\
    \ := orbit(planet1, planet1Sun, planet2Sun, planet1OrbitSun, planet2OrbitSun,\
    \ planet1OrbitSun)\n    planet2OrbitSunOrbitSunOrbitSun := orbit(planet2, planet2Sun,\
    \ planet1Sun, planet2OrbitSun, planet1OrbitSun, planet2OrbitSun)\n    planet1OrbitSunOrbitSunOrbitSunOrbit\
    \ := orbit(planet1, planet1Sun, planet2Sun, planet1OrbitSun, planet2OrbitSun,\
    \ planet1OrbitSun, planet2OrbitSun)\n    planet2OrbitSunOrbitSunOrbitSunOrbitSun\
    \ := orbit(planet2, planet2Sun, planet1Sun, planet2OrbitSun, planet1OrbitSun,\
    \ plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8hfq114z_test.go:40:125: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1Planet2, err := planet2Planet(planet1, planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n        return []interface{}{}\n\
    \    }\n    planet1Planet1, err := planet1Planet(planet1, planet2)\n    if err\
    \ != nil {\n        fmt.Println(err)\n        return []interface{}{}\n    }\n\
    \    planet1Planet1Planet2, err := planet1Planet2Planet(planet1, planet2, planet1Planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n        return []interface{}{}\n\
    \    }\n    planet1Planet1Planet1Planet2, err := planet1Planet1Planet2Planet(planet1,\
    \ planet2, planet1Planet2, planet1Planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \        return []interface{}{}\n    }\n    planet1Planet1Planet1Planet1Planet2,\
    \ err := planet1Planet1Planet2Planet1Planet2Planet(planet1, planet2, planet1Planet2,\
    \ planet1Planet1, planet1Planet1Planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \        return []interface{}{}\n    }\n    planet1Planet1Planet1Planet1Planet1Planet2,\
    \ err := planet1Planet1Planet2Planet1Planet1Planet2Planet(planet1, planet2, planet1Planet2,\
    \ planet1Planet1, planet1Planet1Planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \        return []interface{}{}\n    }\n    planet1Planet1Planet1Planet1Planet1Planet1Planet2,\
    \ err := planet1Planet1Planet2Planet1Planet1Planet2Planet1Planet(planet1, planet2,\
    \ planet1Planet2, planet1Planet1, planet1Planet1Planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n        return []interface{}{}\n    }\n    planet1Planet1Planet1Planet1Planet1Planet1Planet1Planet2,\
    \ err := planet1Planet1Planet2Planet\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9n2g7h6w_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := getOrbit(planet1)\n\
    \    planet2Orbit := getOrbit(planet2)\n    \n    planet1Sun := getSun(planet1)\n\
    \    planet2Sun := getSun(planet2)\n    \n    planet1SunDistance := getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2SunDistance := getDistance(planet2Sun, planet2Orbit)\n\
    \    \n    planet1OrbitDistance := getDistance(planet1Orbit, planet1Orbit)\n \
    \   planet2OrbitDistance := getDistance(planet2Orbit, planet2Orbit)\n    \n  \
    \  planet1OrbitDistance /= getDistance(planet1Sun, planet1Orbit)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Sun, planet2Orbit)\n    \n    planet1OrbitDistance /=\
    \ getDistance(planet1Sun, planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun,\
    \ planet2Orbit)\n    \n    planet1OrbitDistance /= getDistance(planet1Sun, planet1Orbit)\n\
    \    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n    \n   \
    \ planet1OrbitDistance /= getDistance(planet1Sun, planet1Orbit)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Sun, planet2Orbit)\n    \n    planet1OrbitDistance /=\
    \ getDistance(planet1Sun, planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun,\
    \ planet2Orbit)\n    \n    planet1OrbitDistance /= getDistance(planet1Sun, planet1Orbit)\n\
    \    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n    \n   \
    \ planet1OrbitDistance /= getDistance(planet1Sun, planet1Orbit)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Sun, planet2Orbit)\n    \n    planet1OrbitDistance /=\
    \ getDistance(planet1Sun, planet\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx27gzv_z_test.go:58:59: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    \n    planet1Orbit := getOrbit(planet1)\n    planet2Orbit := getOrbit(planet2)\n\
    \    \n    planet1Sun := getSun()\n    planet2Sun := getSun()\n    \n    planet1Distance\
    \ := getDistance(planet1Orbit, planet1Sun)\n    planet2Distance := getDistance(planet2Orbit,\
    \ planet2Sun)\n    \n    planet1OrbitList := []interface{}{}\n    planet2OrbitList\
    \ := []interface{}{}\n    \n    if planet1Distance < planet2Distance {\n     \
    \   planet1OrbitList = append(planet1OrbitList, planet1)\n        planet2OrbitList\
    \ = append(planet2OrbitList, planet2)\n    } else {\n        planet1OrbitList\
    \ = append(planet1OrbitList, planet2)\n        planet2OrbitList = append(planet2OrbitList,\
    \ planet1)\n    }\n    \n    planet1OrbitList = append(planet1OrbitList, planet1Orbit...)\n\
    \    planet2OrbitList = append(planet2OrbitList, planet2Orbit...)\n    \n    sort.Sort(sort.Reverse(sort.StringSlice(planet1OrbitList)))\n\
    \    sort.Sort(sort.Reverse(sort.StringSlice(planet2OrbitList)))\n    \n    return\
    \ planet1OrbitList\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_u4318ps_test.go:27:21: undefined: getOrbit

    /tmp/tmp_u4318ps_test.go:28:21: undefined: getOrbit

    /tmp/tmp_u4318ps_test.go:30:19: undefined: getSun

    /tmp/tmp_u4318ps_test.go:31:19: undefined: getSun

    /tmp/tmp_u4318ps_test.go:33:24: undefined: getDistance

    /tmp/tmp_u4318ps_test.go:34:24: undefined: getDistance

    /tmp/tmp_u4318ps_test.go:50:5: undefined: sort

    /tmp/tmp_u4318ps_test.go:51:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1\
    \ := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2 := planet2\n\
    \    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n    planet2\
    \ := planet2\n    planet1 := planet1\n    planet2 := planet2\n    planet1 := planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwz4ca_pt_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1\n   \
    \ planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n   \
    \ \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9gzh7ch8_test.go:53:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    planet1Orbit := planet1Orbit(planet1)\n\
    \    planet2Orbit := planet2Orbit(planet2)\n    \n    planet1Orbit.sort()\n  \
    \  planet2Orbit.sort()\n    \n    planet1Orbit.intersect(planet2Orbit)\n    \n\
    \    return planet1Orbit.list\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprhc403y0_test.go:25:13: no new variables on left side of :=

    /tmp/tmprhc403y0_test.go:25:16: undefined: strings

    /tmp/tmprhc403y0_test.go:26:13: no new variables on left side of :=

    /tmp/tmprhc403y0_test.go:26:16: undefined: strings

    /tmp/tmprhc403y0_test.go:28:21: undefined: planet1Orbit

    /tmp/tmprhc403y0_test.go:29:21: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = strings.ToLower(planet1), strings.ToLower(planet2)\n    planet1Orbit, planet2Orbit\
    \ := planet1Orbit(planet1), planet2Orbit(planet2)\n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit.([]string), planet2Orbit.([]string)\n    \n    planet1Orbit,\
    \ planet2Orbit = append(planet1Orbit, planet2Orbit...), append(planet1Orbit, planet2Orbit...)\n\
    \    \n    planet1Orbit, planet2Orbit = sort.Strings(planet1Orbit), sort.Strings(planet2Orbit)\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet2Orbit...),\
    \ append(planet1Orbit, planet2Orbit...)\n    \n    planet1Orbit, planet2Orbit\
    \ = sort.Strings(planet1Orbit), sort.Strings(planet2Orbit)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet2Orbit...),\
    \ append(planet1Orbit, planet2Orbit...)\n    \n    planet1Orbit, planet2Orbit\
    \ = sort.Strings(planet1Orbit), sort.Strings(planet2Orbit)\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit, planet2Orbit = append(planet1Orbit, planet2Orbit...),\
    \ append(planet1Orbit, planet2Orbit...)\n    \n    planet1Orbit, plan\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzgu7_zqp_test.go:49:5: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1.(string), planet2.(string)\n\
    \    planet1, planet2 = planet1.ToUpper(), planet2.ToUpper()\n    planet1, planet2\
    \ = planet1.ToLower(), planet2.ToLower()\n    planet1, planet2 = planet1.ToTitle(),\
    \ planet2.ToTitle()\n    planet1, planet2 = planet1.ToCamelCase(), planet2.ToCamelCase()\n\
    \    planet1, planet2 = planet1.ToPascalCase(), planet2.ToPascalCase()\n    planet1,\
    \ planet2 = planet1.ToSnakeCase(), planet2.ToSnakeCase()\n    planet1, planet2\
    \ = planet1.ToKebabCase(), planet2.ToKebabCase()\n    planet1, planet2 = planet1.ToHumanized(),\
    \ planet2.ToHumanized()\n    planet1, planet2 = planet1.ToHumanized(), planet2.ToHumanized()\n\
    \    planet1, planet2 = planet1.ToHumanized(), planet2.ToHumanized()\n    planet1,\
    \ planet2 = planet1.ToHumanized(), planet2.ToHumanized()\n    planet1, planet2\
    \ = planet1.ToHumanized(), planet2.ToHumanized()\n    planet1, planet2 = planet1.ToHumanized(),\
    \ planet2.ToHumanized()\n    planet1, planet2 = planet1.ToHumanized(), planet2.ToHumanized()\n\
    \    planet1, planet2 = planet1.ToHumanized(), planet2.ToHumanized()\n    planet1,\
    \ planet2 = planet1.ToHumanized(), planet2.ToHumanized()\n    planet1, planet2\
    \ = planet1.ToHumanized(), planet2.ToHumanized()\n    planet1, planet2 = planet1.ToHumanized(),\
    \ planet2.ToHumanized()\n    planet1, planet2 = planet1.ToHumanized(), planet2.ToHumanized()\n\
    \    planet1, planet2 = planet1.ToHumanized(), planet2.ToHumanized()\n    planet1,\
    \ planet2 = planet1.\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpot8lezr3_test.go:48:1: expected selector or type assertion, found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, err := planet1Orbit(planet1)\n    if\
    \ err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err := planet2Orbit(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSun, err\
    \ := planet1OrbitSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSun, err := planet2OrbitSun(planet2)\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    planet1OrbitSun, err = planet1OrbitSun(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSun, err\
    \ = planet2OrbitSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1OrbitSun, err = planet1OrbitSun(planet1)\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    planet2OrbitSun, err = planet2OrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSun, err\
    \ = planet1OrbitSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2OrbitSun, err = planet2OrbitSun(planet2)\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    planet1OrbitSun, err = planet1OrbitSun(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2OrbitSun, err\
    \ = planet2OrbitSun(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1OrbitSun, err = planet1OrbitSun(planet1)\n    if err != nil\
    \ {\n        fmt.Println(err)\n    }\n    planet2OrbitSun, err = planet2OrbitSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet1OrbitSun, err\
    \ = planet1OrbitSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp76iv5vj8_test.go:87:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1.ToLower(), planet2.ToLower()\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1],\
    \ planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2\
    \ = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1[:1], planet2[:1]\n\
    \    planet1, planet2 = planet1[:1], planet2[:1]\n    planet1, planet2 = planet1\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp63k426ai_test.go:54:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit, planet2Orbit := planet1, planet2\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1], planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgkqq530y_test.go:40:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1\n\
    \    planet2Orbit := planet2\n    \n    planet1Orbit, planet2Orbit = planet2Orbit,\
    \ planet1Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit,\
    \ planet2Orbit\n    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n\
    \    \n    planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n   \
    \ planet1Orbit, planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit,\
    \ planet2Orbit = planet1Orbit, planet2Orbit\n    \n    planet1Orbit, planet2Orbit\
    \ = planet1Orbit, planet2Orbit\n    \n    plan\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp11ou7b9h_test.go:65:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\n    planet2\
    \ := planet2[:len(planet2)-1]\n    planet1 := planet1[:len(planet1)-1]\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmhdx7dfd_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1, planet2\
    \ = strings.ToLower(planet1), strings.ToLower(planet2)\n    planet1, planet2 =\
    \ planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n    planet1, planet2 = planet1, planet2\n    planet1, planet2\
    \ = planet1, planet2\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphxsm9qfl_test.go:62:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet2 := planet2\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1 := planet1\n    planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq3fklk_1_test.go:102:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := getOrbit(planet1)\n\
    \    planet2Orbit := getOrbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit.list\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7f3wbt5i_test.go:25:21: undefined: getOrbit

    /tmp/tmp7f3wbt5i_test.go:26:21: undefined: getOrbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, err\
    \ := getOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n    }\n\
    \    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet1SunDistance := planet1Orbit.Distance(planet1Sun)\n    planet2SunDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    if planet1SunDistance < planet2SunDistance\
    \ {\n        planet1Orbit.Next(planet1Sun)\n    }\n    if planet2SunDistance <\
    \ planet1SunDistance {\n        planet2Orbit.Next(planet2Sun)\n    }\n    planet1Orbit.Next(planet1Sun)\n\
    \    planet2Orbit.Next(planet2Sun)\n    planet1Orbit.Next(planet1Sun)\n    planet2Orbit.Next(planet2Sun)\n\
    \    planet1Orbit.Next(planet1Sun)\n    planet2Orbit.Next(planet2Sun)\n    planet1Orbit.Next(planet1Sun)\n\
    \    planet2Orbit.Next(planet2Sun)\n    planet1Orbit.Next(planet1Sun)\n    planet2Orbit.Next(planet2Sun)\n\
    \    planet1Orbit.Next(planet1Sun)\n    planet2Orbit.Next(planet2Sun)\n    planet1Orbit.Next(planet1Sun)\n\
    \    planet2Orbit.Next(planet2Sun)\n    planet1Orbit.Next(planet1Sun)\n    planet2Orbit.Next(planet2Sun)\n\
    \    planet1Orbit.Next(planet1Sun)\n    planet2Orbit.Next(planet2Sun)\n    planet1Orbit.Next(planet1Sun)\n\
    \    planet2Orbit.Next(planet2Sun)\n    planet1Orbit.Next(planet1Sun)\n    planet2Orbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy56vd423_test.go:71:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n\
    \    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit\
    \ = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit = planet2Orbit[:len(planet2Orbit)-1]\n\
    \    \n    planet1Orbit = planet1Orbit[:len(planet1Orbit)-1]\n    planet2Orbit\
    \ = planet2Orbit[:len(planet2Orbit)-1]\n    \n    planet1Orbit = planet\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp09nombwe_test.go:61:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074380
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    \n    planet1 := planet1\n    planet2 := planet2\n    \n    planet1Orbit,\
    \ err := getPlanetOrbit(planet1)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Orbit, err := getPlanetOrbit(planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    \n    planet1Sun, err := getPlanetOrbit(\"\
    Sun\")\n    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Sun,\
    \ err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunProximity := getPlanetProximity(planet1Orbit, planet1Sun)\n\
    \    planet2SunProximity := getPlanetProximity(planet2Orbit, planet2Sun)\n   \
    \ \n    planet1Proximity := getPlanetProximity(planet1Orbit, planet1Orbit)\n \
    \   planet2Proximity := getPlanetProximity(planet2Orbit, planet2Orbit)\n    \n\
    \    planet1ProximitySorted := getPlanetProximitySorted(planet1Proximity)\n  \
    \  planet2ProximitySorted := getPlanetProximitySorted(planet2Proximity)\n    \n\
    \    planet1ProximitySortedSorted := getPlanetProximitySortedSorted(planet1ProximitySorted)\n\
    \    planet2ProximitySortedSorted := getPlanetProximitySortedSorted(planet2ProximitySorted)\n\
    \    \n    planet1ProximitySortedSortedSorted := getPlanetProximitySortedSortedSorted(planet1ProximitySortedSorted)\n\
    \    planet2ProximitySortedSortedSorted := getPlanetProximitySortedSortedSorted(planet2ProximitySortedSorted)\n\
    \    \n    planet1ProximitySortedSortedSortedSorted := getPlanetProximitySortedSortedSortedSorted(planet1ProximitySortedSortedSorted)\n\
    \    planet2ProximitySortedSortedSortedSorted := getPlanetProximitySortedSortedSortedSorted(planet\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyrz49u9i_test.go:64:98: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\"\
    )\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunDistance\
    \ := planet1Sun.Distance(planet1Orbit)\n    planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n\
    \    \n    planet1OrbitDistance := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance\
    \ := planet2Orbit.Distance(planet2Sun)\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1SunDistance\n    planet2OrbitDistance *= planet2SunDistance\n    \n\
    \    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance /=\
    \ planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance\
    \ *= planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2Or\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5768pnvo_test.go:78:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1Orbit(planet1)\n\
    \    planet2Orbit := planet2Orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    result := []interface{}{}\n    for _, planet1 := range planet1Orbit {\n \
    \       for _, planet2 := range planet2Orbit {\n            if planet1 == planet2\
    \ {\n                continue\n            }\n            if planet1.distanceTo(planet2)\
    \ < planet1.distanceTo(sun) {\n                planet1Orbit.remove(planet1)\n\
    \                planet2Orbit.remove(planet2)\n                planet1Orbit.sort()\n\
    \                planet2Orbit.sort()\n                planet1Orbit = append(planet1Orbit,\
    \ planet1)\n                planet2Orbit = append(planet2Orbit, planet2)\n   \
    \             planet1Orbit.sort()\n                planet2Orbit.sort()\n     \
    \           planet1Orbit = append(planet1Orbit, planet1)\n                planet2Orbit\
    \ = append(planet2Orbit, planet2)\n                planet1Orbit.sort()\n     \
    \           planet2Orbit.sort()\n                planet1Orbit = append(planet1Orbit,\
    \ planet1)\n                planet2Orbit = append(planet2Orbit, planet2)\n   \
    \             planet1Orbit.sort()\n                planet2Orbit.sort()\n     \
    \           planet1Orbit = append(planet1Orbit, planet1)\n                planet2Orbit\
    \ = append(planet2Orbit, planet2)\n                planet1Orbit.sort()\n     \
    \           planet2Orbit.sort()\n                planet1Orbit = append(planet1Orbit,\
    \ planet1)\n                planet2Orbit = append(planet2Orbit, planet2)\n   \
    \             planet1Orbit.sort()\n                planet2Orbit.sort()\n     \
    \           planet1Orbit = append(planet1Orbit, planet1)\n                planet2Orbit\
    \ = append(planet2Orbit, planet2)\n                planet1Orbit.sort()\n     \
    \           planet2Orbit.sort()\n                planet1Orbit = append(planet1Orbit,\
    \ planet1)\n                planet2Orbit = append(planet2Or\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeshnv8y6_test.go:65:48: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := strings.ToLower(planet1)\n\
    \    planet2 := strings.ToLower(planet2)\n    \n    planet1Orbit, err := getOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n        return []interface{}{}\n\
    \    }\n    \n    planet2Orbit, err := getOrbit(planet2)\n    if err != nil {\n\
    \        fmt.Println(err)\n        return []interface{}{}\n    }\n    \n    planet1Sun,\
    \ err := getSun(planet1)\n    if err != nil {\n        fmt.Println(err)\n    \
    \    return []interface{}{}\n    }\n    \n    planet2Sun, err := getSun(planet2)\n\
    \    if err != nil {\n        fmt.Println(err)\n        return []interface{}{}\n\
    \    }\n    \n    planet1SunDistance := getDistance(planet1Orbit, planet1Sun)\n\
    \    planet2SunDistance := getDistance(planet2Orbit, planet2Sun)\n    \n    if\
    \ planet1SunDistance < planet2SunDistance {\n        planet1Orbit, planet2Orbit\
    \ = planet2Orbit, planet1Orbit\n    }\n    \n    planet1Orbit, planet2Orbit =\
    \ planet1Orbit, planet2Orbit\n    \n    planet1OrbitList := []interface{}{}\n\
    \    planet2OrbitList := []interface{}{}\n    \n    for planet := range planet1Orbit\
    \ {\n        planet1OrbitList = append(planet1OrbitList, planet)\n    }\n    \n\
    \    for planet := range planet2Orbit {\n        planet2OrbitList = append(planet2OrbitList,\
    \ planet)\n    }\n    \n    planet1OrbitList = append(planet1OrbitList, planet1)\n\
    \    planet2OrbitList = append(planet2OrbitList, planet2)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, planet2)\n    planet2OrbitList = append(planet2OrbitList,\
    \ planet1)\n    \n    planet1OrbitList = append(planet1OrbitList, planet1)\n \
    \   planet2OrbitList = append(planet2OrbitList, planet2)\n    \n    planet1OrbitList\
    \ = append(planet1OrbitList, \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsl1a012v_test.go:82:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit := planet1\n    planet2Orbit := planet2\n\
    \    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n    planet1OrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpir1d3h38_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Sun := sun(planet1)\n  \
    \  planet2Sun := sun(planet2)\n    \n    planet1SunDistance := distance(planet1Sun,\
    \ planet1Orbit)\n    planet2SunDistance := distance(planet2Sun, planet2Orbit)\n\
    \    \n    planet1OrbitDistance := distance(planet1Orbit, planet1Orbit)\n    planet2OrbitDistance\
    \ := distance(planet2Orbit, planet2Orbit)\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1SunDistance\n    planet2OrbitDistance\
    \ /= planet2SunDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance\
    \ *= planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1OrbitDistance\n\
    \    planet2OrbitDistance /= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1OrbitDistance\n    planet2OrbitDistance /= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance *= planet1OrbitDistance\n    planet\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp49bw_jbl_test.go:72:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1 := strings.ToLower(planet1)\n    planet2\
    \ := strings.ToLower(planet2)\n    planet1 := strings.Trim(planet1, \" \")\n \
    \   planet2 := strings.Trim(planet2, \" \")\n    planet1 := strings.Trim(planet1,\
    \ \",\")\n    planet2 := strings.Trim(planet2, \",\")\n    planet1 := strings.Trim(planet1,\
    \ \".\")\n    planet2 := strings.Trim(planet2, \".\")\n    planet1 := strings.Trim(planet1,\
    \ \"/\")\n    planet2 := strings.Trim(planet2, \"/\")\n    planet1 := strings.Trim(planet1,\
    \ \"\\\\\")\n    planet2 := strings.Trim(planet2, \"\\\\\")\n    planet1 := strings.Trim(planet1,\
    \ \"-\")\n    planet2 := strings.Trim(planet2, \"-\")\n    planet1 := strings.Trim(planet1,\
    \ \"_\")\n    planet2 := strings.Trim(planet2, \"_\")\n    planet1 := strings.Trim(planet1,\
    \ \"$\")\n    planet2 := strings.Trim(planet2, \"$\")\n    planet1 := strings.Trim(planet1,\
    \ \"&\")\n    planet2 := strings.Trim(planet2, \"&\")\n    planet1 := strings.Trim(planet1,\
    \ \"!\")\n    planet2 := strings.Trim(planet2, \"!\")\n    planet1 := strings.Trim(planet1,\
    \ \"@\")\n    planet2 := strings.Trim(planet2, \"@\")\n    planet1 := strings.Trim(planet1,\
    \ \"$\")\n    planet2 := strings.Trim(planet2, \"$\")\n    planet1 := strings.Trim(planet1,\
    \ \"%\")\n    planet2 := strings.Trim(planet2, \"%\")\n    planet1 := strings.Trim(planet1,\
    \ \"^\")\n    planet2 := strings.Trim(planet2, \"^\")\n    planet1 := strings.Trim(planet1,\
    \ \"&\")\n    planet2 := strings.Trim(planet2, \"&\")\n    planet1 := strings.Trim(planet1,\
    \ \"*\")\n    planet2 := strings.Trim(planet2, \"*\")\n    planet1 := strings.Trim(planet1,\
    \ \"+\")\n    planet2 := strings.Trim(planet2, \"+\")\n    planet1 := strings.Trim(plan\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpypwnoxbu_test.go:63:33: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074381
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := orbit(planet1)\n\
    \    planet2Orbit := orbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    result := []interface{}{}\n    \n    for _, planet := range planet1Orbit\
    \ {\n        if planet == planet2 {\n            result = append(result, planet)\n\
    \        }\n    }\n    \n    for _, planet := range planet2Orbit {\n        if\
    \ planet == planet1 {\n            result = append(result, planet)\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqug1ekt2_test.go:25:21: undefined: orbit

    /tmp/tmpqug1ekt2_test.go:26:21: undefined: orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    planet1Orbit := planet1\n    planet2Orbit := planet2\n    planet1OrbitOrbit\
    \ := planet1Orbit\n    planet2OrbitOrbit := planet2Orbit\n    planet1OrbitOrbitOrbit\
    \ := planet1OrbitOrbit\n    planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1OrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphkdvpiv1_test.go:44:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := planet1, planet2\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:len(planet1Orbit)-1],\
    \ planet2Orbit[:len(planet2Orbit)-1]\n    planet1Orbit, planet2Orbit = planet1Orbit[:\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9bwiz3hm_test.go:38:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := getOrbit(planet1)\n\
    \    planet2Orbit := getOrbit(planet2)\n    \n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    \n    planet1Orbit.intersect(planet2Orbit)\n    \n    return planet1Orbit\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfg3v5cyo_test.go:25:21: undefined: getOrbit

    /tmp/tmpfg3v5cyo_test.go:26:21: undefined: getOrbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    planet1Orbit := planet1\n    planet2Orbit := planet2\n\
    \    planet1OrbitOrbit := planet1\n    planet2OrbitOrbit := planet2\n    planet1OrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit :=\
    \ planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet1\n    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2\n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvv330uvi_test.go:50:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit, planet2Orbit\
    \ := getOrbits(planet1, planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n\
    \    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n\
    \    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun,\
    \ planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n\
    \    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n\
    \    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n    planet1Sun,\
    \ planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun := getSun(planet1)\n\
    \    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun, planet2Sun :=\
    \ getSun(planet1)\n    planet1Sun, planet2Sun := getSun(planet2)\n    planet1Sun,\
    \ planet2Sun := getSun(planet1)\n    planet1Sun, planet2Sun := get\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp73x0fyqh_test.go:52:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := getOrbit(planet1)\n\
    \    planet2Orbit := getOrbit(planet2)\n    planet1Sun := getSun(planet1)\n  \
    \  planet2Sun := getSun(planet2)\n    planet1SunDistance := getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2SunDistance := getDistance(planet2Sun, planet2Orbit)\n\
    \    planet1OrbitDistance := getDistance(planet1Orbit, planet1Sun)\n    planet2OrbitDistance\
    \ := getDistance(planet2Orbit, planet2Sun)\n    planet1OrbitDistance /= getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n\
    \    planet1OrbitDistance /= getDistance(planet1Orbit, planet1Sun)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Orbit, planet2Sun)\n    planet1OrbitDistance /= getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n\
    \    planet1OrbitDistance /= getDistance(planet1Orbit, planet1Sun)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Orbit, planet2Sun)\n    planet1OrbitDistance /= getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n\
    \    planet1OrbitDistance /= getDistance(planet1Orbit, planet1Sun)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Sun, planet2Orbit)\n    planet1OrbitDistance /= getDistance(planet1Sun,\
    \ planet1Orbit)\n    planet2OrbitDistance /= getDistance(planet2Sun, planet2Orbit)\n\
    \    planet1OrbitDistance /= getDistance(planet1Sun, planet1Orbit)\n    planet2OrbitDistance\
    \ /= getDistance(planet2Sun, planet2\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv8iy3qg1_test.go:48:60: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getOrbit(planet1)\n  \
    \  if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n    }\n  \
    \  \n    planet1Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    planet2Sun, err := getSun()\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    \n    planet1SunDistance := planet1Sun.Distance(planet1Orbit)\n  \
    \  planet2SunDistance := planet2Sun.Distance(planet2Orbit)\n    \n    planet1OrbitDistance\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2OrbitDistance := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitDistance /= planet1OrbitDistance\n    planet2OrbitDistance\
    \ /= planet2OrbitDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1SunDistance\n    planet2OrbitDistance /= planet2SunDistance\n    \n\
    \    planet1OrbitDistance *= planet1OrbitDistance\n    planet2OrbitDistance *=\
    \ planet2OrbitDistance\n    \n    planet1OrbitDistance /= planet1SunDistance\n\
    \    planet2OrbitDistance /= planet2SunDistance\n    \n    planet1OrbitDistance\
    \ *= planet1OrbitDistance\n    planet2OrbitDistance *= planet2OrbitDistance\n\
    \    \n    planet1OrbitDistance /= planet1SunDistance\n    planet2OrbitDistance\
    \ /= planet2SunDistance\n    \n    planet1OrbitDistance *= planet1OrbitDistance\n\
    \    planet2OrbitDistance *= planet2OrbitDistance\n    \n    planet1OrbitDistance\
    \ /= planet1SunDistance\n    planet2OrbitDistance /= planet2SunDistance\n    \n\
    \    planet1OrbitDistance *= \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwkvbysyw_test.go:80:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1\n\
    \    planet2Orbit := planet2\n    planet1OrbitOrbit := planet1Orbit\n    planet2OrbitOrbit\
    \ := planet2Orbit\n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n    planet2OrbitOrbitOrbit\
    \ := planet2OrbitOrbit\n    planet1OrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbit\n    planet1OrbitOrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7_kj_p2o_test.go:40:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1Orbit := planet1Orbit(planet1)\n\
    \    planet2Orbit := planet2Orbit(planet2)\n    planet1Orbit.sort()\n    planet2Orbit.sort()\n\
    \    result := []interface{}{}\n    for _, planet := range planet1Orbit {\n  \
    \      if planet == planet2 {\n            result = append(result, planet)\n \
    \       }\n    }\n    for _, planet := range planet2Orbit {\n        if planet\
    \ == planet1 {\n            result = append(result, planet)\n        }\n    }\n\
    \    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_soypasq_test.go:25:21: undefined: planet1Orbit

    /tmp/tmp_soypasq_test.go:26:21: undefined: planet2Orbit

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit, err := getPlanetOrbit(planet1)\n\
    \    if err != nil {\n        fmt.Println(err)\n    }\n    planet2Orbit, err :=\
    \ getPlanetOrbit(planet2)\n    if err != nil {\n        fmt.Println(err)\n   \
    \ }\n    \n    planet1Sun, err := getPlanetOrbit(\"Sun\")\n    if err != nil {\n\
    \        fmt.Println(err)\n    }\n    planet2Sun, err := getPlanetOrbit(\"Sun\"\
    )\n    if err != nil {\n        fmt.Println(err)\n    }\n    \n    planet1SunProximity\
    \ := planet1Orbit.Distance(planet1Sun)\n    planet2SunProximity := planet2Orbit.Distance(planet2Sun)\n\
    \    \n    planet1OrbitProximity := planet1Orbit.Distance(planet1Orbit)\n    planet2OrbitProximity\
    \ := planet2Orbit.Distance(planet2Orbit)\n    \n    planet1OrbitProximityProximity\
    \ := planet1OrbitProximity.Distance(planet1SunProximity)\n    planet2OrbitProximityProximity\
    \ := planet2OrbitProximity.Distance(planet2SunProximity)\n    \n    planet1OrbitProximityProximityProximity\
    \ := planet1OrbitProximityProximity.Distance(planet1OrbitProximityProximity)\n\
    \    planet2OrbitProximityProximityProximity := planet2OrbitProximityProximityProximity.Distance(planet2OrbitProximityProximityProximity)\n\
    \    \n    planet1OrbitProximityProximityProximityProximity := planet1OrbitProximityProximityProximityProximity.Distance(planet1OrbitProximityProximityProximityProximity)\n\
    \    planet2OrbitProximityProximityProximityProximity := planet2OrbitProximityProximityProximityProximity.Distance(planet2OrbitProximityProximity\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkvz437ay_test.go:59:145: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074382
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1 := planet1\n\
    \    planet2 := planet2\n    \n    planet1Orbit := planet1\n    planet2Orbit :=\
    \ planet2\n    \n    planet1OrbitOrbit := planet1Orbit\n    planet2OrbitOrbit\
    \ := planet2Orbit\n    \n    planet1OrbitOrbitOrbit := planet1OrbitOrbit\n   \
    \ planet2OrbitOrbitOrbit := planet2OrbitOrbit\n    \n    planet1OrbitOrbitOrbitOrbit\
    \ := planet1OrbitOrbitOrbit\n    planet2OrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbit\n \
    \   planet2OrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    \n    planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit := planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\n\
    \    planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbit\
    \ := planet2OrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOrbitOr\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqt28jbws_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074382
