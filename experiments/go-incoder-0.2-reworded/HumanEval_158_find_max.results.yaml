language: go_test.go
name: HumanEval_158_find_max
results:
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, c := range word {\n            count += unicode.IsLetter(c)\n        }\n\
    \        if count > max {\n            result = word\n            max = count\n\
    \        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgfvf028w_test.go:24:22: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write code here\n\
    \    \n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpwhcjelcd_test.go:46: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpwhcjelcd_test.go:46: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpwhcjelcd_test.go:46:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpwhcjelcd_test.go:46: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpwhcjelcd_test.go:46: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpwhcjelcd_test.go:46: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpwhcjelcd_test.go:46:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpwhcjelcd_test.go:46: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpwhcjelcd_test.go:46: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpwhcjelcd_test.go:46: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            if c != ' ' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    word = w\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpmqsrgmp9_test.go:58: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        c := len(w)\n        if c >\
    \ max {\n            max = c\n            word = w\n        }\n    }\n    return\
    \ word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp3xtortmz_test.go:53: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            count += letterCount[letter]\n        }\n\
    \        if count > max {\n            max = count\n            word = word\n\
    \        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n \
    \ candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk7wcatru_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   count := 0\n    for _, word := range words {\n        count += len(word)\n\
    \        if count > len(result) {\n            result = word\n        }\n    }\n\
    \    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpf099mvr9_test.go:52: expected 'enam', got 'game'\n    ---\
    \ FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpf099mvr9_test.go:52: expected\
    \ 'aaaaaaa', got 'cc'\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n      \
    \  tmpf099mvr9_test.go:52: expected 'abc', got 'cba'\n    --- FAIL: TestFind_Max/test_num__5\
    \ (0.00s)\n        tmpf099mvr9_test.go:52: expected 'gonna', got 'rock'\n    ---\
    \ FAIL: TestFind_Max/test_num__7 (0.00s)\n        tmpf099mvr9_test.go:52: expected\
    \ 'this', got 'prrk'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max == 0 {\n        return\
    \ \"\"\n    }\n    for word, count := range count {\n        if count == max {\n\
    \            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n1tebbw_test.go:24:5: word declared but not used

    /tmp/tmp8n1tebbw_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        c := len(w)\n        if c >\
    \ max {\n            max = c\n            word = w\n        }\n    }\n    return\
    \ word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp3xtortmz_test.go:53: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            if letter == 'a' || letter == 'e' ||\
    \ letter == 'i' || letter == 'o' || letter == 'u' {\n                count++\n\
    \            }\n        }\n        if count > max {\n            result = word\n\
    \            max = count\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpuldt9xx9_test.go:58: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpuldt9xx9_test.go:58:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmpuldt9xx9_test.go:58: expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpuldt9xx9_test.go:58: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max > 0 {\n        return\
    \ word\n    }\n    for _, word := range words {\n        if count[word] == max\
    \ {\n            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp94xjswm1_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    i :=\
    \ 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    i = word\n        }\n    }\n    return i\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ayti5ca_test.go:30:17: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmp8ayti5ca_test.go:33:12: cannot use i (variable of type int) as type string
    in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := words[0]\n    for _, w := range words {\n        count := strings.Count(w,\
    \ max)\n        if count > 1 {\n            return w\n        }\n        if count\
    \ > len(max) {\n            max = w\n        }\n    }\n    return max\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6lfernra_test.go:19:5: undefined: sort

    /tmp/tmp6lfernra_test.go:22:18: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == word[count] {\n           \
    \     count++\n            } else {\n                break\n            }\n  \
    \      }\n        if count > max {\n            max = count\n            word\
    \ = word\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpouo6ek6f_test.go:24:26: invalid operation: letter == word[count] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := -1\n    for i, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            count += letterCount[letter]\n        }\n\
    \        if count > max {\n            max = count\n            index = i\n  \
    \      }\n    }\n    return words[index]\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphb0rfb17_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := words[0]\n    for _, word := range words {\n        count := 0\n \
    \       for _, c := range word {\n            count += unicode.IsLetter(c)\n \
    \       }\n        if count > len(max) {\n            max = word\n        }\n\
    \    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptg0rylou_test.go:19:5: undefined: sort

    /tmp/tmptg0rylou_test.go:24:22: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    var maxCount int\n    var maxWord string\n    for _, word := range words\
    \ {\n        count := strings.Count(word, \"\")\n        if count > maxCount {\n\
    \            maxCount = count\n            maxWord = word\n        }\n    }\n\
    \    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpelyl16t5_test.go:19:5: undefined: sort

    /tmp/tmpelyl16t5_test.go:23:18: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            if letter == 'a' {\n                count++\n \
    \           }\n        }\n        if count > max {\n            max = count\n\
    \            index = word\n        }\n    }\n    return words[index]\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc4217qlt_test.go:30:21: cannot use word (variable of type string) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9jrohvvu_test.go:274:6: expected ''('', found TestFind_Max

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    min := len(words[0])\n    for _, word := range words {\n        if count[word]\
    \ > max {\n            max = count[word]\n        }\n        if count[word] <\
    \ min {\n            min = count[word]\n        }\n    }\n    for _, word := range\
    \ words {\n        if count[word] == max {\n            return word\n        }\n\
    \    }\n    return words[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpxyiv3n6q_test.go:63: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpxyiv3n6q_test.go:63:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmpxyiv3n6q_test.go:63: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmpxyiv3n6q_test.go:63: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpxyiv3n6q_test.go:63:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ c := range word {\n            if c != word[len(word)-1] {\n               \
    \ count++\n            }\n        }\n        if count > max {\n            max\
    \ = count\n            word = word\n        }\n    }\n    return word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3lf_ztsh_test.go:24:21: invalid operation: c != word[len(word) - 1] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            count++\n        }\n        if count > max {\n\
    \            max = count\n            index = len(words)\n        }\n    }\n \
    \   return words[index]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ii_g5zv_test.go:23:16: letter declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word] = m[word] + 1\n    }\n    max\
    \ := 0\n    key := \"\"\n    for k, v := range m {\n        if v > max {\n   \
    \         max = v\n            key = k\n        }\n    }\n    return key\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp_x5pqrn3_test.go:56: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp_x5pqrn3_test.go:56:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmp_x5pqrn3_test.go:56: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmp_x5pqrn3_test.go:56: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp_x5pqrn3_test.go:56:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := words[0]\n    count := 0\n    for _, word := range words {\n     \
    \   count += len(word)\n        if count > len(max) {\n            max = word\n\
    \        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfwxhn0dg_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            count++\n        }\n        if count > max {\n\
    \            max = count\n            index = len(words)\n        }\n    }\n \
    \   return words[index]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ii_g5zv_test.go:23:16: letter declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word]++\n    }\n    max := 0\n  \
    \  word := \"\"\n    for word, count := range m {\n        if count > max {\n\
    \            max = count\n        }\n    }\n    if max > 0 {\n        return word\n\
    \    }\n    for _, word := range words {\n        if m[word] == max {\n      \
    \      return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp19wu7lri_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            if letter == 'a' {\n                count++\n \
    \           }\n        }\n        if count > max {\n            max = count\n\
    \            index = word\n        }\n    }\n    return words[index]\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc4217qlt_test.go:30:21: cannot use word (variable of type string) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            if c != ' ' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    word = w\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpmqsrgmp9_test.go:58: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := 0\n    word := \"\"\n    for _, w := range words {\n        count\
    \ := 0\n        for _, c := range w {\n            count += unicode.IsLetter(c)\n\
    \        }\n        if count > max {\n            max = count\n            word\
    \ = w\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpun9rgyf9_test.go:19:5: undefined: sort

    /tmp/tmpun9rgyf9_test.go:25:22: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074415
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == letter[0] {\n             \
    \   count++\n            }\n        }\n        if count > max {\n            max\
    \ = count\n            word = word\n        }\n    }\n    return word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_xjibq_5_test.go:24:32: invalid operation: cannot index letter (variable
    of type rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                count++\n      \
    \      }\n        }\n        if count > max {\n            max = count\n     \
    \       word = word\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp0505nn5p_test.go:58: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp0505nn5p_test.go:58: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp0505nn5p_test.go:58:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp0505nn5p_test.go:58: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp0505nn5p_test.go:58: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp0505nn5p_test.go:58: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp0505nn5p_test.go:58:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp0505nn5p_test.go:58: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp0505nn5p_test.go:58: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp0505nn5p_test.go:58: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            if letter == 'a' || letter == 'e' ||\
    \ letter == 'i' || letter == 'o' || letter == 'u' {\n                count++\n\
    \            }\n        }\n        if count > max {\n            max = count\n\
    \            result = word\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmplr52g2c7_test.go:58: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmplr52g2c7_test.go:58:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmplr52g2c7_test.go:58: expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmplr52g2c7_test.go:58: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    min := len(words[0])\n    for _, word := range words {\n        if count[word]\
    \ > max {\n            max = count[word]\n        }\n        if count[word] <\
    \ min {\n            min = count[word]\n        }\n    }\n    for _, word := range\
    \ words {\n        if count[word] == max {\n            return word\n        }\n\
    \    }\n    return words[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpxyiv3n6q_test.go:63: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpxyiv3n6q_test.go:63:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmpxyiv3n6q_test.go:63: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmpxyiv3n6q_test.go:63: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpxyiv3n6q_test.go:63:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max == 0 {\n        return\
    \ \"\"\n    }\n    for word, count := range count {\n        if count == max {\n\
    \            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n1tebbw_test.go:24:5: word declared but not used

    /tmp/tmp8n1tebbw_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := -1\n    for _, word := range words {\n        count := 0\n        for _,\
    \ c := range word {\n            count++\n        }\n        if count > max {\n\
    \            max = count\n            index = -1\n        } else if count == max\
    \ {\n            if index == -1 {\n                index = len(word)\n       \
    \     }\n        }\n    }\n    if index == -1 {\n        return \"\"\n    }\n\
    \    return words[index]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprllb7lx3_test.go:23:16: c declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word]++\n    }\n    max := 0\n  \
    \  word := \"\"\n    for word, count := range m {\n        if count > max {\n\
    \            max = count\n        }\n    }\n    if max > 0 {\n        return word\n\
    \    }\n    for _, word := range words {\n        if m[word] == max {\n      \
    \      return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp19wu7lri_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := 0\n    word := \"\"\n    for _, w := range words {\n        count\
    \ := 0\n        for _, c := range w {\n            if c != word[len(word)-1] {\n\
    \                count++\n            }\n        }\n        if count > max {\n\
    \            max = count\n            word = w\n        }\n    }\n    return word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp94q3m180_test.go:19:5: undefined: sort

    /tmp/tmp94q3m180_test.go:25:21: invalid operation: c != word[len(word) - 1] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    index = word\n        }\n    }\n    return words[index]\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyp6g8ref_test.go:30:21: cannot use word (variable of type string) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    result\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == word[0] {\n               \
    \ count++\n            }\n        }\n        if count > max {\n            max\
    \ = count\n            result = word\n        }\n    }\n    return result\n}\n\
    \nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp31wvvkpl_test.go:24:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == word[0] {\n               \
    \ count++\n            }\n        }\n        if count > max {\n            max\
    \ = count\n            word = word\n        }\n    }\n    return word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmqplsk_r_test.go:24:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := words[0]\n    for _, word := range words {\n        count := 0\n \
    \       for _, c := range word {\n            count += counts[c]\n        }\n\
    \        if count > maxCount {\n            max = word\n            maxCount =\
    \ count\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8gsxr9a1_test.go:19:5: undefined: sort

    /tmp/tmp8gsxr9a1_test.go:24:22: undefined: counts

    /tmp/tmp8gsxr9a1_test.go:26:20: undefined: maxCount

    /tmp/tmp8gsxr9a1_test.go:28:13: undefined: maxCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    m := make(map[string]int)\n    for _, word := range words {\n    \
    \    m[word]++\n    }\n    max := 0\n    key := \"\"\n    for k, v := range m\
    \ {\n        if v > max {\n            max = v\n            key = k\n        }\n\
    \    }\n    return key\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpzn94p1kk_test.go:57: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpzn94p1kk_test.go:57:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n\
    \        tmpzn94p1kk_test.go:57: expected 'aaaaaaa', got 'cc'\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpzn94p1kk_test.go:57: expected 'footbott', got 'play'\n \
    \   --- FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpzn94p1kk_test.go:57:\
    \ expected 'gonna', got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n\
    \        tmpzn94p1kk_test.go:57: expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    max\
    \ := words[0]\n    for _, word := range words {\n        count := 0\n        for\
    \ _, char := range word {\n            if char != max[0] {\n                count++\n\
    \            }\n        }\n        if count > max {\n            max = count\n\
    \            max = word\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp02i5cqp7_test.go:20:9: no new variables on left side of :=

    /tmp/tmp02i5cqp7_test.go:20:12: cannot use words[0] (variable of type string)
    as type int in assignment

    /tmp/tmp02i5cqp7_test.go:24:27: invalid operation: cannot index max (variable
    of type int)

    /tmp/tmp02i5cqp7_test.go:30:19: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmp02i5cqp7_test.go:33:12: cannot use max (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := words[0]\n    count := 0\n    for _, word := range words {\n     \
    \   if word == max {\n            count++\n        } else {\n            max =\
    \ word\n            count = 1\n        }\n    }\n    if count > len(words) {\n\
    \        return max\n    }\n    return words[len(words)-count]\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1joyx_80_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, c\
    \ := range word {\n            count += int(unicode.IsLetter(c))\n        }\n\
    \        if count > max {\n            max = count\n            index = len(words)\n\
    \        }\n    }\n    return words[index]\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbl1s5e5j_test.go:24:26: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            count += unicode.IsLetter(c)\n        }\n        if\
    \ count > max {\n            max = count\n            word = w\n        }\n  \
    \  }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnlawn2it_test.go:24:22: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            if letter == 'a' || letter == 'e' ||\
    \ letter == 'i' || letter == 'o' || letter == 'u' {\n                count++\n\
    \            }\n        }\n        if count > max {\n            result = word\n\
    \            max = count\n        }\n    }\n    if max > 0 {\n        return fmt.Sprintf(\"\
    %v\", result)\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp_ptbtc56_test.go:61: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp_ptbtc56_test.go:61:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmp_ptbtc56_test.go:61: expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp_ptbtc56_test.go:61: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9jrohvvu_test.go:274:6: expected ''('', found TestFind_Max

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9jrohvvu_test.go:274:6: expected ''('', found TestFind_Max

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9jrohvvu_test.go:274:6: expected ''('', found TestFind_Max

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            count += letterCount[letter]\n      \
    \  }\n        if count > max {\n            result = word\n            max = count\n\
    \        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5rn4h2yb_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    max := words[0]\n    for _, word := range\
    \ words {\n        count := 0\n        for _, c := range word {\n            count++\n\
    \            if count > max {\n                max = count\n            }\n  \
    \      }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpge23w5kp_test.go:25:16: c declared but not used

    /tmp/tmpge23w5kp_test.go:27:24: invalid operation: count > max (mismatched types
    int and string)

    /tmp/tmpge23w5kp_test.go:28:23: cannot use count (variable of type int) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            if letter == 'a' || letter == 'e' ||\
    \ letter == 'i' || letter == 'o' || letter == 'u' {\n                count++\n\
    \            }\n        }\n        if count > max {\n            result = word\n\
    \            max = count\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpuldt9xx9_test.go:58: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpuldt9xx9_test.go:58:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmpuldt9xx9_test.go:58: expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpuldt9xx9_test.go:58: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max > 0 {\n        for\
    \ word, count := range count {\n            if count == max {\n              \
    \  return word\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbfg8hcwm_test.go:24:5: word declared but not used

    /tmp/tmpbfg8hcwm_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    max := words[0]\n    for _, word := range words {\n        if count[word]\
    \ > max {\n            max = count[word]\n            max = word\n        }\n\
    \    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi15m7yv6_test.go:24:9: no new variables on left side of :=

    /tmp/tmpi15m7yv6_test.go:24:12: cannot use words[0] (variable of type string)
    as type int in assignment

    /tmp/tmpi15m7yv6_test.go:28:19: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmpi15m7yv6_test.go:31:12: cannot use max (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == word[0] {\n               \
    \ count++\n            }\n        }\n        if count > max {\n            max\
    \ = count\n            word = word\n        }\n    }\n    return word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmqplsk_r_test.go:24:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := words[0]\n    for _, word := range words {\n        count := 0\n \
    \       for _, letter := range word {\n            count += letterCount[letter]\n\
    \        }\n        if count > maxCount {\n            max = word\n          \
    \  maxCount = count\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb2c6x195_test.go:19:5: undefined: sort

    /tmp/tmpb2c6x195_test.go:24:22: undefined: letterCount

    /tmp/tmpb2c6x195_test.go:26:20: undefined: maxCount

    /tmp/tmpb2c6x195_test.go:28:13: undefined: maxCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write code here\n\
    \    result := \"\"\n    max := 0\n    for _, word := range words {\n        count\
    \ := 0\n        for _, letter := range word {\n            if letter == result[len(result)-1]\
    \ {\n                count++\n            } else {\n                count = 0\n\
    \            }\n        }\n        if count > max {\n            result = word\n\
    \            max = count\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps1nhkmc9_test.go:25:26: invalid operation: letter == result[len(result)
    - 1] (mismatched types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := words[0]\n    for _, word := range words {\n        count := 0\n \
    \       for _, c := range word {\n            count += counts[c]\n        }\n\
    \        if count > maxCount {\n            max = word\n            maxCount =\
    \ count\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8gsxr9a1_test.go:19:5: undefined: sort

    /tmp/tmp8gsxr9a1_test.go:24:22: undefined: counts

    /tmp/tmp8gsxr9a1_test.go:26:20: undefined: maxCount

    /tmp/tmp8gsxr9a1_test.go:28:13: undefined: maxCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                count++\n      \
    \      }\n        }\n        if count > max {\n            max = count\n     \
    \       word = word\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp0505nn5p_test.go:58: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp0505nn5p_test.go:58: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp0505nn5p_test.go:58:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp0505nn5p_test.go:58: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp0505nn5p_test.go:58: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp0505nn5p_test.go:58: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp0505nn5p_test.go:58:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp0505nn5p_test.go:58: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp0505nn5p_test.go:58: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp0505nn5p_test.go:58: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max == 0 {\n        return\
    \ \"\"\n    }\n    for word, count := range count {\n        if count == max {\n\
    \            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n1tebbw_test.go:24:5: word declared but not used

    /tmp/tmp8n1tebbw_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    var maxCount int\n    var maxWord string\n    for _, word := range words\
    \ {\n        count := 0\n        for _, letter := range word {\n            if\
    \ letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter ==\
    \ 'u' {\n                count++\n            }\n        }\n        if count >\
    \ maxCount {\n            maxCount = count\n            maxWord = word\n     \
    \   }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv8u8cb_8_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            if letter == word[0] {\n            \
    \    count++\n            }\n        }\n        if count > max {\n           \
    \ max = count\n            result = word\n        }\n    }\n    return result\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplg8vfhny_test.go:24:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074417
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    var maxCount int\n    var maxWord string\n    for _, word := range words\
    \ {\n        count := 0\n        for _, c := range word {\n            count +=\
    \ int(unicode.IsLetter(c))\n        }\n        if count > maxCount {\n       \
    \     maxCount = count\n            maxWord = word\n        }\n    }\n    return\
    \ maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaz6s9_ux_test.go:19:5: undefined: sort

    /tmp/tmpaz6s9_ux_test.go:25:26: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                count++\n      \
    \      }\n        }\n        if count > max {\n            max = count\n     \
    \       word = word\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp0505nn5p_test.go:58: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp0505nn5p_test.go:58: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp0505nn5p_test.go:58:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp0505nn5p_test.go:58: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp0505nn5p_test.go:58: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp0505nn5p_test.go:58: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp0505nn5p_test.go:58:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp0505nn5p_test.go:58: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp0505nn5p_test.go:58: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp0505nn5p_test.go:58: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            if c != ' ' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    word = w\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpmqsrgmp9_test.go:58: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            count += letterCount[letter]\n      \
    \  }\n        if count > max {\n            max = count\n            result =\
    \ word\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3udzujn4_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            count += letterCount[letter]\n      \
    \  }\n        if count > max {\n            max = count\n            result =\
    \ word\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3udzujn4_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    result\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                count++\n      \
    \      }\n        }\n        if count > max {\n            result = word\n   \
    \         max = count\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp8lkpfc54_test.go:58: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp8lkpfc54_test.go:58:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmp8lkpfc54_test.go:58: expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp8lkpfc54_test.go:58: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074418
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    result\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                count++\n      \
    \      }\n        }\n        if count > max {\n            max = count\n     \
    \       result = word\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpdksvdu71_test.go:58: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpdksvdu71_test.go:58:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmpdksvdu71_test.go:58: expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpdksvdu71_test.go:58: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max == 0 {\n        return\
    \ \"\"\n    }\n    for word, count := range count {\n        if count == max {\n\
    \            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n1tebbw_test.go:24:5: word declared but not used

    /tmp/tmp8n1tebbw_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9jrohvvu_test.go:274:6: expected ''('', found TestFind_Max

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            count++\n        }\n        if count > max {\n   \
    \         max = count\n            word = w\n        }\n    }\n    return word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm3lbafeq_test.go:23:16: c declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := words[0]\n    for _, word := range words {\n        count := 0\n \
    \       for _, letter := range word {\n            if letter == max[0] {\n   \
    \             count++\n            }\n        }\n        if count > len(max) {\n\
    \            max = word\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoqc4dir3_test.go:19:5: undefined: sort

    /tmp/tmpoqc4dir3_test.go:24:26: invalid operation: letter == max[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            if letter == 'a' || letter == 'e' ||\
    \ letter == 'i' || letter == 'o' || letter == 'u' {\n                count++\n\
    \            }\n        }\n        if count > max {\n            result = word\n\
    \            max = count\n        }\n    }\n    if max > 0 {\n        result =\
    \ words[len(words)-1]\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmph8ubxv47_test.go:61: expected 'enam', got 'game'\n    ---\
    \ FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmph8ubxv47_test.go:61: expected\
    \ 'aaaaaaa', got 'cc'\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n      \
    \  tmph8ubxv47_test.go:61: expected 'abc', got 'cba'\n    --- FAIL: TestFind_Max/test_num__5\
    \ (0.00s)\n        tmph8ubxv47_test.go:61: expected 'gonna', got 'rock'\n    ---\
    \ FAIL: TestFind_Max/test_num__7 (0.00s)\n        tmph8ubxv47_test.go:61: expected\
    \ 'this', got 'prrk'\n    --- FAIL: TestFind_Max/test_num__8 (0.00s)\n       \
    \ tmph8ubxv47_test.go:61: expected 'b', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == letter[0] {\n             \
    \   count++\n            }\n        }\n        if count > max {\n            max\
    \ = count\n            word = word\n        }\n    }\n    return word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_xjibq_5_test.go:24:32: invalid operation: cannot index letter (variable
    of type rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == 'a' {\n                count++\n\
    \            }\n        }\n        if count > max {\n            max = count\n\
    \            word = word\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp14y1zqcu_test.go:58: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp14y1zqcu_test.go:58: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp14y1zqcu_test.go:58:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp14y1zqcu_test.go:58: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp14y1zqcu_test.go:58: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp14y1zqcu_test.go:58: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp14y1zqcu_test.go:58:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp14y1zqcu_test.go:58: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp14y1zqcu_test.go:58: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp14y1zqcu_test.go:58: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max == 0 {\n        return\
    \ \"\"\n    }\n    for word, count := range count {\n        if count == max {\n\
    \            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n1tebbw_test.go:24:5: word declared but not used

    /tmp/tmp8n1tebbw_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            count += unicode.IsLetter(c)\n        }\n        if\
    \ count > max {\n            max = count\n            word = w\n        }\n  \
    \  }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnlawn2it_test.go:24:22: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    max\
    \ := words[0]\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            count += letterCount[letter]\n      \
    \  }\n        if count > max {\n            max = count\n            max = word\n\
    \        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_4pj0q0c_test.go:20:9: no new variables on left side of :=

    /tmp/tmp_4pj0q0c_test.go:20:12: cannot use words[0] (variable of type string)
    as type int in assignment

    /tmp/tmp_4pj0q0c_test.go:24:22: undefined: letterCount

    /tmp/tmp_4pj0q0c_test.go:28:19: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmp_4pj0q0c_test.go:31:12: cannot use max (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    result\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == word[0] {\n               \
    \ count++\n            }\n        }\n        if count > max {\n            max\
    \ = count\n            result = word\n        }\n    }\n    return result\n}\n\
    \nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp31wvvkpl_test.go:24:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            count += letterCount[letter]\n      \
    \  }\n        if count > max {\n            max = count\n            result =\
    \ word\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3udzujn4_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word] = m[word] + 1\n    }\n    max\
    \ := 0\n    key := \"\"\n    for k, v := range m {\n        if v > max {\n   \
    \         max = v\n            key = k\n        }\n    }\n    return key\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp_x5pqrn3_test.go:56: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp_x5pqrn3_test.go:56:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmp_x5pqrn3_test.go:56: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmp_x5pqrn3_test.go:56: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp_x5pqrn3_test.go:56:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    max\
    \ := words[0]\n    for _, word := range words {\n        count := 0\n        for\
    \ _, char := range word {\n            if char != max[0] {\n                count++\n\
    \            }\n        }\n        if count > max {\n            max = count\n\
    \            max = word\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp02i5cqp7_test.go:20:9: no new variables on left side of :=

    /tmp/tmp02i5cqp7_test.go:20:12: cannot use words[0] (variable of type string)
    as type int in assignment

    /tmp/tmp02i5cqp7_test.go:24:27: invalid operation: cannot index max (variable
    of type int)

    /tmp/tmp02i5cqp7_test.go:30:19: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmp02i5cqp7_test.go:33:12: cannot use max (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            count += letterCount[letter]\n        }\n\
    \        if count > max {\n            max = count\n            word = word\n\
    \        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n \
    \ candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk7wcatru_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write code here\n\
    \    result := \"\"\n    max := 0\n    for _, word := range words {\n        count\
    \ := 0\n        for _, letter := range word {\n            if letter == result[len(result)-1]\
    \ {\n                count++\n            } else {\n                count = 0\n\
    \            }\n            if count > max {\n                result = word\n\
    \                max = count\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyplel5q5_test.go:25:26: invalid operation: letter == result[len(result)
    - 1] (mismatched types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    \n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp1wzz6py1_test.go:46: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp1wzz6py1_test.go:46: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp1wzz6py1_test.go:46:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp1wzz6py1_test.go:46: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp1wzz6py1_test.go:46: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp1wzz6py1_test.go:46: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp1wzz6py1_test.go:46:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp1wzz6py1_test.go:46: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp1wzz6py1_test.go:46: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp1wzz6py1_test.go:46: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    var maxCount int\n    var maxWord string\n    for _, word := range words\
    \ {\n        count := 0\n        for _, letter := range word {\n            if\
    \ letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter ==\
    \ 'u' {\n                count++\n            }\n        }\n        if count >\
    \ maxCount {\n            maxCount = count\n            maxWord = word\n     \
    \   }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv8u8cb_8_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    i :=\
    \ 0\n    for _, word := range words {\n        count := 0\n        for _, c :=\
    \ range word {\n            if c != word[i] {\n                count++\n     \
    \       }\n            i++\n        }\n        if count > max {\n            max\
    \ = count\n        }\n    }\n    if max > 0 {\n        return words[len(words)-1]\n\
    \    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidmun4q6_test.go:24:21: invalid operation: c != word[i] (mismatched types
    rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := -1\n    for i := 0; i < len(words); i++ {\n        count := 0\n        for\
    \ _, word := range words {\n            count += len(word) - len(strings.Replace(word,\
    \ \"-\", \"\", -1))\n        }\n        if count > max {\n            max = count\n\
    \            index = i\n        }\n    }\n    if index == -1 {\n        return\
    \ \"\"\n    }\n    return words[index]\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxopnjo3t_test.go:24:38: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        c := len(w)\n        if c >\
    \ max {\n            max = c\n            word = w\n        }\n    }\n    return\
    \ word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp3xtortmz_test.go:53: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    result\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                count++\n      \
    \      }\n        }\n        if count > max {\n            max = count\n     \
    \       result = word\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpdksvdu71_test.go:58: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpdksvdu71_test.go:58:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmpdksvdu71_test.go:58: expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpdksvdu71_test.go:58: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, c\
    \ := range word {\n            if c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u' {\n                count++\n            }\n        }\n        if\
    \ count > max {\n            max = count\n            index = word\n        }\n\
    \    }\n    return words[index]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp59cwf749_test.go:30:21: cannot use word (variable of type string) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    var maxCount int\n    var maxWord string\n    for _, word := range words\
    \ {\n        count := 0\n        for _, letter := range word {\n            count\
    \ += letterCount[letter]\n        }\n        if count > maxCount {\n         \
    \   maxCount = count\n            maxWord = word\n        }\n    }\n    return\
    \ maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjlk4j76a_test.go:19:5: undefined: sort

    /tmp/tmpjlk4j76a_test.go:25:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    min := len(words[0])\n    for _, word := range words {\n        if count[word]\
    \ > max {\n            max = count[word]\n        }\n        if count[word] <\
    \ min {\n            min = count[word]\n        }\n    }\n    for _, word := range\
    \ words {\n        if count[word] == max {\n            return word\n        }\n\
    \    }\n    return words[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpxyiv3n6q_test.go:63: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpxyiv3n6q_test.go:63:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmpxyiv3n6q_test.go:63: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmpxyiv3n6q_test.go:63: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpxyiv3n6q_test.go:63:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9jrohvvu_test.go:274:6: expected ''('', found TestFind_Max

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    i :=\
    \ 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    i = word\n        }\n    }\n    return i\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ayti5ca_test.go:30:17: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmp8ayti5ca_test.go:33:12: cannot use i (variable of type int) as type string
    in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            if c != ' ' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    word = w\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpmqsrgmp9_test.go:58: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ char := range word {\n            if char != ' ' {\n                count++\n\
    \            }\n        }\n        if count > max {\n            max = count\n\
    \            word = word\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpa3gke2s6_test.go:58: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpa3gke2s6_test.go:58: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpa3gke2s6_test.go:58:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpa3gke2s6_test.go:58: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpa3gke2s6_test.go:58: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpa3gke2s6_test.go:58: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpa3gke2s6_test.go:58:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpa3gke2s6_test.go:58: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpa3gke2s6_test.go:58: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpa3gke2s6_test.go:58: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074419
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    m := make(map[string]int)\n    for _, word := range words {\n    \
    \    m[word]++\n    }\n    max := 0\n    key := \"\"\n    for k, v := range m\
    \ {\n        if v > max {\n            max = v\n            key = k\n        }\n\
    \    }\n    return key\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpzn94p1kk_test.go:57: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpzn94p1kk_test.go:57:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n\
    \        tmpzn94p1kk_test.go:57: expected 'aaaaaaa', got 'cc'\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpzn94p1kk_test.go:57: expected 'footbott', got 'play'\n \
    \   --- FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpzn94p1kk_test.go:57:\
    \ expected 'gonna', got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n\
    \        tmpzn94p1kk_test.go:57: expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max > 0 {\n        return\
    \ word\n    }\n    for _, word := range words {\n        if count[word] > max\
    \ {\n            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpllnkks39_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    max := words[0]\n    for _, w := range words\
    \ {\n        count := 0\n        for _, c := range w {\n            count += counts[c]\n\
    \        }\n        if count > maxCount {\n            maxCount = count\n    \
    \        max = w\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnppdkb07_test.go:26:22: undefined: counts

    /tmp/tmpnppdkb07_test.go:28:20: undefined: maxCount

    /tmp/tmpnppdkb07_test.go:29:13: undefined: maxCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    index = len(words) - 1 // index of word with max number of unique characters\n\
    \        }\n    }\n    return words[index]\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp29_23gzx_test.go:58: expected 'enam', got 'game'\n    ---\
    \ FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp29_23gzx_test.go:58: expected\
    \ 'aaaaaaa', got 'cc'\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n      \
    \  tmp29_23gzx_test.go:58: expected 'abc', got 'cba'\n    --- FAIL: TestFind_Max/test_num__5\
    \ (0.00s)\n        tmp29_23gzx_test.go:58: expected 'gonna', got 'rock'\n    ---\
    \ FAIL: TestFind_Max/test_num__7 (0.00s)\n        tmp29_23gzx_test.go:58: expected\
    \ 'this', got 'prrk'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074419
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word] = m[word] + 1\n    }\n    for\
    \ word, count := range m {\n        if count > len(word) {\n            return\
    \ word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpdbdpu3y7_test.go:53: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpdbdpu3y7_test.go:53: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpdbdpu3y7_test.go:53:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpdbdpu3y7_test.go:53: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpdbdpu3y7_test.go:53: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpdbdpu3y7_test.go:53: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpdbdpu3y7_test.go:53:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpdbdpu3y7_test.go:53: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpdbdpu3y7_test.go:53: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpdbdpu3y7_test.go:53: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074419
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write code here\n\
    \    result := \"\"\n    max := 0\n    for _, word := range words {\n        count\
    \ := 0\n        for _, letter := range word {\n            if letter == result[len(result)-1]\
    \ {\n                count++\n            } else {\n                count = 0\n\
    \            }\n        }\n        if count > max {\n            result = word\n\
    \            max = count\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps1nhkmc9_test.go:25:26: invalid operation: letter == result[len(result)
    - 1] (mismatched types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word] = m[word] + 1\n    }\n    for\
    \ word, count := range m {\n        if count > len(word) {\n            return\
    \ word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpdbdpu3y7_test.go:53: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpdbdpu3y7_test.go:53: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpdbdpu3y7_test.go:53:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpdbdpu3y7_test.go:53: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpdbdpu3y7_test.go:53: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpdbdpu3y7_test.go:53: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpdbdpu3y7_test.go:53:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpdbdpu3y7_test.go:53: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpdbdpu3y7_test.go:53: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpdbdpu3y7_test.go:53: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074419
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write code here\n\
    \    m := make(map[string]int)\n    for _, word := range words {\n        m[word]++\n\
    \    }\n    max := 0\n    key := \"\"\n    for key, value := range m {\n     \
    \   if value > max {\n            max = value\n        }\n    }\n    if max >\
    \ 0 {\n        return key\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv26uofwi_test.go:26:9: key declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word]++\n    }\n    max := 0\n  \
    \  word := \"\"\n    for word, count := range m {\n        if count > max {\n\
    \            max = count\n        }\n    }\n    if max == 0 {\n        return\
    \ \"\"\n    }\n    for word, count := range m {\n        if count == max {\n \
    \           return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7l0ipb5a_test.go:24:5: word declared but not used

    /tmp/tmp7l0ipb5a_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := 0\n    word := \"\"\n    for _, word := range words {\n        count\
    \ := 0\n        for _, letter := range word {\n            count += letterToCount(letter)\n\
    \        }\n        if count > max {\n            max = count\n            word\
    \ = word\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppp360eel_test.go:19:5: undefined: sort

    /tmp/tmppp360eel_test.go:25:22: undefined: letterToCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074419
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, c := range word {\n            if c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' {\n                count++\n            }\n        }\n     \
    \   if count > max {\n            max = count\n            result = word\n   \
    \     }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpicdldd3u_test.go:58: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpicdldd3u_test.go:58:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmpicdldd3u_test.go:58: expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpicdldd3u_test.go:58: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074420
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    \n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp1wzz6py1_test.go:46: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp1wzz6py1_test.go:46: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp1wzz6py1_test.go:46:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp1wzz6py1_test.go:46: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp1wzz6py1_test.go:46: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp1wzz6py1_test.go:46: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp1wzz6py1_test.go:46:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp1wzz6py1_test.go:46: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp1wzz6py1_test.go:46: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp1wzz6py1_test.go:46: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == letter[0] {\n             \
    \   count++\n            }\n        }\n        if count > max {\n            max\
    \ = count\n            word = word\n        }\n    }\n    return word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_xjibq_5_test.go:24:32: invalid operation: cannot index letter (variable
    of type rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word] = count[word] + 1\n   \
    \ }\n    max := 0\n    word := \"\"\n    for word, count := range count {\n  \
    \      if count > max {\n            max = count\n        }\n    }\n    if max\
    \ > 0 {\n        return word\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7sisibn5_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074420
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word] = m[word] + 1\n    }\n    for\
    \ word, count := range m {\n        if count > len(word) {\n            return\
    \ word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpdbdpu3y7_test.go:53: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpdbdpu3y7_test.go:53: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpdbdpu3y7_test.go:53:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpdbdpu3y7_test.go:53: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpdbdpu3y7_test.go:53: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpdbdpu3y7_test.go:53: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpdbdpu3y7_test.go:53:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpdbdpu3y7_test.go:53: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpdbdpu3y7_test.go:53: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpdbdpu3y7_test.go:53: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074419
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write code here\n\
    \    \n    return \"\"\n}\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpvcx9i87n_test.go:45: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpvcx9i87n_test.go:45: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpvcx9i87n_test.go:45:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpvcx9i87n_test.go:45: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpvcx9i87n_test.go:45: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpvcx9i87n_test.go:45: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpvcx9i87n_test.go:45:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpvcx9i87n_test.go:45: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpvcx9i87n_test.go:45: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpvcx9i87n_test.go:45: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            count += letterCount[letter]\n        }\n     \
    \   if count > max {\n            max = count\n            index = word\n    \
    \    }\n    }\n    return index\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpymv72zoy_test.go:24:22: undefined: letterCount

    /tmp/tmpymv72zoy_test.go:28:21: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmpymv72zoy_test.go:31:12: cannot use index (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074420
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max > 0 {\n        return\
    \ word\n    }\n    for _, word := range words {\n        if count[word] == max\
    \ {\n            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp94xjswm1_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    \n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp1wzz6py1_test.go:46: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp1wzz6py1_test.go:46: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp1wzz6py1_test.go:46:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp1wzz6py1_test.go:46: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp1wzz6py1_test.go:46: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp1wzz6py1_test.go:46: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp1wzz6py1_test.go:46:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp1wzz6py1_test.go:46: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp1wzz6py1_test.go:46: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp1wzz6py1_test.go:46: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := 0\n    max := words[0]\n    for _, word := range words {\n       \
    \ count := 0\n        for _, letter := range word {\n            count += letterCount[letter]\n\
    \        }\n        if count > max {\n            max = count\n            max\
    \ = word\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgirw3y2b_test.go:19:5: undefined: sort

    /tmp/tmpgirw3y2b_test.go:21:9: no new variables on left side of :=

    /tmp/tmpgirw3y2b_test.go:21:12: cannot use words[0] (variable of type string)
    as type int in assignment

    /tmp/tmpgirw3y2b_test.go:25:22: undefined: letterCount

    /tmp/tmpgirw3y2b_test.go:29:19: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmpgirw3y2b_test.go:32:12: cannot use max (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074420
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    result\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                count++\n      \
    \      }\n        }\n        if count > max {\n            max = count\n     \
    \       result = word\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpdksvdu71_test.go:58: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpdksvdu71_test.go:58:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmpdksvdu71_test.go:58: expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpdksvdu71_test.go:58: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := 0\n    word := \"\"\n    for _, word := range words {\n        count\
    \ := 0\n        for _, char := range word {\n            if char == word[0] {\n\
    \                count++\n            }\n        }\n        if count > max {\n\
    \            max = count\n            word = word\n        }\n    }\n    return\
    \ word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu6ai6wv1_test.go:19:5: undefined: sort

    /tmp/tmpu6ai6wv1_test.go:25:24: invalid operation: char == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074420
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max > 0 {\n        return\
    \ word\n    }\n    for _, word := range words {\n        if count[word] == max\
    \ {\n            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp94xjswm1_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max > 0 {\n        return\
    \ word\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvw9rhm4w_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    index = word\n        }\n    }\n    return index\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps4xfkpb3_test.go:30:21: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmps4xfkpb3_test.go:33:12: cannot use index (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            count++\n        }\n        if count > max {\n\
    \            max = count\n            index = word\n        }\n    }\n    return\
    \ words[index]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkm2zcovm_test.go:23:16: letter declared but not used

    /tmp/tmpkm2zcovm_test.go:28:21: cannot use word (variable of type string) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            count += unicode.IsLetter(c)\n        }\n        if\
    \ count > max {\n            max = count\n            word = w\n        }\n  \
    \  }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnlawn2it_test.go:24:22: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word]++\n    }\n    max := 0\n  \
    \  key := \"\"\n    for k, v := range m {\n        if v > max {\n            max\
    \ = v\n            key = k\n        }\n    }\n    return key\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpw2dqdk3c_test.go:56: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpw2dqdk3c_test.go:56:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmpw2dqdk3c_test.go:56: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmpw2dqdk3c_test.go:56: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpw2dqdk3c_test.go:56:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            count += letterCount[letter]\n      \
    \  }\n        if count > max {\n            result = word\n            max = count\n\
    \        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5rn4h2yb_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9jrohvvu_test.go:274:6: expected ''('', found TestFind_Max

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := words[0]\n    count := 0\n    for _, word := range words {\n     \
    \   count += len(word)\n        if count > len(max) {\n            max = word\n\
    \        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfwxhn0dg_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := 0\n    word := \"\"\n    for _, s := range words {\n        count\
    \ := 0\n        for _, c := range s {\n            if count < max {\n        \
    \        count++\n                word += c\n            }\n        }\n      \
    \  if count > max {\n            max = count\n            word = s\n        }\n\
    \    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfm0wzxw5_test.go:19:5: undefined: sort

    /tmp/tmpfm0wzxw5_test.go:27:17: invalid operation: word += c (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074420
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                count++\n      \
    \      }\n        }\n        if count > max {\n            max = count\n     \
    \       word = word\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp0505nn5p_test.go:58: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp0505nn5p_test.go:58: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp0505nn5p_test.go:58:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp0505nn5p_test.go:58: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp0505nn5p_test.go:58: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp0505nn5p_test.go:58: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp0505nn5p_test.go:58:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp0505nn5p_test.go:58: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp0505nn5p_test.go:58: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp0505nn5p_test.go:58: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    result\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                count++\n      \
    \      }\n        }\n        if count > max {\n            result = word\n   \
    \         max = count\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp8lkpfc54_test.go:58: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp8lkpfc54_test.go:58:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmp8lkpfc54_test.go:58: expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp8lkpfc54_test.go:58: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074418
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    \n    \n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp1mq9qbga_test.go:47: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp1mq9qbga_test.go:47: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp1mq9qbga_test.go:47:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp1mq9qbga_test.go:47: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp1mq9qbga_test.go:47: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp1mq9qbga_test.go:47: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp1mq9qbga_test.go:47:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp1mq9qbga_test.go:47: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp1mq9qbga_test.go:47: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp1mq9qbga_test.go:47: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word] = count[word] + 1\n   \
    \ }\n    max := 0\n    max := words[0]\n    for _, word := range words {\n   \
    \     if count[word] > max {\n            max = count[word]\n            max =\
    \ word\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnvl2ayb1_test.go:24:9: no new variables on left side of :=

    /tmp/tmpnvl2ayb1_test.go:24:12: cannot use words[0] (variable of type string)
    as type int in assignment

    /tmp/tmpnvl2ayb1_test.go:28:19: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmpnvl2ayb1_test.go:31:12: cannot use max (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := words[0]\n    for _, word := range words {\n        count := 0\n \
    \       for _, letter := range word {\n            count += letterCount[letter]\n\
    \        }\n        if count > maxCount {\n            max = word\n          \
    \  maxCount = count\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb2c6x195_test.go:19:5: undefined: sort

    /tmp/tmpb2c6x195_test.go:24:22: undefined: letterCount

    /tmp/tmpb2c6x195_test.go:26:20: undefined: maxCount

    /tmp/tmpb2c6x195_test.go:28:13: undefined: maxCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            count++\n        }\n        if count > max {\n   \
    \         max = count\n            word = w\n        }\n    }\n    return word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm3lbafeq_test.go:23:16: c declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    min := len(words[0])\n    for _, word := range words {\n        if count[word]\
    \ > max {\n            max = count[word]\n        }\n        if count[word] <\
    \ min {\n            min = count[word]\n        }\n    }\n    for _, word := range\
    \ words {\n        if count[word] == max {\n            return word\n        }\n\
    \    }\n    return words[min]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmphfukox_c_test.go:63: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmphfukox_c_test.go:63:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmphfukox_c_test.go:63: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmphfukox_c_test.go:63: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmphfukox_c_test.go:63:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := -1\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                count++\n      \
    \      }\n        }\n        if count > max {\n            max = count\n     \
    \       index = -1\n        } else if count == max {\n            index = strings.Index(word,\
    \ letter)\n        }\n    }\n    if index == -1 {\n        return words[0]\n \
    \   }\n    return words[index]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4zsmilpv_test.go:32:21: undefined: strings

    /tmp/tmp4zsmilpv_test.go:32:41: undefined: letter

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            count += letterCount[letter]\n      \
    \  }\n        if count > max {\n            result = word\n            max = count\n\
    \        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5rn4h2yb_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := words[0]\n    for _, word := range words {\n        count := 0\n \
    \       for _, letter := range word {\n            count += letterCount[letter]\n\
    \        }\n        if count > maxCount {\n            max = word\n          \
    \  maxCount = count\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb2c6x195_test.go:19:5: undefined: sort

    /tmp/tmpb2c6x195_test.go:24:22: undefined: letterCount

    /tmp/tmpb2c6x195_test.go:26:20: undefined: maxCount

    /tmp/tmpb2c6x195_test.go:28:13: undefined: maxCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            if letter == 'a' || letter == 'e' ||\
    \ letter == 'i' || letter == 'o' || letter == 'u' {\n                count++\n\
    \            }\n        }\n        if count > max {\n            result = word\n\
    \            max = count\n        }\n    }\n    if max > 0 {\n        return fmt.Sprintf(\"\
    %v\", result)\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp_ptbtc56_test.go:61: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp_ptbtc56_test.go:61:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmp_ptbtc56_test.go:61: expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp_ptbtc56_test.go:61: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word] = count[word] + 1\n   \
    \ }\n    max := 0\n    word := \"\"\n    for word, count := range count {\n  \
    \      if count > max {\n            max = count\n        }\n    }\n    if max\
    \ == 0 {\n        return \"\"\n    }\n    for word, count := range count {\n \
    \       if count == max {\n            return word\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwfrxmwpj_test.go:24:5: word declared but not used

    /tmp/tmpwfrxmwpj_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max > 0 {\n        return\
    \ word\n    }\n    for _, word := range words {\n        if count[word] > max\
    \ {\n            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpllnkks39_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            count += letterCount[letter]\n      \
    \  }\n        if count > max {\n            result = word\n            max = count\n\
    \        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5rn4h2yb_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word]++\n    }\n    for k, v := range\
    \ m {\n        if v > len(words) {\n            return k\n        }\n    }\n \
    \   return words[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp8s5k472u_test.go:53: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp8s5k472u_test.go:53:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmp8s5k472u_test.go:53: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmp8s5k472u_test.go:53: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp8s5k472u_test.go:53:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max == 0 {\n        return\
    \ \"\"\n    }\n    for word, count := range count {\n        if count == max {\n\
    \            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n1tebbw_test.go:24:5: word declared but not used

    /tmp/tmp8n1tebbw_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            count += letterCount[letter]\n      \
    \  }\n        if count > max {\n            result = word\n            max = count\n\
    \        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5rn4h2yb_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    max := words[0]\n    for _, word := range words {\n        if count[word]\
    \ > max {\n            max = count[word]\n            max = word\n        }\n\
    \    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi15m7yv6_test.go:24:9: no new variables on left side of :=

    /tmp/tmpi15m7yv6_test.go:24:12: cannot use words[0] (variable of type string)
    as type int in assignment

    /tmp/tmpi15m7yv6_test.go:28:19: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmpi15m7yv6_test.go:31:12: cannot use max (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == word[0] {\n               \
    \ count++\n            }\n        }\n        if count > max {\n            max\
    \ = count\n            word = word\n        }\n    }\n    return word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmqplsk_r_test.go:24:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    result\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' {\n                count++\n      \
    \      }\n        }\n        if count > max {\n            max = count\n     \
    \       result = word\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpdksvdu71_test.go:58: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpdksvdu71_test.go:58:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmpdksvdu71_test.go:58: expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpdksvdu71_test.go:58: expected 'b', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    var maxCount int\n    var maxWord string\n    for _, word := range words\
    \ {\n        count := 0\n        for _, letter := range word {\n            if\
    \ letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter ==\
    \ 'u' {\n                count++\n            }\n        }\n        if count >\
    \ maxCount {\n            maxCount = count\n            maxWord = word\n     \
    \   }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv8u8cb_8_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    i :=\
    \ 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    i = word\n        }\n    }\n    return i\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ayti5ca_test.go:30:17: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmp8ayti5ca_test.go:33:12: cannot use i (variable of type int) as type string
    in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    max := words[0]\n    for _, w := range words\
    \ {\n        count := 0\n        for _, c := range w {\n            if c != max[0]\
    \ {\n                count++\n            }\n        }\n        if count > len(max)\
    \ {\n            max = w\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpblcoic7m_test.go:26:21: invalid operation: c != max[0] (mismatched types
    rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    max\
    \ := words[0]\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            count += letterCount[letter]\n      \
    \  }\n        if count > max {\n            max = count\n            max = word\n\
    \        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_4pj0q0c_test.go:20:9: no new variables on left side of :=

    /tmp/tmp_4pj0q0c_test.go:20:12: cannot use words[0] (variable of type string)
    as type int in assignment

    /tmp/tmp_4pj0q0c_test.go:24:22: undefined: letterCount

    /tmp/tmp_4pj0q0c_test.go:28:19: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmp_4pj0q0c_test.go:31:12: cannot use max (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            count += letterCount[letter]\n        }\n     \
    \   if count > max {\n            max = count\n            index = word\n    \
    \    }\n    }\n    return words[index]\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp15rasf1d_test.go:24:22: undefined: letterCount

    /tmp/tmp15rasf1d_test.go:28:21: cannot use word (variable of type string) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            count += counts[c]\n        }\n        if count >\
    \ max {\n            max = count\n            word = w\n        }\n    }\n   \
    \ return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeg8ejsh__test.go:24:22: undefined: counts

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := 0\n    word := \"\"\n    for _, s := range words {\n        count\
    \ := 0\n        for _, c := range s {\n            if c != word[len(word)-1] {\n\
    \                count++\n            }\n        }\n        if count > max {\n\
    \            max = count\n            word = s\n        }\n    }\n    return word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpofzhrsvh_test.go:19:5: undefined: sort

    /tmp/tmpofzhrsvh_test.go:25:21: invalid operation: c != word[len(word) - 1] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write code here\n\
    \    max := 0\n    max := words[0]\n    for _, word := range words {\n       \
    \ if strings.Count(word) > max {\n            max = strings.Count(word)\n    \
    \    }\n    }\n    for _, word := range words {\n        if strings.Count(word)\
    \ == max {\n            return word\n        }\n    }\n    return max\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpox9q7mc__test.go:21:9: no new variables on left side of :=

    /tmp/tmpox9q7mc__test.go:21:12: cannot use words[0] (variable of type string)
    as type int in assignment

    /tmp/tmpox9q7mc__test.go:23:12: undefined: strings

    /tmp/tmpox9q7mc__test.go:24:19: undefined: strings

    /tmp/tmpox9q7mc__test.go:28:12: undefined: strings

    /tmp/tmpox9q7mc__test.go:32:12: cannot use max (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max > 0 {\n        return\
    \ word\n    }\n    for _, word := range words {\n        if count[word] == max\
    \ {\n            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp94xjswm1_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := 0\n    word := \"\"\n    for _, word := range words {\n        count\
    \ := 0\n        for _, letter := range word {\n            if letter == word[0]\
    \ {\n                count++\n            }\n        }\n        if count > max\
    \ {\n            max = count\n            word = word\n        }\n    }\n    return\
    \ word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeb74d_xc_test.go:19:5: undefined: sort

    /tmp/tmpeb74d_xc_test.go:25:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9jrohvvu_test.go:274:6: expected ''('', found TestFind_Max

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    index = word\n        }\n    }\n    return index\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps4xfkpb3_test.go:30:21: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmps4xfkpb3_test.go:33:12: cannot use index (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := 0\n    word := \"\"\n    for _, word := range words {\n        count\
    \ := 0\n        for _, letter := range word {\n            if letter == 'a' ||\
    \ letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n       \
    \         count++\n            }\n        }\n        if count > max {\n      \
    \      max = count\n            word = word\n        }\n    }\n    return word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp71gbmoku_test.go:19:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    words := make(map[string]int)\n    for _,\
    \ word := range words {\n        count := 0\n        for _, letter := range word\
    \ {\n            count++\n            words[letter] = count\n        }\n    }\n\
    \    max := 0\n    max := words[\"\"]\n    for _, word := range words {\n    \
    \    if max < word {\n            max = word\n        }\n    }\n    return max\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9qqxc09h_test.go:22:11: no new variables on left side of :=

    /tmp/tmp9qqxc09h_test.go:22:14: cannot use make(map[string]int) (value of type
    map[string]int) as type []string in assignment

    /tmp/tmp9qqxc09h_test.go:27:29: cannot use count (variable of type int) as type
    string in assignment

    /tmp/tmp9qqxc09h_test.go:31:9: no new variables on left side of :=

    /tmp/tmp9qqxc09h_test.go:31:12: cannot use words[""] (variable of type string)
    as type int in assignment

    /tmp/tmp9qqxc09h_test.go:31:18: cannot convert "" (untyped string constant) to
    int

    /tmp/tmp9qqxc09h_test.go:33:18: invalid operation: max < word (mismatched types
    int and string)

    /tmp/tmp9qqxc09h_test.go:34:19: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmp9qqxc09h_test.go:37:12: cannot use max (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            count += letterCount[letter]\n      \
    \  }\n        if count > max {\n            result = word\n            max = count\n\
    \        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5rn4h2yb_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            count += letterCount[letter]\n        }\n     \
    \   if count > max {\n            max = count\n            index = word\n    \
    \    }\n    }\n    return words[index]\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp15rasf1d_test.go:24:22: undefined: letterCount

    /tmp/tmp15rasf1d_test.go:28:21: cannot use word (variable of type string) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            if letter == word[0] {\n            \
    \    count++\n            }\n        }\n        if count > max {\n           \
    \ result = word\n            max = count\n        }\n    }\n    if max > 0 {\n\
    \        result = words[strings.Index(words[0], result)]\n    }\n    return result\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx89gk3ot_test.go:24:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    /tmp/tmpx89gk3ot_test.go:34:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            count++\n        }\n        if count > max {\n   \
    \         max = count\n            word = w\n        }\n    }\n    return word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm3lbafeq_test.go:23:16: c declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == word[0] {\n               \
    \ count++\n            }\n        }\n        if count > max {\n            max\
    \ = count\n            word = word\n        }\n    }\n    return word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmqplsk_r_test.go:24:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := words[0]\n    for _, w := range words {\n        count := 0\n    \
    \    for _, c := range w {\n            if c == max[0] {\n                count++\n\
    \            }\n        }\n        if count > len(max) {\n            max = w\n\
    \        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplytlxofq_test.go:19:5: undefined: sort

    /tmp/tmplytlxofq_test.go:24:21: invalid operation: c == max[0] (mismatched types
    rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max == 0 {\n        return\
    \ \"\"\n    }\n    for word, count := range count {\n        if count == max {\n\
    \            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n1tebbw_test.go:24:5: word declared but not used

    /tmp/tmp8n1tebbw_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    result := \"\"\n \
    \   max := 0\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            count += letterCount[letter]\n      \
    \  }\n        if count > max {\n            result = word\n            max = count\n\
    \        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5rn4h2yb_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word] = m[word] + 1\n    }\n    max\
    \ := 0\n    key := \"\"\n    for k, v := range m {\n        if v > max {\n   \
    \         max = v\n            key = k\n        }\n    }\n    return key\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp_x5pqrn3_test.go:56: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp_x5pqrn3_test.go:56:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n\
    \        tmp_x5pqrn3_test.go:56: expected 'footbott', got 'play'\n    --- FAIL:\
    \ TestFind_Max/test_num__5 (0.00s)\n        tmp_x5pqrn3_test.go:56: expected 'gonna',\
    \ got 'we'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp_x5pqrn3_test.go:56:\
    \ expected 'nation', got 'we'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            count += letterCount[letter]\n        }\n     \
    \   if count > max {\n            max = count\n            index = word\n    \
    \    }\n    }\n    return index\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpymv72zoy_test.go:24:22: undefined: letterCount

    /tmp/tmpymv72zoy_test.go:28:21: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmpymv72zoy_test.go:31:12: cannot use index (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074420
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max > 0 {\n        return\
    \ word\n    }\n    for _, word := range words {\n        if count[word] > max\
    \ {\n            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpllnkks39_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := -1\n    for i, w := range words {\n        count := 0\n        for _, c :=\
    \ range w {\n            count += unicode.Is(unicode.Ideographic(c), unicode.Emoji)\
    \ || unicode.Is(unicode.Letter(c), unicode.Emoji)\n        }\n        if count\
    \ > max {\n            max = count\n            index = i\n        }\n    }\n\
    \    if index != -1 {\n        return words[index]\n    }\n    return \"\"\n}\n\
    \nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp94l0c6zj_test.go:24:22: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word]++\n    }\n    max := 0\n  \
    \  word := \"\"\n    for word, count := range m {\n        if count > max {\n\
    \            max = count\n        }\n    }\n    if max > 0 {\n        return word\n\
    \    }\n    for _, word := range words {\n        if m[word] == max {\n      \
    \      return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp19wu7lri_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074413
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    max := words[0]\n    for _, word := range\
    \ words {\n        count := 0\n        for _, letter := range word {\n       \
    \     count += letterCount[letter]\n        }\n        if count > maxCount {\n\
    \            maxCount = count\n            max = word\n        }\n    }\n    return\
    \ max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5c56dvjx_test.go:26:22: undefined: letterCount

    /tmp/tmp5c56dvjx_test.go:28:20: undefined: maxCount

    /tmp/tmp5c56dvjx_test.go:29:13: undefined: maxCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := 0\n    word := \"\"\n    for _, word := range words {\n        count\
    \ := 0\n        for _, letter := range word {\n            if letter == word[0]\
    \ {\n                count++\n            }\n        }\n        if count > max\
    \ {\n            max = count\n            word = word\n        }\n    }\n    return\
    \ word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeb74d_xc_test.go:19:5: undefined: sort

    /tmp/tmpeb74d_xc_test.go:25:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == word[0] {\n               \
    \ count++\n            }\n        }\n        if count > max {\n            max\
    \ = count\n            word = word\n        }\n    }\n    return word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmqplsk_r_test.go:24:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            if c != ' ' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    word = w\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpmqsrgmp9_test.go:58: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m := make(map[string]int)\n\
    \    for _, word := range words {\n        m[word] = m[word] + 1\n    }\n    max\
    \ := 0\n    key := \"\"\n    for word, count := range m {\n        if count >\
    \ max {\n            max = count\n            key = word\n        }\n    }\n \
    \   return key\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpymt534m__test.go:56: expected 'string', got 'of'\n    ---\
    \ FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpymt534m__test.go:56: expected\
    \ 'aaaaaaa', got 'bb'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n      \
    \  tmpymt534m__test.go:56: expected 'footbott', got 'play'\n    --- FAIL: TestFind_Max/test_num__5\
    \ (0.00s)\n        tmpymt534m__test.go:56: expected 'gonna', got 'we'\n    ---\
    \ FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpymt534m__test.go:56: expected\
    \ 'nation', got 'are'\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n      \
    \  tmpymt534m__test.go:56: expected 'this', got 'prrk'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            count += unicode.Is(unicode.Ideographic(c), unicode.Emoji)\
    \ || unicode.Is(unicode.Letter(c), unicode.Emoji)\n        }\n        if count\
    \ > max {\n            max = count\n            word = w\n        }\n    }\n \
    \   return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaisqe7t8_test.go:24:22: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    index = word\n        }\n    }\n    return words[index]\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyp6g8ref_test.go:30:21: cannot use word (variable of type string) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    max := words[0]\n    for _, word := range\
    \ words {\n        count := 0\n        for _, letter := range word {\n       \
    \     count += letterCount[letter]\n        }\n        if count > maxCount {\n\
    \            max = word\n            maxCount = count\n        }\n    }\n    return\
    \ max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl8n2tqxl_test.go:26:22: undefined: letterCount

    /tmp/tmpl8n2tqxl_test.go:28:20: undefined: maxCount

    /tmp/tmpl8n2tqxl_test.go:30:13: undefined: maxCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    max := words[0]\n    for _, word := range\
    \ words {\n        count := 0\n        for _, letter := range word {\n       \
    \     if letter == max[0] {\n                count++\n            }\n        }\n\
    \        if count > len(max) {\n            max = word\n        }\n    }\n   \
    \ return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppsprhf0__test.go:26:26: invalid operation: letter == max[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max == 0 {\n        return\
    \ \"\"\n    }\n    for _, word := range words {\n        if count[word] == max\
    \ {\n            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb441hkig_test.go:24:5: word declared but not used

    /tmp/tmpb441hkig_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := 0\n    word := \"\"\n    for _, word := range words {\n        count\
    \ := 0\n        for _, letter := range word {\n            if letter == word[0]\
    \ {\n                count++\n            }\n        }\n        if count > max\
    \ {\n            max = count\n            word = word\n        }\n    }\n    return\
    \ word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeb74d_xc_test.go:19:5: undefined: sort

    /tmp/tmpeb74d_xc_test.go:25:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, w := range words {\n        count := 0\n        for _, c\
    \ := range w {\n            if c != ' ' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    word = w\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpmqsrgmp9_test.go:58: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    result\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == word[0] {\n               \
    \ count++\n            }\n        }\n        if count > max {\n            max\
    \ = count\n            result = word\n        }\n    }\n    return result\n}\n\
    \nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp31wvvkpl_test.go:24:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    sort.Strings(words)\n\
    \    max := 0\n    word := \"\"\n    for _, word := range words {\n        count\
    \ := 0\n        for _, letter := range word {\n            if letter == word[0]\
    \ {\n                count++\n            }\n        }\n        if count > max\
    \ {\n            max = count\n            word = word\n        }\n    }\n    return\
    \ word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeb74d_xc_test.go:19:5: undefined: sort

    /tmp/tmpeb74d_xc_test.go:25:26: invalid operation: letter == word[0] (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074421
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    \n    \n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp1mq9qbga_test.go:47: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp1mq9qbga_test.go:47: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp1mq9qbga_test.go:47:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp1mq9qbga_test.go:47: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp1mq9qbga_test.go:47: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp1mq9qbga_test.go:47: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp1mq9qbga_test.go:47:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp1mq9qbga_test.go:47: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp1mq9qbga_test.go:47: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp1mq9qbga_test.go:47: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074421
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, letter\
    \ := range word {\n            if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n                count++\n         \
    \   }\n        }\n        if count > max {\n            max = count\n        \
    \    index = len(words)\n        }\n    }\n    return words[index]\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\npanic: runtime error: index out of range\
    \ [3] with length 3 [recovered]\n\tpanic: runtime error: index out of range [3]\
    \ with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x514620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x514620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.find_max(...)\n\t/tmp/tmp_6qk07g4_test.go:33\n\
    command-line-arguments_test.TestFind_Max(0xc0001a0340?)\n\t/tmp/tmp_6qk07g4_test.go:43\
    \ +0x1972\ntesting.tRunner(0xc0001a0340, 0x529f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    word\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            if letter == word[len(word)-1] {\n     \
    \           count++\n            }\n        }\n        if count > max {\n    \
    \        max = count\n            word = word\n        }\n    }\n    return word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgtfi9q4b_test.go:24:26: invalid operation: letter == word[len(word) -
    1] (mismatched types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    max\
    \ := words[0]\n    for _, word := range words {\n        count := 0\n        for\
    \ _, letter := range word {\n            count += letterCount[letter]\n      \
    \  }\n        if count > max {\n            max = count\n            max = word\n\
    \        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_4pj0q0c_test.go:20:9: no new variables on left side of :=

    /tmp/tmp_4pj0q0c_test.go:20:12: cannot use words[0] (variable of type string)
    as type int in assignment

    /tmp/tmp_4pj0q0c_test.go:24:22: undefined: letterCount

    /tmp/tmp_4pj0q0c_test.go:28:19: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmp_4pj0q0c_test.go:31:12: cannot use max (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074418
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    word := \"\"\n    for word, count := range count {\n        if count > max\
    \ {\n            max = count\n        }\n    }\n    if max > 0 {\n        for\
    \ _, word := range words {\n            if count[word] == max {\n            \
    \    return word\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcr947oj6_test.go:24:5: word declared but not used

    /tmp/tmpcr947oj6_test.go:25:9: word declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074422
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write code here\n\
    \    \n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpwhcjelcd_test.go:46: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpwhcjelcd_test.go:46: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpwhcjelcd_test.go:46:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpwhcjelcd_test.go:46: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpwhcjelcd_test.go:46: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpwhcjelcd_test.go:46: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpwhcjelcd_test.go:46:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpwhcjelcd_test.go:46: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpwhcjelcd_test.go:46: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpwhcjelcd_test.go:46: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074414
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    result\
    \ := \"\"\n    for _, word := range words {\n        count := 0\n        for _,\
    \ letter := range word {\n            count += letterCount[letter]\n        }\n\
    \        if count > max {\n            max = count\n            result = word\n\
    \        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2gawjx94_test.go:24:22: undefined: letterCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074422
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    for _, word := range words {\n        count[word]++\n    }\n    max := 0\n\
    \    max := words[0]\n    for _, word := range words {\n        if count[word]\
    \ > max {\n            max = count[word]\n            max = word\n        }\n\
    \    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi15m7yv6_test.go:24:9: no new variables on left side of :=

    /tmp/tmpi15m7yv6_test.go:24:12: cannot use words[0] (variable of type string)
    as type int in assignment

    /tmp/tmpi15m7yv6_test.go:28:19: cannot use word (variable of type string) as type
    int in assignment

    /tmp/tmpi15m7yv6_test.go:31:12: cannot use max (variable of type int) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074416
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    index\
    \ := 0\n    for _, word := range words {\n        count := 0\n        for _, c\
    \ := range word {\n            count += int(c)\n        }\n        if count >\
    \ max {\n            max = count\n            index = len(words)\n        }\n\
    \    }\n    return words[index]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\npanic: runtime error: index out of range\
    \ [3] with length 3 [recovered]\n\tpanic: runtime error: index out of range [3]\
    \ with length 3\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x514620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x514620, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.find_max(...)\n\t/tmp/tmpwk9_1d9o_test.go:31\n\
    command-line-arguments_test.TestFind_Max(0xc0001036c0?)\n\t/tmp/tmpwk9_1d9o_test.go:41\
    \ +0x17f2\ntesting.tRunner(0xc0001036c0, 0x529f88)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074422
