language: go_test.go
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n     \
    \   return word\n    }\n    vowelsCount = 0\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if word[i] == word[len(word)-1] {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount > 0 {\n        return word\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpk3rvnp09_test.go:70: expected 'u', got 'yogurt'\n    ---\
    \ FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpk3rvnp09_test.go:70:\
    \ expected 'u', got 'full'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n\
    \        tmpk3rvnp09_test.go:70: expected '', got 'easy'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmpk3rvnp09_test.go:70: expected '', got 'eAsy'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpk3rvnp09_test.go:70: expected\
    \ '', got 'ali'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n   \
    \     tmpk3rvnp09_test.go:70: expected 'a', got 'bad'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpk3rvnp09_test.go:70: expected 'o', got 'most'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpk3rvnp09_test.go:70: expected\
    \ '', got 'ab'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n    \
    \    tmpk3rvnp09_test.go:70: expected '', got 'ba'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpk3rvnp09_test.go:70: expected '', got 'quick'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpk3rvnp09_test.go:70:\
    \ expected 'i', got 'anime'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpk3rvnp09_test.go:70: expected '', got 'Asia'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpk3rvnp09_test.go:70:\
    \ expected 'o', got 'Above'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    for i := len(word) - 2; i >= 0; i-- {\n        if strings.Contains(word[i],\
    \ \"a\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"e\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"i\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"o\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"u\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"A\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"E\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"I\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"O\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"U\") {\n            vowelsCount++\n        }\n    }\n    if vowelsCount <\
    \ 2 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    for i := len(word)\
    \ - 3; i >= 0; i-- {\n        if strings.Contains(word[i], \"a\") {\n        \
    \    vowelsCount++\n        }\n        if strings.Contains(word[i], \"e\") {\n\
    \            vowelsCount++\n        }\n        if strings.Contains(word[i], \"\
    i\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"o\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"u\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"A\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"E\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"I\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"O\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"U\") {\n            vowelsCount++\n        }\n    }\n    if vowelsCount <\
    \ 2 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    for i := len(word)\
    \ - \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzsc1bot9_test.go:108:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Write your code here\n    vowels := []string{\"a\"\
    , \"e\", \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -=\
    \ 1\n    vowelsLen += 2\n    for i := 0; i < len(word); i++ {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            vowels--\n        } else {\n            vowels++\n        }\n\
    \        if vowels < 0 {\n            vowelsLen = 0\n        }\n        if vowels\
    \ > vowelsLen {\n            vowelsLen = vowels\n        }\n    }\n    return\
    \ vowels[vowelsLen]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpab7nug7z_test.go:30:13: invalid operation: vowels-- (non-numeric type
    []string)

    /tmp/tmpab7nug7z_test.go:32:13: invalid operation: vowels++ (non-numeric type
    []string)

    /tmp/tmpab7nug7z_test.go:34:21: cannot convert 0 (untyped int constant) to []string

    /tmp/tmpab7nug7z_test.go:37:21: invalid operation: vowels > vowelsLen (mismatched
    types []string and int)

    /tmp/tmpab7nug7z_test.go:38:25: cannot use vowels (variable of type []string)
    as type int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 1\n   \
    \ \n    vowels\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppqod9zzc_test.go:118:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen -=\
    \ 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowel\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphn76pt9w_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 2; i >= 0; i-- {\n        if word[i] == word[i+1] {\n       \
    \     vowelsCount++\n            if vowelsCount > len(vowels)-1 {\n          \
    \      return \"\"\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp3zeqfm_o_test.go:67: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp3zeqfm_o_test.go:67: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp3zeqfm_o_test.go:67: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp3zeqfm_o_test.go:67: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp3zeqfm_o_test.go:67:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp3zeqfm_o_test.go:67: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen += 2\n    i := len(word) - 1\n    j := len(word)\
    \ - 2\n    k := len(word) - 3\n    l := len(word) - 4\n    m := len(word) - 5\n\
    \    n := len(word) - 6\n    o := len(word) - 7\n    p := len(word) - 8\n    q\
    \ := len(word) - 9\n    r := len(word) - 10\n    s := len(word) - 11\n    t :=\
    \ len(word) - 12\n    u := len(word) - 13\n    v := len(word) - 14\n    w := len(word)\
    \ - 15\n    x := len(word) - 16\n    y := len(word) - 17\n    z := len(word) -\
    \ 18\n    switch {\n    case word[i] == vowels[j]:\n        return word[i]\n \
    \   case word[i] == vowels[k]:\n        return word[i]\n    case word[i] == vowels[l]:\n\
    \        return word[i]\n    case word[i] == vowels[m]:\n        return word[i]\n\
    \    case word[i] == vowels[n]:\n        return word[i]\n    case word[i] == vowels[o]:\n\
    \        return word[i]\n    case word[i] == vowels[p]:\n        return word[i]\n\
    \    case word[i] == vowels[q]:\n        return word[i]\n    case word[i] == vowels[r]:\n\
    \        return word[i]\n    case word[i] == vowels[s]:\n        return word[i]\n\
    \    case word[i] == vowels[t]:\n        return word[i]\n    case word[i] == vowels[u]:\n\
    \        return word[i]\n    case word[i] == vowels[v]:\n        return word[i]\n\
    \    case word[i] == vowels[w]:\n        return word[i]\n    case word[i] == vowels[x]:\n\
    \        return word[i]\n    case word[i] == vowels[y]:\n        return word[i]\n\
    \    case word[i] == vowels[z]:\n        return word[i]\n    default:\n      \
    \  return \"\"\n    }\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn8s63m1c_test.go:46:21: invalid operation: word[i] == vowels[j] (mismatched
    types byte and rune)

    /tmp/tmpn8s63m1c_test.go:47:16: cannot use word[i] (value of type byte) as type
    string in return statement

    /tmp/tmpn8s63m1c_test.go:48:21: invalid operation: word[i] == vowels[k] (mismatched
    types byte and rune)

    /tmp/tmpn8s63m1c_test.go:49:16: cannot use word[i] (value of type byte) as type
    string in return statement

    /tmp/tmpn8s63m1c_test.go:50:21: invalid operation: word[i] == vowels[l] (mismatched
    types byte and rune)

    /tmp/tmpn8s63m1c_test.go:51:16: cannot use word[i] (value of type byte) as type
    string in return statement

    /tmp/tmpn8s63m1c_test.go:52:21: invalid operation: word[i] == vowels[m] (mismatched
    types byte and rune)

    /tmp/tmpn8s63m1c_test.go:53:16: cannot use word[i] (value of type byte) as type
    string in return statement

    /tmp/tmpn8s63m1c_test.go:54:21: invalid operation: word[i] == vowels[n] (mismatched
    types byte and rune)

    /tmp/tmpn8s63m1c_test.go:55:16: cannot use word[i] (value of type byte) as type
    string in return statement

    /tmp/tmpn8s63m1c_test.go:55:16: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range vowels {\n\
    \        if word == v {\n            vowelsCount++\n        }\n    }\n    if vowelsCount\
    \ > 0 {\n        for _, v := range vowels {\n            if word == v {\n    \
    \            return v\n            }\n        }\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp3g4u371q_test.go:66: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp3g4u371q_test.go:66: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp3g4u371q_test.go:66: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp3g4u371q_test.go:66: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp3g4u371q_test.go:66:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp3g4u371q_test.go:66: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    for i := len(word) - 2; i >= 0; i-- {\n        if strings.Contains(word[i],\
    \ \"a\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"e\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"i\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"o\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"u\") {\n            vowelsCount++\n        }\n    }\n    if vowelsCount <\
    \ 2 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if strings.Contains(word[i], \"a\") {\n        \
    \    vowelsCount++\n        }\n        if strings.Contains(word[i], \"e\") {\n\
    \            vowelsCount++\n        }\n        if strings.Contains(word[i], \"\
    i\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"o\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"u\") {\n            vowelsCount++\n        }\n    }\n    if vowelsCount <\
    \ 2 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if strings.Contains(word[i], \"a\") {\n        \
    \    vowelsCount++\n        }\n        if strings.Contains(word[i], \"e\") {\n\
    \            vowelsCount++\n        }\n        if strings.Contains(word[i], \"\
    i\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"o\") {\n            vowelsCount++\n        }\n        if strings.Contains(word[i],\
    \ \"u\") {\n            vowelsCount++\n        }\n    }\n    if vowelsCount <\
    \ 2 {\n        return \"\"\n    }\n    vowelsCount -= 2\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if strings.Contains(word[i], \"a\") {\n        \
    \    vowelsCount++\n        }\n        if strings.Contains(word[i], \"e\") {\n\
    \            vowelsCount++\n        }\n        if strings.Contains(word[i], \"\
    i\") {\n            \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0p6of0mo_test.go:107:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowelsCount\
    \ := 0\n    vowelsCount += len(word) - len(word[:len(word)-1])\n    for _, v :=\
    \ range vowels {\n        if word[len(word)-1-v-1] == v {\n            return\
    \ string(v)\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv1_h6rjs_test.go:27:17: invalid operation: len(word) - 1 - v (mismatched
    types int and rune)

    /tmp/tmpv1_h6rjs_test.go:27:37: invalid operation: word[len(word) - 1 - v - 1]
    == v (mismatched types byte and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmd4x1wcm_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 1\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    lastConsonant\
    \ := strings.LastIndex(word, \"\")\n    if lastConsonant == -1 {\n        return\
    \ \"\"\n    }\n    lastConsonant += 1 // +1 because we already checked the length\
    \ above\n    lastConsonant /= 2\n    lastConsonant %= len(word)\n    if lastConsonant\
    \ == 0 {\n        return \"\"\n    }\n    lastConsonant += 1 // +1 because we\
    \ already checked the length above\n    lastConsonant /= 2\n    lastConsonant\
    \ %= len(word)\n    if lastConsonant == 0 {\n        return \"\"\n    }\n    lastConsonant\
    \ += 1 // +1 because we already checked the length above\n    lastConsonant /=\
    \ 2\n    lastConsonant %= len(word)\n    if lastConsonant == 0 {\n        return\
    \ \"\"\n    }\n    lastConsonant += 1 // +1 because we already checked the length\
    \ above\n    lastConsonant /= 2\n    lastConsonant %= len(word)\n    if lastConsonant\
    \ == 0 {\n        return \"\"\n    }\n    lastConsonant += 1 // +1 because we\
    \ already checked the length above\n    lastConsonant /= 2\n    lastConsonant\
    \ %= len(word)\n    if lastConsonant == 0 {\n        return \"\"\n    }\n    lastConsonant\
    \ += 1 // +1 because we already checked the length above\n    lastConsonant /=\
    \ 2\n    lastConsonant %= len(word)\n    if lastConsonant == 0 {\n        return\
    \ \"\"\n    }\n    lastConsonant += 1 // +1 because we already checked the length\
    \ above\n    lastConsonant /= 2\n    lastConsonant %= len(word)\n    if lastConsonant\
    \ == 0 {\n        return \"\"\n    }\n    lastConsonant += 1 // +1 because we\
    \ already checked the length above\n    lastConsonant /= 2\n    lastConsonant\
    \ %= len(word)\n    if lastConsonant == 0 {\n        return \"\"\n    }\n    lastConsonant\
    \ += 1 // +1 because we \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyuvj7e_e_test.go:90:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    if\
    \ vowelsCount < 0 {\n        vowelsCount += len(vowels)\n    }\n    return vowels[vowelsCount]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqh_3uq8__test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 2; i >= 0; i-- {\n        if word[i] == word[i+1] && word[i]\
    \ == word[i+2] {\n            vowelsCount++\n        }\n    }\n    if vowelsCount\
    \ > 0 {\n        return word[len(vowels)-1]\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9gzi0rap_test.go:37:16: cannot use word[len(vowels) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n\
    \            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaisteg3t_test.go:33:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    lastConsonant := len(word) - 1\n    lastConsonantLen := len(word[lastConsonant])\n\
    \    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\n    lastConsonantLen\
    \ += 2\n    \n    lastConsonantLen -= 1\n    lastConsonantLen /= 2\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_7ru0us9_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n\
    \            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaisteg3t_test.go:33:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word[len(word)-1:] == v {\n            return v\n        }\n \
    \   }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpajr0dcho_test.go:59: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpajr0dcho_test.go:59: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpajr0dcho_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpajr0dcho_test.go:59: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpajr0dcho_test.go:59: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpajr0dcho_test.go:59: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpajr0dcho_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpajr0dcho_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpajr0dcho_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Write your code here\n    vowels := []string{\"a\"\
    , \"e\", \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range vowels\
    \ {\n        if word == v {\n            vowelsCount++\n        }\n    }\n   \
    \ if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount -= 1\n  \
    \  for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1]\
    \ {\n            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6tjla9oc_test.go:37:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n\
    \            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaisteg3t_test.go:33:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for _,\
    \ v := range vowels {\n        if word[len(word)-len(v)-1] == v {\n          \
    \  return v\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk601ke3u_test.go:32:40: invalid operation: word[len(word) - len(v) - 1]
    == v (mismatched types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels) - 1 // -1 because we start\
    \ from right side\n    vowelsCount += len(vowels) - 1\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpib7irjmh_test.go:60: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpib7irjmh_test.go:60: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpib7irjmh_test.go:60: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpib7irjmh_test.go:60: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpib7irjmh_test.go:60:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpib7irjmh_test.go:60: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 2; i >= 0; i-- {\n        if word[i] == word[i+1] {\n       \
    \     vowelsCount++\n            if vowelsCount >= len(vowels) {\n           \
    \     return \"\"\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpjyrtmlta_test.go:67: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpjyrtmlta_test.go:67: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpjyrtmlta_test.go:67: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpjyrtmlta_test.go:67: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpjyrtmlta_test.go:67:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpjyrtmlta_test.go:67: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouy\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowel\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6i9nzq7j_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmprns6cpsc_test.go:64: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmprns6cpsc_test.go:64: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmprns6cpsc_test.go:64: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmprns6cpsc_test.go:64: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmprns6cpsc_test.go:64:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmprns6cpsc_test.go:64: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    i := len(word) -\
    \ 1\n    vowelFound := false\n    for i >= 0 {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ vowelFound = true\n            break\n        }\n        i--\n    }\n    if\
    \ vowelFound {\n        return word[i]\n    }\n    i := len(word) - 1\n    vowelFound\
    \ = false\n    for i >= 0 {\n        if word[i] == 'A' || word[i] == 'E' || word[i]\
    \ == 'I' || word[i] == 'O' || word[i] == 'U' {\n            vowelFound = true\n\
    \            break\n        }\n        i--\n    }\n    if vowelFound {\n     \
    \   return word[i]\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjzcnt6y0_test.go:23:5: vowels declared but not used

    /tmp/tmpjzcnt6y0_test.go:34:16: cannot use word[i] (value of type byte) as type
    string in return statement

    /tmp/tmpjzcnt6y0_test.go:36:7: no new variables on left side of :=

    /tmp/tmpjzcnt6y0_test.go:46:16: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphbkn0cth_test.go:90:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n     \
    \   return word\n    }\n    \n    vowelsCount = 0\n    for i := len(word) - 2;\
    \ i >= 0; i-- {\n        if word[i] == word[i+1] {\n            vowelsCount++\n\
    \        }\n    }\n    if vowelsCount > 0 {\n        return word\n    }\n    \n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp4gapskoa_test.go:72: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp4gapskoa_test.go:72: expected\
    \ 'u', got 'full'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n \
    \       tmp4gapskoa_test.go:72: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp4gapskoa_test.go:72: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp4gapskoa_test.go:72:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp4gapskoa_test.go:72: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n\
    \            if vowelsCount > len(vowels) {\n                return \"\"\n   \
    \         }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp92bfhdwg_test.go:67: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp92bfhdwg_test.go:67: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp92bfhdwg_test.go:67: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp92bfhdwg_test.go:67: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp92bfhdwg_test.go:67:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp92bfhdwg_test.go:67: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 2; i >= 0; i-- {\n        if word[i] == word[i+1] {\n       \
    \     vowelsCount++\n            if vowelsCount >= len(vowels) {\n           \
    \     return word[i]\n            }\n        }\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_vksubi2_test.go:35:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    \n\
    \    i := len(word) - 1\n    \n    for len(word) > 0 {\n        if word[i] ==\
    \ 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            i -= 1\n            i -= 2\n        } else {\n            i -=\
    \ 1\n        }\n    }\n    \n    if i == -1 {\n        return \"\"\n    }\n  \
    \  \n    i -= 2\n    \n    for len(word) > 0 {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ i -= 1\n            i -= 2\n        } else {\n            i -= 1\n        }\n\
    \    }\n    \n    if i == -1 {\n        return \"\"\n    }\n    \n    i -= 2\n\
    \    \n    for len(word) > 0 {\n        if word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n \
    \           i -= 2\n        } else {\n            i -= 1\n        }\n    }\n \
    \   \n    if i == -1 {\n        return \"\"\n    }\n    \n    i -= 2\n    \n \
    \   for len(word) > 0 {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n         \
    \   i -= 2\n        } else {\n            i -= 1\n        }\n    }\n    \n   \
    \ if i == -1 {\n        return \"\"\n    }\n    \n    i -= 2\n    \n    for len(word)\
    \ > 0 {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            i -= 1\n            i -= 2\n       \
    \ } else {\n            i -= 1\n        }\n    }\n    \n    if i == -1 {\n   \
    \     return \"\"\n    }\n    \n    i -= 2\n    \n    for len(word) > 0 {\n  \
    \      if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            i -= 1\n            i -= 2\n        } else\
    \ {\n            i -= 1\n        }\n    }\n    \n    if i == -1 {\n        return\
    \ \"\"\n    }\n    \n    i -= 2\n    \n    for len(word) > 0 {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo3ef8xit_test.go:122:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen -= 2\n    vowelsLen -= 3\n    vowelsLen -=\
    \ 4\n    vowelsLen -= 5\n    vowelsLen -= 6\n    vowelsLen -= 7\n    vowelsLen\
    \ -= 8\n    vowelsLen -= 9\n    vowelsLen -= 10\n    vowelsLen -= 11\n    vowelsLen\
    \ -= 12\n    vowelsLen -= 13\n    vowelsLen -= 14\n    vowelsLen -= 15\n    vowelsLen\
    \ -= 16\n    vowelsLen -= 17\n    vowelsLen -= 18\n    vowelsLen -= 19\n    vowelsLen\
    \ -= 20\n    vowelsLen -= 21\n    vowelsLen -= 22\n    vowelsLen -= 23\n    vowelsLen\
    \ -= 24\n    vowelsLen -= 25\n    vowelsLen -= 26\n    vowelsLen -= 27\n    vowelsLen\
    \ -= 28\n    vowelsLen -= 29\n    vowelsLen -= 30\n    vowelsLen -= 31\n    vowelsLen\
    \ -= 32\n    vowelsLen -= 33\n    vowelsLen -= 34\n    vowelsLen -= 35\n    vowelsLen\
    \ -= 36\n    vowelsLen -= 37\n    vowelsLen -= 38\n    vowelsLen -= 39\n    vowelsLen\
    \ -= 40\n    vowelsLen -= 41\n    vowelsLen -= 42\n    vowelsLen -= 43\n    vowelsLen\
    \ -= 44\n    vowelsLen -= 45\n    vowelsLen -= 46\n    vowelsLen -= 47\n    vowelsLen\
    \ -= 48\n    vowelsLen -= 49\n    vowelsLen -= 50\n    vowelsLen -= 51\n    vowelsLen\
    \ -= 52\n    vowelsLen -= 53\n    vowelsLen -= 54\n    vowelsLen -= 55\n    vowelsLen\
    \ -= 56\n    vowelsLen -= 57\n    vowelsLen -= 58\n    vowelsLen -= 59\n    vowelsLen\
    \ -= 60\n    vowelsLen -= 61\n    vowelsLen -= 62\n    vowelsLen -= 63\n    vowelsLen\
    \ -= 64\n    vowelsLen -= 65\n    vowelsLen -= 66\n    vowelsLen -= 67\n    vowelsLen\
    \ -= 68\n    vowelsLen -= 69\n    vowelsLen -= 70\n    vowel\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk5r4f7xq_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowel\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4uuxa_zb_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouy\")\n    vowelsLen := len(vowels)\n\
    \    \n    index := len(word) - 1\n    \n    for i := 0; i < len(word); i++ {\n\
    \        if word[i] == 'y' {\n            index = i\n            break\n     \
    \   }\n    }\n    \n    for i := index; i >= 0; i-- {\n        if word[i] == 'y'\
    \ {\n            index = i\n            break\n        }\n    }\n    \n    if\
    \ index == -1 {\n        return \"\"\n    }\n    \n    i := 0\n    \n    for ;\
    \ i < index; i++ {\n        if word[i] == 'y' {\n            break\n        }\n\
    \    }\n    \n    for ; i < len(word); i++ {\n        if word[i] == 'y' {\n  \
    \          break\n        }\n    }\n    \n    if i == 0 {\n        return \"\"\
    \n    }\n    \n    for ; i < len(word); i++ {\n        if word[i] == 'y' {\n \
    \           break\n        }\n    }\n    \n    for ; i < len(word); i++ {\n  \
    \      if word[i] == 'y' {\n            break\n        }\n    }\n    \n    if\
    \ i == 0 {\n        return \"\"\n    }\n    \n    for ; i < len(word); i++ {\n\
    \        if word[i] == 'y' {\n            break\n        }\n    }\n    \n    for\
    \ ; i < len(word); i++ {\n        if word[i] == 'y' {\n            break\n   \
    \     }\n    }\n    \n    if i == 0 {\n        return \"\"\n    }\n    \n    for\
    \ ; i < len(word); i++ {\n        if word[i] == 'y' {\n            break\n   \
    \     }\n    }\n    \n    for ; i < len(word); i++ {\n        if word[i] == 'y'\
    \ {\n            break\n        }\n    }\n    \n    if i == 0 {\n        return\
    \ \"\"\n    }\n    \n    for ; i < len(word); i++ {\n        if word[i] == 'y'\
    \ {\n            break\n        }\n    }\n    \n    for ; i < len(word); i++ {\n\
    \        if word[i] == 'y' {\n            break\n        }\n    }\n    \n    if\
    \ i == 0 {\n        return \"\"\n    }\n    \n    for ; i < len(word); i++ {\n\
    \        if word[i] == 'y' {\n            break\n        }\n    }\n    \n    for\
    \ ; i < len(word); i++ {\n        if word[i] == 'y' {\n            break\n   \
    \     }\n    }\n    \n    if i == 0 {\n        return \"\"\n    }\n    \n    for\
    \ ; i < len(word); i++ {\n        if word[i] == 'y' {\n            break\n   \
    \     }\n    }\n    \n    for ; i < len(word); i++ {\n        if word[i] == 'y'\
    \ {\n            break\n        }\n    }\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp891tlh4g_test.go:156:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6hf0nt82_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    \n    i := len(word) - 1\n    \n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n  \
    \  return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp64bgctms_test.go:24:5: vowelsLen declared but not used

    /tmp/tmp64bgctms_test.go:26:5: i declared but not used

    /tmp/tmp64bgctms_test.go:30:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    \n    index := len(word) - 1\n    \n    for index >= 0 {\n        if word[index]\
    \ == vowels[vowelsLen] {\n            vowelsLen--\n        }\n        index--\n\
    \    }\n    \n    return word[index+1:]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbn36cu56_test.go:29:27: invalid operation: word[index] == vowels[vowelsLen]
    (mismatched types byte and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels) - len(word) // count the\
    \ vowels\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n     \
    \   return \"\"\n    }\n    vowelsCount -= 2 // count the vowels\n    vowelsCount\
    \ /= 2 // count the consonants\n    vowelsCount += 1 // count the vowels\n   \
    \ vowelsCount /= 2 // count the consonants\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            if vowelsCount > 0 {\n             \
    \   vowelsCount--\n                return word[i]\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfssefp91_test.go:42:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= len(word) - len(word[:len(word)-1])\n\
    \    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    if vowelsCount\
    \ > len(vowels)-1 {\n        vowelsCount = len(vowels)-1\n    }\n    return vowels[vowelsCount]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp5cmiy69k_test.go:68: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp5cmiy69k_test.go:68: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp5cmiy69k_test.go:68: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp5cmiy69k_test.go:68: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp5cmiy69k_test.go:68:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp5cmiy69k_test.go:68: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune(\"aeiouAEIOU\")\n    vowelLen := len(vowel)\n\
    \    vowelPos := 0\n    vowelLen -= len(word) % vowelLen\n    \n    for i := 0;\
    \ i < len(word); i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelPos = i\n   \
    \         break\n        }\n    }\n    \n    if vowelPos == 0 {\n        return\
    \ \"\"\n    }\n    \n    vowelPos -= len(word) % vowelLen\n    \n    for i :=\
    \ 0; i < len(word); i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelPos = i\n   \
    \         break\n        }\n    }\n    \n    if vowelPos == 0 {\n        return\
    \ \"\"\n    }\n    \n    vowelPos -= len(word) % vowelLen\n    \n    for i :=\
    \ 0; i < len(word); i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelPos = i\n   \
    \         break\n        }\n    }\n    \n    if vowelPos == 0 {\n        return\
    \ \"\"\n    }\n    \n    vowelPos -= len(word) % vowelLen\n    \n    for i :=\
    \ 0; i < len(word); i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelPos = i\n   \
    \         break\n        }\n    }\n    \n    if vowelPos == 0 {\n        return\
    \ \"\"\n    }\n    \n    vowelPos -= len(word) % vowelLen\n    \n    for i :=\
    \ 0; i < len(word); i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelPos = i\n   \
    \         break\n        }\n    }\n    \n    if vowelPos == 0 {\n        return\
    \ \"\"\n    }\n    \n    vowelPos -= len(word) % vowelLen\n    \n    for i :=\
    \ 0; i < len(word); i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelPos = i\n   \
    \         break\n        }\n    }\n    \n    if vowelPos == 0 {\n        return\
    \ \"\"\n    }\n    \n    vowelPos -= len(word) % vowelLen\n    \n    for i \n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxczjfszk_test.go:107:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 1\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphbkn0cth_test.go:90:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen -=\
    \ 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz7qkq05y_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphopteei4_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen -=\
    \ 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz7qkq05y_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount <= 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphl4ckmx3_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n\
    \            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaisteg3t_test.go:33:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5dnmitnn_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    lastVowel := \"\"\n    lastVowelLen := 0\n    \n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        char := word[i]\n        \n        if\
    \ char == vowels[vowelsLen] {\n            lastVowel = char\n            lastVowelLen\
    \ = 1\n        } else {\n            if lastVowelLen > 0 {\n                lastVowelLen\
    \ -= 1\n                lastVowel = vowels[vowelsLen]\n            }\n       \
    \ }\n    }\n    \n    return lastVowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp63z0kdy9_test.go:35:20: invalid operation: char == vowels[vowelsLen] (mismatched
    types byte and string)

    /tmp/tmp63z0kdy9_test.go:36:25: cannot use char (variable of type byte) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n     \
    \   return word\n    }\n    vowelsCount = 0\n    for _, v := range vowels {\n\
    \        if word[len(word)-1:] == v {\n            vowelsCount++\n        }\n\
    \    }\n    if vowelsCount > 0 {\n        return word\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpk7b8n9gt_test.go:70: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpk7b8n9gt_test.go:70: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpk7b8n9gt_test.go:70: expected '', got 'ali'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpk7b8n9gt_test.go:70: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpk7b8n9gt_test.go:70: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpk7b8n9gt_test.go:70: expected '', got 'ba'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpk7b8n9gt_test.go:70: expected 'i', got 'anime'\n    ---\
    \ FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpk7b8n9gt_test.go:70:\
    \ expected '', got 'Asia'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpk7b8n9gt_test.go:70: expected 'o', got 'Above'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    \n    i := len(word) - 1\n    \n    for i >= 0 {\n  \
    \      if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            i -= 1\n            continue\n        }\n \
    \       \n        if word[i] == 'y' || word[i] == 'o' || word[i] == 'u' {\n  \
    \          i -= 1\n            continue\n        }\n        \n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            i -= 1\n            continue\n        }\n        \n        if\
    \ word[i] == 'y' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n \
    \           continue\n        }\n        \n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ i -= 1\n            continue\n        }\n        \n        if word[i] == 'y'\
    \ || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n            continue\n\
    \        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n            continue\n\
    \        }\n        \n        if word[i] == 'y' || word[i] == 'o' || word[i] ==\
    \ 'u' {\n            i -= 1\n            continue\n        }\n        \n     \
    \   if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u' {\n            i -= 1\n            continue\n        }\n    \
    \    \n        if word[i] == 'y' || word[i] == 'o' || word[i] == 'u' {\n     \
    \       i -= 1\n            continue\n        }\n        \n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            i -= 1\n            continue\n        }\n        \n        if\
    \ word[i] == 'y' || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n \
    \           continue\n        }\n        \n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ i -= 1\n            continue\n        }\n        \n        if word[i] == 'y'\
    \ || word[i] == 'o' || word[i] == 'u' {\n            i -= 1\n            continue\n\
    \        }\n        \n        if word[i] == 'a' || word[i]\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0v8v1fbt_test.go:101:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune(\"aeiou\")\n    vowelLen := len(vowel)\n\
    \    vowelIdx := 0\n    vowelIdx := len(word) - vowelLen - 1\n    vowelIdx -=\
    \ len(word) % vowelLen\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx\
    \ %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n\
    \    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx\
    \ += 1\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n\
    \    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx\
    \ %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n\
    \    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx\
    \ += 1\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n\
    \    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx\
    \ %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n\
    \    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx\
    \ += 1\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n\
    \    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx\
    \ %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n\
    \    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx\
    \ += 1\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n\
    \    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx\
    \ %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx += 1\n\
    \    vowelIdx %= vowelLen\n    vowelIdx += 1\n    vowelIdx %= vowelLen\n    vowelIdx\
    \ += 1\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjuldpkyl_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    i := len(word) - 1\n    j := len(word) - 2\n    k :=\
    \ len(word) - 3\n    l := len(word) - 4\n    m := len(word) - 5\n    n := len(word)\
    \ - 6\n    o := len(word) - 7\n    p := len(word) - 8\n    q := len(word) - 9\n\
    \    r := len(word) - 10\n    s := len(word) - 11\n    t := len(word) - 12\n \
    \   u := len(word) - 13\n    v := len(word) - 14\n    w := len(word) - 15\n  \
    \  x := len(word) - 16\n    y := len(word) - 17\n    z := len(word) - 18\n   \
    \ \n    if word[i] == 'a' {\n        return vowels[0]\n    }\n    if word[i] ==\
    \ 'e' {\n        return vowels[1]\n    }\n    if word[i] == 'i' {\n        return\
    \ vowels[2]\n    }\n    if word[i] == 'o' {\n        return vowels[3]\n    }\n\
    \    if word[i] == 'u' {\n        return vowels[4]\n    }\n    if word[i] == 'y'\
    \ {\n        return vowels[5]\n    }\n    if word[i] == 'A' {\n        return\
    \ vowels[6]\n    }\n    if word[i] == 'E' {\n        return vowels[7]\n    }\n\
    \    if word[i] == 'I' {\n        return vowels[8]\n    }\n    if word[i] == 'O'\
    \ {\n        return vowels[9]\n    }\n    if word[i] == 'U' {\n        return\
    \ vowels[10]\n    }\n    if word[i] == 'Y' {\n        return vowels[11]\n    }\n\
    \    if word[i] == 'a' {\n        return vowels[12]\n    }\n    if word[i] ==\
    \ 'e' {\n        return vowels[13]\n    }\n    if word[i] == 'i' {\n        return\
    \ vowels[14]\n    }\n    if word[i] == 'o' {\n        return vowels[15]\n    }\n\
    \    if word[i] == 'u' {\n        return vowels[16]\n    }\n    if word[i] ==\
    \ 'y' {\n        return vowels[17]\n    }\n    if word[i] == 'A' {\n        return\
    \ vowels[18]\n    }\n    if word[i] == 'E' {\n        return vowels[19]\n    }\n\
    \    if word[i] == 'I' {\n        return vowels[20]\n    }\n    if word[i] ==\
    \ 'O' {\n        return vowels[21]\n    }\n    if word[i]\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpevt0ut6l_test.go:112:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    lastVowel := \"\"\n    for i := len(word) - 2; i >= 0; i--\
    \ {\n        if word[i] == word[i+1] {\n            lastVowel = word[i]\n    \
    \        break\n        }\n    }\n    if lastVowel == \"\" {\n        return \"\
    \"\n    }\n    if strings.Contains(word, lastVowel) {\n        return lastVowel\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkq59vies_test.go:26:12: undefined: strings

    /tmp/tmpkq59vies_test.go:39:25: cannot use word[i] (value of type byte) as type
    string in assignment

    /tmp/tmpkq59vies_test.go:46:8: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowelsLen\
    \ := len(vowels)\n    vowelsLen += vowelsLen % 2\n    vowelsLen -= vowelsLen %\
    \ 2\n    vowelsLen += vowelsLen % 2\n    vowelsLen -= vowelsLen % 2\n    vowelsLen\
    \ += vowelsLen % 2\n    vowelsLen -= vowelsLen % 2\n    vowelsLen += vowelsLen\
    \ % 2\n    vowelsLen -= vowelsLen % 2\n    vowelsLen += vowelsLen % 2\n    vowelsLen\
    \ -= vowelsLen % 2\n    vowelsLen += vowelsLen % 2\n    vowelsLen -= vowelsLen\
    \ % 2\n    vowelsLen += vowelsLen % 2\n    vowelsLen -= vowelsLen % 2\n    vowelsLen\
    \ += vowelsLen % 2\n    vowelsLen -= vowelsLen % 2\n    vowelsLen += vowelsLen\
    \ % 2\n    vowelsLen -= vowelsLen % 2\n    vowelsLen += vowelsLen % 2\n    vowelsLen\
    \ -= vowelsLen % 2\n    vowelsLen += vowelsLen % 2\n    vowelsLen -= vowelsLen\
    \ % 2\n    vowelsLen += vowelsLen % 2\n    vowelsLen -= vowelsLen % 2\n    vowelsLen\
    \ += vowelsLen % 2\n    vowelsLen -= vowelsLen % 2\n    vowelsLen += vowelsLen\
    \ % 2\n    vowelsLen -= vowelsLen % 2\n    vowelsLen += vowelsLen % 2\n    vowelsLen\
    \ -= vowelsLen % 2\n    vowelsLen += vowelsLen % 2\n    vowelsLen -= vowelsLen\
    \ % 2\n    vowelsLen += vowelsLen % 2\n    vowelsLen -= vowelsLen % 2\n    vowelsLen\
    \ += vowelsLen % 2\n    vowelsLen -= vowelsLen % 2\n    vowelsLen += vowelsLen\
    \ % 2\n    vowelsLen -= vowelsLen % 2\n    vowelsLen += vowelsLen % 2\n    vowelsLen\
    \ -= vowelsLen % 2\n    vowelsLen += vowelsLen % 2\n    vowelsLen -= vowelsLen\
    \ % 2\n    vowelsLen += vowelsLen % 2\n    vowelsLen -= vowelsLen % 2\n    vowel\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9m5ifjhz_test.go:70:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n     \
    \   return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %= len(vowels)\n\
    \    return vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp1ha2xrop_test.go:63: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp1ha2xrop_test.go:63: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp1ha2xrop_test.go:63: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp1ha2xrop_test.go:63: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp1ha2xrop_test.go:63:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp1ha2xrop_test.go:63: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    lastConsonant := len(word) - 1\n    lastConsonant -= lastConsonant\
    \ % 2\n    lastConsonant /= 2\n    lastConsonant += 2\n    \n    lastVowel :=\
    \ len(word) - vowelsLen\n    lastVowel -= lastVowel % 2\n    lastVowel /= 2\n\
    \    lastVowel += 2\n    \n    lastVowel = lastVowel % len(vowels)\n    \n   \
    \ lastVowel = lastVowel % len(vowels)\n    \n    lastVowel = lastVowel % len(vowels)\n\
    \    \n    lastVowel = lastVowel % len(vowels)\n    \n    lastVowel = lastVowel\
    \ % len(vowels)\n    \n    lastVowel = lastVowel % len(vowels)\n    \n    lastVowel\
    \ = lastVowel % len(vowels)\n    \n    lastVowel = lastVowel % len(vowels)\n \
    \   \n    lastVowel = lastVowel % len(vowels)\n    \n    lastVowel = lastVowel\
    \ % len(vowels)\n    \n    lastVowel = lastVowel % len(vowels)\n    \n    lastVowel\
    \ = lastVowel % len(vowels)\n    \n    lastVowel = lastVowel % len(vowels)\n \
    \   \n    lastVowel = lastVowel % len(vowels)\n    \n    lastVowel = lastVowel\
    \ % len(vowels)\n    \n    lastVowel = lastVowel % len(vowels)\n    \n    lastVowel\
    \ = lastVowel % len(vowels)\n    \n    lastVowel = lastVowel % len(vowels)\n \
    \   \n    lastVowel = lastVowel % len(vowels)\n    \n    lastVowel = lastVowel\
    \ % len(vowels)\n    \n    lastVowel = lastVowel % len(vowels)\n    \n    lastVowel\
    \ = lastVowel % len(vowels)\n    \n    lastVowel\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgo86opx6_test.go:84:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word[len(word)-1:] == v {\n            return v\n        }\n \
    \   }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpajr0dcho_test.go:59: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpajr0dcho_test.go:59: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpajr0dcho_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpajr0dcho_test.go:59: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpajr0dcho_test.go:59: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpajr0dcho_test.go:59: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpajr0dcho_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpajr0dcho_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpajr0dcho_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    i := len(word)\
    \ - 1\n    for {\n        if i >= 0 {\n            if strings.Contains(word, vowels[i])\
    \ {\n                return vowels[i]\n            }\n            i--\n      \
    \  } else {\n            break\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwnj8woqv_test.go:27:12: undefined: strings

    /tmp/tmpwnj8woqv_test.go:40:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    lastConsonant := false\n    for _, v := range vowels {\n        if\
    \ strings.Contains(word, v) {\n            vowelsCount++\n            lastConsonant\
    \ = true\n        }\n    }\n    if lastConsonant {\n        return \"\"\n    }\n\
    \    lastConsonant = false\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n            lastConsonant = true\n        }\n\
    \    }\n    if lastConsonant {\n        return \"\"\n    }\n    lastConsonant\
    \ = false\n    for _, v := range vowels {\n        if strings.Contains(word, v)\
    \ {\n            vowelsCount++\n            lastConsonant = true\n        }\n\
    \    }\n    if lastConsonant {\n        return \"\"\n    }\n    lastConsonant\
    \ = false\n    for _, v := range vowels {\n        if strings.Contains(word, v)\
    \ {\n            vowelsCount++\n            lastConsonant = true\n        }\n\
    \    }\n    if lastConsonant {\n        return \"\"\n    }\n    lastConsonant\
    \ = false\n    for _, v := range vowels {\n        if strings.Contains(word, v)\
    \ {\n            vowelsCount++\n            lastConsonant = true\n        }\n\
    \    }\n    if lastConsonant {\n        return \"\"\n    }\n    lastConsonant\
    \ = false\n    for _, v := range vowels {\n        if strings.Contains(word, v)\
    \ {\n            vowelsCount++\n            lastConsonant = true\n        }\n\
    \    }\n    if lastConsonant {\n        return \"\"\n    }\n    lastConsonant\
    \ = false\n    for _, v := range vowels {\n        if strings.Contains(word, v)\
    \ {\n            vowelsCount++\n            lastConsonant = true\n        }\n\
    \    }\n    if lastConsonant {\n        return \"\"\n    }\n    lastConsonant\
    \ = false\n    for _, v := range vowels {\n        if strings.Contains(word, v)\
    \ {\n            vowelsCount++\n            lastConsonant = true\n        }\n\
    \    }\n    if lastConsonant {\n        return \"\"\n    }\n    lastConsonant\
    \ = false\n    for _, v := range vowels {\n        if strings.Contains(\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp4b6ibj4_test.go:118:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphopteei4_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := \"aeiouAEIOU\"\n    vowelCount := 0\n    vowelIndex\
    \ := len(word) - 1\n    for i := 0; i < len(word); i++ {\n        if word[i] ==\
    \ 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            vowelCount++\n        }\n        if word[i] == 'A' || word[i]\
    \ == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n           \
    \ vowelCount++\n        }\n        if vowelCount > 0 {\n            vowelIndex\
    \ = i\n        }\n    }\n    if vowelIndex == -1 {\n        return \"\"\n    }\n\
    \    if word[vowelIndex] == 'a' || word[vowelIndex] == 'e' || word[vowelIndex]\
    \ == 'i' || word[vowelIndex] == 'o' || word[vowelIndex] == 'u' {\n        return\
    \ word[vowelIndex]\n    }\n    if word[vowelIndex] == 'A' || word[vowelIndex]\
    \ == 'E' || word[vowelIndex] == 'I' || word[vowelIndex] == 'O' || word[vowelIndex]\
    \ == 'U' {\n        return word[vowelIndex]\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt8gznfmk_test.go:23:5: vowel declared but not used

    /tmp/tmpt8gznfmk_test.go:41:16: cannot use word[vowelIndex] (value of type byte)
    as type string in return statement

    /tmp/tmpt8gznfmk_test.go:44:16: cannot use word[vowelIndex] (value of type byte)
    as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074644
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    i := len(word) - 1\n    for i >= 0 {\n        if word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   \
    \         vowel_count++\n        }\n        i -= 1\n    }\n    if vowel_count\
    \ > 0 {\n        i := len(word) - 1\n        for i >= 0 {\n            if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n                return word[i]\n            }\n            i -= 1\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp06wmdkmb_test.go:23:5: vowel declared but not used

    /tmp/tmp06wmdkmb_test.go:36:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074644
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    if\
    \ vowelsCount == 0 {\n        return \"\"\n    }\n    i := len(word) - 1\n   \
    \ for {\n        if i == 0 {\n            break\n        }\n        if strings.Contains(word[i],\
    \ vowels[vowelsCount]) {\n            vowelsCount++\n        }\n        i--\n\
    \    }\n    return word[i]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwjz9ayaw_test.go:27:12: undefined: strings

    /tmp/tmpwjz9ayaw_test.go:45:12: undefined: strings

    /tmp/tmpwjz9ayaw_test.go:50:12: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074644
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen\
    \ += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowel\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4hrvuoz3_test.go:96:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_count += strings.Count(word, \"a\")\n    vowel_count += strings.Count(word,\
    \ \"e\")\n    vowel_count += strings.Count(word, \"i\")\n    vowel_count += strings.Count(word,\
    \ \"o\")\n    vowel_count += strings.Count(word, \"u\")\n    if vowel_count >\
    \ len(vowel)-1 {\n        return \"\"\n    }\n    i := len(word) - 1\n    for\
    \ ; i < len(word); i++ {\n        if strings.Contains(string(word[i]), vowel[vowel_count])\
    \ {\n            vowel_count++\n        } else {\n            vowel_count = 0\n\
    \        }\n        if vowel_count == len(vowel) {\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdw5nt6f_test.go:25:20: undefined: strings

    /tmp/tmpvdw5nt6f_test.go:26:20: undefined: strings

    /tmp/tmpvdw5nt6f_test.go:27:20: undefined: strings

    /tmp/tmpvdw5nt6f_test.go:28:20: undefined: strings

    /tmp/tmpvdw5nt6f_test.go:29:20: undefined: strings

    /tmp/tmpvdw5nt6f_test.go:35:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074644
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    return\
    \ vowels[vowelsCount]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphdnog5wi_test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074644
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6hf0nt82_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd_sex7vm_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074644
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n\
    \            return word[len(word)-1]\n        }\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk18s74u4_test.go:33:20: cannot use word[len(word) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowelsLen\
    \ := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n\
    \    \n    vowelsLen -= len(word)\n    \n    i := len(word) - 1\n    \n    for\
    \ len(word) > 0 {\n        if word[i] >= 'a' && word[i] <= 'z' {\n           \
    \ i -= 1\n            continue\n        }\n        if word[i] >= 'A' && word[i]\
    \ <= 'Z' {\n            i -= 1\n            continue\n        }\n        if word[i]\
    \ == vowels[vowelsLen] {\n            return string(vowels[vowelsLen])\n     \
    \   }\n        i -= 1\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy5hxec3l_test.go:42:23: invalid operation: word[i] == vowels[vowelsLen]
    (mismatched types byte and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5dnmitnn_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphopteei4_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6hf0nt82_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount < 2 {\n     \
    \   return \"\"\n    }\n    vowelsCount -= 2\n    vowelsCount %= len(vowels)\n\
    \    lastVowel := vowels[vowelsCount]\n    lastVowelIndex := len(word) - len(lastVowel)\n\
    \    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n\
    \    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n\
    \    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n\
    \    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n\
    \    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n\
    \    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n\
    \    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n\
    \    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n\
    \    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n\
    \    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n\
    \    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n\
    \    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex--\n\
    \    lastVowelIndex--\n    lastVowelIndex--\n    lastVowelIndex\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputmebzl2_test.go:88:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word[len(word)-1:] == v {\n            return v\n        }\n \
    \   }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpajr0dcho_test.go:59: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpajr0dcho_test.go:59: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpajr0dcho_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpajr0dcho_test.go:59: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpajr0dcho_test.go:59: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpajr0dcho_test.go:59: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpajr0dcho_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpajr0dcho_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpajr0dcho_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    lastConsonant := strings.LastIndex(word,\
    \ \"c\")\n    if lastConsonant == -1 {\n        return \"\"\n    }\n    lastConsonant++\n\
    \    lastConsonantIndex := strings.LastIndex(word[lastConsonant:], \"c\")\n  \
    \  if lastConsonantIndex == -1 {\n        return \"\"\n    }\n    lastConsonantIndex++\n\
    \    if lastConsonantIndex < lastConsonant {\n        lastConsonantIndex++\n \
    \   }\n    if lastConsonantIndex == lastConsonant {\n        return word[lastConsonantIndex]\n\
    \    }\n    if lastConsonantIndex > lastConsonant {\n        lastConsonantIndex--\n\
    \    }\n    if lastConsonantIndex == lastConsonant {\n        return word[lastConsonantIndex]\n\
    \    }\n    if lastConsonantIndex < lastConsonant {\n        lastConsonantIndex--\n\
    \    }\n    if lastConsonantIndex == lastConsonant {\n        return word[lastConsonantIndex]\n\
    \    }\n    if lastConsonantIndex > lastConsonant {\n        lastConsonantIndex--\n\
    \    }\n    if lastConsonantIndex == lastConsonant {\n        return word[lastConsonantIndex]\n\
    \    }\n    if lastConsonantIndex < lastConsonant {\n        lastConsonantIndex--\n\
    \    }\n    if lastConsonantIndex == lastConsonant {\n        return word[lastConsonantIndex]\n\
    \    }\n    if lastConsonantIndex > lastConsonant {\n        lastConsonantIndex--\n\
    \    }\n    if lastConsonantIndex == lastConsonant {\n        return word[lastConsonantIndex]\n\
    \    }\n    if lastConsonantIndex < lastConsonant {\n        lastConsonantIndex--\n\
    \    }\n    if lastConsonantIndex == lastConsonant {\n        return word[lastConsonantIndex]\n\
    \    }\n    if lastConsonantIndex > lastConsonant {\n        lastConsonantIndex--\n\
    \    }\n    if lastConsonantIndex == lastConsonant {\n        return word[lastConsonantIndex]\n\
    \    }\n    if last\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjypaeii6_test.go:93:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels) - 2\n    for _, v := range\
    \ vowels {\n        if word == v {\n            return v\n        }\n    }\n \
    \   for _, v := range vowels {\n        if word[len(word)-1:] == v {\n       \
    \     return v\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpjn7euh3r_test.go:64: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpjn7euh3r_test.go:64: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpjn7euh3r_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpjn7euh3r_test.go:64: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpjn7euh3r_test.go:64: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpjn7euh3r_test.go:64: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpjn7euh3r_test.go:64: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpjn7euh3r_test.go:64:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpjn7euh3r_test.go:64: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.007s\nFAIL\n"
  timestamp: 1660074646
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    for i := len(word) - 2; i >= 0; i-- {\n        if word[i] == word[i+1]\
    \ {\n            if strings.Contains(word, vowels[vowelsCount]) {\n          \
    \      return vowels[vowelsCount]\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr9aqdsww_test.go:27:12: undefined: strings

    /tmp/tmpr9aqdsww_test.go:40:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074646
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 2; i >= 0; i-- {\n        if word[i] == word[i+1] && word[i]\
    \ != \"\" {\n            if word[i] == \"a\" || word[i] == \"e\" || word[i] ==\
    \ \"i\" || word[i] == \"o\" || word[i] == \"u\" {\n                return word[i]\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjdv8r7i4_test.go:32:47: invalid operation: word[i] != "" (mismatched types
    byte and untyped string)

    /tmp/tmpjdv8r7i4_test.go:33:27: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmpjdv8r7i4_test.go:33:45: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmpjdv8r7i4_test.go:33:63: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmpjdv8r7i4_test.go:33:81: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmpjdv8r7i4_test.go:33:99: invalid operation: word[i] == "u" (mismatched
    types byte and untyped string)

    /tmp/tmpjdv8r7i4_test.go:34:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074646
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune(\"aeiou\")\n    vowel = append(vowel,\
    \ vowel...)\n    vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n\
    \    vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n  \
    \  vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel\
    \ = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel =\
    \ append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel = append(vowel,\
    \ vowel...)\n    vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n\
    \    vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n  \
    \  vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel\
    \ = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel =\
    \ append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel = append(vowel,\
    \ vowel...)\n    vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n\
    \    vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n  \
    \  vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel\
    \ = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel =\
    \ append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel = append(vowel,\
    \ vowel...)\n    vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n\
    \    vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n  \
    \  vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel\
    \ = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel =\
    \ append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel = append(vowel,\
    \ vowel...)\n    vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n\
    \    vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n  \
    \  vowel = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel\
    \ = append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel =\
    \ append(vowel, vowel...)\n    vowel = append(vowel, vowel...)\n    vowel = append(vowel\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppeh4uegv_test.go:79:25: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels) - len(strings.Split(word,\
    \ \"e\"))\n    vowelsCount += len(vowels) - len(strings.Split(word, \"i\"))\n\
    \    vowelsCount += len(vowels) - len(strings.Split(word, \"o\"))\n    vowelsCount\
    \ += len(vowels) - len(strings.Split(word, \"u\"))\n    if vowelsCount < 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= len(strings.Split(word, \"a\"\
    ))\n    vowelsCount -= len(strings.Split(word, \"e\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \"i\"))\n    vowelsCount -= len(strings.Split(word, \"o\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"u\"))\n    if vowelsCount < 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= len(strings.Split(word, \"A\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"E\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \"I\"))\n    vowelsCount -= len(strings.Split(word, \"O\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"U\"))\n    if vowelsCount < 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= len(strings.Split(word, \"a\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"e\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \"i\"))\n    vowelsCount -= len(strings.Split(word, \"o\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"u\"))\n    if vowelsCount < 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= len(strings.Split(word, \"A\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"E\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \"I\"))\n    vowelsCount -= len(strings.Split(word, \"O\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"U\"))\n    if vowelsCount < 0 {\n        return\
    \ \"\"\n    }\n    vowelsCount -= len(strings.Split(word, \"a\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"e\"))\n    vowelsCount -= len(strings.Split(word,\
    \ \"i\"))\n    vowelsCount -= len(strings.Split(word, \"o\"))\n    vowelsCount\
    \ -= len(strings.Split(word, \"u\"))\n    if vowelsCount < 0 {\n        return\
    \ \"\"\n    }\n    vowel\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1foabww0_test.go:73:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowel := \"\"\n    vowel_count\
    \ := 0\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   \
    \         vowel = word[i]\n            vowel_count++\n        }\n    }\n    if\
    \ vowel_count == 0 {\n        return \"\"\n    }\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u' {\n            if vowel_count > 1 {\n  \
    \              vowel = word[i]\n                vowel_count--\n            }\n\
    \        }\n    }\n    return vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp206xjlp6_test.go:28:21: cannot use word[i] (value of type byte) as type
    string in assignment

    /tmp/tmp206xjlp6_test.go:38:25: cannot use word[i] (value of type byte) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074646
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 3\n    vowelsLen -= 4\n    vowelsLen -= 5\n    vowelsLen -= 6\n    vowelsLen\
    \ -= 7\n    vowelsLen -= 8\n    vowelsLen -= 9\n    vowelsLen -= 10\n    vowelsLen\
    \ -= 11\n    vowelsLen -= 12\n    vowelsLen -= 13\n    vowelsLen -= 14\n    vowelsLen\
    \ -= 15\n    vowelsLen -= 16\n    vowelsLen -= 17\n    vowelsLen -= 18\n    vowelsLen\
    \ -= 19\n    vowelsLen -= 20\n    vowelsLen -= 21\n    vowelsLen -= 22\n    vowelsLen\
    \ -= 23\n    vowelsLen -= 24\n    vowelsLen -= 25\n    vowelsLen -= 26\n    vowelsLen\
    \ -= 27\n    vowelsLen -= 28\n    vowelsLen -= 29\n    vowelsLen -= 30\n    vowelsLen\
    \ -= 31\n    vowelsLen -= 32\n    vowelsLen -= 33\n    vowelsLen -= 34\n    vowelsLen\
    \ -= 35\n    vowelsLen -= 36\n    vowelsLen -= 37\n    vowelsLen -= 38\n    vowelsLen\
    \ -= 39\n    vowelsLen -= 40\n    vowelsLen -= 41\n    vowelsLen -= 42\n    vowelsLen\
    \ -= 43\n    vowelsLen -= 44\n    vowelsLen -= 45\n    vowelsLen -= 46\n    vowelsLen\
    \ -= 47\n    vowelsLen -= 48\n    vowelsLen -= 49\n    vowelsLen -= 50\n    vowelsLen\
    \ -= 51\n    vowelsLen -= 52\n    vowelsLen -= 53\n    vowelsLen -= 54\n    vowelsLen\
    \ -= 55\n    vowelsLen -= 56\n    vowelsLen -= 57\n    vowelsLen -= 58\n    vowelsLen\
    \ -= 59\n    vowelsLen -= 60\n    vowelsLen -= 61\n    vowelsLen -= 62\n    vowelsLen\
    \ -= 63\n    vowelsLen -= 64\n    vowelsLen -= 65\n    vowelsLen -= 66\n    vowelsLen\
    \ -= 67\n    vowelsLen -= 68\n    vowelsLen -= 69\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt5bue015_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8cow1pet_test.go:88:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if word[i] == word[len(word)-1] {\n            if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n                return word[i]\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv31ujgj2_test.go:37:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074646
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    \n    i := len(word) - 1\n    \n    for ; i>=0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            i -= vowelsLen\n        }\n    }\n    \n    if i == -1 {\n  \
    \      return \"\"\n    }\n    \n    return word[i]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd8ozimtr_test.go:38:12: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074646
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels) - len(strings.Split(word,\
    \ \"\")) - 1 // count vowels\n    vowelsCount += len(strings.Split(word, \"\"\
    )) - 1 // count consonants\n    vowelsCount -= len(strings.Split(word, \"\"))\
    \ - 1 // count vowels at the end\n    vowelsCount -= len(strings.Split(word, \"\
    \")) - 1 // count consonants at the end\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count vowels at the beginning\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count consonants at the beginning\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count vowels at the end\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count consonants at the end\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count vowels at the beginning\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count consonants at the beginning\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count vowels at the end\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count consonants at the end\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count vowels at the beginning\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count consonants at the beginning\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count vowels at the end\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count consonants at the end\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count vowels at the beginning\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count consonants at the beginning\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count vowels at the end\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count consonants at the end\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count vowels at the beginning\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count consonants at the beginning\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count vowels at the end\n    vowelsCount -= len(strings.Split(word,\
    \ \"\")) - 1 // count consonants at the end\n    vowelsCount -= len(strings.Split(word,\
    \ \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv5wopfx3_test.go:50:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n\
    \            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaisteg3t_test.go:33:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    \n    lastVowel := -1\n    lastConsonant := -1\n    lastConsonantLen := -1\n\
    \    \n    lastConsonantLen := len(word)\n    \n    for i := 0; i < len(word);\
    \ i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            lastVowel = i\n        }\n        if\
    \ word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i]\
    \ == 'U' {\n            lastVowel = i\n        }\n        if word[i] == word[i+1]\
    \ {\n            lastConsonant = i\n        }\n        if word[i] == word[i-1]\
    \ {\n            lastConsonant = i\n        }\n    }\n    \n    if lastVowel ==\
    \ -1 && lastConsonant == -1 {\n        return \"\"\n    }\n    \n    if lastVowel\
    \ == -1 {\n        lastVowel = lastConsonant - 1\n    }\n    if lastConsonant\
    \ == -1 {\n        lastConsonant = lastVowel + 1\n    }\n    \n    if lastConsonant\
    \ > lastVowel {\n        lastConsonant = lastVowel\n    }\n    \n    if lastConsonantLen\
    \ > lastVowel {\n        lastConsonantLen = lastVowel\n    }\n    \n    if lastConsonantLen\
    \ > lastVowel {\n        lastConsonantLen = lastVowel\n    }\n    \n    if lastConsonantLen\
    \ > lastVowel {\n        lastConsonantLen = lastVowel\n    }\n    \n    if lastConsonantLen\
    \ > lastVowel {\n        lastConsonantLen = lastVowel\n    }\n    \n    if lastConsonantLen\
    \ > lastVowel {\n        lastConsonantLen = lastVowel\n    }\n    \n    if lastConsonantLen\
    \ > lastVowel {\n        lastConsonantLen = lastVowel\n    }\n    \n    if lastConsonantLen\
    \ > lastVowel {\n        lastConsonantLen = lastVowel\n    }\n    \n    if lastConsonantLen\
    \ > lastVowel {\n        lastConsonantLen = lastVowel\n    }\n    \n    if lastConsonantLen\
    \ > lastVow\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd1dus4du_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    \n    i := len(word) - 1\n    \n    for i >= 0 {\n        if word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\
    \            i -= 1\n            continue\n        }\n        \n        if word[i]\
    \ == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U'\
    \ {\n            i -= 1\n            continue\n        }\n        \n        if\
    \ word[i] == 'y' || word[i] == 'u' || word[i] == 'Y' || word[i] == 'U' {\n   \
    \         i -= 1\n            continue\n        }\n        \n        if word[i]\
    \ == 'o' || word[i] == 'O' {\n            i -= 1\n            continue\n     \
    \   }\n        \n        if word[i] == 'e' || word[i] == 'E' {\n            i\
    \ -= 1\n            continue\n        }\n        \n        if word[i] == 'i' ||\
    \ word[i] == 'I' {\n            i -= 1\n            continue\n        }\n    \
    \    \n        if word[i] == 'a' || word[i] == 'A' {\n            i -= 1\n   \
    \         continue\n        }\n        \n        if word[i] == 'l' || word[i]\
    \ == 'L' {\n            i -= 1\n            continue\n        }\n        \n  \
    \      if word[i] == 's' || word[i] == 'S' {\n            i -= 1\n           \
    \ continue\n        }\n        \n        if word[i] == 'd' || word[i] == 'D' {\n\
    \            i -= 1\n            continue\n        }\n        \n        if word[i]\
    \ == 'f' || word[i] == 'F' {\n            i -= 1\n            continue\n     \
    \   }\n        \n        if word[i] == 'g' || word[i] == 'G' {\n            i\
    \ -= 1\n            continue\n        }\n        \n        if word[i] == 'p' ||\
    \ word[i] == 'P' {\n            i -= 1\n            continue\n        }\n    \
    \    \n        if word[i] == 'v' || word[i] == 'V' {\n            i -= 1\n   \
    \         continue\n        }\n        \n        if word[i] == 'z' || word[i]\
    \ == 'Z' {\n            i -= 1\n            continue\n        }\n        \n  \
    \      if word[i] == 'c' || word[i] == 'C' {\n            i -= 1\n           \
    \ continue\n        }\n        \n        if word[i] == 'm' || word[i] == 'M' {\n\
    \            i -= 1\n            continue\n        }\n        \n        if word[i]\
    \ == 'p' || word[i] == 'P' {\n            i -= 1\n            continue\n     \
    \   }\n        \n        if word[i] == 't' || word[i] == 'T' {\n            i\
    \ -= 1\n            continue\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n \
    \ candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiyjmezrc_test.go:123:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowelsCount\
    \ := 0\n    vowelsCount += len(word) - len(word[:len(word)-1])\n    for _, v :=\
    \ range vowels {\n        if word[len(word)-1:] == string(v) {\n            return\
    \ string(v)\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp5tj8ai27_test.go:59: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp5tj8ai27_test.go:59: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp5tj8ai27_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmp5tj8ai27_test.go:59: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmp5tj8ai27_test.go:59: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmp5tj8ai27_test.go:59: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp5tj8ai27_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp5tj8ai27_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp5tj8ai27_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074646
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount += 2\n    vowelsCount /= len(vowels)\n    vowelsCount\
    \ %= len(vowels)\n    vowelsCount \nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp64msvo7d_test.go:88:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    \n    i := len(word) - 1\n    \n    for i >= 0 {\n        if word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\
    \            i -= 1\n            continue\n        }\n        \n        if word[i]\
    \ == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U'\
    \ {\n            i -= 1\n            continue\n        }\n        \n        if\
    \ word[i] == word[i+1] {\n            i -= 1\n            continue\n        }\n\
    \        \n        if word[i] == word[i-1] {\n            i -= 1\n           \
    \ continue\n        }\n        \n        if word[i] == word[i+1] && word[i+1]\
    \ == word[i+2] {\n            i -= 2\n            continue\n        }\n      \
    \  \n        if word[i] == word[i-1] && word[i-1] == word[i-2] {\n           \
    \ i -= 2\n            continue\n        }\n        \n        if word[i] == word[i+1]\
    \ && word[i+1] == word[i-1] {\n            i -= 2\n            continue\n    \
    \    }\n        \n        if word[i] == word[i-1] && word[i-1] == word[i+1] {\n\
    \            i -= 2\n            continue\n        }\n        \n        if word[i]\
    \ == word[i-1] && word[i-1] == word[i+1] && word[i+1] == word[i+2] {\n       \
    \     i -= 3\n            continue\n        }\n        \n        if word[i] ==\
    \ word[i-1] && word[i-1] == word[i+1] && word[i+1] == word[i-1] {\n          \
    \  i -= 3\n            continue\n        }\n        \n        if word[i] == word[i+1]\
    \ && word[i+1] == word[i-1] && word[i-1] == word[i-2] {\n            i -= 3\n\
    \            continue\n        }\n        \n        if word[i] == word[i-1] &&\
    \ word[i-1] == word[i+1] && word[i+1] == word[i-1] {\n            i -= 3\n   \
    \         continue\n        }\n        \n        if word[i] == word[i-1] && word[i-1]\
    \ == word[i+1] && word[i+1] == word[i+2] {\n            i -= 4\n            continue\n\
    \        }\n        \n        if word[i] == word[i-1] && word[i-1] == word[i+1]\
    \ && word[i+1] == word[i-1] {\n            i -= 4\n            continue\n    \
    \    }\n        \n        if word[i] == word[i+1] && word[i+1] == word[i-1] &&\
    \ word[i-1] == word[i-2] {\n            i -= 4\n            continue\n       \
    \ }\n        \n        if word[i] == word[i-1] && word[i-1] == word[i+1] && word[i+1]\
    \ == word[i-1] {\n            i -= 4\n            continue\n        }\n      \
    \  \n        if word[i] == word[i-1] && word[i-1] == word[i+1] && word[i+1] ==\
    \ word[i+2] {\n            \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsylzypk8_test.go:111:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    vowel_start := 0\n    vowel_end := len(word) - 1\n    for i := 0;\
    \ i < len(word); i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowel_count++\n  \
    \          if vowel_count == 1 {\n                vowel_start = i\n          \
    \  }\n            if vowel_count == 2 {\n                vowel_end = i\n     \
    \       }\n        }\n    }\n    if vowel_start == 0 {\n        return \"\"\n\
    \    }\n    if vowel_end == len(word)-1 {\n        return \"\"\n    }\n    if\
    \ vowel_start == vowel_end {\n        return \"\"\n    }\n    if vowel_start >\
    \ vowel_end {\n        return \"\"\n    }\n    vowel_count := 0\n    vowel_start\
    \ := 0\n    vowel_end := len(word) - 1\n    for i := 0; i < len(word); i++ {\n\
    \        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            vowel_count++\n            if vowel_count ==\
    \ 1 {\n                vowel_start = i\n            }\n            if vowel_count\
    \ == 2 {\n                vowel_end = i\n            }\n        }\n    }\n   \
    \ if vowel_start == 0 {\n        return \"\"\n    }\n    if vowel_end == len(word)-1\
    \ {\n        return \"\"\n    }\n    if vowel_start == vowel_end {\n        return\
    \ \"\"\n    }\n    if vowel_start > vowel_end {\n        return \"\"\n    }\n\
    \    if vowel_start < vowel_end {\n        vowel_start := vowel_end - 1\n    \
    \    vowel_end := len(word)\n    }\n    if word[vowel_start] == 'a' || word[vowel_start]\
    \ == 'e' || word[vowel_start] == 'i' || word[vowel_start] == 'o' || word[vowel_start]\
    \ == 'u' {\n        return word[vowel_start]\n    }\n    if word[vowel_end] ==\
    \ 'a' || word[vowel_end] == 'e' || word[vowel_end] == 'i' || word[vowel_end] ==\
    \ 'o' || word[vowel_end] == 'u' {\n        return word[vowel_end]\n    }\n   \
    \ if word[vowel_start] == 'a' || word[vowel_start] == 'e' || word[vowel_start]\
    \ == 'i' || word[vowel_start] == 'o' || word[vowel_start] == 'u' {\n        return\
    \ word[vowel_start]\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9vyd1od5_test.go:88:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowelsLen\
    \ := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n\
    \    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpigvpr9bj_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074646
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 2\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if strings.Contains(word[i], \"a\") {\n            vowelsCount--\n\
    \        }\n        if strings.Contains(word[i], \"e\") {\n            vowelsCount--\n\
    \        }\n        if strings.Contains(word[i], \"i\") {\n            vowelsCount--\n\
    \        }\n        if strings.Contains(word[i], \"o\") {\n            vowelsCount--\n\
    \        }\n        if strings.Contains(word[i], \"u\") {\n            vowelsCount--\n\
    \        }\n        if vowelsCount == 0 {\n            return word[i]\n      \
    \  }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppp74log__test.go:26:12: undefined: strings

    /tmp/tmppp74log__test.go:35:12: undefined: strings

    /tmp/tmppp74log__test.go:38:12: undefined: strings

    /tmp/tmppp74log__test.go:41:12: undefined: strings

    /tmp/tmppp74log__test.go:44:12: undefined: strings

    /tmp/tmppp74log__test.go:47:12: undefined: strings

    /tmp/tmppp74log__test.go:51:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\n    vowelsLen += 2\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6hf0nt82_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    lastVowelIndex := len(word) - vowelsLen\n    \n    for i :=\
    \ 0; i < len(word); i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n            if i == lastVowelIndex\
    \ {\n                return word[i]\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj5lgpqba_test.go:34:24: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Write your code here\n    vowels := []string{\"a\"\
    , \"e\", \"i\", \"o\", \"u\"}\n    vowelsCount := 0\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount > 0 {\n        for _, v := range vowels {\n \
    \           if strings.Contains(word, v) {\n                vowelsCount--\n  \
    \          }\n        }\n    }\n    if vowelsCount < 0 {\n        return \"\"\n\
    \    }\n    vowelsCount -= 2\n    vowelsCount %= len(vowels)\n    return vowels[vowelsCount]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl496ogvj_test.go:27:12: undefined: strings

    /tmp/tmpl496ogvj_test.go:33:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    i := len(word) - 1\n    \n    for {\n        if i >= 0 {\n \
    \           if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] ==\
    \ 'o' || word[i] == 'u' {\n                i -= vowelsLen\n            } else\
    \ {\n                i -= 2\n            }\n        } else {\n            break\n\
    \        }\n    }\n    \n    if i >= 0 {\n        return vowels[i]\n    }\n  \
    \  return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpisqqznmw_test.go:74: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpisqqznmw_test.go:74: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpisqqznmw_test.go:74: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpisqqznmw_test.go:74: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpisqqznmw_test.go:74:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpisqqznmw_test.go:74: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n\
    \    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)\n    vowelsCount\
    \ += len(vowels)\n    vowelsCount += len(vowels)\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphopteei4_test.go:87:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074642
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Write your code here\n    vowel := \"\"\n    vowelCount\
    \ := 0\n    vowelIndex := len(word) - 1\n    for i := 0; i < len(word); i++ {\n\
    \        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            vowel = word[i]\n            vowelCount++\n\
    \        }\n    }\n    if vowelCount > 0 {\n        for i := len(word) - 1; i\
    \ >= 0; i-- {\n            if word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u' {\n                vowel = word[i]\n   \
    \             vowelCount++\n            }\n        }\n    }\n    if vowelCount\
    \ > 0 {\n        for i := len(word) - 1; i >= 0; i-- {\n            if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n                vowel = word[i]\n                vowelCount++\n         \
    \   }\n        }\n    }\n    if vowelCount > 0 {\n        for i := len(word) -\
    \ 1; i >= 0; i-- {\n            if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n                vowel = word[i]\n\
    \                vowelCount++\n            }\n        }\n    }\n    if vowelCount\
    \ > 0 {\n        for i := len(word) - 1; i >= 0; i-- {\n            if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n                vowel = word[i]\n                vowelCount++\n         \
    \   }\n        }\n    }\n    if vowelCount > 0 {\n        for i := len(word) -\
    \ 1; i >= 0; i-- {\n            if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n                vowel = word[i]\n\
    \                vowelCount++\n            }\n        }\n    }\n    if vowelCount\
    \ > 0 {\n        for i := len(word) - 1; i >= 0; i-- {\n            if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n                vowel = word[i]\n                vowelCount++\n         \
    \   }\n        }\n    }\n    if vowelCount > 0 {\n        for i := len(word) -\
    \ 1; i >= 0; i-- {\n            if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n                vowel\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpataxt2rv_test.go:85:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowel := \"\"\n    vowelCount :=\
    \ 0\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ vowel = word[i]\n            vowelCount++\n        }\n    }\n    if vowelCount\
    \ > 0 {\n        return vowel\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvrh2i_ii_test.go:28:21: cannot use word[i] (value of type byte) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    i := len(word) - 1\n    j := len(word) - 2\n    k :=\
    \ len(word) - 3\n    l := len(word) - 4\n    m := len(word) - 5\n    n := len(word)\
    \ - 6\n    o := len(word) - 7\n    p := len(word) - 8\n    q := len(word) - 9\n\
    \    r := len(word) - 10\n    s := len(word) - 11\n    t := len(word) - 12\n \
    \   u := len(word) - 13\n    v := len(word) - 14\n    w := len(word) - 15\n  \
    \  x := len(word) - 16\n    y := len(word) - 17\n    z := len(word) - 18\n   \
    \ \n    switch {\n    case word[i] >= 'a' && word[i] <= 'z':\n        i -= 1\n\
    \    case word[i] >= 'A' && word[i] <= 'Z':\n        i -= 1\n    case word[j]\
    \ >= 'a' && word[j] <= 'z':\n        j -= 1\n    case word[j] >= 'A' && word[j]\
    \ <= 'Z':\n        j -= 1\n    case word[k] >= 'a' && word[k] <= 'z':\n      \
    \  k -= 1\n    case word[k] >= 'A' && word[k] <= 'Z':\n        k -= 1\n    case\
    \ word[l] >= 'a' && word[l] <= 'z':\n        l -= 1\n    case word[l] >= 'A' &&\
    \ word[l] <= 'Z':\n        l -= 1\n    case word[m] >= 'a' && word[m] <= 'z':\n\
    \        m -= 1\n    case word[m] >= 'A' && word[m] <= 'Z':\n        m -= 1\n\
    \    case word[n] >= 'a' && word[n] <= 'z':\n        n -= 1\n    case word[n]\
    \ >= 'A' && word[n] <= 'Z':\n        n -= 1\n    case word[o] >= 'a' && word[o]\
    \ <= 'z':\n        o -= 1\n    case word[o] >= 'A' && word[o] <= 'Z':\n      \
    \  o -= 1\n    case word[p] >= 'a' && word[p] <= 'z':\n        p -= 1\n    case\
    \ word[p] >= 'A' && word[p] <= 'Z':\n        p -= 1\n    case word[q] >= 'a' &&\
    \ word[q] <= 'z':\n        q\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpucvodr2u_test.go:80:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    lastConsonant := len(word) - 1 // last consonant\n    lastVowel\
    \ := len(word) - 2 // last vowel\n    \n    lastConsonantVowel := word[lastConsonant]\n\
    \    lastVowelVowel := word[lastVowel]\n    \n    lastConsonantVowelIndex := -1\n\
    \    lastVowelVowelIndex := -1\n    \n    for i := 0; i < vowelsLen; i++ {\n \
    \       if word[lastConsonant] == vowels[i] {\n            lastConsonantVowelIndex\
    \ = i\n        }\n        if word[lastVowel] == vowels[i] {\n            lastVowelVowelIndex\
    \ = i\n        }\n    }\n    \n    if lastConsonantVowelIndex == -1 || lastVowelVowelIndex\
    \ == -1 {\n        return \"\"\n    }\n    \n    if lastConsonantVowelIndex >\
    \ lastVowelVowelIndex {\n        return word[lastConsonantVowelIndex+1 : lastVowelVowelIndex]\n\
    \    } else {\n        return word[lastVowelVowelIndex+1 : lastConsonantVowelIndex]\n\
    \    }\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6tvxjuey_test.go:32:5: lastConsonantVowel declared but not used

    /tmp/tmp6tvxjuey_test.go:33:5: lastVowelVowel declared but not used

    /tmp/tmp6tvxjuey_test.go:39:35: invalid operation: word[lastConsonant] == vowels[i]
    (mismatched types byte and string)

    /tmp/tmp6tvxjuey_test.go:42:31: invalid operation: word[lastVowel] == vowels[i]
    (mismatched types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if word == v {\n\
    \            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n    \
    \    return \"\"\n    }\n    vowelsCount -= 1\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmd4x1wcm_test.go:98:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount <= 1 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount\
    \ /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n   \
    \ vowelsCount /= 2\n    vowelsCount /= 2\n    vowelsCount /= 2\n    vowel\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmped8abt20_test.go:94:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n\
    \            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaisteg3t_test.go:33:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    i := len(word) - 1\n    \n    for ; i>=0; i-- {\n        if\
    \ word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i]\
    \ == 'u' {\n            i -= vowelsLen\n        } else {\n            i -= 2\n\
    \        }\n    }\n    \n    if i == -1 {\n        return \"\"\n    }\n    \n\
    \    return word[i]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbswe0d3u_test.go:43:12: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        if word[i] == word[len(word)-1] {\n\
    \            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaisteg3t_test.go:33:20: cannot use word[i] (value of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074641
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount == 0 {\n\
    \        return \"\"\n    }\n    vowelsCount -= 1\n    lastConsonant := strings.LastIndex(word,\
    \ \"\")\n    if lastConsonant == -1 {\n        return \"\"\n    }\n    lastConsonant\
    \ += 1 // skip the letter\n    lastConsonantLen := len(word) - lastConsonant\n\
    \    lastConsonantLen -= 1 // skip the letter\n    for _, v := range vowels {\n\
    \        if strings.Contains(word[v:], v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount > lastConsonantLen {\n        return \"\"\n \
    \   }\n    return word[lastConsonant:]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsy5abk2q_test.go:26:12: undefined: strings

    /tmp/tmpsy5abk2q_test.go:34:22: undefined: strings

    /tmp/tmpsy5abk2q_test.go:42:12: undefined: strings

    /tmp/tmpsy5abk2q_test.go:42:34: invalid argument: index v (variable of type string)
    must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvyobif7_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount == 0 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= len(vowels)\n    vowelsCount /= 2\n    if vowelsCount < 0 {\n        vowelsCount\
    \ = 0\n    }\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels)-1\n\
    \    }\n    vowelsCount *= 2\n    vowelsCount /= 2\n    if vowelsCount < 0 {\n\
    \        vowelsCount = 0\n    }\n    if vowelsCount > len(vowels)-1 {\n      \
    \  vowelsCount = len(vowels)-1\n    }\n    vowelsCount *= 2\n    vowelsCount /=\
    \ 2\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    if vowelsCount\
    \ > len(vowels)-1 {\n        vowelsCount = len(vowels)-1\n    }\n    vowelsCount\
    \ *= 2\n    vowelsCount /= 2\n    if vowelsCount < 0 {\n        vowelsCount =\
    \ 0\n    }\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels)-1\n\
    \    }\n    vowelsCount *= 2\n    vowelsCount /= 2\n    if vowelsCount < 0 {\n\
    \        vowelsCount = 0\n    }\n    if vowelsCount > len(vowels)-1 {\n      \
    \  vowelsCount = len(vowels)-1\n    }\n    vowelsCount *= 2\n    vowelsCount /=\
    \ 2\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    if vowelsCount\
    \ > len(vowels)-1 {\n        vowelsCount = len(vowels)-1\n    }\n    vowelsCount\
    \ *= 2\n    vowelsCount /= 2\n    if vowelsCount < 0 {\n        vowelsCount =\
    \ 0\n    }\n    if vowelsCount > len(vowels)-1 {\n        vowelsCount = len(vowels)-1\n\
    \    }\n    vowelsCount *= 2\n    vowelsCount /= 2\n    if vowelsCount < 0 {\n\
    \        vowelsCount = 0\n    }\n    if vowelsCount > len(vowels)-1 {\n      \
    \  vowelsCount = len(vowels)-1\n    }\n    vowelsCount *= 2\n    vowelsCount /=\
    \ 2\n    if vowelsCount < 0 {\n        vowelsCount = 0\n    }\n    if vowelsCount\
    \ > len(vowels)-1 {\n        vowel\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo1xd_2s7_test.go:105:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiouAEIOU\")\n    i := len(word) -\
    \ 1\n    result := \"\"\n    for i >= 0 {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ i -= 1\n            continue\n        }\n        if word[i] == 'A' || word[i]\
    \ == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n           \
    \ i -= 1\n            continue\n        }\n        if word[i] == 'y' || word[i]\
    \ == 'u' || word[i] == 'Y' || word[i] == 'U' {\n            i -= 1\n         \
    \   continue\n        }\n        if word[i] == 'o' || word[i] == 'O' {\n     \
    \       i -= 1\n            continue\n        }\n        if word[i] == 'e' ||\
    \ word[i] == 'E' {\n            i -= 1\n            continue\n        }\n    \
    \    if word[i] == 'i' || word[i] == 'I' {\n            i -= 1\n            continue\n\
    \        }\n        if word[i] == 'a' || word[i] == 'A' {\n            i -= 1\n\
    \            continue\n        }\n        if word[i] == 'l' || word[i] == 'L'\
    \ {\n            i -= 1\n            continue\n        }\n        if word[i] ==\
    \ 's' || word[i] == 'S' {\n            i -= 1\n            continue\n        }\n\
    \        if word[i] == 'd' || word[i] == 'D' {\n            i -= 1\n         \
    \   continue\n        }\n        if word[i] == 'f' || word[i] == 'F' {\n     \
    \       i -= 1\n            continue\n        }\n        if word[i] == 'g' ||\
    \ word[i] == 'G' {\n            i -= 1\n            continue\n        }\n    \
    \    if word[i] == 'h' || word[i] == 'H' {\n            i -= 1\n            continue\n\
    \        }\n        if word[i] == 'j' || word[i] == 'J' {\n            i -= 1\n\
    \            continue\n        }\n        if word[i] == 'k' || word[i] == 'K'\
    \ {\n            i -= 1\n            continue\n        }\n        if word[i] ==\
    \ 'm' || word[i] == 'M' {\n            i -= 1\n            continue\n        }\n\
    \        if word[i] == 'p' || word[i] == 'P' {\n            i -= 1\n         \
    \   continue\n        }\n        if word[i] == 'q' || word[i] == 'Q' {\n     \
    \       i -= 1\n            continue\n        }\n        if word[i] == 'z' ||\
    \ word[i] == 'Z' {\n            i -= 1\n            continue\n        }\n    \
    \    if word[i] == 'x' || word[i] == 'X' {\n            i -= 1\n            continue\n\
    \        }\n        if word[i] == 'c' || word[i] == 'C' {\n            i -= 1\n\
    \            continue\n        }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc61yl22e_test.go:112:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 3\n    vowelsLen -= 4\n    vowelsLen -= 5\n    vowelsLen -= 6\n    vowelsLen\
    \ -= 7\n    vowelsLen -= 8\n    vowelsLen -= 9\n    vowelsLen -= 10\n    vowelsLen\
    \ -= 11\n    vowelsLen -= 12\n    vowelsLen -= 13\n    vowelsLen -= 14\n    vowelsLen\
    \ -= 15\n    vowelsLen -= 16\n    vowelsLen -= 17\n    vowelsLen -= 18\n    vowelsLen\
    \ -= 19\n    vowelsLen -= 20\n    vowelsLen -= 21\n    vowelsLen -= 22\n    vowelsLen\
    \ -= 23\n    vowelsLen -= 24\n    vowelsLen -= 25\n    vowelsLen -= 26\n    vowelsLen\
    \ -= 27\n    vowelsLen -= 28\n    vowelsLen -= 29\n    vowelsLen -= 30\n    vowelsLen\
    \ -= 31\n    vowelsLen -= 32\n    vowelsLen -= 33\n    vowelsLen -= 34\n    vowelsLen\
    \ -= 35\n    vowelsLen -= 36\n    vowelsLen -= 37\n    vowelsLen -= 38\n    vowelsLen\
    \ -= 39\n    vowelsLen -= 40\n    vowelsLen -= 41\n    vowelsLen -= 42\n    vowelsLen\
    \ -= 43\n    vowelsLen -= 44\n    vowelsLen -= 45\n    vowelsLen -= 46\n    vowelsLen\
    \ -= 47\n    vowelsLen -= 48\n    vowelsLen -= 49\n    vowelsLen -= 50\n    vowelsLen\
    \ -= 51\n    vowelsLen -= 52\n    vowelsLen -= 53\n    vowelsLen -= 54\n    vowelsLen\
    \ -= 55\n    vowelsLen -= 56\n    vowelsLen -= 57\n    vowelsLen -= 58\n    vowelsLen\
    \ -= 59\n    vowelsLen -= 60\n    vowelsLen -= 61\n    vowelsLen -= 62\n    vowelsLen\
    \ -= 63\n    vowelsLen -= 64\n    vowelsLen -= 65\n    vowelsLen -= 66\n    vowelsLen\
    \ -= 67\n    vowelsLen -= 68\n    vowelsLen -= 69\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt5bue015_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\n    vowelsLen /= 2\n    vowelsLen += 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 1\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcv4si1u_test.go:100:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074643
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    return vowels[vowelsCount]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_t6bqnu_test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen += 2\n    \n    lastConsonant := false\n  \
    \  lastVowel := false\n    lastVowelLen := 0\n    \n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        c := word[i]\n        if lastConsonant {\n          \
    \  if c == lastVowel {\n                lastVowelLen = i - lastVowel\n       \
    \         if lastVowelLen < 0 {\n                    return \"\"\n           \
    \     }\n                if lastVowelLen > vowelsLen {\n                    return\
    \ \"\"\n                }\n                \n                if lastVowelLen <\
    \ vowelsLen {\n                    return \"\"\n                }\n          \
    \      \n                if lastVowelLen > 0 {\n                    lastVowel\
    \ = vowels[lastVowelLen]\n                }\n                \n              \
    \  lastConsonant = false\n                lastVowel = false\n                lastVowelLen\
    \ = 0\n            } else {\n                lastConsonant = false\n         \
    \       lastVowel = false\n                lastVowelLen = 0\n            }\n \
    \       } else {\n            if c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u' {\n                lastConsonant = true\n                lastVowel\
    \ = c\n                lastVowelLen = 0\n            }\n        }\n    }\n   \
    \ return lastVowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7tcmfrh0_test.go:35:21: invalid operation: c == lastVowel (mismatched
    types byte and bool)

    /tmp/tmp7tcmfrh0_test.go:36:32: invalid operation: i - lastVowel (mismatched types
    int and bool)

    /tmp/tmp7tcmfrh0_test.go:49:33: cannot use vowels[lastVowelLen] (variable of type
    rune) as type bool in assignment

    /tmp/tmp7tcmfrh0_test.go:63:29: cannot use c (variable of type byte) as type bool
    in assignment

    /tmp/tmp7tcmfrh0_test.go:68:12: cannot use lastVowel (variable of type bool) as
    type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if word == v {\n            return v\n        }\n    }\n    vowelsCount\
    \ += len(word) - len(vowels)\n    for _, v := range word {\n        if v == 'a'\
    \ || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n            vowelsCount +=\
    \ 1\n        }\n    }\n    if vowelsCount > len(vowels)-1 {\n        return \"\
    \"\n    }\n    vowelsCount -= len(vowels)\n    for _, v := range vowels {\n  \
    \      if word == v {\n            return v\n        }\n    }\n    vowelsCount\
    \ -= len(word) - len(vowels)\n    for _, v := range word {\n        if v == 'a'\
    \ || v == 'e' || v == 'i' || v == 'o' || v == 'u' {\n            vowelsCount +=\
    \ 1\n        }\n    }\n    if vowelsCount < 0 {\n        return \"\"\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp6dqflxh2_test.go:83: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp6dqflxh2_test.go:83: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp6dqflxh2_test.go:83: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp6dqflxh2_test.go:83: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp6dqflxh2_test.go:83:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp6dqflxh2_test.go:83: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074648
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n   \
    \ \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen\
    \ -= 1\n    vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen\
    \ /= 2\n    vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n   \
    \ vowelsLen += 2\n    \n    vowelsLen -= 1\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    \n    vowel\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfeq5wq40_test.go:114:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    vowelsLen -= 1\n    vowelsLen /= 2\n    \n    i := len(word) - 1\n    \n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ vowelsLen -= 1\n        }\n        if word[i] == 'y' && word[i-1] == 'u' &&\
    \ word[i-2] == 'g' && word[i-3] == 'r' && word[i-4] == 't' {\n            vowelsLen\
    \ -= 1\n        }\n        if word[i] == 'a' && word[i-1] == 'b' && word[i-2]\
    \ == 'c' && word[i-3] == 'd' && word[i-4] == 'e' && word[i-5] == 'f' && word[i-6]\
    \ == 'g' && word[i-7] == 'h' && word[i-8] == 'i' && word[i-9] == 'j' && word[i-10]\
    \ == 'k' && word[i-11] == 'l' && word[i-12] == 'm' && word[i-13] == 'n' && word[i-14]\
    \ == 'o' && word[i-15] == 'p' && word[i-16] == 'q' && word[i-17] == 'r' && word[i-18]\
    \ == 's' && word[i-19] == 't' && word[i-20] == 'u' && word[i-21] == 'v' && word[i-22]\
    \ == 'w' && word[i-23] == 'x' && word[i-24] == 'y' && word[i-25] == 'z' {\n  \
    \          vowelsLen -= 1\n        }\n        if word[i] == 'a' && word[i-1] ==\
    \ 'b' && word[i-2] == 'c' && word[i-3] == 'd' && word[i-4] == 'e' && word[i-5]\
    \ == 'f' && word[i-6] == 'g' && word[i-7] == 'h' && word[i-8] == 'i' && word[i-9]\
    \ == 'j' && word[i-10] == 'k' && word[i-11] == 'l' && word[i-12] == 'm' && word[i-13]\
    \ == 'n' && word[i-14] == 'o' && word[i-15] == 'p' && word[i-16] == 'q' && word[i-17]\
    \ == 'r' && word[i-18] == 's' && word[i-19] == 't' && word[i-20] == 'u' && word[i-21]\
    \ == 'v' && word[i-22] == 'w' && word[i-23] == 'x' && word[i-24] == 'y' && word[i-25]\
    \ == 'z' && word[i-26] == 'a' && word[i-27] == 'b' && word[i-28] == 'c' && word[i-29]\
    \ == 'd' && word[i-30] == 'e' && word[i-31] == 'f\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj74xqqza_test.go:40:665: rune literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []rune(\"aeiouAEIOU\"\
    )\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    i := len(word) - 1\n\
    \    j := len(word) - 1\n    k := len(word) - 1\n    l := len(word) - 1\n    m\
    \ := len(word) - 1\n    n := len(word) - 1\n    o := len(word) - 1\n    p := len(word)\
    \ - 1\n    q := len(word) - 1\n    r := len(word) - 1\n    s := len(word) - 1\n\
    \    t := len(word) - 1\n    u := len(word) - 1\n    v := len(word) - 1\n    w\
    \ := len(word) - 1\n    x := len(word) - 1\n    y := len(word) - 1\n    z := len(word)\
    \ - 1\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe0tspukb_test.go:221:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowel := \"\"\n    vowels := []string{\"\
    a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if word[i] == \"a\" || word[i] == \"e\" || word[i] == \"i\" || word[i]\
    \ == \"o\" || word[i] == \"u\" {\n            vowel = word[i]\n            break\n\
    \        }\n    }\n    if vowel != \"\" {\n        return vowel\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfe0i_j9k_test.go:25:5: vowels declared but not used

    /tmp/tmpfe0i_j9k_test.go:27:23: invalid operation: word[i] == "a" (mismatched
    types byte and untyped string)

    /tmp/tmpfe0i_j9k_test.go:27:41: invalid operation: word[i] == "e" (mismatched
    types byte and untyped string)

    /tmp/tmpfe0i_j9k_test.go:27:59: invalid operation: word[i] == "i" (mismatched
    types byte and untyped string)

    /tmp/tmpfe0i_j9k_test.go:27:77: invalid operation: word[i] == "o" (mismatched
    types byte and untyped string)

    /tmp/tmpfe0i_j9k_test.go:27:95: invalid operation: word[i] == "u" (mismatched
    types byte and untyped string)

    /tmp/tmpfe0i_j9k_test.go:28:21: cannot use word[i] (value of type byte) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen\
    \ -= 2\n    vowelsLen -= 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4oq0vvz_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    return vowels[vowelsCount]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_t6bqnu_test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    vowelsLen := len(vowels)\n\
    \    vowelsCount := 0\n    vowelsIndex := 0\n    vowelsIndexMax := len(word) -\
    \ vowelsLen - 1\n    for i := 0; i < len(word); i++ {\n        if word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\
    \            vowelsCount++\n        }\n        if vowelsCount > vowelsIndexMax\
    \ {\n            vowelsIndex = i\n            vowelsIndexMax = vowelsCount\n \
    \       }\n    }\n    if vowelsCount > vowelsIndexMax {\n        return \"\"\n\
    \    }\n    return word[vowelsIndex+1 : vowelsIndex+vowelsLen]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:8] with length 6 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:8] with length 6\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_closest_vowel({0x51e876?, 0xc00006f508?})\n\
    \t/tmp/tmpav43x_dk_test.go:40 +0xad\ncommand-line-arguments_test.TestGet_Closest_Vowel(0x0?)\n\
    \t/tmp/tmpav43x_dk_test.go:50 +0x4d\ntesting.tRunner(0xc000134000, 0x528fa0)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n"
  timestamp: 1660074648
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel := []rune{'a', 'e', 'i', 'o', 'u'}\n    vowel_count\
    \ := 0\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' ||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n   \
    \         vowel_count++\n        }\n    }\n    if vowel_count > 0 {\n        vowel_count\
    \ -= 1\n    }\n    if vowel_count < 0 {\n        vowel_count = 0\n    }\n    if\
    \ vowel_count == 0 {\n        return \"\"\n    }\n    vowel_count += 2\n    i\
    \ := len(word) - 1\n    j := len(word) - 1\n    k := len(word) - 1\n    l := len(word)\
    \ - 1\n    m := len(word) - 1\n    n := len(word) - 1\n    o := len(word) - 1\n\
    \    p := len(word) - 1\n    q := len(word) - 1\n    r := len(word) - 1\n    s\
    \ := len(word) - 1\n    t := len(word) - 1\n    u := len(word) - 1\n    v := len(word)\
    \ - 1\n    w := len(word) - 1\n    x := len(word) - 1\n    y := len(word) - 1\n\
    \    z := len(word) - 1\n    switch {\n    case word[i] == 'a' || word[i] == 'e'\
    \ || word[i] == 'i' || word[i] == 'o' || word[i] == 'u':\n        i += 2\n   \
    \ case word[j] == 'a' || word[j] == 'e' || word[j] == 'i' || word[j] == 'o' ||\
    \ word[j] == 'u':\n        j -= 2\n    case word[k] == 'a' || word[k] == 'e' ||\
    \ word[k] == 'i' || word[k] == 'o' || word[k] == 'u':\n        k -= 2\n    case\
    \ word[l] == 'a' || word[l] == 'e' || word[l] == 'i' || word[l] == 'o' || word[l]\
    \ == 'u':\n        l -= 2\n    case word[m] == 'a' || word[m] == 'e' || word[m]\
    \ == 'i' || word[m] == 'o' || word[m] == 'u':\n        m -= 2\n    case word[n]\
    \ == 'a' || word[n] == 'e' || word[n] == 'i' || word[n] == 'o' || word[n] == 'u':\n\
    \        n -= 2\n    case word[o] == 'a' || word[o] == 'e' || word[o] == 'i' ||\
    \ word[o] == 'o' || word[o] == 'u':\n        o -= 2\n    case word[p] == 'a' ||\
    \ word[p] == 'e' || word[p] == 'i' || word[p] == 'o' || word[p] == 'u':\n    \
    \    p -= 2\n    case word[q] == 'a' || word\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm5byvnk1_test.go:75:32: expected '':'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    vowels := []string{\"a\", \"e\"\
    , \"i\", \"o\", \"u\"}\n    vowelsLen := len(vowels)\n    vowelsLen -= 1\n   \
    \ vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n\
    \    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen +=\
    \ 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\n    vowelsLen /= 2\n    vowelsLen += 2\n    vowelsLen /= 2\n    vowelsLen\
    \ += 2\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5eu5y28m_test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsLen := len(vowels)\n    vowelsLen -= 1\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen += 2\n    vowelsLen\
    \ -= 2\n    vowelsLen += 2\n    vowelsLen -= 2\n    vowelsLen \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphy7oiqg__test.go:95:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    vowelsCount += len(vowels)/2\n\
    \    vowelsCount += len(vowels)/3\n    vowelsCount += len(vowels)/4\n    vowelsCount\
    \ += len(vowels)/5\n    vowelsCount += len(vowels)/6\n    vowelsCount += len(vowels)/7\n\
    \    vowelsCount += len(vowels)/8\n    vowelsCount += len(vowels)/9\n    vowelsCount\
    \ += len(vowels)/10\n    vowelsCount += len(vowels)/11\n    vowelsCount += len(vowels)/12\n\
    \    vowelsCount += len(vowels)/13\n    vowelsCount += len(vowels)/14\n    vowelsCount\
    \ += len(vowels)/15\n    vowelsCount += len(vowels)/16\n    vowelsCount += len(vowels)/17\n\
    \    vowelsCount += len(vowels)/18\n    vowelsCount += len(vowels)/19\n    vowelsCount\
    \ += len(vowels)/20\n    vowelsCount += len(vowels)/21\n    vowelsCount += len(vowels)/22\n\
    \    vowelsCount += len(vowels)/23\n    vowelsCount += len(vowels)/24\n    vowelsCount\
    \ += len(vowels)/25\n    vowelsCount += len(vowels)/26\n    vowelsCount += len(vowels)/27\n\
    \    vowelsCount += len(vowels)/28\n    vowelsCount += len(vowels)/29\n    vowelsCount\
    \ += len(vowels)/30\n    vowelsCount += len(vowels)/31\n    vowelsCount += len(vowels)/32\n\
    \    vowelsCount += len(vowels)/33\n    vowelsCount += len(vowels)/34\n    vowelsCount\
    \ += len(vowels)/35\n    vowelsCount += len(vowels)/36\n    vowelsCount += len(vowels)/37\n\
    \    vowelsCount += len(vowels)/38\n    vowelsCount += len(vowels)/39\n    vowelsCount\
    \ += len(vowels)/40\n    vowelsCount += len(vowels)/41\n    vowelsCount += len(vowels)/42\n\
    \    vowelsCount += len(vowels)/43\n    vowelsCount += len(vowels)/44\n    vowelsCount\
    \ += len(vowels)/45\n    vowelsCount += len(vowels)/46\n    vowelsCount += len(vowels)/47\n\
    \    vowelsCount += len(vowels)/48\n    vowelsCount += len(vowels)/49\n    vowels\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt9m6ef6a_test.go:75:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074639
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    for _, v := range vowels {\n        if strings.Contains(word,\
    \ v) {\n            vowelsCount++\n        }\n    }\n    if vowelsCount > 0 {\n\
    \        vowelsCount -= 1\n    }\n    if vowelsCount == 0 {\n        return \"\
    \"\n    }\n    lastConsonant := false\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if strings.Contains(word[i], \"a\") {\n            lastConsonant\
    \ = true\n            break\n        }\n    }\n    if lastConsonant {\n      \
    \  return \"\"\n    }\n    lastVowel := false\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if strings.Contains(word[i], \"e\") {\n            lastVowel\
    \ = true\n            break\n        }\n    }\n    if lastVowel {\n        return\
    \ \"\"\n    }\n    lastConsonant = false\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        if strings.Contains(word[i], \"i\") {\n            lastConsonant\
    \ = true\n            break\n        }\n    }\n    if lastConsonant {\n      \
    \  return \"\"\n    }\n    lastVowel = false\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if strings.Contains(word[i], \"o\") {\n            lastVowel\
    \ = true\n            break\n        }\n    }\n    if lastVowel {\n        return\
    \ \"\"\n    }\n    lastConsonant = false\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        if strings.Contains(word[i], \"u\") {\n            lastConsonant\
    \ = true\n            break\n        }\n    }\n    if lastConsonant {\n      \
    \  return \"\"\n    }\n    return word[len(word)-1]\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnd1fe_o5_test.go:26:12: undefined: strings

    /tmp/tmpnd1fe_o5_test.go:38:12: undefined: strings

    /tmp/tmpnd1fe_o5_test.go:48:12: undefined: strings

    /tmp/tmpnd1fe_o5_test.go:58:12: undefined: strings

    /tmp/tmpnd1fe_o5_test.go:68:12: undefined: strings

    /tmp/tmpnd1fe_o5_test.go:78:12: undefined: strings

    /tmp/tmpnd1fe_o5_test.go:86:12: cannot use word[len(word) - 1] (value of type
    byte) as type string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074647
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    vowelsCount := 0\n    vowelsCount += len(vowels)\n    for _, v := range vowels\
    \ {\n        if strings.Contains(word, v) {\n            vowelsCount++\n     \
    \   }\n    }\n    if vowelsCount < 2 {\n        return \"\"\n    }\n    vowelsCount\
    \ -= 2\n    vowelsCount /= 2\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount %= len(vowels)\n    vowelsCount\
    \ += 2\n    vowelsCount /= len(vowels)\n    vowelsCount \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8cow1pet_test.go:88:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074645
