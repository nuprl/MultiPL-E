language: go_test.go
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // We need to perform N right shift operations to\
    \ get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decreasing order.\n    // We need to perform N right shift operations\
    \ to get non-decre\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjwrsfi1m_test.go:69:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ i == len(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp96xkh7m4_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp96xkh7m4_test.go:59\
    \ +0x505\ntesting.tRunner(0xc0001a0340, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[i+1] {\n            shift -= 1\n            arr[i], arr[i+1] =\
    \ arr[i+1], arr[i]\n        }\n    }\n    \n    return arr[0] == 0\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpkp1x2xmz_test.go:37\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpkp1x2xmz_test.go:53\
    \ +0x51f\ntesting.tRunner(0xc0001a0340, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on arr[0] i.e. arr[0]\n  \
    \  // will be moved to arr[1] and arr[1] will be moved to arr[2] and so on.\n\
    \    // We will keep track of how many times we perform right shift operation\
    \ on\n    // arr[0]. \n    var count int = 0\n    for i := 0; i < len(arr); i++\
    \ {\n        // We will perform right shift operation on arr[i] i.e. arr[i] will\
    \ be\n        // moved to arr[i+1] and arr[i+1] will be moved to arr[i+2] and\
    \ so on.\n        // We will keep track of how many times we perform right shift\
    \ operation on\n        // arr[i]. \n        count += 1 \n        arr[i] = arr[i+1]\n\
    \        arr[i+1] = arr[i+2]\n        arr[i+2] = arr[i+3]\n        arr[i+3] =\
    \ arr[i]\n    }\n    \n    // We will perform right shift operation on arr[0]\
    \ i.e. arr[0] will be\n    // moved to arr[1] and arr[1] will be moved to arr[2]\
    \ and so on.\n    // We will keep track of how many times we perform right shift\
    \ operation on\n    // arr[0]. \n    count += 1 \n    arr[0] = arr[1]\n    arr[1]\
    \ = arr[2]\n    arr[2] = arr[3]\n    arr[3] = arr[0]\n    \n    // We will perform\
    \ right shift operation on arr[0] i.e. arr[0] will be\n    // moved to arr[1]\
    \ and arr[1] will be moved to arr[2] and so on.\n    // We will keep track of\
    \ how many times we perform right shift operation on\n    // arr[0]. \n    count\
    \ += 1 \n    arr[0] = arr[1]\n    arr[1] = arr[2]\n    arr[2] = arr[3]\n    arr[3]\
    \ = arr[0]\n    \n    // We will perform right shift operation on arr[0] i.e.\
    \ arr[0] will be\n    // moved to arr[1] and arr[1] will be moved to arr[2] and\
    \ so on.\n    // We will keep track of how many times we perform right shift operation\
    \ on\n    // arr[0]. \n    count += 1 \n    arr[0] = arr[1]\n    arr[1] = arr[2]\n\
    \    arr[2] = arr[3]\n    arr[3] = arr[0]\n    \n    // We will perform right\
    \ shift operation on arr[0] i.e. arr[0] will be\n    // moved to arr[1] and arr[1]\
    \ will be moved to arr[2] and so on.\n    // We will keep track of how many times\
    \ we perform right shift operation on\n    // arr[0]. \n    count += 1 \n    arr[0]\
    \ = arr[1]\n    arr[1] = arr[2]\n    arr[2] = arr[3]\n    arr[3] = arr[0]\n  \
    \  \n    // We will perform right shift operation on arr[0] i.e. arr[0] \nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp48dxy83u_test.go:92:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp913afi64_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp913afi64_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else if i == j {\n            break\n        } else {\n    \
    \        i++\n            j--\n        }\n    }\n    \n    return false\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpvbs27t6t_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpvbs27t6t_test.go:62\
    \ +0x532\ntesting.tRunner(0xc00019b1e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else if arr[i] < arr[j] {\n            i++\n        } else {\n\
    \            j--\n        }\n        if i == j {\n            break\n        }\n\
    \    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpixyssw9y_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpixyssw9y_test.go:63\
    \ +0x532\ntesting.tRunner(0xc0001924e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp913afi64_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp913afi64_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp3wkjr3yk_test.go:29 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    shift -= 1\n    \n    for\
    \ i := 0; i < shift; i++ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n\
    \    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpp1od75pl_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpp1od75pl_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i = i -\
    \ 1\n            j = j - 1\n        } else {\n            break\n        }\n \
    \   }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp3pel1f5o_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp3pel1f5o_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of shifts performed so far\n    // and\
    \ we will keep track of the last element of the list \n    // and we will keep\
    \ track of the last element of the list \n    // and we will keep track of the\
    \ last element of the list \n    // and we will keep track of the last element\
    \ of the list \n    // and we will keep track of the last element of the list\
    \ \n    // and we will keep track of the last element of the list \n    // and\
    \ we will keep track of the last element of the list \n    // and we will keep\
    \ track of the last element of the list \n    // and we will keep track of the\
    \ last element of the list \n    // and we will keep track of the last element\
    \ of the list \n    // and we will keep track of the last element of the list\
    \ \n    // and we will keep track of the last element of the list \n    // and\
    \ we will keep track of the last element of the list \n    // and we will keep\
    \ track of the last element of the list \n    // and we will keep track of the\
    \ last element of the list \n    // and we will keep track of the last element\
    \ of the list \n    // and we will keep track of the last element of the list\
    \ \n    // and we will keep track of the last element of the list \n    // and\
    \ we will keep track of the last element of the list \n    // and we will keep\
    \ track of the last element of the list \n    // and we will keep track of the\
    \ last element of the list \n    // and we will keep track of the last element\
    \ of the list \n    // and we will keep track of the last element of the list\
    \ \n    // and we will keep track of the last element of the list \n    // and\
    \ we will keep track of the last element of the list \n    // and we will keep\
    \ track of the last element of the list \n    // and we will keep track of the\
    \ last element of the list \n    // and we will keep track of the last element\
    \ of the list \n    // and we will keep track of the last element of the list\
    \ \n    // and we will keep track of the last element of the list \n    // and\
    \ we will keep track of the last element of the list \n    // and we will keep\
    \ track of the last element of the list \n    // and we will keep track of the\
    \ last element of the list \n    // and we will keep track of the last element\
    \ of the list \n    // and we will keep track of the last element of the list\
    \ \n    // and we will keep track of the last element of the list \n    // and\
    \ we will keep track of the last element of the list \n    // and we will keep\
    \ track of the last element of the list \n    // and we will keep track of the\
    \ last element of the list \n    // and we will keep track of the last element\
    \ of the list \n    // and we will keep track of the last element of the list\
    \ \n    // and we will keep track of the last element of the list \n    // and\
    \ we will keep track of the last element of the list \n    // and we will keep\
    \ track of the last element of the list \n    // and we will keep \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpslqmu9w3_test.go:80:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ i != len(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp660zx9ov_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp660zx9ov_test.go:59\
    \ +0x505\ntesting.tRunner(0xc0001a0340, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // If there are more than 1 element in the array then\
    \ we cannot perform \n    // any operation on the given array and hence return\
    \ false.\n    if n > 1 {\n        return false\n    }\n    \n    // If there are\
    \ only 1 element in the array then we cannot perform any \n    // operation on\
    \ the given array and hence return false.\n    if n == 1 {\n        return false\n\
    \    }\n    \n    // If the array has only 1 element then we cannot perform any\
    \ operation \n    // on the given array and hence return false.\n    if arr[0]\
    \ == 1 {\n        return false\n    }\n    \n    // If the array has only 2 elements\
    \ then we cannot perform any operation \n    // on the given array and hence return\
    \ false.\n    if arr[0] == arr[1] {\n        return false\n    }\n    \n    //\
    \ If the array has only 3 elements then we cannot perform any operation \n   \
    \ // on the given array and hence return false.\n    if arr[0] == arr[1]+1 {\n\
    \        return false\n    }\n    \n    // If the array has only 4 elements then\
    \ we cannot perform any operation \n    // on the given array and hence return\
    \ false.\n    if arr[0] == arr[1]+2 {\n        return false\n    }\n    \n   \
    \ // If the array has only 5 elements then we cannot perform any operation \n\
    \    // on the given array and hence return false.\n    if arr[0] == arr[1]+3\
    \ {\n        return false\n    }\n    \n    // If the array has only 6 elements\
    \ then we cannot perform any operation \n    // on the given array and hence return\
    \ false.\n    if arr[0] == arr[1]+4 {\n        return false\n    }\n    \n   \
    \ // If the array has only 7 elements then we cannot perform any operation \n\
    \    // on the given array and hence return false.\n    if arr[0] == arr[1]+5\
    \ {\n        return false\n    }\n    \n    // If the array has only 8 elements\
    \ then we cannot perform any operation \n    // on the given array and hence return\
    \ false.\n    if arr[0] == arr[1]+6 {\n        return false\n    }\n    \n   \
    \ // If the array has only 9 elements then we cannot perform any operation \n\
    \    // on the given array and hence return false.\n    if arr[0] == arr[1]+7\
    \ {\n        return false\n    }\n    \n    // If the array has only 10 elements\
    \ then we cannot perform any operation \n    // on the given array and hence return\
    \ false.\n    if arr[0] == arr[1]+8 {\n        return false\n    }\n    \n   \
    \ // If the array has only 11 elements then we cannot perform any operation \n\
    \    // on the given array and hence return false.\n    if arr[0] == arr[1]+\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2_cg7onw_test.go:111:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return arr[0] == 0\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmprhl2ujh0_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmprhl2ujh0_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    for j := len(arr) - 2; j >=0; j-- {\n        if arr[j]\
    \ > arr[j+1] {\n            arr[j], arr[j+1] = arr[j+1], arr[j]\n            i\
    \ = j\n        }\n    }\n    arr[0], arr[1] = arr[1], arr[0]\n    return move_one_ball(arr[:i])\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpm3j7_5gu_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpm3j7_5gu_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp913afi64_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp913afi64_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We have two pointers left and right to traverse the given array\n    //\
    \ arr[0] will be the starting point and arr[N-1] will be the end point\n    //\
    \ left will point to the first element of the array and right will point to\n\
    \    // the last element of the array\n    left := 0\n    right := len(arr) -\
    \ 1\n    \n    // We will keep track of the number of right shift operations performed\
    \ \n    // till now and will keep track of the number of right shift operations\n\
    \    // performed till now and will keep track of the number of right shift\n\
    \    // operations performed till now and will keep track of the number of right\n\
    \    // shift operations performed till now and will keep track of the number\
    \ of right\n    // shift operations performed till now and will keep track of\
    \ the number of right\n    // shift operations performed till now and will keep\
    \ track of the number of right\n    // shift operations performed till now and\
    \ will keep track of the number of right\n    // shift operations performed till\
    \ now and will keep track of the number of right\n    // shift operations performed\
    \ till now and will keep track of the number of right\n    // shift operations\
    \ performed till now and will keep track of the number of right\n    // shift\
    \ operations performed till now and will keep track of the number of right\n \
    \   // shift operations performed till now and will keep track of the number of\
    \ right\n    // shift operations performed till now and will keep track of the\
    \ number of right\n    // shift operations performed till now and will keep track\
    \ of the number of right\n    // shift operations performed till now and will\
    \ keep track of the number of right\n    // shift operations performed till now\
    \ and will keep track of the number of right\n    // shift operations performed\
    \ till now and will keep track of the number of right\n    // shift operations\
    \ performed till now and will keep track of the number of right\n    // shift\
    \ operations performed till now and will keep track of the number of right\n \
    \   // shift operations performed till now and will keep track of the number of\
    \ right\n    // shift operations performed till now and will keep track of the\
    \ number of right\n    // shift operations performed till now and will keep track\
    \ of the number of right\n    // shift operations performed till now and will\
    \ keep track of the number of right\n    // shift operations performed till now\
    \ and will keep track of the number of right\n    // shift operations performed\
    \ till now and will keep track of the number of right\n    // shift operations\
    \ performed till now and will keep track of the number of right\n    // shift\
    \ operations performed till now and will keep track of the number of right\n \
    \   // shift operations performed till now and will keep track of the number of\
    \ right\n    // shift operations performed till now and will keep track of the\
    \ number of right\n    // shift operations performed till now and will keep track\
    \ of the number of right\n    // shift \nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz2wo1t8l_test.go:73:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp3wkjr3yk_test.go:29 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmplf0s1zws_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmplf0s1zws_test.go:62\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    shift -= 1\n    \n    for\
    \ i := 0; i < shift; i++ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n\
    \    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpp1od75pl_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpp1od75pl_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i -= 1\n\
    \            j -= 1\n        } else if i == j {\n            return true\n   \
    \     } else {\n            arr[i], arr[j] = arr[j], arr[i]\n            i -=\
    \ 1\n            j -= 1\n        }\n    }\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpozqkg0hm_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpozqkg0hm_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp913afi64_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp913afi64_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // to achieve non-decreasing order\n    var shiftCount int = 0\n    \n   \
    \ // We will keep track of the last element in the list\n    var lastElement int\
    \ = 0\n    \n    // We will keep track of the first element in the list\n    var\
    \ firstElement int = 0\n    \n    // We will keep track of the number of elements\
    \ in the list\n    var numElements int = len(arr)\n    \n    // We will keep track\
    \ of the number of elements in the list after performing\n    // right shift operations\n\
    \    var numElementsAfterShift int = 0\n    \n    // We will keep track of the\
    \ number of elements in the list after performing\n    // right shift operations\
    \ after the first right shift operation\n    var numElementsAfterShiftAfter int\
    \ = 0\n    \n    // We will keep track of the number of elements in the list after\
    \ performing\n    // right shift operations after the second right shift operation\n\
    \    var numElementsAfterShiftAfter2 int = 0\n    \n    // We will keep track\
    \ of the number of elements in the list after performing\n    // right shift operations\
    \ after the third right shift operation\n    var numElementsAfterShiftAfter3 int\
    \ = 0\n    \n    // We will keep track of the number of elements in the list after\
    \ performing\n    // right shift operations after the fourth right shift operation\n\
    \    var numElementsAfterShiftAfter4 int = 0\n    \n    // We will keep track\
    \ of the number of elements in the list after performing\n    // right shift operations\
    \ after the fifth right shift operation\n    var numElementsAfterShiftAfter5 int\
    \ = 0\n    \n    // We will keep track of the number of elements in the list after\
    \ performing\n    // right shift operations after the sixth right shift operation\n\
    \    var numElementsAfterShiftAfter6 int = 0\n    \n    // We will keep track\
    \ of the number of elements in the list after performing\n    // right shift operations\
    \ after the seventh right shift operation\n    var numElementsAfterShiftAfter7\
    \ int = 0\n    \n    // We will keep track of the number of elements in the list\
    \ after performing\n    // right shift operations after the eighth right shift\
    \ operation\n    var numElementsAfterShiftAfter8 int = 0\n    \n    // We will\
    \ keep track of the number of elements in the list after performing\n    // right\
    \ shift operations after the ninth right shift operation\n    var numElementsAfterShiftAfter9\
    \ int = 0\n    \n    // We will keep track of the number of elements in the list\
    \ after performing\n    // right shift operations after the tenth right shift\
    \ operation\n    var numElementsAfterShiftAfter10 int = 0\n    \n    // \nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp19ci8_f7_test.go:92:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074272
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpp59mvm2u_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpp59mvm2u_test.go:62\
    \ +0x525\ntesting.tRunner(0xc0001a01a0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of shifts performed so far.\n    var shifts\
    \ int = 0\n    \n    // We will keep track of the last element in the list.\n\
    \    var lastElement int = 0\n    \n    // We will keep track of the last element\
    \ in the list after performing\n    // right shift operations.\n    var lastElementAfterRightShiftOperations\
    \ int = 0\n    \n    // We will keep track of the last element in the list after\
    \ performing\n    // left shift operations.\n    var lastElementAfterLeftShiftOperations\
    \ int = 0\n    \n    // We will keep track of the last element in the list after\
    \ performing\n    // swap operations.\n    var lastElementAfterSwapOperations\
    \ int = 0\n    \n    // We will keep track of the last element in the list after\
    \ performing\n    // insert operations.\n    var lastElementAfterInsertOperations\
    \ int = 0\n    \n    // We will keep track of the last element in the list after\
    \ performing\n    // delete operations.\n    var lastElementAfterDeleteOperations\
    \ int = 0\n    \n    // We will keep track of the last element in the list after\
    \ performing\n    // reverse operations.\n    var lastElementAfterReverseOperations\
    \ int = 0\n    \n    // We will keep track of the last element in the list after\
    \ performing\n    // rotate operations.\n    var lastElementAfterRotateOperations\
    \ int = 0\n    \n    // We will keep track of the last element in the list after\
    \ performing\n    // reverse rotate operations.\n    var lastElementAfterReverseRotateOperations\
    \ int = 0\n    \n    // We will keep track of the last element in the list after\
    \ performing\n    // rotate left operations.\n    var lastElementAfterRotateLeftOperations\
    \ int = 0\n    \n    // We will keep track of the last element in the list after\
    \ performing\n    // rotate right operations.\n    var lastElementAfterRotateRightOperations\
    \ int = 0\n    \n    // We will keep track of the last element in the list after\
    \ performing\n    // rotate right left operations.\n    var lastElementAfterRotateRightLeftOperations\
    \ int = 0\n    \n    // We will keep track of the last element in the list after\
    \ performing\n    // rotate left right operations.\n    var lastElementAfterRotateLeftRightOperations\
    \ int = 0\n    \n    // We will keep track of the last element in the list after\
    \ performing\n    // rotate right left right operations.\n    var lastElementAfterRotateLeftRightRightOperations\
    \ int = 0\n    \n    // We will keep track of the last element in the list after\
    \ performing\n    // rotate right left right left operations.\n    var lastElementAfterRotateLeftRightLeftOper\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn9tg4ahc_test.go:94:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n    //\
    \ arr[N-1] will be moved to arr[0]\n    // arr[0] will be moved to arr[1]\n  \
    \  // arr[1] will be moved to arr[2]\n    // ...\n    // arr[N-1] will be moved\
    \ to arr[0]\n    // arr[0] will be moved to arr[1]\n    // arr[1] will be moved\
    \ to arr[2]\n    // ...\n    // arr[N-1] will be moved to arr[0]\n    // arr[0]\
    \ will be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n\
    \    // arr[N-1] will be moved to arr[0]\n    // arr[0] will be moved to arr[1]\n\
    \    // arr[1] will be moved to arr[2]\n    // ...\n    // arr[N-1] will be moved\
    \ to arr[0]\n    // arr[0] will be moved to arr[1]\n    // arr[1] will be moved\
    \ to arr[2]\n    // ...\n    // arr[N-1] will be moved to arr[0]\n    // arr[0]\
    \ will be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n\
    \    // arr[N-1] will be moved to arr[0]\n    // arr[0] will be moved to arr[1]\n\
    \    // arr[1] will be moved to arr[2]\n    // ...\n    // arr[N-1] will be moved\
    \ to arr[0]\n    // arr[0] will be moved to arr[1]\n    // arr[1] will be moved\
    \ to arr[2]\n    // ...\n    // arr[N-1] will be moved to arr[0]\n    // arr[0]\
    \ will be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n\
    \    // arr[N-1] will be moved to arr[0]\n    // arr[0] will be moved to arr[1]\n\
    \    // arr[1] will be moved to arr[2]\n    // ...\n    // arr[N-1] will be moved\
    \ to arr[0]\n    // arr[0] will be moved to arr[1]\n    // arr[1] will be moved\
    \ to arr[2]\n    // ...\n    // arr[N-1] will be moved to arr[0]\n    // arr[0]\
    \ will be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n\
    \    // arr[N-1] will be moved to arr[0]\n    // arr[0] will be moved to arr[1]\n\
    \    // arr[1] will be moved to arr[2]\n    // ...\n    // arr[N-1] will be moved\
    \ to arr[0]\n    // arr[0] will be moved to arr[1]\n    // arr[1] will be moved\
    \ to arr[2]\n    // ...\n    // arr[N-1] will be moved to arr[0]\n    // arr[0]\
    \ will be moved to arr[1]\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_vtz2a73_test.go:96:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmplf0s1zws_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmplf0s1zws_test.go:62\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n    for\
    \ i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n            shift\
    \ -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return false\n   \
    \ }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++ {\n       \
    \ if arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n \
    \   if shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n\
    \    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n     \
    \       shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift -=\
    \ 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph_ntrum0_test.go:159:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp7dh90yb__test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppdgetfvu_test.go:98:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n    }\n\
    \    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpy3mzhbpu_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpy3mzhbpu_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074275
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n\
    \            shift += 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    return\
    \ true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5mk05924_test.go:46:11: no new variables on left side of :=

    /tmp/tmp5mk05924_test.go:58:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ i == len(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp96xkh7m4_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp96xkh7m4_test.go:59\
    \ +0x505\ntesting.tRunner(0xc0001a0340, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp913afi64_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp913afi64_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp3wkjr3yk_test.go:29 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp913afi64_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp913afi64_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[0] = arr[0], arr[0]\n\
    \    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpq9iba5in_test.go:29 +0x72 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := 0\n    \n    for {\n        if j == i {\n     \
    \       break\n        }\n        \n        if arr[j] > arr[i] {\n           \
    \ arr[j], arr[i] = arr[i], arr[j]\n            j = j + 1\n        } else {\n \
    \           i = i - 1\n        }\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpq1rh6o2h_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpq1rh6o2h_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := 0\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            arr[i], arr[j] = arr[j], arr[i]\n      \
    \      i++\n            j--\n        }\n        if i == j {\n            break\n\
    \        }\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp_hn6w6v8_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp_hn6w6v8_test.go:61\
    \ +0x5a6\ntesting.tRunner(0xc0001a01a0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmplf0s1zws_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmplf0s1zws_test.go:62\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpipidiehj_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpipidiehj_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on arr[0] i.e. arr[0]\n  \
    \  // will be moved to arr[1] i.e. arr[1]\n    arr[0] = arr[1]\n    \n    // We\
    \ are going to perform right shift operation on arr[1] i.e. arr[1]\n    // will\
    \ be moved to arr[2] i.e. arr[2]\n    arr[1] = arr[2]\n    \n    // We are going\
    \ to perform right shift operation on arr[2] i.e. arr[2]\n    // will be moved\
    \ to arr[3] i.e. arr[3]\n    arr[2] = arr[3]\n    \n    // We are going to perform\
    \ right shift operation on arr[3] i.e. arr[3]\n    // will be moved to arr[0]\
    \ i.e. arr[0]\n    arr[3] = arr[0]\n    \n    // We are going to perform right\
    \ shift operation on arr[0] i.e. arr[0]\n    // will be moved to arr[1] i.e. arr[1]\n\
    \    arr[0] = arr[1]\n    \n    // We are going to perform right shift operation\
    \ on arr[1] i.e. arr[1]\n    // will be moved to arr[2] i.e. arr[2]\n    arr[1]\
    \ = arr[2]\n    \n    // We are going to perform right shift operation on arr[2]\
    \ i.e. arr[2]\n    // will be moved to arr[3] i.e. arr[3]\n    arr[2] = arr[3]\n\
    \    \n    // We are going to perform right shift operation on arr[3] i.e. arr[3]\n\
    \    // will be moved to arr[0] i.e. arr[0]\n    arr[3] = arr[0]\n    \n    //\
    \ We are going to perform right shift operation on arr[0] i.e. arr[0]\n    //\
    \ will be moved to arr[1] i.e. arr[1]\n    arr[0] = arr[1]\n    \n    // We are\
    \ going to perform right shift operation on arr[1] i.e. arr[1]\n    // will be\
    \ moved to arr[2] i.e. arr[2]\n    arr[1] = arr[2]\n    \n    // We are going\
    \ to perform right shift operation on arr[2] i.e. arr[2]\n    // will be moved\
    \ to arr[3] i.e. arr[3]\n    arr[2] = arr[3]\n    \n    // We are going to perform\
    \ right shift operation on arr[3] i.e. arr[3]\n    // will be moved to arr[0]\
    \ i.e. arr[0]\n    arr[3] = arr[0]\n    \n    // We are going to perform right\
    \ shift operation on arr[0] i.e. arr[0]\n    // will be moved to arr[1] i.e. arr[1]\n\
    \    arr[0] = arr[1]\n    \n    // We are going to perform right shift operation\
    \ on arr[1] i.e. arr[1]\n    // will be moved to arr[2] i.e. arr[2]\n    arr[1]\
    \ = arr[2]\n    \n    // We are going to perform right shift operation on arr[2]\
    \ i.e. arr[2]\n    // will be moved to arr[3] i.e. arr[3]\n    arr[2] = arr[3]\n\
    \    \n    // We are going to perform \nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_73uqknp_test.go:95:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp913afi64_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp913afi64_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // We will keep track of the number of right shift\
    \ operations performed.\n    // If this number is greater than or equal to 'n',\
    \ then we know that \n    // we can obtain the sorted list by performing right\
    \ shift operations.\n    // If this number is less than 'n', then we know that\
    \ we can not obtain\n    // the sorted list by performing right shift operations.\n\
    \    shift := 0\n    \n    // We will keep track of the number of elements in\
    \ the list after performing\n    // right shift operations.\n    shift += n\n\
    \    \n    // We will keep track of the number of elements in the list after performing\n\
    \    // right shift operations.\n    shift += n\n    \n    // We will keep track\
    \ of the number of elements in the list after performing\n    // right shift operations.\n\
    \    shift += n\n    \n    // We will keep track of the number of elements in\
    \ the list after performing\n    // right shift operations.\n    shift += n\n\
    \    \n    // We will keep track of the number of elements in the list after performing\n\
    \    // right shift operations.\n    shift += n\n    \n    // We will keep track\
    \ of the number of elements in the list after performing\n    // right shift operations.\n\
    \    shift += n\n    \n    // We will keep track of the number of elements in\
    \ the list after performing\n    // right shift operations.\n    shift += n\n\
    \    \n    // We will keep track of the number of elements in the list after performing\n\
    \    // right shift operations.\n    shift += n\n    \n    // We will keep track\
    \ of the number of elements in the list after performing\n    // right shift operations.\n\
    \    shift += n\n    \n    // We will keep track of the number of elements in\
    \ the list after performing\n    // right shift operations.\n    shift += n\n\
    \    \n    // We will keep track of the number of elements in the list after performing\n\
    \    // right shift operations.\n    shift += n\n    \n    // We will keep track\
    \ of the number of elements in the list after performing\n    // right shift operations.\n\
    \    shift += n\n    \n    // We will keep track of the number of elements in\
    \ the list after performing\n    // right shift operations.\n    shift += n\n\
    \    \n    // We will keep track of the number of elements in the list after performing\n\
    \    // right shift operations.\n    shift += n\n    \n    // We will keep track\
    \ of the number of elements in the list after performing\n    // right shift operations.\n\
    \    shift += n\n    \n    // We will keep track of the number of elements in\
    \ the list after perform\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1i2cz4wn_test.go:104:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[0] = arr[0], arr[0]\n\
    \    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpq9iba5in_test.go:29 +0x72 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            arr[i], arr[j] = arr[j], arr[i]\n\
    \            i++\n            j--\n        }\n        if i == j {\n          \
    \  break\n        }\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpmeh2dlll_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpmeh2dlll_test.go:61\
    \ +0x5a6\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[shift] = 0\n    \n   \
    \ return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpk0zgsps2_test.go:29 +0x7b fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6db\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on the given list \n    //\
    \ arr[1], arr[2], ..., arr[N-1].\n    // We are going to perform right shift operation\
    \ on arr[1], arr[2], ..., arr[N-1].\n    // We are going to perform right shift\
    \ operation on arr[1], arr[2], ..., arr[N-1].\n    // We are going to perform\
    \ right shift operation on arr[1], arr[2], ..., arr[N-1].\n    // We are going\
    \ to perform right shift operation on arr[1], arr[2], ..., arr[N-1].\n    // We\
    \ are going to perform right shift operation on arr[1], arr[2], ..., arr[N-1].\n\
    \    // We are going to perform right shift operation on arr[1], arr[2], ...,\
    \ arr[N-1].\n    // We are going to perform right shift operation on arr[1], arr[2],\
    \ ..., arr[N-1].\n    // We are going to perform right shift operation on arr[1],\
    \ arr[2], ..., arr[N-1].\n    // We are going to perform right shift operation\
    \ on arr[1], arr[2], ..., arr[N-1].\n    // We are going to perform right shift\
    \ operation on arr[1], arr[2], ..., arr[N-1].\n    // We are going to perform\
    \ right shift operation on arr[1], arr[2], ..., arr[N-1].\n    // We are going\
    \ to perform right shift operation on arr[1], arr[2], ..., arr[N-1].\n    // We\
    \ are going to perform right shift operation on arr[1], arr[2], ..., arr[N-1].\n\
    \    // We are going to perform right shift operation on arr[1], arr[2], ...,\
    \ arr[N-1].\n    // We are going to perform right shift operation on arr[1], arr[2],\
    \ ..., arr[N-1].\n    // We are going to perform right shift operation on arr[1],\
    \ arr[2], ..., arr[N-1].\n    // We are going to perform right shift operation\
    \ on arr[1], arr[2], ..., arr[N-1].\n    // We are going to perform right shift\
    \ operation on arr[1], arr[2], ..., arr[N-1].\n    // We are going to perform\
    \ right shift operation on arr[1], arr[2], ..., arr[N-1].\n    // We are going\
    \ to perform right shift operation on arr[1], arr[2], ..., arr[N-1].\n    // We\
    \ are going to perform right shift operation on arr[1], arr[2], ..., arr[N-1].\n\
    \    // We are going to perform right shift operation on arr[1], arr[2], ...,\
    \ arr[N-1].\n    // We are going to perform right shift operation on arr[1], arr[2],\
    \ ..., arr[N-1].\n    // We are going to perform right shift operation on arr[1],\
    \ arr[2], ..., arr[N-1].\n    // We are going to perform right shift operation\
    \ on arr[1], arr[2], ..., arr[N-1].\n    // We \nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp57f7pf61_test.go:62:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppdgetfvu_test.go:98:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpipidiehj_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpipidiehj_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    shift -= 1\n    \n    for\
    \ i := 0; i < shift; i++ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n\
    \    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpp1od75pl_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpp1od75pl_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpimfjaihl_test.go:29 +0xbf fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef71f\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpimfjaihl_test.go:43 +0x7f fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpimfjaihl_test.go:43 +0x7f fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpimfjaihl_test.go:43 +0x7f fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpimfjaihl_test.go:43 +0x7f fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpimfjaihl_test.go:43 +0x7f fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpimfjaihl_test.go:43 +0x7f fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpimfjaihl_test.go:43 +0x7f fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpimfjaihl_test.go:43 +0x7f fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpimfjaihl_test.go:43 +0x7f fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6df\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074277
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // If arr[0] is greater than arr[1], then arr[0] will be moved to the\n   \
    \ // right and arr[1] will be moved to the left.\n    // If arr[1] is greater\
    \ than arr[2], then arr[1] will be moved to the\n    // right and arr[2] will\
    \ be moved to the left.\n    // If arr[2] is greater than arr[3], then arr[2]\
    \ will be moved to the\n    // right and arr[3] will be moved to the left.\n \
    \   // If arr[3] is greater than arr[0], then arr[3] will be moved to the\n  \
    \  // right and arr[0] will be moved to the left.\n    // If arr[0] is greater\
    \ than arr[1], then arr[0] will be moved to the\n    // right and arr[1] will\
    \ be moved to the left.\n    // If arr[1] is greater than arr[2], then arr[1]\
    \ will be moved to the\n    // right and arr[2] will be moved to the left.\n \
    \   // If arr[2] is greater than arr[3], then arr[2] will be moved to the\n  \
    \  // right and arr[3] will be moved to the left.\n    // If arr[3] is greater\
    \ than arr[0], then arr[3] will be moved to the\n    // right and arr[0] will\
    \ be moved to the left.\n    // If arr[0] is greater than arr[1], then arr[0]\
    \ will be moved to the\n    // right and arr[1] will be moved to the left.\n \
    \   // If arr[1] is greater than arr[2], then arr[1] will be moved to the\n  \
    \  // right and arr[2] will be moved to the left.\n    // If arr[2] is greater\
    \ than arr[3], then arr[2] will be moved to the\n    // right and arr[3] will\
    \ be moved to the left.\n    // If arr[3] is greater than arr[0], then arr[3]\
    \ will be moved to the\n    // right and arr[0] will be moved to the left.\n \
    \   // If arr[0] is greater than arr[1], then arr[0] will be moved to the\n  \
    \  // right and arr[1] will be moved to the left.\n    // If arr[1] is greater\
    \ than arr[2], then arr[1] will be moved to the\n    // right and arr[2] will\
    \ be moved to the left.\n    // If arr[2] is greater than arr[3], then arr[2]\
    \ will be moved to the\n    // right and arr[3] will be moved to the left.\n \
    \   // If arr[3] is greater than arr[0], then arr[3] will be moved to the\n  \
    \  // right and arr[0] will be moved to the left.\n    // If arr[0] is greater\
    \ than arr[1], then arr[0] will be moved to the\n    // right and arr[1] will\
    \ be moved to the left.\n    // If arr[1] is greater than arr[2], then arr[1]\
    \ will be moved to the\n    // right and arr[2] will be moved to the left.\n \
    \   // If arr[2] is greater than arr[3], then arr[2] will be moved to the\n  \
    \  // right and arr[3] will be moved to the left.\n    // If arr[3] is greater\
    \ than \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg35_w9ds_test.go:73:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ >>= 1\n        \n        if arr[i] != 0 {\n            arr[i] |= (arr[i-1] >>\
    \ shift) \n            arr[i-1] >>= shift\n            shift -= 1\n        }\n\
    \    }\n    \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmphrid__d7_test.go:40\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmphrid__d7_test.go:56\
    \ +0x632\ntesting.tRunner(0xc0001a01a0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    \n    return true\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpaxp8e_rn_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpaxp8e_rn_test.go:63\
    \ +0x525\ntesting.tRunner(0xc000192680, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // to achieve non-decreasing order\n    var shiftCount int = 0\n    \n   \
    \ // Keep track of the current position in the given list\n    var currentPos\
    \ int = 0\n    \n    // Keep track of the current element in the given list\n\
    \    var currentElement int = 0\n    \n    // Keep track of the current element\
    \ in the given list\n    var currentElement2 int = 0\n    \n    // Keep track\
    \ of the current element in the given list\n    var currentElement3 int = 0\n\
    \    \n    // Keep track of the current element in the given list\n    var currentElement4\
    \ int = 0\n    \n    // Keep track of the current element in the given list\n\
    \    var currentElement5 int = 0\n    \n    // Keep track of the current element\
    \ in the given list\n    var currentElement6 int = 0\n    \n    // Keep track\
    \ of the current element in the given list\n    var currentElement7 int = 0\n\
    \    \n    // Keep track of the current element in the given list\n    var currentElement8\
    \ int = 0\n    \n    // Keep track of the current element in the given list\n\
    \    var currentElement9 int = 0\n    \n    // Keep track of the current element\
    \ in the given list\n    var currentElement10 int = 0\n    \n    // Keep track\
    \ of the current element in the given list\n    var currentElement11 int = 0\n\
    \    \n    // Keep track of the current element in the given list\n    var currentElement12\
    \ int = 0\n    \n    // Keep track of the current element in the given list\n\
    \    var currentElement13 int = 0\n    \n    // Keep track of the current element\
    \ in the given list\n    var currentElement14 int = 0\n    \n    // Keep track\
    \ of the current element in the given list\n    var currentElement15 int = 0\n\
    \    \n    // Keep track of the current element in the given list\n    var currentElement16\
    \ int = 0\n    \n    // Keep track of the current element in the given list\n\
    \    var currentElement17 int = 0\n    \n    // Keep track of the current element\
    \ in the given list\n    var currentElement18 int = 0\n    \n    // Keep track\
    \ of the current element in the given list\n    var currentElement19 int = 0\n\
    \    \n    // Keep track of the current element in the given list\n    var currentElement20\
    \ int = 0\n    \n    // Keep track of the current element in the given list\n\
    \    var currentElement21 int = 0\n    \n    // Keep track of the current element\
    \ in the given list\n    var currentElement22 int = 0\n    \n    // Keep track\
    \ of the current element in the given list\n    var currentElement23 int = 0\n\
    \    \n    // Keep track of the current element in the given list\n    var currentElement24\
    \ int = 0\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmoie8e1w_test.go:112:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp3wkjr3yk_test.go:29 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp3wkjr3yk_test.go:44 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n    //\
    \ arr[N-1] will be moved to arr[0]\n    // arr[0] will be moved to arr[1]\n  \
    \  // arr[1] will be moved to arr[2]\n    // ...\n    // arr[0] will be moved\
    \ to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n    // arr[0]\
    \ will be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n\
    \    // arr[0] will be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n\
    \    // ...\n    // arr[0] will be moved to arr[1]\n    // arr[1] will be moved\
    \ to arr[2]\n    // ...\n    // arr[0] will be moved to arr[1]\n    // arr[1]\
    \ will be moved to arr[2]\n    // ...\n    // arr[0] will be moved to arr[1]\n\
    \    // arr[1] will be moved to arr[2]\n    // ...\n    // arr[0] will be moved\
    \ to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n    // arr[0]\
    \ will be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n\
    \    // arr[0] will be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n\
    \    // ...\n    // arr[0] will be moved to arr[1]\n    // arr[1] will be moved\
    \ to arr[2]\n    // ...\n    // arr[0] will be moved to arr[1]\n    // arr[1]\
    \ will be moved to arr[2]\n    // ...\n    // arr[0] will be moved to arr[1]\n\
    \    // arr[1] will be moved to arr[2]\n    // ...\n    // arr[0] will be moved\
    \ to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n    // arr[0]\
    \ will be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n\
    \    // arr[0] will be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n\
    \    // ...\n    // arr[0] will be moved to arr[1]\n    // arr[1] will be moved\
    \ to arr[2]\n    // ...\n    // arr[0] will be moved to arr[1]\n    // arr[1]\
    \ will be moved to arr[2]\n    // ...\n    // arr[0] will be moved to arr[1]\n\
    \    // arr[1] will be moved to arr[2]\n    // ...\n    // arr[0] will be moved\
    \ to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n    // arr[0]\
    \ will be moved to arr[1]\n    // arr[1] will be moved to arr[2]\n    // ...\n\
    \    // arr[0] will be moved to arr[1]\n    // arr[1] will be moved to \nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpitv5yw26_test.go:104:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // If we have only one element then we cannot move it to the first position\n\
    \    if len(arr) == 1 {\n        return false\n    }\n    \n    // We have more\
    \ than one element so we need to perform right shift operation \n    // on all\
    \ the elements of the list to move the last element to the first\n    // position\n\
    \    for i := len(arr) - 1; i > 0; i-- {\n        arr[i] = arr[i-1]\n    }\n \
    \   arr[0] = arr[len(arr)-1]\n    \n    // Now we need to check if we can get\
    \ non-decreasing order for the list by\n    // performing right shift operation\
    \ on all the elements of the list\n    for i := 0; i < len(arr); i++ {\n     \
    \   for j := 0; j < len(arr); j++ {\n            if arr[j] > arr[j+1] {\n    \
    \            return false\n            }\n        }\n    }\n    return true\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpyd70iznc_test.go:76: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpyd70iznc_test.go:76:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n    }\n    \n    for i := 0; i < shift; i++ {\n       \
    \ arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n    }\n    \n    return arr[0]\
    \ == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpchedlps2_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpchedlps2_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ i == len(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp96xkh7m4_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp96xkh7m4_test.go:59\
    \ +0x505\ntesting.tRunner(0xc0001a0340, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmplf0s1zws_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmplf0s1zws_test.go:62\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on arr[0] i.e. arr[0]\n  \
    \  // will be moved to arr[1] and arr[1] will be moved to arr[2] and so on\n \
    \   // until we reach the end of the list\n    for i := 1; i < len(arr); i++ {\n\
    \        arr[i-1], arr[i] = arr[i], arr[i-1]\n    }\n    \n    // We are going\
    \ to perform right shift operation on arr[0] i.e. arr[0]\n    // will be moved\
    \ to arr[1] and arr[1] will be moved to arr[2] and so on\n    // until we reach\
    \ the end of the list\n    for i := 1; i < len(arr); i++ {\n        arr[i-1],\
    \ arr[i] = arr[i], arr[i-1]\n    }\n    \n    // We are going to perform right\
    \ shift operation on arr[0] i.e. arr[0]\n    // will be moved to arr[1] and arr[1]\
    \ will be moved to arr[2] and so on\n    // until we reach the end of the list\n\
    \    for i := 1; i < len(arr); i++ {\n        arr[i-1], arr[i] = arr[i], arr[i-1]\n\
    \    }\n    \n    // We are going to perform right shift operation on arr[0] i.e.\
    \ arr[0]\n    // will be moved to arr[1] and arr[1] will be moved to arr[2] and\
    \ so on\n    // until we reach the end of the list\n    for i := 1; i < len(arr);\
    \ i++ {\n        arr[i-1], arr[i] = arr[i], arr[i-1]\n    }\n    \n    // We are\
    \ going to perform right shift operation on arr[0] i.e. arr[0]\n    // will be\
    \ moved to arr[1] and arr[1] will be moved to arr[2] and so on\n    // until we\
    \ reach the end of the list\n    for i := 1; i < len(arr); i++ {\n        arr[i-1],\
    \ arr[i] = arr[i], arr[i-1]\n    }\n    \n    // We are going to perform right\
    \ shift operation on arr[0] i.e. arr[0]\n    // will be moved to arr[1] and arr[1]\
    \ will be moved to arr[2] and so on\n    // until we reach the end of the list\n\
    \    for i := 1; i < len(arr); i++ {\n        arr[i-1], arr[i] = arr[i], arr[i-1]\n\
    \    }\n    \n    // We are going to perform right shift operation on arr[0] i.e.\
    \ arr[0]\n    // will be moved to arr[1] and arr[1] will be moved to arr[2] and\
    \ so on\n    // until we reach the end of the list\n    for i := 1; i < len(arr);\
    \ i++ {\n        arr[i-1], arr[i] = arr[i], arr[i-1]\n    }\n    \n    // We are\
    \ going to perform right shift operation on arr[0] i.e. arr[0]\n    // will be\
    \ moved to arr[1] and arr[1] will be moved to arr[2] and so \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjiivjmxp_test.go:85:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp913afi64_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp913afi64_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform N right shift operations.\n    // For each right\
    \ shift operation we shift all elements of the list by one\n    // position in\
    \ the right direction.\n    // We will keep track of the number of shifts performed\
    \ so far.\n    var shifts int = 0\n    \n    // We will keep track of the last\
    \ element of the list i.e. arr[N-1].\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // We will perform right shift operation\
    \ on the last element of the list.\n    // \nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz8e_vkdp_test.go:75:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on the given list until\n\
    \    // we reach the end of the list. \n    // We will keep track of the number\
    \ of right shift operations performed\n    // and we will keep track of the number\
    \ of elements in the given list.\n    shiftCount := 0\n    arrLen := len(arr)\n\
    \    \n    // We will keep track of the number of elements in the given list and\n\
    \    // we will keep track of the number of right shift operations performed.\n\
    \    arrLen -= 1 // We will move the last element to the starting position\n \
    \   shiftCount += 1 // We will perform right shift operation on the given list\n\
    \    \n    // We will keep track of the number of elements in the given list and\n\
    \    // we will keep track of the number of right shift operations performed.\n\
    \    arrLen -= 1 // We will move the last element to the starting position\n \
    \   shiftCount += 1 // We will perform right shift operation on the given list\n\
    \    \n    // We will keep track of the number of elements in the given list and\n\
    \    // we will keep track of the number of right shift operations performed.\n\
    \    arrLen -= 1 // We will move the last element to the starting position\n \
    \   shiftCount += 1 // We will perform right shift operation on the given list\n\
    \    \n    // We will keep track of the number of elements in the given list and\n\
    \    // we will keep track of the number of right shift operations performed.\n\
    \    arrLen -= 1 // We will move the last element to the starting position\n \
    \   shiftCount += 1 // We will perform right shift operation on the given list\n\
    \    \n    // We will keep track of the number of elements in the given list and\n\
    \    // we will keep track of the number of right shift operations performed.\n\
    \    arrLen -= 1 // We will move the last element to the starting position\n \
    \   shiftCount += 1 // We will perform right shift operation on the given list\n\
    \    \n    // We will keep track of the number of elements in the given list and\n\
    \    // we will keep track of the number of right shift operations performed.\n\
    \    arrLen -= 1 // We will move the last element to the starting position\n \
    \   shiftCount += 1 // We will perform right shift operation on the given list\n\
    \    \n    // We will keep track of the number of elements in the given list and\n\
    \    // we will keep track of the number of right shift operations performed.\n\
    \    arrLen -= 1 // We will move the last element to the starting position\n \
    \   shiftCount += 1 // We will perform right shift operation on the given list\n\
    \    \n    // We will keep track of the number of elements in the given list and\n\
    \    // we will keep track of the number of right shift operations performed.\n\
    \    arrLen -= 1 // We will \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppksy69sa_test.go:79:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // Initialize a boolean array indicating if the element\
    \ is in non-decreasing order\n    non_decreasing := make([]bool, len(arr))\n \
    \   \n    // Initialize a boolean array indicating if the element is in non-increasing\
    \ order\n    non_increasing := make([]bool, len(arr))\n    \n    // Initialize\
    \ a boolean array indicating if the element is in increasing order\n    increasing\
    \ := make([]bool, len(arr))\n    \n    // Initialize a boolean array indicating\
    \ if the element is in decreasing order\n    decreasing := make([]bool, len(arr))\n\
    \    \n    // Initialize a boolean array indicating if the element is in non-increasing\
    \ order after right shift\n    non_increasing_after_right_shift := make([]bool,\
    \ len(arr))\n    \n    // Initialize a boolean array indicating if the element\
    \ is in non-decreasing order after right shift\n    non_decreasing_after_right_shift\
    \ := make([]bool, len(arr))\n    \n    // Initialize a boolean array indicating\
    \ if the element is in non-increasing order after right shift\n    non_increasing_after_right_shift_2\
    \ := make([]bool, len(arr))\n    \n    // Initialize a boolean array indicating\
    \ if the element is in non-decreasing order after right shift\n    non_decreasing_after_right_shift_2\
    \ := make([]bool, len(arr))\n    \n    // Initialize a boolean array indicating\
    \ if the element is in non-increasing order after right shift\n    non_increasing_after_right_shift_3\
    \ := make([]bool, len(arr))\n    \n    // Initialize a boolean array indicating\
    \ if the element is in non-decreasing order after right shift\n    non_decreasing_after_right_shift_3\
    \ := make([]bool, len(arr))\n    \n    // Initialize a boolean array indicating\
    \ if the element is in non-increasing order after right shift\n    non_increasing_after_right_shift_4\
    \ := make([]bool, len(arr))\n    \n    // Initialize a boolean array indicating\
    \ if the element is in non-decreasing order after right shift\n    non_decreasing_after_right_shift_4\
    \ := make([]bool, len(arr))\n    \n    // Initialize a boolean array indicating\
    \ if the element is in non-increasing order after right shift\n    non_increasing_after_right_shift_5\
    \ := make([]bool, len(arr))\n    \n    // Initialize a boolean array indicating\
    \ if the element is in non-decreasing order after right shift\n    non_decreasing_after_right_shift_5\
    \ := make([]bool, len(arr))\n    \n    // Initialize a boolean array indicating\
    \ \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkg3e4xhy_test.go:79:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp7dh90yb__test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // and will keep track of the current position in the given list\n    shift\
    \ := 0\n    pos := 0\n    \n    // We will keep track of the number of elements\
    \ in the given list \n    // and will keep track of the current position in the\
    \ given list\n    len := len(arr)\n    \n    // We will keep track of the number\
    \ of elements in the given list \n    // and will keep track of the current position\
    \ in the given list\n    pos := 0\n    \n    // We will keep track of the number\
    \ of elements in the given list \n    // and will keep track of the current position\
    \ in the given list\n    len := len(arr)\n    \n    // We will keep track of the\
    \ number of elements in the given list \n    // and will keep track of the current\
    \ position in the given list\n    pos := 0\n    \n    // We will keep track of\
    \ the number of elements in the given list \n    // and will keep track of the\
    \ current position in the given list\n    len := len(arr)\n    \n    // We will\
    \ keep track of the number of elements in the given list \n    // and will keep\
    \ track of the current position in the given list\n    pos := 0\n    \n    //\
    \ We will keep track of the number of elements in the given list \n    // and\
    \ will keep track of the current position in the given list\n    len := len(arr)\n\
    \    \n    // We will keep track of the number of elements in the given list \n\
    \    // and will keep track of the current position in the given list\n    pos\
    \ := 0\n    \n    // We will keep track of the number of elements in the given\
    \ list \n    // and will keep track of the current position in the given list\n\
    \    len := len(arr)\n    \n    // We will keep track of the number of elements\
    \ in the given list \n    // and will keep track of the current position in the\
    \ given list\n    pos := 0\n    \n    // We will keep track of the number of elements\
    \ in the given list \n    // and will keep track of the current position in the\
    \ given list\n    len := len(arr)\n    \n    // We will keep track of the number\
    \ of elements in the given list \n    // and will keep track of the current position\
    \ in the given list\n    pos := 0\n    \n    // We will keep track of the number\
    \ of elements in the given list \n    // and will keep track of the current position\
    \ in the given list\n    len := len(arr)\n    \n    // We will keep track of the\
    \ number of elements in the given list \n    // and will keep track of the current\
    \ position in the given list\n    pos := 0\n    \n    // We will keep track of\
    \ the number of elements in the given list \n    // and will keep track of the\
    \ current position in the given \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppb7caeu5_test.go:97:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            arr[i], arr[j] = arr[j], arr[i]\n\
    \            i -= 1\n            j--\n        }\n        if i >= 0 && j >= 0 {\n\
    \            break\n        }\n    }\n    return arr == arr[0:i]\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmkvp6riy_test.go:51:12: invalid operation: arr == arr[0:i] (slice can
    only be compared to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmplf0s1zws_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmplf0s1zws_test.go:62\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift := len(arr) - 1\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[shift] {\n\
    \            shift += 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbdefbdvf_test.go:46:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform N right shift operations.\n    // We will perform\
    \ N right shift operations until we reach the end of the list.\n    // We will\
    \ perform N right shift operations until we reach the end of the list.\n    //\
    \ We will perform N right shift operations until we reach the end of the list.\n\
    \    // We will perform N right shift operations until we reach the end of the\
    \ list.\n    // We will perform N right shift operations until we reach the end\
    \ of the list.\n    // We will perform N right shift operations until we reach\
    \ the end of the list.\n    // We will perform N right shift operations until\
    \ we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until we reach the end of the list.\n    // We will perform N right shift operations\
    \ until \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7ajl6jm4_test.go:68:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // Find the minimum element in the given array\n \
    \   min := arr[0]\n    for i := 1; i < n; i++ {\n        if arr[i] < min {\n \
    \           min = arr[i]\n        }\n    }\n    \n    // Perform right shift operation\
    \ on minimum element and check if it is \n    // possible to get non-decreasing\
    \ order for the given array.\n    arr[0] = min\n    \n    for i := 1; i < n; i++\
    \ {\n        arr[i] = arr[i-1]\n    }\n    \n    return move_one_ball(arr)\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpc1_wslxm_test.go:29 +0x91 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6f1\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpc1_wslxm_test.go:52 +0x73 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpc1_wslxm_test.go:52 +0x73 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpc1_wslxm_test.go:52 +0x73 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpc1_wslxm_test.go:52 +0x73 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpc1_wslxm_test.go:52 +0x73 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpc1_wslxm_test.go:52 +0x73 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpc1_wslxm_test.go:52 +0x73 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpc1_wslxm_test.go:52 +0x73 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpc1_wslxm_test.go:52 +0x73 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074277
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on arr[0]\n    // arr[0] will\
    \ be moved to arr[1]\n    arr[0] = arr[1]\n    \n    // We are going to perform\
    \ right shift operation on arr[1]\n    // arr[1] will be moved to arr[2]\n   \
    \ arr[1] = arr[2]\n    \n    // We are going to perform right shift operation\
    \ on arr[2]\n    // arr[2] will be moved to arr[3]\n    arr[2] = arr[3]\n    \n\
    \    // We are going to perform right shift operation on arr[3]\n    // arr[3]\
    \ will be moved to arr[0]\n    arr[3] = arr[0]\n    \n    // We are going to perform\
    \ right shift operation on arr[0]\n    // arr[0] will be moved to arr[1]\n   \
    \ arr[0] = arr[1]\n    \n    // We are going to perform right shift operation\
    \ on arr[1]\n    // arr[1] will be moved to arr[2]\n    arr[1] = arr[2]\n    \n\
    \    // We are going to perform right shift operation on arr[2]\n    // arr[2]\
    \ will be moved to arr[3]\n    arr[2] = arr[3]\n    \n    // We are going to perform\
    \ right shift operation on arr[3]\n    // arr[3] will be moved to arr[0]\n   \
    \ arr[3] = arr[0]\n    \n    // We are going to perform right shift operation\
    \ on arr[0]\n    // arr[0] will be moved to arr[1]\n    arr[0] = arr[1]\n    \n\
    \    // We are going to perform right shift operation on arr[1]\n    // arr[1]\
    \ will be moved to arr[2]\n    arr[1] = arr[2]\n    \n    // We are going to perform\
    \ right shift operation on arr[2]\n    // arr[2] will be moved to arr[3]\n   \
    \ arr[2] = arr[3]\n    \n    // We are going to perform right shift operation\
    \ on arr[3]\n    // arr[3] will be moved to arr[0]\n    arr[3] = arr[0]\n    \n\
    \    // We are going to perform right shift operation on arr[0]\n    // arr[0]\
    \ will be moved to arr[1]\n    arr[0] = arr[1]\n    \n    // We are going to perform\
    \ right shift operation on arr[1]\n    // arr[1] will be moved to arr[2]\n   \
    \ arr[1] = arr[2]\n    \n    // We are going to perform right shift operation\
    \ on arr[2]\n    // arr[2] will be moved to arr[3]\n    arr[2] = arr[3]\n    \n\
    \    // We are going to perform right shift operation on arr[3]\n    // arr[3]\
    \ will be moved to arr[0]\n    arr[3] = arr[0]\n    \n    // We are going to perform\
    \ right shift operation on arr[0]\n    // arr[0] will be moved to arr[1]\n   \
    \ arr[0] = arr[1]\n    \n    // We are going to perform right shift \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6xv3ecqd_test.go:103:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[0] = arr[0], arr[0]\n\
    \    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpq9iba5in_test.go:29 +0x72 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpq9iba5in_test.go:42 +0x54 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp7dh90yb__test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // to determine if we can achieve non-decreasing order or not.\n    var rightShiftCount\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement2\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement3\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement4\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement5\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement6\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement7\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement8\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement9\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement10\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement11\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement12\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement13\
    \ int = 0\n    \n    // We will keep track of the last element in the given list\n\
    \    // to determine if we can achieve non-decreasing order or not.\n    var lastElement14\
    \ int = 0\n    \n    // We will keep track\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt3kx3w15_test.go:95:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppdgetfvu_test.go:98:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of how many times we perform right shift operation\n\
    \    // and will keep track of last element of list after right shift operation\n\
    \    // is performed.\n    count := 0\n    last := arr[0]\n    \n    // We will\
    \ keep track of how many times we perform right shift operation\n    // and will\
    \ keep track of last element of list after right shift operation\n    // is performed.\n\
    \    count := 0\n    last := arr[0]\n    \n    // We will keep track of how many\
    \ times we perform right shift operation\n    // and will keep track of last element\
    \ of list after right shift operation\n    // is performed.\n    count := 0\n\
    \    last := arr[0]\n    \n    // We will keep track of how many times we perform\
    \ right shift operation\n    // and will keep track of last element of list after\
    \ right shift operation\n    // is performed.\n    count := 0\n    last := arr[0]\n\
    \    \n    // We will keep track of how many times we perform right shift operation\n\
    \    // and will keep track of last element of list after right shift operation\n\
    \    // is performed.\n    count := 0\n    last := arr[0]\n    \n    // We will\
    \ keep track of how many times we perform right shift operation\n    // and will\
    \ keep track of last element of list after right shift operation\n    // is performed.\n\
    \    count := 0\n    last := arr[0]\n    \n    // We will keep track of how many\
    \ times we perform right shift operation\n    // and will keep track of last element\
    \ of list after right shift operation\n    // is performed.\n    count := 0\n\
    \    last := arr[0]\n    \n    // We will keep track of how many times we perform\
    \ right shift operation\n    // and will keep track of last element of list after\
    \ right shift operation\n    // is performed.\n    count := 0\n    last := arr[0]\n\
    \    \n    // We will keep track of how many times we perform right shift operation\n\
    \    // and will keep track of last element of list after right shift operation\n\
    \    // is performed.\n    count := 0\n    last := arr[0]\n    \n    // We will\
    \ keep track of how many times we perform right shift operation\n    // and will\
    \ keep track of last element of list after right shift operation\n    // is performed.\n\
    \    count := 0\n    last := arr[0]\n    \n    // We will keep track of how many\
    \ times we perform right shift operation\n    // and will keep track of last element\
    \ of list after right shift operation\n    // is performed.\n    count := 0\n\
    \    last := arr[0]\n    \n    // We will keep track of \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkepg6dzg_test.go:101:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp913afi64_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp913afi64_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed on\n\
    \    // the given list\n    shift := 0\n    \n    // Keep track of the number\
    \ of elements in the given list\n    n := len(arr)\n    \n    // Keep track of\
    \ the current element in the given list\n    current := 0\n    \n    // Keep track\
    \ of the number of elements in the sorted list\n    sortedCount := 0\n    \n \
    \   // Keep track of the number of elements in the unsorted list\n    unsortedCount\
    \ := 0\n    \n    // Keep track of the number of elements in the sorted list\n\
    \    sortedCount := 0\n    \n    // Keep track of the number of elements in the\
    \ unsorted list\n    unsortedCount := 0\n    \n    // Keep track of the number\
    \ of elements in the sorted list\n    sortedCount := 0\n    \n    // Keep track\
    \ of the number of elements in the unsorted list\n    unsortedCount := 0\n   \
    \ \n    // Keep track of the number of elements in the sorted list\n    sortedCount\
    \ := 0\n    \n    // Keep track of the number of elements in the unsorted list\n\
    \    unsortedCount := 0\n    \n    // Keep track of the number of elements in\
    \ the sorted list\n    sortedCount := 0\n    \n    // Keep track of the number\
    \ of elements in the unsorted list\n    unsortedCount := 0\n    \n    // Keep\
    \ track of the number of elements in the sorted list\n    sortedCount := 0\n \
    \   \n    // Keep track of the number of elements in the unsorted list\n    unsortedCount\
    \ := 0\n    \n    // Keep track of the number of elements in the sorted list\n\
    \    sortedCount := 0\n    \n    // Keep track of the number of elements in the\
    \ unsorted list\n    unsortedCount := 0\n    \n    // Keep track of the number\
    \ of elements in the sorted list\n    sortedCount := 0\n    \n    // Keep track\
    \ of the number of elements in the unsorted list\n    unsortedCount := 0\n   \
    \ \n    // Keep track of the number of elements in the sorted list\n    sortedCount\
    \ := 0\n    \n    // Keep track of the number of elements in the unsorted list\n\
    \    unsortedCount := 0\n    \n    // Keep track of the number of elements in\
    \ the sorted list\n    sortedCount := 0\n    \n    // Keep track of the number\
    \ of elements in the unsorted list\n    unsortedCount := 0\n    \n    // Keep\
    \ track of the number of elements in the sorted list\n    sortedCount := 0\n \
    \   \n    // Keep track of the number of elements in the unsorted list\n    unsortedCount\
    \ := 0\n    \n    // Keep track of the number of elements in the sorted list\n\
    \    sortedCount := 0\n    \n    // Keep track of the number of elements in the\
    \ unsorted list\n    unsortedCount := \nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpom5mnl5u_test.go:115:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n    }\n\
    \    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpy3mzhbpu_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpy3mzhbpu_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            arr[i], arr[j] = arr[j], arr[i]\n\
    \            i++\n            j--\n        }\n        if i == j {\n          \
    \  break\n        }\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpmeh2dlll_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpmeh2dlll_test.go:61\
    \ +0x5a6\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmplf0s1zws_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmplf0s1zws_test.go:62\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp7dh90yb__test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // Perform right shift operation on arr[0] i.e. arr[0]\n    arr[0] = arr[0]>>1\n\
    \    \n    // Perform right shift operation on arr[1] i.e. arr[1]\n    arr[1]\
    \ = arr[1]>>1\n    \n    // Perform right shift operation on arr[2] i.e. arr[2]\n\
    \    arr[2] = arr[2]>>1\n    \n    // Perform right shift operation on arr[3]\
    \ i.e. arr[3]\n    arr[3] = arr[3]>>1\n    \n    // Perform right shift operation\
    \ on arr[4] i.e. arr[4]\n    arr[4] = arr[4]>>1\n    \n    // Perform right shift\
    \ operation on arr[5] i.e. arr[5]\n    arr[5] = arr[5]>>1\n    \n    // Perform\
    \ right shift operation on arr[6] i.e. arr[6]\n    arr[6] = arr[6]>>1\n    \n\
    \    // Perform right shift operation on arr[7] i.e. arr[7]\n    arr[7] = arr[7]>>1\n\
    \    \n    // Perform right shift operation on arr[8] i.e. arr[8]\n    arr[8]\
    \ = arr[8]>>1\n    \n    // Perform right shift operation on arr[9] i.e. arr[9]\n\
    \    arr[9] = arr[9]>>1\n    \n    // Perform right shift operation on arr[10]\
    \ i.e. arr[10]\n    arr[10] = arr[10]>>1\n    \n    // Perform right shift operation\
    \ on arr[11] i.e. arr[11]\n    arr[11] = arr[11]>>1\n    \n    // Perform right\
    \ shift operation on arr[12] i.e. arr[12]\n    arr[12] = arr[12]>>1\n    \n  \
    \  // Perform right shift operation on arr[13] i.e. arr[13]\n    arr[13] = arr[13]>>1\n\
    \    \n    // Perform right shift operation on arr[14] i.e. arr[14]\n    arr[14]\
    \ = arr[14]>>1\n    \n    // Perform right shift operation on arr[15] i.e. arr[15]\n\
    \    arr[15] = arr[15]>>1\n    \n    // Perform right shift operation on arr[16]\
    \ i.e. arr[16]\n    arr[16] = arr[16]>>1\n    \n    // Perform right shift operation\
    \ on arr[17] i.e. arr[17]\n    arr[17] = arr[17]>>1\n    \n    // Perform right\
    \ shift operation on arr[18] i.e. arr[18]\n    arr[18] = arr[18]>>1\n    \n  \
    \  // Perform right shift operation on arr[19] i.e. arr[19]\n    arr[19] = arr[19]>>1\n\
    \    \n    // Perform right shift operation on \nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpet0qezn2_test.go:95:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp7dh90yb__test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    arr[0],\
    \ arr[0] = arr[0], arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpzi49e91o_test.go:29 +0xa5 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef705\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpzi49e91o_test.go:43 +0x6c fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6cc\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpzi49e91o_test.go:43 +0x6c fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6cc\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpzi49e91o_test.go:43 +0x6c fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6cc\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpzi49e91o_test.go:43 +0x6c fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6cc\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpzi49e91o_test.go:43 +0x6c fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6cc\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpzi49e91o_test.go:43 +0x6c fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6cc\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpzi49e91o_test.go:43 +0x6c fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6cc\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpzi49e91o_test.go:43 +0x6c fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6cc\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpzi49e91o_test.go:43 +0x6c fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6cc\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074278
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // Find the minimum element in the given list\n  \
    \  min := arr[0]\n    for i := 1; i < n; i++ {\n        if arr[i] < min {\n  \
    \          min = arr[i]\n        }\n    }\n    \n    // Find the maximum element\
    \ in the given list\n    max := arr[0]\n    for i := 1; i < n; i++ {\n       \
    \ if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    //\
    \ Find the middle element in the given list\n    middle := (min + max) / 2\n \
    \   \n    // Perform right shift operation on the given list to move the middle\
    \ element\n    // to the starting position\n    for i := 0; i < n; i++ {\n   \
    \     arr[i] = arr[i] - 1\n    }\n    \n    // Perform right shift operation on\
    \ the given list to move the middle element\n    // to the starting position\n\
    \    for i := 0; i < n; i++ {\n        arr[i] = arr[i] + middle\n    }\n    \n\
    \    // Perform right shift operation on the given list to move the middle element\n\
    \    // to the starting position\n    for i := 0; i < n; i++ {\n        arr[i]\
    \ = arr[i] - middle\n    }\n    \n    // Perform right shift operation on the\
    \ given list to move the middle element\n    // to the starting position\n   \
    \ for i := 0; i < n; i++ {\n        arr[i] = arr[i] + 1\n    }\n    \n    // Perform\
    \ right shift operation on the given list to move the middle element\n    // to\
    \ the starting position\n    for i := 0; i < n; i++ {\n        arr[i] = arr[i]\
    \ - 1\n    }\n    \n    // Perform right shift operation on the given list to\
    \ move the middle element\n    // to the starting position\n    for i := 0; i\
    \ < n; i++ {\n        arr[i] = arr[i] + middle\n    }\n    \n    // Perform right\
    \ shift operation on the given list to move the middle element\n    // to the\
    \ starting position\n    for i := 0; i < n; i++ {\n        arr[i] = arr[i] - middle\n\
    \    }\n    \n    // Perform right shift operation on the given list to move the\
    \ middle element\n    // to the starting position\n    for i := 0; i < n; i++\
    \ {\n        arr[i] = arr[i] + 1\n    }\n    \n    // Perform right shift operation\
    \ on the given list to move the middle element\n    // to the starting position\n\
    \    for i := 0; i < n; i++ {\n        arr[i] = arr[i] - 1\n    }\n    \n    //\
    \ Perform right shift operation on the given list to move the middle element\n\
    \    // to the starting position\n    for i := \nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjc9tzusi_test.go:112:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // so far.\n    var shiftCount int = 0\n    \n    // We will keep track of\
    \ the last element of the list i.e. the element at\n    // 0th index.\n    var\
    \ lastElement int = 0\n    \n    // We will keep track of the number of elements\
    \ in the list i.e. the number\n    // of elements in the given list.\n    var\
    \ numElements int = len(arr)\n    \n    // We will keep track of the number of\
    \ elements in the list that are less\n    // than or equal to 0th index.\n   \
    \ var numElementsLessThanZero = numElements\n    \n    // We will keep track of\
    \ the number of elements in the list that are greater\n    // than or equal to\
    \ 0th index.\n    var numElementsGreaterThanZero = numElements\n    \n    // We\
    \ will keep track of the number of elements in the list that are equal\n    //\
    \ to 0th index.\n    var numElementsEqualToZero = numElements\n    \n    // We\
    \ will keep track of the number of elements in the list that are less\n    //\
    \ than or equal to 0th index.\n    var numElementsLessThanZeroEqualToZero = numElements\n\
    \    \n    // We will keep track of the number of elements in the list that are\
    \ greater\n    // than or equal to 0th index.\n    var numElementsGreaterThanZeroEqualToZero\
    \ = numElements\n    \n    // We will keep track of the number of elements in\
    \ the list that are equal\n    // to 0th index.\n    var numElementsEqualToZeroEqualToZero\
    \ = numElements\n    \n    // We will keep track of the number of elements in\
    \ the list that are less\n    // than or equal to 0th index.\n    var numElementsLessThanZeroEqualToZeroEqualToZero\
    \ = numElements\n    \n    // We will keep track of the number of elements in\
    \ the list that are greater\n    // than or equal to 0th index.\n    var numElementsGreaterThanZeroEqualToZeroEqualToZero\
    \ = numElements\n    \n    // We will keep track of the number of elements in\
    \ the list that are equal\n    // to 0th index.\n    var numElementsEqualToZeroEqualToZeroEqualToZero\
    \ = numElements\n    \n    // We will keep track of the number of elements in\
    \ the list that are less\n    // than or equal to 0th index.\n    var numElementsLessThanZeroEqualToZeroEqualToZeroEqualToZero\
    \ = numElements\n    \n    // We will keep track of the number of elements in\
    \ the list that are greater\n    // than or equal to 0th index.\n    var numElementsGreaterThanZeroEqualToZeroEqual\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi84o0mbl_test.go:88:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n    for\
    \ i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n            shift\
    \ -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return false\n   \
    \ }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++ {\n       \
    \ if arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n \
    \   if shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n\
    \    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n     \
    \       shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift -=\
    \ 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph_ntrum0_test.go:159:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n    for\
    \ i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n            shift\
    \ -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return false\n   \
    \ }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++ {\n       \
    \ if arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n \
    \   if shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n\
    \    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n     \
    \       shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift -=\
    \ 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph_ntrum0_test.go:159:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp913afi64_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp913afi64_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[shift] = 0\n    \n   \
    \ return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpk0zgsps2_test.go:29 +0x7b fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6db\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpk0zgsps2_test.go:42 +0x5d fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6bd\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp7dh90yb__test.go:29 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp7dh90yb__test.go:42 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    arr[0], arr[shift] = arr[shift],\
    \ arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpymfmuqez_test.go:29 +0x85 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpymfmuqez_test.go:42 +0x65 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6c5\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // to determine if we can achieve non-decreasing order\n    shiftCount :=\
    \ 0\n    \n    // We will keep track of the number of elements in the list to\
    \ determine\n    // if we can achieve non-decreasing order\n    elementCount :=\
    \ len(arr)\n    \n    // We will keep track of the number of elements in the list\
    \ to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ list to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ list to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ list to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ list to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ list to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ list to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ list to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ list to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ list to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ list to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ list to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ list to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ list to determine\n    // if we can achieve non-decreasing order\n    elementCount\
    \ := len(arr)\n    \n    // We will \nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6wg68_zl_test.go:99:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  n := len(arr)\n    \n    // We will keep track of the number of right shift\
    \ operations performed\n    // to check if we can achieve non-decreasing order\n\
    \    shift := 0\n    \n    // We will keep track of the number of elements in\
    \ the list which are not\n    // greater than the previous element in the list\n\
    \    notGreaterElements := 0\n    \n    // We will keep track of the number of\
    \ elements in the list which are less\n    // than the previous element in the\
    \ list\n    lessElements := 0\n    \n    // We will keep track of the number of\
    \ elements in the list which are equal\n    // to the previous element in the\
    \ list\n    equalElements := 0\n    \n    // We will keep track of the number\
    \ of elements in the list which are greater\n    // than the previous element\
    \ in the list\n    greaterElements := 0\n    \n    // We will keep track of the\
    \ number of elements in the list which are not\n    // greater than the previous\
    \ element in the list\n    notGreaterElements := 0\n    \n    // We will keep\
    \ track of the number of elements in the list which are less\n    // than the\
    \ previous element in the list\n    lessElements := 0\n    \n    // We will keep\
    \ track of the number of elements in the list which are equal\n    // to the previous\
    \ element in the list\n    equalElements := 0\n    \n    // We will keep track\
    \ of the number of elements in the list which are greater\n    // than the previous\
    \ element in the list\n    greaterElements := 0\n    \n    // We will keep track\
    \ of the number of elements in the list which are not\n    // greater than the\
    \ previous element in the list\n    notGreaterElements := 0\n    \n    // We will\
    \ keep track of the number of elements in the list which are less\n    // than\
    \ the previous element in the list\n    lessElements := 0\n    \n    // We will\
    \ keep track of the number of elements in the list which are equal\n    // to\
    \ the previous element in the list\n    equalElements := 0\n    \n    // We will\
    \ keep track of the number of elements in the list which are greater\n    // than\
    \ the previous element in the list\n    greaterElements := 0\n    \n    // We\
    \ will keep track of the number of elements in the list which are not\n    //\
    \ greater than the previous element in the list\n    notGreaterElements := 0\n\
    \    \n    // We will keep track of the number of elements in the list which are\
    \ less\n    // than the previous element in the list\n    lessElements := 0\n\
    \    \n    // We will keep track of the number of elements in the list which are\
    \ equal\n    // to the previous element in the list\n    equalElements := 0\n\
    \    \n    // We will keep track of the number of elements in the list which are\
    \ greater\n    // than the \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpooa99gqa_test.go:102:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 19 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmptv0d_8j2_test.go:29 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmptv0d_8j2_test.go:40 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074275
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0qm7vx5h_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0qm7vx5h_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing right shift operation on arr until we get sorted\
    \ list\n    // by performing \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpywydyln2_test.go:68:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074276
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n        shift -= 1\n    }\n    \n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp913afi64_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp913afi64_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074273
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:29 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmps5qkkzjs_test.go:40 +0xb7 fp"
  timestamp: 1660074274
