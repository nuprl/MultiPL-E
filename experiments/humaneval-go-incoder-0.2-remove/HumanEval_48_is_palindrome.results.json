{
  "language": "go_test.go",
  "name": "HumanEval_48_is_palindrome",
  "results": [
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length - 1\n    middle := (start + end) / 2\n    for start < end {\n        if text[middle] != text[middle+1] {\n            return false\n        }\n        middle++\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv4tk4b60_test.go:10:10: no new variables on left side of :=\n/tmp/tmpv4tk4b60_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmrmqgq42_test.go:10:10: no new variables on left side of :=\n/tmp/tmpmrmqgq42_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    middle := (start + end) / 2\n    for start < end {\n        if text[middle] != text[start] {\n            return false\n        }\n        start++\n        end--\n        middle = (start + end) / 2\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmp95zcsubl_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmp95zcsubl_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuaxxe27l_test.go:10:10: no new variables on left side of :=\n/tmp/tmpuaxxe27l_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    if length == 1 {\n        return text == text[0:1]\n    }\n    if length == 2 {\n        return text == text[0:1] || text == text[1:0]\n    }\n    middle := length / 2\n    left := text[0:middle]\n    right := text[middle:]\n    return is_palindrome(left) && is_palindrome(right)\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0vqstj1o_test.go:10:10: no new variables on left side of :=\n/tmp/tmp0vqstj1o_test.go:10:13: undefined: strings\n/tmp/tmp0vqstj1o_test.go:19:52: invalid slice indices: 0 < 1\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    middle := (start + end) / 2\n    for start < middle && end > middle {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return start == end\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvavph9md_test.go:10:10: no new variables on left side of :=\n/tmp/tmpvavph9md_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start += 1\n        end -= 1\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpscmbw6g1_test.go:10:10: no new variables on left side of :=\n/tmp/tmpscmbw6g1_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := (length-1)/2\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppy2y5nwg_test.go:16:5: middle declared but not used\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    \n    // Check if text is empty or only contains space\n    if text == \"\" || text == \" \" {\n        return true\n    }\n    \n    // Check if text is palindrome\n    if text[start] == text[end] {\n        return is_palindrome(text[start+1:end-1])\n    }\n    \n    return false\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8kk803x3_test.go:10:10: no new variables on left side of :=\n/tmp/tmp8kk803x3_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    index := 0\n    result := true\n    for index < length {\n        if text[index] != text[len(text)-1-index] {\n            result = false\n            break\n        }\n        index++\n    }\n    return result\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4rwxzp16_test.go:10:10: no new variables on left side of :=\n/tmp/tmp4rwxzp16_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start += 1\n        end -= 1\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpscmbw6g1_test.go:10:10: no new variables on left side of :=\n/tmp/tmpscmbw6g1_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9pinwoti_test.go:10:10: no new variables on left side of :=\n/tmp/tmp9pinwoti_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \",\", \"\", -1)\n    text := strings.Replace(text, \";\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \",\", \"\", -1)\n    text := strings.Replace(text, \";\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \",\", \"\", -1)\n    text := strings.Replace(text, \";\", \"\", -1)\n    text := \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp4inkdrsk_test.go:51:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073978
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3dfs_n3s_test.go:10:10: no new variables on left side of :=\n/tmp/tmp3dfs_n3s_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := (start + end) / 2\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp01azu45l_test.go:16:5: middle declared but not used\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    // Checks for palindrome with even length\n    if length%2 == 0 {\n        for start < end {\n            if text[start] != text[end] {\n                return false\n            }\n            start++\n            end--\n        }\n        return true\n    }\n    \n    // Checks for palindrome with odd length\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeyt_yx_b_test.go:10:10: no new variables on left side of :=\n/tmp/tmpeyt_yx_b_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"$\", \"\", -1)\n    text := strings.Replace(text, \"%\", \"\", -1)\n    text := strings.Replace(text, \"^\", \"\", -1)\n    text := strings.Replace(text, \"&\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"+\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"=\", \"\", -1)\n    text := strings.Replace(text, \"<\", \"\", -1)\n    text := strings.Replace(text, \">\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"|\", \"\", -1)\n    text := strings.Replace(text, \"{\", \"\", -1)\n    text := strings.Replace(text, \"}\", \"\", -1)\n    text := strings.Replace(text, \"[\", \"\", -1)\n    text := strings.Replace(text, \"]\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"\\\"\", \"\", -1)\n    text := strings.Replace(text, \"`\", \"\", -1)\n    text := strings.Replace(text, \";\", \"\", -1)\n    text := strings.Replace(text, \",\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"$\", \"\", -1)\n    \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpj4nryk5e_test.go:51:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073978
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    middle := (start + end) / 2\n    for start < end {\n        if text[middle] != text[start] {\n            return false\n        }\n        middle++\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmp9e9z3opi_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmp9e9z3opi_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        \n        start++\n        end--\n    }\n    \n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi0xkfjb3_test.go:10:10: no new variables on left side of :=\n/tmp/tmpi0xkfjb3_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    left := 0\n    right := length - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \";\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"[\", \"\", -1)\n    text := strings.Replace(text, \"]\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"\\\"\", \"\", -1)\n    text := strings.Replace(text, \"%\", \"\", -1)\n    text := strings.Replace(text, \"#\", \"\", -1)\n    text := strings.Replace(text, \"$\", \"\", -1)\n    text := strings.Replace(text, \"&\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"+\", \"\", -1)\n    text := strings.Replace(text, \"=\", \"\", -1)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"[\", \"\", -1)\n    text := strings.Replace(text, \"]\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"\\\"\", \"\", -1)\n    text := strings.Replace(text, \"%\", \"\", -1)\n    text := strings.Replace(text, \"#\", \"\", -1)\n    text := strings.Replace(text, \"$\", \"\", -1)\n    text := strings.Replace(text, \"&\", \"\", -1)\n    text \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpk1e4ars2_test.go:51:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073978
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start += 1\n        end -= 1\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpscmbw6g1_test.go:10:10: no new variables on left side of :=\n/tmp/tmpscmbw6g1_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := length / 2\n    for start < middle {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "timestamp": 1660073980
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9pinwoti_test.go:10:10: no new variables on left side of :=\n/tmp/tmp9pinwoti_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuaxxe27l_test.go:10:10: no new variables on left side of :=\n/tmp/tmpuaxxe27l_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := (start + end) / 2\n    for start < middle {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyv3vc6ml_test.go:10:10: no new variables on left side of :=\n/tmp/tmpyv3vc6ml_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073980
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n\n    if length == 1 {\n        return text == text[:len(text)/2]\n    }\n\n    start := 0\n    end := length - 1\n\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "timestamp": 1660073980
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpsam5nzdx_test.go:50:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073980
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Trim(text, \" \")\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpx68ejmz9_test.go:51:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073980
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    for i := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyfxgevb1_test.go:10:10: no new variables on left side of :=\n/tmp/tmpyfxgevb1_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length == 0 {\n        return true\n    }\n    if length == 1 {\n        return text == text[:len(text)/2]\n    }\n    middle := length/2\n    return is_palindrome(text[:middle]) && is_palindrome(text[middle:])\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmprjhnul59_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__2 (0.00s)\n        tmprjhnul59_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmprjhnul59_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3dfs_n3s_test.go:10:10: no new variables on left side of :=\n/tmp/tmp3dfs_n3s_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuaxxe27l_test.go:10:10: no new variables on left side of :=\n/tmp/tmpuaxxe27l_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9pinwoti_test.go:10:10: no new variables on left side of :=\n/tmp/tmp9pinwoti_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length <= 0 {\n        return false\n    }\n    if length == 1 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := length / 2\n    for start < middle && end > middle {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return start == end\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__0 (0.00s)\n        tmp2woiywe6_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp57uk8vsa_test.go:10:10: no new variables on left side of :=\n/tmp/tmp57uk8vsa_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start += 1\n        end -= 1\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpscmbw6g1_test.go:10:10: no new variables on left side of :=\n/tmp/tmpscmbw6g1_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := (start + end) / 2\n    for start < end {\n        if text[middle] != text[start] {\n            return false\n        }\n        middle++\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmputt0epbq_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmputt0epbq_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"@\", \"\", -1)\n    text := strings.Replace(text, \"$\", \"\", -1)\n    text := strings.Replace(text, \"%\", \"\", -1)\n    text := strings.Replace(text, \"^\", \"\", -1)\n    text := strings.Replace(text, \"&\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"[\", \"\", -1)\n    text := strings.Replace(text, \"]\", \"\", -1)\n    text := strings.Replace(text, \"{\", \"\", -1)\n    text := strings.Replace(text, \"}\", \"\", -1)\n    text := strings.Replace(text, \"<\", \"\", -1)\n    text := strings.Replace(text, \">\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"+\", \"\", -1)\n    text := strings.Replace(text, \"=\", \"\", -1)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"@\", \"\", -1)\n    text := strings.Replace(text, \"$\", \"\", -1)\n    text := strings.Replace(text, \"%\", \"\", -1)\n    text := strings.Replace(text, \"^\", \"\", -1)\n    text := strings.Replace(text, \"&\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"[\", \"\", -1)\n    text \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpb_22pzsw_test.go:51:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073980
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9pinwoti_test.go:10:10: no new variables on left side of :=\n/tmp/tmp9pinwoti_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length == 0 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length <= 0 {\n        return false\n    }\n    start := 0\n    end := length-1\n    middle := (start + end) / 2\n    for start < end {\n        if text[middle] != text[start] {\n            return false\n        }\n        middle++\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__0 (0.00s)\n        tmp_evd0lx__test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmp_evd0lx__test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmp_evd0lx__test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuaxxe27l_test.go:10:10: no new variables on left side of :=\n/tmp/tmpuaxxe27l_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3dfs_n3s_test.go:10:10: no new variables on left side of :=\n/tmp/tmp3dfs_n3s_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\"\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpp8_n1bmx_test.go:49:42: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073980
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    index := 0\n    result := true\n    for index < length/2 {\n        if text[index] != text[length-1-index] {\n            result = false\n            break\n        }\n        index++\n    }\n    return result\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphow06whx_test.go:10:10: no new variables on left side of :=\n/tmp/tmphow06whx_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp57uk8vsa_test.go:10:10: no new variables on left side of :=\n/tmp/tmp57uk8vsa_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    middle := (start + end) / 2\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpix9s7ry2_test.go:16:5: middle declared but not used\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuaxxe27l_test.go:10:10: no new variables on left side of :=\n/tmp/tmpuaxxe27l_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length <= 0 {\n        return false\n    }\n\n    start := 0\n    end := length - 1\n\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__0 (0.00s)\n        tmpjzy3iyxt_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpgr_u3kgf_test.go:51:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073980
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"$\", \"\", -1)\n    text := strings.Replace(text, \"%\", \"\", -1)\n    text := strings.Replace(text, \"^\", \"\", -1)\n    text := strings.Replace(text, \"&\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"[\", \"\", -1)\n    text := strings.Replace(text, \"]\", \"\", -1)\n    text := strings.Replace(text, \"{\", \"\", -1)\n    text := strings.Replace(text, \"}\", \"\", -1)\n    text := strings.Replace(text, \"|\", \"\", -1)\n    text := strings.Replace(text, \"~\", \"\", -1)\n    text := strings.Replace(text, \"`\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"@\", \"\", -1)\n    text := strings.Replace(text, \"#\", \"\", -1)\n    text := strings.Replace(text, \"$\", \"\", -1)\n    text := strings.Replace(text, \"%\", \"\", -1)\n    text := strings.Replace(text, \"^\", \"\", -1)\n    text := strings.Replace(text, \"&\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"[\", \"\", -1)\n    text := strings.Replace(text, \"]\", \"\", -1)\n    text := strings.Replace(text, \"{\", \"\", -1)\n    text := strings.Replace(text, \"}\", \"\", -1)\n    text := strings.Replace(text, \"|\", \"\", -1)\n    text := strings.Replace(text, \"~\", \"\", -1)\n    text := strings.Replace(text, \"`\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"@\", \"\", -1)\n    text := strings.Replace(text, \"#\", \"\", -1)\n    \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpj9o2v0oa_test.go:51:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073980
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        \n        start++\n        end--\n    }\n    \n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi0xkfjb3_test.go:10:10: no new variables on left side of :=\n/tmp/tmpi0xkfjb3_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n\n    start := 0\n    end := length - 1\n\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length == 0 {\n        return true\n    }\n    if length == 1 {\n        return text == text[0:length]\n    }\n    middle := length / 2\n    left := text[0:middle]\n    right := text[middle:]\n    return is_palindrome(left) && is_palindrome(right)\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__3 (0.00s)\n        tmpbh0kv_pm_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Palindrome/test_num__5 (0.00s)\n        tmpbh0kv_pm_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Palindrome/test_num__6 (0.00s)\n        tmpbh0kv_pm_test.go:42: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length - 1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        \n        start++\n        end--\n    }\n    \n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpasmxnj75_test.go:10:10: no new variables on left side of :=\n/tmp/tmpasmxnj75_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        \n        start++\n        end--\n    }\n    \n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073982
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuaxxe27l_test.go:10:10: no new variables on left side of :=\n/tmp/tmpuaxxe27l_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start += 1\n        end -= 1\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpscmbw6g1_test.go:10:10: no new variables on left side of :=\n/tmp/tmpscmbw6g1_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9pinwoti_test.go:10:10: no new variables on left side of :=\n/tmp/tmp9pinwoti_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpg9ts77wn_test.go:51:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length == 0 {\n        return true\n    }\n    if length == 1 {\n        return text == text[:len(text)/2]\n    }\n    if length%2 == 0 {\n        return is_palindrome(text[:length/2]) && is_palindrome(text[length/2:])\n    }\n    return is_palindrome(text[:length/2]) && is_palindrome(text[length/2:])\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmpddimpqo9_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__2 (0.00s)\n        tmpddimpqo9_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmpddimpqo9_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073982
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length == 0 {\n        return true\n    }\n    if length == 1 {\n        return text == text[:len(text)/2]\n    }\n    if length%2 == 0 {\n        return is_palindrome_test(text, length/2)\n    }\n    return is_palindrome_test(text, length/2+1)\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw_qmh4gd_test.go:18:16: undefined: is_palindrome_test\n/tmp/tmpw_qmh4gd_test.go:20:12: undefined: is_palindrome_test\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073982
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpg9ts77wn_test.go:51:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    if length == 2 {\n        return text == text[0:1]\n    }\n    for i := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqr7qpk0j_test.go:10:10: no new variables on left side of :=\n/tmp/tmpqr7qpk0j_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073982
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    middle := (start + end) / 2\n    for start < end {\n        if text[middle] != text[start] {\n            return false\n        }\n        middle++\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmp9e9z3opi_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmp9e9z3opi_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9pinwoti_test.go:10:10: no new variables on left side of :=\n/tmp/tmp9pinwoti_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    for i := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        \n        start++\n        end--\n    }\n    \n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073982
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp57uk8vsa_test.go:10:10: no new variables on left side of :=\n/tmp/tmp57uk8vsa_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"\\\"\", \"\", -1)\n    text := strings.Replace(text, \"[\", \"\", -1)\n    text := strings.Replace(text, \"]\", \"\", -1)\n    text := strings.Replace(text, \"{\", \"\", -1)\n    text := strings.Replace(text, \"}\", \"\", -1)\n    text := strings.Replace(text, \";\", \"\", -1)\n    text := strings.Replace(text, \"#\", \"\", -1)\n    text := strings.Replace(text, \"$\", \"\", -1)\n    text := strings.Replace(text, \"%\", \"\", -1)\n    text := strings.Replace(text, \"^\", \"\", -1)\n    text := strings.Replace(text, \"&\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"+\", \"\", -1)\n    text := strings.Replace(text, \"=\", \"\", -1)\n    text := strings.Replace(text, \":\", \"\", -1)\n    text := strings.Replace(text, \";\", \"\", -1)\n    text := strings.Replace(text, \"<\", \"\", -1)\n    text := strings.Replace(text, \">\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpaz_zaf67_test.go:51:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073982
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    for i := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyfxgevb1_test.go:10:10: no new variables on left side of :=\n/tmp/tmpyfxgevb1_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp57uk8vsa_test.go:10:10: no new variables on left side of :=\n/tmp/tmp57uk8vsa_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \",\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \",\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \",\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \",\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \",\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpa12orwc0_test.go:51:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073982
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := (length-1)/2\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi31exbuj_test.go:10:10: no new variables on left side of :=\n/tmp/tmpi31exbuj_test.go:10:13: undefined: strings\n/tmp/tmpi31exbuj_test.go:17:5: middle declared but not used\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length == 0 {\n        return true\n    }\n    if length == 1 {\n        return text == text[:len(text)/2]\n    }\n    middle := length / 2\n    return is_palindrome(text[:middle]) && is_palindrome(text[middle:])\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmp_2b7b_ma_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__2 (0.00s)\n        tmp_2b7b_ma_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmp_2b7b_ma_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        \n        start++\n        end--\n    }\n    \n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9cxtnn0u_test.go:10:10: no new variables on left side of :=\n/tmp/tmp9cxtnn0u_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    for i := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length <= 1 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    middle := (start + end) / 2\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start += 1\n        end -= 1\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt8rf3tty_test.go:16:5: middle declared but not used\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := (start + end) / 2\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi242elfq_test.go:10:10: no new variables on left side of :=\n/tmp/tmpi242elfq_test.go:10:13: undefined: strings\n/tmp/tmpi242elfq_test.go:17:5: middle declared but not used\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3dfs_n3s_test.go:10:10: no new variables on left side of :=\n/tmp/tmp3dfs_n3s_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuaxxe27l_test.go:10:10: no new variables on left side of :=\n/tmp/tmpuaxxe27l_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuaxxe27l_test.go:10:10: no new variables on left side of :=\n/tmp/tmpuaxxe27l_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n\n    start := 0\n    end := length - 1\n    middle := (start + end) / 2\n    middle %= length\n\n    for start < middle && end > middle {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n\n    return start == end\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    left := 0\n    right := length - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3dfs_n3s_test.go:10:10: no new variables on left side of :=\n/tmp/tmp3dfs_n3s_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp57uk8vsa_test.go:10:10: no new variables on left side of :=\n/tmp/tmp57uk8vsa_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuaxxe27l_test.go:10:10: no new variables on left side of :=\n/tmp/tmpuaxxe27l_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length - 1\n    middle := (start + end) / 2\n    \n    // Check if middle is even\n    if middle % 2 == 0 {\n        return is_palindrome_even(text, middle, length)\n    }\n    \n    // Check if middle is odd\n    return is_palindrome_odd(text, middle, length)\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpja4pywny_test.go:10:10: no new variables on left side of :=\n/tmp/tmpja4pywny_test.go:10:13: undefined: strings\n/tmp/tmpja4pywny_test.go:18:16: undefined: is_palindrome_even\n/tmp/tmpja4pywny_test.go:22:12: undefined: is_palindrome_odd\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start += 1\n        end -= 1\n    }\n    \n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy0yw0khk_test.go:10:10: no new variables on left side of :=\n/tmp/tmpy0yw0khk_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length <= 0 {\n        return false\n    }\n    start := 0\n    end := length - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__0 (0.00s)\n        tmpyvwbyn1f_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start += 1\n        end -= 1\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy2_q2gsw_test.go:10:10: no new variables on left side of :=\n/tmp/tmpy2_q2gsw_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length <= 1 {\n        return true\n    }\n    left := 0\n    right := length - 1\n    middle := (left + right) / 2\n    for left < right {\n        if text[middle] != text[left] {\n            return false\n        }\n        left++\n        right--\n        middle = (left + right) / 2\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmpx0zoc6ya_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmpx0zoc6ya_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuaxxe27l_test.go:10:10: no new variables on left side of :=\n/tmp/tmpuaxxe27l_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    while (start < end) {\n        if text[start] != text[end] {\n            return false\n        }\n        \n        start++\n        end--\n    }\n    \n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp_eiiso1g_test.go:14:25: expected ';', found '{'\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073982
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpkxe3qxma_test.go:50:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073982
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    middle := (start + end) / 2\n    for middle < length {\n        if text[middle] != text[middle+1] {\n            return false\n        }\n        middle++\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\npanic: runtime error: index out of range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range [5] with length 5\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512620, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512620, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838 +0x207\ncommand-line-arguments_test.is_palindrome(...)\n\t/tmp/tmp9z2sonuy_test.go:18\ncommand-line-arguments_test.TestIs_Palindrome(0x0?)\n\t/tmp/tmp9z2sonuy_test.go:35 +0x47f\ntesting.tRunner(0xc00019b1e0, 0x527f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486 +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := (length / 2)\n    for start < middle {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoy54llo2_test.go:10:10: no new variables on left side of :=\n/tmp/tmpoy54llo2_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length <= 0 {\n        return false\n    }\n    start := 0\n    end := length-1\n    middle := (start + end) / 2\n    for start < end {\n        if text[middle] != text[start] {\n            return false\n        }\n        middle++\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__0 (0.00s)\n        tmp_evd0lx__test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmp_evd0lx__test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmp_evd0lx__test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start += 1\n        end -= 1\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpahr_jvmt_test.go:10:10: no new variables on left side of :=\n/tmp/tmpahr_jvmt_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := (length-1)/2\n    for start < middle && end > middle {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return start == end\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length == 0 {\n        return true\n    }\n    if length == 1 {\n        return text == text[:len(text)/2]\n    }\n    if length%2 == 0 {\n        return is_palindrome(text[:length/2]) && is_palindrome(text[length/2:])\n    }\n    return is_palindrome(text[:length/2]) && is_palindrome(text[length/2:])\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmpddimpqo9_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__2 (0.00s)\n        tmpddimpqo9_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmpddimpqo9_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073982
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length <= 0 {\n        return false\n    }\n    for i := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__0 (0.00s)\n        tmpdpckwmf6_test.go:41: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length == 0 {\n        return true\n    }\n    if length == 1 {\n        return text == text[0:length]\n    }\n    left := 0\n    right := length - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        \n        start++\n        end--\n    }\n    \n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi0xkfjb3_test.go:10:10: no new variables on left side of :=\n/tmp/tmpi0xkfjb3_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\"\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpoz4ojl1r_test.go:49:42: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length == 0 {\n        return true\n    }\n    if length == 1 {\n        return text == text[:len(text)/2]\n    }\n    middle := length / 2\n    left := text[:middle]\n    right := text[middle:]\n    return is_palindrome(left) && is_palindrome(right)\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmpdqra_d51_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__2 (0.00s)\n        tmpdqra_d51_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmpdqra_d51_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    left := 0\n    right := length - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length - 1\n\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbt1jw77d_test.go:10:10: no new variables on left side of :=\n/tmp/tmpbt1jw77d_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    \n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptwzhajr6_test.go:10:10: no new variables on left side of :=\n/tmp/tmptwzhajr6_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"$\", \"\", -1)\n    text := strings.Replace(text, \"%\", \"\", -1)\n    text := strings.Replace(text, \"^\", \"\", -1)\n    text := strings.Replace(text, \"&\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"_\", \"\", -1)\n    text := strings.Replace(text, \"=\", \"\", -1)\n    text := strings.Replace(text, \"+\", \"\", -1)\n    text := strings.Replace(text, \"|\", \"\", -1)\n    text := strings.Replace(text, \"{\", \"\", -1)\n    text := strings.Replace(text, \"}\", \"\", -1)\n    text := strings.Replace(text, \"[\", \"\", -1)\n    text := strings.Replace(text, \"]\", \"\", -1)\n    text := strings.Replace(text, \"<\", \"\", -1)\n    text := strings.Replace(text, \">\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"$\", \"\", -1)\n    text := strings.Replace(text, \"%\", \"\", -1)\n    text := strings.Replace(text, \"^\", \"\", -1)\n    text := strings.Replace(text, \"&\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp0ruau421_test.go:51:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmrmqgq42_test.go:10:10: no new variables on left side of :=\n/tmp/tmpmrmqgq42_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\"\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpg8w6sjgw_test.go:49:42: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmrmqgq42_test.go:10:10: no new variables on left side of :=\n/tmp/tmpmrmqgq42_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        \n        start++\n        end--\n    }\n    \n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9cxtnn0u_test.go:10:10: no new variables on left side of :=\n/tmp/tmp9cxtnn0u_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp57uk8vsa_test.go:10:10: no new variables on left side of :=\n/tmp/tmp57uk8vsa_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    if length == 1 {\n        return text == text[0]\n    }\n    if length == 2 {\n        return text == text[0] + text[1]\n    }\n    start := 0\n    end := length-1\n    middle := length / 2\n    for start < middle && end > middle {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9jomq67u_test.go:10:10: no new variables on left side of :=\n/tmp/tmp9jomq67u_test.go:10:13: undefined: strings\n/tmp/tmp9jomq67u_test.go:16:24: invalid operation: text == text[0] (mismatched types string and byte)\n/tmp/tmp9jomq67u_test.go:19:24: invalid operation: text == text[0] + text[1] (mismatched types string and byte)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    start := 0\n    end := len(text) - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3dfs_n3s_test.go:10:10: no new variables on left side of :=\n/tmp/tmp3dfs_n3s_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length == 0 {\n        return true\n    }\n\n    if length == 1 {\n        return text == text[:len(text)/2]\n    }\n\n    middle := length / 2\n    left := text[:middle]\n    right := text[middle:]\n\n    return is_palindrome(left) && is_palindrome(right)\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmprw9qjtil_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__2 (0.00s)\n        tmprw9qjtil_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmprw9qjtil_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := length/2\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps1ryxt_s_test.go:16:5: middle declared but not used\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"_\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"%\", \"\", -1)\n    text := strings.Replace(text, \"$\", \"\", -1)\n    text := strings.Replace(text, \"#\", \"\", -1)\n    text := strings.Replace(text, \"^\", \"\", -1)\n    text := strings.Replace(text, \"&\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"_\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"%\", \"\", -1)\n    text := strings.Replace(text, \"$\", \"\", -1)\n    text := strings.Replace(text, \"#\", \"\", -1)\n    text := strings.Replace(text, \"^\", \"\", -1)\n    text := strings.Replace(text, \"&\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"_\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpgjyan3sd_test.go:50:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start += 1\n        end -= 1\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpscmbw6g1_test.go:10:10: no new variables on left side of :=\n/tmp/tmpscmbw6g1_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := (start + end) / 2\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi242elfq_test.go:10:10: no new variables on left side of :=\n/tmp/tmpi242elfq_test.go:10:13: undefined: strings\n/tmp/tmpi242elfq_test.go:17:5: middle declared but not used\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    for i := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyfxgevb1_test.go:10:10: no new variables on left side of :=\n/tmp/tmpyfxgevb1_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073981
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    start := 0\n    end := length - 1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        \n        start++\n        end--\n    }\n    \n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length == 0 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := (start + end) / 2\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxlj2gf7j_test.go:16:5: middle declared but not used\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    for i := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    text := strings.Replace(text, \" \", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \";\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"[\", \"\", -1)\n    text := strings.Replace(text, \"]\", \"\", -1)\n    text := strings.Replace(text, \"{\", \"\", -1)\n    text := strings.Replace(text, \"}\", \"\", -1)\n    text := strings.Replace(text, \"+\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"^\", \"\", -1)\n    text := strings.Replace(text, \"~\", \"\", -1)\n    text := strings.Replace(text, \"=\", \"\", -1)\n    text := strings.Replace(text, \",\", \"\", -1)\n    text := strings.Replace(text, \".\", \"\", -1)\n    text := strings.Replace(text, \"?\", \"\", -1)\n    text := strings.Replace(text, \"!\", \"\", -1)\n    text := strings.Replace(text, \";\", \"\", -1)\n    text := strings.Replace(text, \"'\", \"\", -1)\n    text := strings.Replace(text, \"(\", \"\", -1)\n    text := strings.Replace(text, \")\", \"\", -1)\n    text := strings.Replace(text, \"/\", \"\", -1)\n    text := strings.Replace(text, \"\\\\\", \"\", -1)\n    text := strings.Replace(text, \"[\", \"\", -1)\n    text := strings.Replace(text, \"]\", \"\", -1)\n    text := strings.Replace(text, \"{\", \"\", -1)\n    text := strings.Replace(text, \"}\", \"\", -1)\n    text := strings.Replace(text, \"+\", \"\", -1)\n    text := strings.Replace(text, \"-\", \"\", -1)\n    text := strings.Replace(text, \"*\", \"\", -1)\n    text := strings.Replace(text, \"^\", \"\", -1)\n    text \nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpp3s5gtvb_test.go:51:6: expected '(', found TestIs_Palindrome\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := (start + end) / 2\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi242elfq_test.go:10:10: no new variables on left side of :=\n/tmp/tmpi242elfq_test.go:10:13: undefined: strings\n/tmp/tmpi242elfq_test.go:17:5: middle declared but not used\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start += 1\n        end -= 1\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    for i := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073983
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start += 1\n        end -= 1\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpscmbw6g1_test.go:10:10: no new variables on left side of :=\n/tmp/tmpscmbw6g1_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    length := len(text)\n    start := 0\n    end := length-1\n    \n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9pinwoti_test.go:10:10: no new variables on left side of :=\n/tmp/tmp9pinwoti_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 1,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length - 1\n    middle := (start + end) / 2\n    for start < end {\n        if text[middle] != text[start] {\n            return false\n        }\n        start++\n        end--\n        middle = (start + end) / 2\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestIs_Palindrome (0.00s)\n    --- FAIL: TestIs_Palindrome/test_num__1 (0.00s)\n        tmp95zcsubl_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Palindrome/test_num__4 (0.00s)\n        tmp95zcsubl_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n    start := 0\n    end := length-1\n    middle := length/2\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps1ryxt_s_test.go:16:5: middle declared but not used\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073984
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    left, right := 0, len(text) - 1\n    for left < right {\n        if text[left] != text[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 2,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    text := strings.ToLower(text)\n    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp71tdzlb0_test.go:10:10: no new variables on left side of :=\n/tmp/tmp71tdzlb0_test.go:10:13: undefined: strings\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073979
    },
    {
      "exit_code": 0,
      "program": "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Checks if given string is a palindrome\nfunc is_palindrome(text string) bool {\n    length := len(text)\n    if length < 2 {\n        return true\n    }\n\n    start := 0\n    end := length-1\n\n    for start < end {\n        if text[start] != text[end] {\n            return false\n        }\n        start++\n        end--\n    }\n\n    return true\n}\n\nfunc TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual: candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected: true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual: candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"), expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660073984
    }
  ]
}