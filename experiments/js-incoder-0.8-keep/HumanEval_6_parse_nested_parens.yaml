name: HumanEval_6_parse_nested_parens
language: js
prompt: "//Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n\
  // [2, 3, 1, 3]\nfunction parse_nested_parens(paren_string){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = parse_nested_parens;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"\
  ),[2, 3, 1, 3]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[1,\
  \ 2, 3, 4]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[4]);\n}\n\ntest();"
completions: ["  var nested = []; // array representing the deepest level of nesting\
    \ of parentheses\n  var paren_string = paren_string.trim(); // remove leading\
    \ and trailing space\n  var paren_string = paren_string.replace(/\\s+/g, \" \"\
    ); // replace any spaces with a single space\n\n  for (var i = 0; i < paren_string.length;\
    \ i++){\n    if (paren_string[i] == '('){ // if we find opening parenthesis, increment\
    \ the nested level\n      nested.push(1);\n    } else if (paren_string[i] == ')'){\
    \ // if we find closing parenthesis, decrement the nested level\n      nested.push(-1);\n\
    \    } else {\n      nested.pop(); // if we find another character, decrease the\
    \ nested level\n    }\n  }\n\n  var max_level = 0; // maximum level of nested\
    \ parentheses\n  for (var i = 0; i < nested.length; i++){\n    if (nested[i] >\
    \ max_level){ // if we find any more levels than previously seen, update the maximum\
    \ level\n      max_level = nested[i];\n    }\n  }\n\n  return max_level; // returns\
    \ the maximum level of nesting of a parentheses\n}\n", "  var level_count = [];\n\
    \  var levels = [];\n  paren_string = paren_string.replace(/\\(\\)/g, ' ').trim();\n\
    \  var nesting_regex = /\\(\\(|\\(\\))/g;\n  while(paren_string.match(nesting_regex)){\n\
    \    level_count.push(paren_string.match(nesting_regex).length);\n    paren_string\
    \ = paren_string.replace(nesting_regex, '');\n  }\n  level_count.push(paren_string.length);\n\
    \  for(var i = level_count.length - 1; i >= 0; i--){\n    levels.push(level_count[i]);\n\
    \  }\n  return levels;\n}\n", "    const level = 0;\n    const max_level = 0;\n\
    \    const groups = {};\n    for (let i = 0; i < paren_string.length; i++){\n\
    \        let c = paren_string[i];\n        if (!(c === '(' || c === '('))\n  \
    \          continue;\n        let levels = groups[c] || 0;\n        if (levels\
    \ < level){\n            level = levels;\n            max_level = level;\n   \
    \     }\n        if (!(c === ')' || c === ')'))\n            levels++;\n     \
    \   groups[c] = levels;\n    }\n    return max_level;\n}\n", "    const max_nesting_level\
    \ = paren_string.replace(/[^ ]+/g, '').length;\n    const group_levels = [];\n\
    \    let nested_level = 0;\n    for(let i = 0; i < paren_string.length; i++){\n\
    \        if(paren_string[i] === '('){\n            if(nested_level > max_nesting_level){\n\
    \                group_levels.push(nested_level);\n            }\n           \
    \ nested_level++;\n        }\n        else if(paren_string[i] === ')'){\n    \
    \        if(nested_level > max_nesting_level){\n                group_levels.push(nested_level);\n\
    \            }\n            nested_level--;\n        }\n    }\n    if(nested_level\
    \ === 0){\n        group_levels.push(nested_level);\n    }\n    return group_levels;\n\
    }\n", "\tvar depth = 0;\n\tvar max_nesting_level = 0;\n\tvar parentheses_level\
    \ = 0;\n\tvar nestings_array = [];\n\n\t//Iterate over each parentheses\n\tfor(var\
    \ i = 0; i < paren_string.length; i++){\n\t\tif((paren_string[i] == '(') || (paren_string[i]\
    \ == '[') || (paren_string[i] == '{')){\n\t\t\tparentheses_level += 1;\n\t\t}\n\
    \t\telse if((paren_string[i] == ')') || (paren_string[i] == ']') || (paren_string[i]\
    \ == '}')){\n\t\t\tparentheses_level -= 1;\n\t\t\tif(parentheses_level == 0){\n\
    \t\t\t\tnestings_array.push(depth);\n\t\t\t\tif(depth > max_nesting_level){\n\t\
    \t\t\t\tmax_nesting_level = depth;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nestings_array;\n\
    }\n", "\tvar nesting_level = 0;\n\tvar parentheses_levels = [];\n\n\tfor(var i\
    \ = 0, len = paren_string.length; i < len; i++){\n\t\tif(paren_string[i]==='('){\n\
    \t\t\tnesting_level++;\n\t\t}\n\t\telse if(paren_string[i]==')'){\n\t\t\tnesting_level--;\n\
    \t\t\tparentheses_levels.push(nesting_level);\n\t\t}\n\t}\n\n\tvar max_level =\
    \ Math.max.apply(null, parentheses_levels);\n\tmax_level = max_level===0 ? 0:\
    \ max_level;\n\n\treturn parentheses_levels.length - max_level;\n}\n", "  var\
    \ level_of_parens = 0;\n  var deepest_level_of_parens = 0;\n  var nested_parens_string\
    \ = paren_string;\n  while (nested_parens_string.length > 0){\n    level_of_parens\
    \ = nested_parens_string.match(/[a-z]{1,2}/g).length;\n    deepest_level_of_parens\
    \ = deepest_level_of_parens + level_of_parens;\n    nested_parens_string = nested_parens_string.replace(/[a-z]{1,2}/g,\
    \ '');\n  }\n  return deepest_level_of_parens;\n}", "    var opening_paren_groups\
    \ = paren_string.match(/\\(/g);\n    var closing_paren_groups = paren_string.match(/\\\
    )/g);\n    var opening_paren_level = 0;\n    var closing_paren_level = 0;\n  \
    \  var nested_paren_levels = [];\n    var nested_paren_groups = [];\n    var level_opening_paren_pairs\
    \ = [];\n    var level_closing_paren_pairs = [];\n    opening_paren_groups.forEach(function(opening_paren_group){\n\
    \        level_opening_paren_pairs.push([]);\n        opening_paren_group.split(\"\
    \ \").forEach(function(character){\n            if(character === \"(\"){\n   \
    \             level_opening_paren_pairs[opening_paren_level].push(opening_paren_group);\n\
    \                opening_paren_level += 1;\n            }else if(character ===\
    \ \")\"){\n                level_opening_paren_pairs[opening_paren_level] = level_opening_paren_pairs[opening_paren_level].sort(function(a,b){\n\
    \                    var a = parseInt(a,10);\n                    var b = parseInt(b,10);\n\
    \                    return a-b;\n                });\n                level_opening_paren_pairs[opening_paren_level].splice(opening_paren_level,1);\n\
    \                opening_paren_level -= 1;\n            }\n        });\n    });\n\
    \    closing_paren_groups.forEach(function(closing_paren_group){\n        level_closing_paren_pairs.push([]);\n\
    \        closing_paren_group.split(\" \").forEach(function(character){\n     \
    \       if(character === \"(\"){\n                level_closing_paren_pairs[closing_paren_level].push(closing_paren_group);\n\
    \                closing_paren_level += 1;\n            }else if(character ===\
    \ \")\"){\n                level_closing_paren_pairs[closing_paren_level] = level_closing_paren_pairs[closing_paren_level].sort(function(a,b){\n\
    \                    var a = parseInt(a,10);\n                    var b = parseInt(b,10);\n\
    \                    return a-b;\n                });\n                level_closing_paren_pairs[closing_paren_level].splice(closing_paren_level,1);\n\
    \                closing_paren_level -= 1;\n            }\n        });\n    });\n\
    \    var level = 0;\n    level_opening_paren_pairs.forEach(function(level_opening_paren_pair){\n\
    \        level_opening_paren_pair.forEach(function(level_opening_paren_group_character){\n\
    \            if(level_opening_paren_group_character === \"(\"){\n            \
    \    nested_paren_groups[level] = level_opening_paren_group;\n               \
    \ nested_paren_levels[level] = opening_paren_level;\n                level +=\
    \ 1;\n            }else if(level_open", "  var result = [];\n  var curr_level\
    \ = 0;\n  var stack = [];\n  var last = [];\n  var open_brace_count = 0; // Number\
    \ of opening braces\n  var close_brace_count = 0; // Number of closing braces\n\
    \n  // Iterate through all the characters in paren_string\n  for(var i=0; i<paren_string.length;\
    \ i++){\n    // Only look at parens\n    if(paren_string[i] == '('){\n      //\
    \ Keep track of number of opening braces\n      open_brace_count++;\n      //\
    \ Push onto the stack\n      stack.push(paren_string[i]);\n    }\n    else if(paren_string[i]\
    \ == ')'){\n      // If number of opening braces is zero, we've just encountered\
    \ the closing bracket\n      if(open_brace_count == 0){\n        // Pop from the\
    \ stack\n        curr_level = stack.pop();\n        // If we are at the top level\
    \ of nesting, then we're done\n        if(curr_level == 0){\n          result.push(last);\n\
    \        }\n        // Otherwise, we're in an intermediate level\n        else\
    \ {\n          stack.push(curr_level);\n          result.push(curr_level);\n \
    \       }\n      }\n      // Keep track of number of closing braces\n      close_brace_count++;\n\
    \    }\n    // Keep track of last character\n    last.push(paren_string[i]);\n\
    \  }\n  return result;\n}\n", "\tvar nested_paren_depth = 0;\n\tvar last_paren_char\
    \ = 0;\n\tfor(var i = 0, len = paren_string.length; i < len;){\n\t\tvar char =\
    \ paren_string.charAt(i++);\n\t\tif (char == '(')\n\t\t\tnested_paren_depth++;\n\
    \t\telse if (char == ')')\n\t\t\tnested_paren_depth--;\n\t\telse if (char == '\
    \ ')\n\t\t\tif (nested_paren_depth > last_paren_char)\n\t\t\t\tnested_paren_depth--;\n\
    \t\tlast_paren_char = nested_paren_depth;\n\t}\n\treturn nested_paren_depth;\n\
    }\n", "  const stack = [];\n  let index = 0;\n  let max_level = 0;\n  let has_empty_p\
    \ = false;\n  let level = 0;\n  while(index < paren_string.length){\n    const\
    \ char = paren_string[index];\n    // If char is a left parentheses char, we are\
    \ going to add the level of nesting to the stack.\n    if(char === '(')\n    \
    \  stack.push(level);\n    // If char is a right parentheses char, we are going\
    \ to pop the level of nesting from the stack.\n    else if(char === ')')\n   \
    \   level = stack.pop();\n    // If char is a space, we can ignore this char.\n\
    \    else if(char === ' ')\n      has_empty_p = true;\n    // If char is a new\
    \ line, we are done.\n    else if(char === '\\n')\n      break;\n    // Otherwise\
    \ we decrease the level of nesting in the stack.\n    else\n      level = stack[stack.length-1];\n\
    \    index++;\n    max_level = max(max_level, level);\n  }\n  return max_level;\n\
    }\n", "\t// Remove extra spaces, including at the beginning/end of the string.\n\
    \tparen_string = paren_string.replace(/^\\s+/, '');\n\tparen_string = paren_string.replace(/\\\
    s+$/, '');\n\t// If the string has no open or close parentheses, return the length\
    \ of the string.\n\tif(!paren_string){\n\t\treturn 0;\n\t}\n\t// Remove all the\
    \ spaces in between open and close parentheses.\n\tvar open_paren = paren_string.indexOf('(');\n\
    \tvar close_paren = paren_string.indexOf(')');\n\tif(close_paren == -1){\n\t\t\
    close_paren = paren_string.length;\n\t}\n\t\n\t// Create an array to hold the\
    \ open and closed parens.\n\tvar parens = [open_paren];\n\t\n\t// Loop through\
    \ each character in the string.\n\tfor(var i = open_paren; i < close_paren; i++){\n\
    \t\t// If the character is a left parenthese, add it to the array and continue.\n\
    \t\tif(paren_string[i] === '('){\n\t\t\tparens.push(paren_string[i]);\n\t\t}\n\
    \t\t// If the character is a right parenthese, remove the last element in the\
    \ array and continue.\n\t\telse if(paren_string[i] === ')'){\n\t\t\tparens.pop();\n\
    \t\t}\n\t\t// If the character is a space, add it to the array and continue.\n\
    \t\telse if(paren_string[i] === ' '){\n\t\t\tparens.push(paren_string[i]);\n\t\
    \t}\n\t\t// If the character is a comma, stop the loop.\n\t\telse if(paren_string[i]\
    \ === ',') {\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Return the number of levels of nesting\
    \ in the string.\n\treturn parens.length;\n}\n", "  let paren_char_count = {};\
    \ //To count the number of times a parentheses has been seen.\n  let paren_string_count\
    \ = 0; //To count the number of groups found in the string.\n  let nested_parens\
    \ = []; //To store each group of nested parentheses.\n  for(let i = 0;i < paren_string.length;i++){\n\
    \    if(paren_char_count[paren_string[i]] === undefined){\n      paren_char_count[paren_string[i]]\
    \ = 1;\n    }else{\n      paren_char_count[paren_string[i]]++;\n    }\n    if(paren_string[i]\
    \ === '('){\n      paren_string_count++;\n    }\n  }\n  for(let i = 0;i < paren_string.length;i++){\n\
    \    if(paren_char_count[paren_string[i]] === 0){\n      nested_parens.push(paren_string_count);\n\
    \    }else if(paren_char_count[paren_string[i]] === 1){\n      paren_string_count--;\n\
    \    }\n  }\n  return nested_parens;\n}\n", "    var stack = [];\n    var level\
    \ = 0;\n    var parens_open = 0;\n    var is_open = false;\n    var in_str = false;\n\
    \    for (var i = 0, len = paren_string.length; i < len; i++){\n        var c\
    \ = paren_string.charAt(i);\n        if (c == '(' || c == '[' || c == '{'){\n\
    \            stack.push(parens_open);\n            is_open = true;\n         \
    \   parens_open++;\n        } else if (c == ')' || c == ']' || c == '}'){\n  \
    \          var new_level = level - parens_open;\n            while (stack.length\
    \ > 0 && stack[stack.length - 1] == new_level){\n                parens_open--;\n\
    \                is_open = false;\n                stack.pop();\n            }\n\
    \            is_open = false;\n            parens_open--;\n            level--;\n\
    \            if (stack.length == 0)\n                return level;\n        }\
    \ else {\n            is_open = false;\n        }\n    }\n    return -1;\n};\n",
  "    let nested_count = 1; //To store the deepest level of nesting for the input\
    \ string.\n    let paren_stack = []; //To store all the groups in parenthesis\
    \ separated by spaces.\n    for(let index = 0; index < paren_string.length; index++){\n\
    \        if(paren_string[index] == '('){\n            paren_stack.push(paren_string[index]);\n\
    \        }\n        else if(paren_string[index] == ')'){\n            nested_count--;\n\
    \            if(nested_count == 0){\n                let current_group_size =\
    \ paren_stack.pop();\n                let current_group_index = paren_stack.indexOf(current_group_size);\n\
    \                let parent_group_index = current_group_index + 1;\n         \
    \       paren_string = paren_string.slice(parent_group_index + 1, index+1);\n\
    \            }\n        }\n    }\n    return paren_string.split(\" \");\n}\n",
  "  let parens_level = [];\n  \n  for (let i = 0; i < paren_string.length; i++){\n\
    \    let character = paren_string.charAt(i);\n    if (character === '(' || character\
    \ === '{' || character === '[') parens_level.push(i);\n    else if (character\
    \ === '{' || character === '[') parens_level.push(i + 1);\n    else if (character\
    \ === ')' || character === '}' || character === ']') parens_level.pop();\n  }\n\
    \  \n  return parens_level;\n}\n", "\tvar paren_level = -1;\n\tvar paren_nesting\
    \ = 0;\n\tfor(var i=0; i < paren_string.length; i++){\n\t\tif(paren_string[i]\
    \ === '('){\n\t\t\tparen_level++;\n\t\t}\n\t\telse if(paren_string[i] === ')'){\n\
    \t\t\tparen_level--;\n\t\t\tif(paren_level === 0){\n\t\t\t\tparen_nesting++;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn paren_nesting;\n}\n", "\tvar nested_level = 0;\n\
    \tvar tokens = paren_string.match(/[^()]+|[\\(\\)]/g);\n\tvar group = [];\n\t\
    for (var i = 0; i < tokens.length; i++){\n\t\tvar token = tokens[i];\n\t\tif (token\
    \ === ')'){\n\t\t\tnested_level--;\n\t\t}\n\t\telse if (token === '('){\n\t\t\t\
    nested_level++;\n\t\t}\n\t\telse if (nested_level === 0){\n\t\t\tgroup.push(token);\n\
    \t\t}\n\t\telse if (nested_level > 0){\n\t\t\tgroup.push(token);\n\t\t}\n\t}\n\
    \treturn group;\n}\n", "\tconst parens_groups = paren_string.trim().split(/\\\
    s+/);\n\tconst levels = [];\n\tlet max_level = -1;\n\n\tfor (let group of parens_groups){\n\
    \t\tconst level_groups = group.split('(');\n\t\tfor (let level_group of level_groups){\n\
    \t\t\tlevels.push(parseInt(level_group.split(')')[0]));\n\t\t}\n\t}\n\n\tlevels.push(levels.length);\n\
    \tfor (let level of levels){\n\t\tif (level > max_level){\n\t\t\tmax_level = level;\n\
    \t\t}\n\t}\n\n\treturn max_level;\n}\n", "\tlet max_level = 0;\n\tlet open_count\
    \ = [0, 0, 0, 0, 0];\n\n\tfor(let i = 0; i < paren_string.length; i++){\n\t\t\
    open_count[paren_string.charAt(i)-'a']++;\n\t}\n\n\tfor(let i = 0; i <= 7; i++){\n\
    \t\tif(open_count[i] === 0){\n\t\t\tmax_level = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\
    \n\treturn max_level;\n}\n", "  var group_count = 0\n  var nested_count = []\n\
    \  for(var i = 0; i< paren_string.length; i++){\n    if(paren_string[i] == '('){\n\
    \      nested_count[group_count] += 1\n    }\n    if(paren_string[i] == ')'){\n\
    \      nested_count[group_count] -= 1\n      if(nested_count[group_count] == 0){\n\
    \        group_count += 1\n      }\n    }\n  }\n  return nested_count\n}\n", " \
    \ let paren_level = paren_string.split(' ').length-1;\n  return paren_level;\n\
    }", "  var nested_parens_level = [];\n  for (var i = 0; i < paren_string.length;\
    \ i++){ \n    var groups = paren_string.charAt(i).split(' '); \n    if (groups.length\
    \ && groups[0].length){ \n      nested_parens_level.push(groups[0].length);\n\
    \    }\n  }\n  return nested_parens_level.reverse();\n}\n", "    var paren_count\
    \ = 0;\n    var max_paren_level = 0;\n    var nested_parens = [];\n\n    //Initialize\
    \ max level of nested parentheses.\n    for (var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === '(') paren_count += 1;\n        if(paren_string[i]\
    \ === ')') paren_count -= 1;\n        if(paren_count > max_paren_level){\n   \
    \         max_paren_level = paren_count;\n        }\n    }\n\n    //Iterate over\
    \ string and parse nested parentheses.\n    for (var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === '('){\n            nested_parens[nested_parens.length]\
    \ = i;\n            paren_count++;\n        }\n\n        else if(paren_string[i]\
    \ === ')'){\n            var last_position = nested_parens.pop();\n          \
    \  if(max_paren_level - paren_count <= nested_parens.length){\n              \
    \  nested_parens[nested_parens.length] = last_position;\n            }\n     \
    \       paren_count--;\n        }\n    }\n\n    //Return maximum level of nested\
    \ parentheses.\n    return nested_parens;\n}\n", "\tvar nested_paren_stack = [];\n\
    \tvar i = 0;\n\twhile(i < paren_string.length){\n\t\tvar char = paren_string.charAt(i);\n\
    \t\tif(char == '(' || char == '[' || char == '{'){\n\t\t\tnested_paren_stack.push(char)\n\
    \t\t} else if(char == '('){\n\t\t\tif(nested_paren_stack.length == 0) return 0\n\
    \t\t\tvar current_char = nested_paren_stack.pop();\n\t\t\tif(current_char != '(')\
    \ return 0\n\t\t} else if(char == '{'){\n\t\t\tif(nested_paren_stack.length ==\
    \ 0) return 0\n\t\t\tvar current_char = nested_paren_stack.pop();\n\t\t\tif(current_char\
    \ != '{') return 0\n\t\t} else {\n\t\t\ti++\n\t\t}\n\t\ti++\n\t}\n\treturn nested_paren_stack.length\n\
    }\n", "    var level = 0;\n    var nested_level = 0;\n    var brackets = paren_string.match(/\\\
    (|\\)/g);\n    if(brackets != null){\n        brackets.forEach(function(bracket){\n\
    \            if(bracket == \"(\"){\n                nested_level++;\n        \
    \    }\n            else{\n                nested_level--;\n            }\n  \
    \          if(nested_level > level){\n                level = nested_level;\n\
    \            }\n        });\n    }\n    return level;\n}\n", "\tvar paren_count\
    \ = 0;\n\tvar paren_stack = [];\n\tvar result = [];\n\tvar i, j, paren_level;\n\
    \tfor(i = 0; i < paren_string.length; i++){\n\t\tif((paren_count > 0) && (paren_count\
    \ % 2 === 0)){\n\t\t\tresult.push(paren_level);\n\t\t\tparen_stack.push(paren_level);\n\
    \t\t}\n\t\telse if(paren_string[i] === '('){\n\t\t\tparen_count++;\n\t\t}\n\t\t\
    else if(paren_string[i] === ')'){\n\t\t\tparen_count--;\n\t\t\tparen_level = paren_stack.pop();\n\
    \t\t}\n\t}\n\tif(paren_count !== 0){\n\t\tthrow \"Invalid input\";\n\t}\n\treturn\
    \ result;\n}\n", "\tvar level = 0,\n\t\tparen_depth = 1,\n\t\toutput = [],\n\t\
    \tgroups = paren_string.match(/\\(.*?\\)/g);\n\n\tfor (var i = 0; i < groups.length;\
    \ i++) {\n\t\tvar group = groups[i].split(' ');\n\t\tvar start = group[0].length,\n\
    \t\t\tend = group[0].length;\n\n\t\tvar nesting = 1;\n\t\tfor (var j = 1; j <\
    \ group.length; j++) {\n\t\t\tvar subgroup = group[j];\n\t\t\tif (subgroup[0]\
    \ == '(') {\n\t\t\t\tnesting++;\n\t\t\t} else if (subgroup[0] == ')') {\n\t\t\t\
    \tnesting--;\n\t\t\t}\n\t\t\tif (nesting < 0) {\n\t\t\t\tstart = group[j-1].length+1;\n\
    \t\t\t\tend = group[j-1].length + group[j].length - 1;\n\t\t\t\tbreak;\n\t\t\t\
    }\n\t\t}\n\t\toutput.push(end - start);\n\t}\n\treturn output;\n}\n", "\tvar max_level\
    \ = 0;\n\tfor(var i=0; i<paren_string.length; i++){\n\t\tif(paren_string.charAt(i)\
    \ == '('){\n\t\t\tmax_level = max(max_level, i);\n\t\t}\n\t\telse{\n\t\t\tmax_level\
    \ = max(max_level, paren_string.lastIndexOf(')', i));\n\t\t}\n\t}\n\treturn max_level;\n\
    }\n", "\tlet output = []\n\tlet level = 0\n\tfor (let i = 0; i < paren_string.length;\
    \ i++){\n\t\tif (paren_string[i] == \"(\"){\n\t\t\tlevel++\n\t\t} else if (paren_string[i]\
    \ == \")\"){\n\t\t\tlevel--\n\t\t\tif (level < 0){\n\t\t\t\tthrow new SyntaxError(\"\
    Malformed parentheses\")\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(level)\n\t\t\
    }\n\t}\n\treturn output\n}\n", "    //Input string must be of parenthesis form.\n\
    \    // Throw exception otherwise.\n    if(paren_string.indexOf(\"(\") < 0 \n\
    \        || paren_string.indexOf(\")\") < 0 \n        || paren_string.indexOf(\"\
    \ \") < 0){\n        throw \"Wrong input string format\";\n    }\n    //Initialize\
    \ an array to store all level counts of nested parenthesis.\n    var paren_array\
    \ = [];\n    //Initialize a level counter to store the number of nested parentheses.\n\
    \    var level = 0;\n    //Iterate through all the chars in the string and record\
    \ the level count.\n    for(var i=0;i<paren_string.length;i++){\n        //If\
    \ the char is an opening parentheses, increase the level count.\n        if(paren_string.charAt(i)\
    \ == \" \" && paren_array[level] == 0){\n            paren_array[level] = 1;\n\
    \        }\n        //If the char is an closing parentheses, decrease the level\
    \ count.\n        else if(paren_string.charAt(i) == \" \" && paren_array[level]\
    \ == 1){\n            paren_array[level] = -1;\n        }\n        //If the level\
    \ of the parentheses is -1, store the level of nesting in the array.\n       \
    \ else if(paren_array[level] == -1){\n            paren_array[level] = paren_string.charAt(i);\n\
    \        }\n        //If the level of the parentheses is 1, store the previous\
    \ level in the array.\n        else if(paren_array[level] == 1){\n           \
    \ paren_array[level-1] = paren_string.charAt(i);\n        }\n        //If the\
    \ level of the parentheses is 2, store the level of nesting in the array.\n  \
    \      else if(paren_array[level] == 2){\n            paren_array[level-2] = paren_string.charAt(i);\n\
    \        }\n        //If the level of the parentheses is higher than 2, throw\
    \ an error.\n        else if(paren_array[level] >= 3){\n            throw \"Error\
    \ occurred in parsing nested parentheses\";\n        }\n    }\n    //Return the\
    \ level of nesting array.\n    return paren_array;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nCan you please explain why you think this method is better than\
    \ the accepted answer? I've found it much easier to understand and I feel it more\
    \ accurately represents the problem.\n<|/ c |>\n<| a tags=string,regex,javascript\
    \ dscore=0 |>\n<code>\nconst parens = \"(())\";\nlet open = 0,\n  close = 0;\n\
    \nconst nestedDepth = parens.split(\"(\").reduce((acc, cur) => {\n  if (cur ==\
    \ \")\") {\n    close++;\n  } else if (cur == \"(\") {\n    open++;\n  }\n  return\
    \ acc + open;\n}, 0);\n", "    paren_string = paren_string.replace(/\\s+/g, \"\
    \ \")\n    var groups = paren_string.match(/(\\([^\\(\\)]*\\))+/g)\n    var max_level\
    \ = -1\n    var level = 0\n    for (var i = 0; i < groups.length; i++){\n    \
    \    if (max_level == -1 || level < max_level){\n            max_level = level\n\
    \        }\n        level = level + 1\n    }\n    return max_level\n}\n", "  \
    \  var paren_array = paren_string.split(\" \");\n    var level = 0;\n    var max_level\
    \ = 0;\n    for(var index = 0; index < paren_array.length; index++){\n       \
    \ var paren_count = paren_array[index].length;\n        level++;\n        if(paren_count\
    \ > max_level){\n            max_level = paren_count;\n        }\n    }\n    return\
    \ max_level;\n}\n", "    // Write your code here.\n    var groups = paren_string.split('\
    \ ');\n    var max_depth = 0;\n    for(var i = 0; i < groups.length; i++){\n \
    \       var depth = parens_depth(groups[i]);\n        if(depth > max_depth){\n\
    \            max_depth = depth;\n        }\n    }\n    return max_depth;\n}\n",
  "  \n  if(paren_string.length < 1 || paren_string.trim() == ''){\n    throw('Invalid\
    \ Paren String: Empty Paren String or Spaces');\n  }\n  \n  \n  // 1. Split parens\
    \ into array of array of strings:\n  var split_str = paren_string.trim().split('\
    \ ').map(function(el) {\n    return el.trim().split('')\n  });\n  \n  // 2. Get\
    \ the deepest level of nesting for every paren string and push it into result\
    \ array.\n  var result_arr = split_str.map(function(el){\n    var max_depth =\
    \ 0;\n    el.forEach(function(el, index) {\n      if(index > 0){\n        if(el[0]\
    \ == '(' && el[index-1][0] == ')'){\n          max_depth++;\n        }\n     \
    \   if(el[0] == ')' && el[index-1][0] == ')'){\n          max_depth--;\n     \
    \   }\n      }\n    });\n    return max_depth;\n  });\n  \n  return result_arr;\n\
    }\n", "\tvar paren_levels = 0;\n\tvar paren_char = null;\n\tvar paren_match =\
    \ null;\n\tvar output_array = [];\n\tfor (var i = 0; i < paren_string.length;\
    \ i++){\n\t\tparen_char = paren_string[i];\n\t\tparen_match = paren_regex[paren_char];\n\
    \t\tif (paren_match){\n\t\t\tif (paren_match[1]){\n\t\t\t\toutput_array.push(paren_match[1].match(paren_match[2]));\n\
    \t\t\t\tparen_levels++;\n\t\t\t}else if (paren_match[2]){\n\t\t\t\tparen_levels++;\n\
    \t\t\t}else if (paren_levels){\n\t\t\t\toutput_array.push(paren_levels);\n\t\t\
    \t}\n\t\t}\n\t}\n\treturn output_array;\n}", "  const max_nesting_level = []\n\
    \  let nesting_level = 0\n  const paren_regex = /\\(|\\)/g\n  let paren_count\
    \ = 0\n  while (paren_count < paren_string.length){\n    const paren_match = paren_string.match(paren_regex)\n\
    \    if (paren_match){\n      nesting_level++\n      max_nesting_level[nesting_level]\
    \ = nesting_level\n    }\n    paren_count += 1\n  }\n  return max_nesting_level\n\
    }\n", "    var nested_paren_counts = [];\n    var paren_match_string = paren_string.replace(/\\\
    s{2,}/g, \" \");\n    paren_match_string = paren_match_string.split(\" \");\n\
    \    for(var i = 0; i < paren_match_string.length; i++){\n        var group_count\
    \ = paren_match_string[i].match(/[^\\(\\)\\s]/g).length;\n        if(group_count\
    \ > 0) nested_paren_counts.push(group_count);\n    }\n    return Math.max(...nested_paren_counts);\n\
    }\n", "    var result = 0;\n    var open_count = 0\n    for(var i=0;i<paren_string.length;i++){\n\
    \        if(paren_string[i]==\"(\"){\n            open_count++\n        }\n  \
    \      else if(paren_string[i]==\")\"){\n            open_count--\n        }\n\
    \        if(open_count==0){\n            result++\n        }\n    }\n    return\
    \ result\n}\n", "    var groups = [],\n        group_index = 0,\n        group_level\
    \ = 0,\n        current_group = [],\n        current_level = 0;\n    for(var i\
    \ = 0; i < paren_string.length; i++){\n        var c = paren_string[i];\n    \
    \    if(c == \"(\"){\n            if(group_level == 0){\n                current_group.push(c);\n\
    \                group_index++;\n            }\n            group_level++;\n \
    \           current_level.push(group_index);\n        }\n        else if(c ==\
    \ \")\"){\n            group_level--;\n            group_index = current_level.pop();\n\
    \        }\n        if(group_level == 0 && current_group.length > 0){\n      \
    \      groups.push(current_group);\n        }\n    }\n    return groups;\n}\n",
  "\tlet paren_count = 0;\n\tlet max_paren_count = 0;\n\tlet paren_level = [];\n\t\
    let paren_group = [];\n\tlet paren_group_level = [];\n\tlet paren_char;\n\n\t\
    //Count the number of parentheses characters in paren_string and record the maximum\
    \ level of nesting\n\tfor(paren_char of paren_string){\n\t\tif(paren_char ===\
    \ '('){\n\t\t\tparen_count++;\n\t\t}\n\t\telse if(paren_char === ')'){\n\t\t\t\
    paren_count--;\n\t\t}\n\t\telse{\n\t\t\t//We are in a nested parentheses\n\t\t\
    \tif(paren_char === ' ' && paren_count < 0){\n\t\t\t\t//If parenthesis count is\
    \ negative then this means there are unbalanced parentheses characters\n\t\t\t\
    \t//e.g. unbalanced parentheses\n\t\t\t\t//>>> parse_nested_parens(' (()()) ')\n\
    \t\t\t\t//[1, -1, -2, -1, -2]\n\t\t\t\t//Remove the negative sign from the paren_group_level\
    \ array because the sign indicates a negative nesting\n\t\t\t\t//e.g. -2\n\t\t\
    \t\t//>>> paren_group_level.pop() \n\t\t\t\t//-2\n\t\t\t\tparen_group_level.pop();\n\
    \t\t\t}\n\t\t\telse{\n\t\t\t\t//If parenthesis count is positive then this means\
    \ there were balanced parentheses characters\n\t\t\t\t//e.g. balanced parentheses\n\
    \t\t\t\t//>>> parse_nested_parens(' ()()')\n\t\t\t\t//[-1, 1, -1, -1, 1, -1]\n\
    \t\t\t\tif(paren_count > 0){\n\t\t\t\t\tparen_group_level.push(paren_count);\n\
    \t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t//This means all the parentheses characters\
    \ were paired up correctly\n\t\t\t\t\t//e.g. correct parentheses\n\t\t\t\t\t//>>>\
    \ parse_nested_parens('()()')\n\t\t\t\t\t//[1, 1, 1]\n\t\t\t\t\t//Parentheses\
    \ are now balanced\n\t\t\t\t\t//Increment max_paren_count by 1\n\t\t\t\t\tmax_paren_count++;\n\
    \t\t\t\t\tparen_count.push(max_paren_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\
    \n\t//Now we have an array of levels for all the parentheses groups\n\t//e.g.\
    \ [1, 1, 1]\n\t//Now add the maximum number of parentheses\n\t//e.g. [2, 3, 3]\n\
    \tparen_count.push(max_paren_count);\n\n\t//Now add the levels for each parentheses\
    \ group\n\t//e.g. [2, 3, 3, 3]\n\t//Sort by decreasing level\n\t//e.g. [-1, 1,\
    \ -1, -1, 1, -1]\n\tparen_count.sort(function(a, b){\n\t\tlet aVal = a;\n\t\t\
    let bVal = b;\n\n\t\tif(a > b){\n\t\t\treturn -1;\n\t\t}\n\t\tif(a < b){\n\t\t\
    \treturn 1;\n\t\t}\n\t\treturn 0;\n", "    var par_string = paren_string.trim().replace(/\\\
    s+/g, \" \").split(\" \");\n    var levels = par_string.map(function(s){return\
    \ s.length});\n    var result = levels\n        .map(function(s, i){\n       \
    \     var nxt = par_string[i + 1];\n            var max = levels[i + 1] || 0;\n\
    \            return nxt.length <= max;\n        })\n        .reduce(function(a,\
    \ b){return a || b});\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ doesn't work if the parentheses are nested.  E.g. (() )\n<|/ c |>\n<| a tags=javascript,algorithm\
    \ |>\nFor a simple case, it looks like this (with a slight modification to account\
    \ for empty strings):\n<code>", "\tlet max_level = 0;\n\tlet max_levels = [];\n\
    \tlet level = 0;\n\tlet levels = [];\n\tlet last_paren = null;\n\tlet last_paren_pos\
    \ = 0;\n\tlet paren_counter = 0;\n\n\twhile (paren_counter < paren_string.length){\n\
    \t\tlet char = paren_string[paren_counter];\n\t\tlet paren_index = paren_string.indexOf(char,\
    \ last_paren_pos);\n\t\tlet paren_chars = paren_string.slice(last_paren_pos, paren_index);\n\
    \t\tlet paren_pos = paren_string.indexOf(char, paren_index + 1);\n\n\t\tfor (let\
    \ i = 0; i < paren_chars.length; i++){\n\t\t\tif (paren_chars[i] == '('){\n\t\t\
    \t\tif (level == 0){\n\t\t\t\t\tlevel++;\n\t\t\t\t\tlevels.push(level);\n\t\t\t\
    \t}\n\t\t\t\telse{\n\t\t\t\t\tif (levels[level - 1] < level){\n\t\t\t\t\t\tlevel\
    \ = levels[level - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlevel++;\n\t\
    \t\t\t\t\tlevels.push(level);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if\
    \ (paren_chars[i] == ')'){\n\t\t\t\tif (levels[level - 1] > level){\n\t\t\t\t\t\
    level = levels[level - 1];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlevel--;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (paren_pos != -1){\n\t\t\tlast_paren = char;\n\
    \t\t\tlast_paren_pos = paren_pos;\n\t\t}\n\t\telse{\n\t\t\tlast_paren = char;\n\
    \t\t\tlast_paren_pos = paren_string.length;\n\t\t}\n\t\tparen_counter++;\n\t}\n\
    \n\treturn levels;\n}\n", "\tvar levels=[];\n\tfor(var i=0;i<paren_string.length;i++){\n\
    \t\tif(paren_string.charAt(i)==')'){\n\t\t\tlevels[levels.length-1]--;\n\t\t}\n\
    \t\tif(levels[levels.length-1]<0){\n\t\t\tlevels.push(paren_string.length);\n\t\
    \t}\n\t}\n\treturn levels;\n}\n\n", "  let re = /\\((.*?)\\)/g;\n  let matches\
    \ = paren_string.match(re);\n  let result = [];\n  for (let match of matches){\n\
    \    result.push(match);\n  }\n  return result;\n}\n", "  var levels = []\n  var\
    \ level_counter = 0\n  var level_level_counter = 0\n  var curr_level_level_counter\
    \ = 0\n  var level = 0\n  var bracket_open = false\n  var prev_char = ' '\n  var\
    \ paren_count = 0\n  for(var i = 0; i < paren_string.length; i++){\n    curr_level_level_counter\
    \ = level_level_counter\n    curr_level_counter = level_counter\n    level_level_counter\
    \ = level_counter\n    level = level_counter\n    if(paren_string[i] == '('){\n\
    \      paren_count += 1\n      if(paren_count > 1){\n        level_level_counter\
    \ += 1\n      }\n    } else if(paren_string[i] == ')'){\n      paren_count -=\
    \ 1\n      if(paren_count > 0){\n        level_level_counter += 1\n      }\n \
    \   }\n\n    if(curr_level_level_counter < level_level_counter){\n      level_counter\
    \ += 1\n    }\n  }\n\n  for(var i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ == '('){\n      if(level_counter == 1){\n        bracket_open = true\n     \
    \ } else if(level_counter > 1){\n        bracket_open = false\n      }\n    }\
    \ else if(paren_string[i] == ')'){\n      if(level_counter == 0){\n        bracket_open\
    \ = false\n      } else if(level_counter > 0){\n        bracket_open = true\n\
    \      }\n    }\n    if(bracket_open == true){\n      levels.push(level)\n   \
    \ }\n  }\n  return levels\n}\n", "    var max_level = 0;\n    var output = [];\n\
    \    for(var i = 0; i < paren_string.length; i++){\n        var character = paren_string[i];\n\
    \        if(character == \"(\"){\n            output.push(max_level);\n      \
    \      max_level += 1;\n        }else if(character == \")\"){\n            if(max_level\
    \ > 0){\n                max_level -= 1;\n            }else{\n               \
    \ console.error('Input is invalid. Cannot parse nested parentheses from string.');\n\
    \                return false;\n            }\n        }\n    }\n    output.push(max_level);\n\
    \    return output;\n}\n", "    // Keep track of level inside parentheses pairs\n\
    \    var levels = [];\n    for(var i=0; i< paren_string.length; i++){\n      \
    \  var level = levels.length + 1; // 0 is outermost level\n        // If current\
    \ char is a left parenthesis, level increases\n        if(paren_string[i] == '('){\n\
    \            level++;\n            // Append level count to list of levels\n \
    \           levels.push(level);\n        }\n        // If current char is a right\
    \ parenthesis, level is decreases\n        else if(paren_string[i] == ')'){\n\
    \            level--;\n            // If the level is less than 1, the level is\
    \ invalid\n            if(level < 1){\n                // Throw an error\n   \
    \             throw Error(\"invalid nesting level\");\n            }\n       \
    \     // Append the level to the list of levels\n            levels.push(level);\n\
    \        }\n        // If current char is a space or line break, level is reset\
    \ to zero\n        else if(paren_string[i] == ' ' || paren_string[i] == '\\n'){\n\
    \            level = 0;\n        }\n    }\n    // Return the deepest level of\
    \ nesting\n    return levels.pop();\n}\n\n", "    // Iterate through the string\
    \ and keep track of the nesting level of parens\n    var max_level = 0;\n    for(var\
    \ i = 0; i < paren_string.length; i++){\n        if(paren_string[i] === '('){\n\
    \            max_level += 1;\n        } else if(paren_string[i] === ')'){\n  \
    \          max_level -= 1;\n        }\n    }\n    // Return the max level\n  \
    \  return max_level;\n}\n", "    var num_levels = -1;\n    var levels_of_nesting\
    \ = [];\n    var level = 0;\n    for (var i = 0, len = paren_string.length; i\
    \ < len; i++){\n        var char = paren_string[i];\n        if (char === '('){\n\
    \            level++;\n        } else if (char === ')'){\n            level--;\n\
    \            if (level === 0){\n                levels_of_nesting.push(level);\n\
    \                num_levels = levels_of_nesting.length - 1;\n            }\n \
    \       }\n    }\n    return levels_of_nesting;\n}\n", "\tlet stack = [];\n\t\
    paren_string.split(\" \").map(x => stack = stack.concat(x));\n\treturn stack.reduce((acc,\
    \ val) => {\n\t\tif(val === \")\") return acc - 1;\n\t\treturn acc + Math.max(\n\
    \t\t\t(\n\t\t\t\tstack.reduce((acc, val) => {\n\t\t\t\t\tif(val === \")\") return\
    \ acc - 1;\n\t\t\t\t\tif(val === \") \") return acc + 1;\n\t\t\t\t\treturn acc;\n\
    \t\t\t\t}, 0) \n\t\t\t),\n\t\t\t0\n\t\t);\n\t}, 0);\n}\n", "\tvar results = [];\n\
    \tvar paren_len = paren_string.length;\n\tvar current_level = 0;\n\tfor(var i\
    \ = 0; i < paren_len; i++){\n\t\tvar char = paren_string.charAt(i);\n\t\tif(char\
    \ === '('){\n\t\t\tcurrent_level++;\n\t\t}else if(char === ')'){\n\t\t\tcurrent_level--;\n\
    \t\t}\n\t\tif(!current_level){\n\t\t\tresults.push(current_level);\n\t\t}\n\t\
    }\n\treturn results;\n}\n\n", "\tvar paren_groups = [];\n\tvar paren_levels =\
    \ paren_string.match(/(\\([^\\(\\)]*\\))+/g);\n\tvar current_paren_level = 0;\n\
    \tvar prev_paren_level = 0;\n\tfor (var i = 0; i < paren_levels.length; i++){\n\
    \t\tif (paren_levels[i].match(/[^\\(]/g) == null){ //If there are no open parens,\
    \ then the paren_level is the level of nesting right after the last close paren.\n\
    \t\t\tparen_levels[i] = paren_levels[i].match(/[^\\(]*/)[0];\n\t\t}\n\t\tvar new_paren_levels\
    \ = paren_levels[i].match(/(\\([^\\(\\)]*\\))*/g);\n\t\tparen_groups.push(new_paren_levels);\n\
    \t\tprev_paren_level = current_paren_level;\n\t\tcurrent_paren_level += new_paren_levels.length;\n\
    \t}\n\tfor (var i = 0; i < paren_groups.length; i++){\n\t\tfor (var j = 0; j <\
    \ prev_paren_level; j++){\n\t\t\tparen_groups[i][j] = 0;\n\t\t}\n\t}\n\treturn\
    \ paren_groups;\n}", "    paren_string = paren_string.replace(/\\s/g, '');\n \
    \   var max_nested_level = 1;\n    var nested_level = 0;\n    for (var i in paren_string){\n\
    \        if (paren_string[i] == '('){\n            nested_level++;\n        }\n\
    \        if (paren_string[i] == ')'){\n            nested_level--;\n        }\n\
    \        if (nested_level > max_nested_level){\n            max_nested_level =\
    \ nested_level;\n        }\n    }\n    return max_nested_level;\n}\n", "  // initialize\
    \ array to store level of nesting\n  const nesting = []\n  \n  // initialize counters\
    \ to store index of opening paren and closing paren\n  let num_open = 0\n  let\
    \ num_close = 0\n\n  // loop through all parentheses\n  for (let i = 0; i < paren_string.length;\
    \ i++) {\n    // find matching parentheses\n    if (paren_string[i] === \"(\"\
    ) {\n      // if opening a new level, increment counters\n      if (num_open ===\
    \ 0) num_open++\n    } else {\n      // if closing a level, decrement counters\n\
    \      if (num_close === 0) num_close--\n    }\n\n    // if opening or closing\
    \ levels change, update array value\n    if (num_open >= num_close) nesting.pop()\n\
    \    else nesting.push([num_open, num_close])\n\n    // reset counters\n    num_open\
    \ = 0\n    num_close = 0\n  }\n\n  // return the number of levels of nesting found\n\
    \  return nesting.length\n}\n", "    var depth=0;\n    var parenStack=[paren_string[0]];\n\
    \    for(var i=1;i<paren_string.length;i++){\n        if(paren_string[i]==\"(\"\
    ){\n            parenStack.push(\")\");\n            depth++;\n        }\n   \
    \     else if(paren_string[i]==\")\"){\n            if(parenStack[parenStack.length-1]==\"\
    (\"){\n                depth--;\n            }\n            parenStack.pop();\n\
    \        }\n    }\n    return depth;\n}", "  let nested_parens = [];\n  paren_string.split(\"\
    \ \").forEach((paren_string, index) => {\n    let num_parens = paren_string.length;\n\
    \    // If this paren string is of the form ((), then it only has 1 level.\n \
    \   if (paren_string.includes(\"()\")) {\n      if (num_parens === 1) {\n    \
    \    nested_parens.push(index);\n      } else {\n        let max_level = parseInt(num_parens\
    \ / 2);\n        for (let i = index; i < (index + max_level); i++) {\n       \
    \   nested_parens.push(i);\n        }\n      }\n    }\n    // If this paren string\
    \ has more than 1 level, go deeper.\n    if (num_parens > 1) {\n      let max_level\
    \ = parseInt(num_parens / 2);\n      nested_parens.push(index);\n      for (let\
    \ i = index; i < index + max_level; i++) {\n        nested_parens.push(i);\n \
    \     }\n    }\n  });\n  return nested_parens;\n}\n", "  var nested_para_levels\
    \ = [];\n  var para_strings = paren_string.split(/\\s+/);\n  para_strings.forEach(function(string_element){\n\
    \    var para_level = -1;\n    var para_string_array = string_element.split('(');\n\
    \    para_string_array.forEach(function(para_string_element){\n      para_level\
    \ = para_level + 1;\n      nested_para_levels.push(para_level);\n    });\n  });\n\
    \  return nested_para_levels;\n}", "  var nested_parens_count = [0, 0, 0];\n \
    \ paren_string = paren_string.trim();\n  var parens_array = paren_string.match(/[\\\
    (\\)\\s]/g);\n  for(var i = 1; i < parens_array.length; i++){\n    switch(parens_array[i][0]){\n\
    \      case \"(\":\n        nested_parens_count[0]++;\n        break;\n      case\
    \ \")\":\n        nested_parens_count[1]++;\n        break;\n      case \" \"\
    :\n        nested_parens_count[2]++;\n        break;\n      default:\n       \
    \ console.log(\"Error: Unrecognized character in parens_array: \" + parens_array[i][0]);\n\
    \        console.log(\"Error on parens_string: \" + paren_string);\n    }\n  }\n\
    \  return nested_parens_count;\n}\n", "  if(paren_string.length <= 0)\n      return\
    \ [];\n\n  var current_level = 0,\n      groups = [],\n      group = [],\n   \
    \   group_len = 0;\n\n  //First pass to find out how many groups to create.\n\
    \  for(var i = 0; i < paren_string.length; i++){\n      var c = paren_string[i];\n\
    \      if(c == '(')\n          group_len++;\n      else if(c == ')')\n       \
    \   group_len--;\n\n      //If this character is ending paren, start a new group\
    \ and keep it nested.\n      if(c == ')'){\n          if(group_len == 0){\n  \
    \            //Add this group to the groups of its parent.\n              group[groups.length]\
    \ = group;\n              group = [];\n              current_level++;\n      \
    \    }\n      } else if(c == '('){\n          if(group_len > 0){\n           \
    \   //If the group had children before, join the group and start a new one.\n\
    \              if(group.length > 0)\n                  groups[groups.length] =\
    \ group;\n              group = [];\n              current_level++;\n        \
    \  }\n      }\n  }\n\n  //Add this group to the groups of its parent.\n  group[groups.length]\
    \ = group;\n\n  return current_level;\n}\n", "    if(paren_string === undefined){\n\
    \        throw \"Input must be a string representing multiple groups for nested\
    \ parentheses separated by spaces.\";\n    }\n\n    //This array keeps track of\
    \ the deepest level of nesting of parentheses\n    //For each group of parentheses,\
    \ it has the length of the number of nested parentheses.\n    var max_levels =\
    \ new Array(paren_string.length);\n\n    for(let i=0; i<paren_string.length; i++){\n\
    \        var current_level = max_levels[i];\n\n        //If this is the first\
    \ time the current level is being processed, initialize the current level\n  \
    \      if(current_level === undefined){\n            max_levels[i] = 0;\n    \
    \    }\n\n        //Get the current parentheses level\n        var current_level_start\
    \ = paren_string.indexOf('(',i);\n\n        //If the current parentheses level\
    \ is equal to the current level, then increment the level\n        //Otherwise,\
    \ if the current parentheses level is less than the current level, then increment\
    \ the level and reset the\n        //current level\n        if(current_level_start\
    \ === i){\n            max_levels[i]++;\n        }\n        else{\n          \
    \  if(current_level_start < i){\n                max_levels[i]++;\n          \
    \      max_levels[i] = 0;\n            }\n        }\n\n        //If the current\
    \ level is equal to the maximum level, then return the maximum level\n       \
    \ //Otherwise, if the current level is greater than the maximum level, then return\
    \ the maximum level\n        //and set the current level to the maximum level\n\
    \        if(current_level === max_levels[i]){\n            return max_levels[i];\n\
    \        }\n        else{\n            return max_levels[i];\n        }\n    }\n\
    \n    //If this point is reached, then none of the parentheses have any nesting\
    \ level\n    //Or if there is only one level of nesting, then return that level\n\
    \    return max_levels[0];\n}\n", "\t// First, let's remove parentheses, if any,\
    \ from the input string.\n\tvar clean_string = paren_string.replace(/[\\(\\)]/g,\
    \ '');\n\t// Get the string inside parentheses.\n\tvar paren_strings = clean_string.split(')');\n\
    \t// Count how many opening parentheses there are (including those at the start).\n\
    \tvar open_count = paren_strings.findIndex(function(s){return s == '(';});\n\t\
    // Get all the parentheses levels inside the string.\n\tvar levels = paren_strings.map(function(s){return\
    \ s.split('(').length - 1;});\n\t// Get the deepest level among all the parenthesis\
    \ levels in an array.\n\tvar max_level = Math.max(...levels);\n\t// Get the minimum\
    \ value of each level among all the levels in an array.\n\tvar min_level = Math.min(...levels);\n\
    \t// Count the number of closing parentheses there are (including those at the\
    \ end).\n\tvar close_count = paren_strings.findIndex(function(s){return s == ')';});\n\
    \t// Now, let's see if the deepest level of parenthesis matches the minimum level,\
    \ and return those parentheses levels.\n\t\n\t// If the minimum level is less\
    \ than the deepest level of parentheses, return all the parentheses levels.\n\t\
    if(min_level < max_level){\n\t\treturn levels;\n\t}\n\t// If not return the parentheses\
    \ levels that has the minimum level.\n\telse{\n\t\treturn paren_strings.filter(function(s){return\
    \ min_level == s.split('(').length;});\n\t}\n}\n", "\tlet parentheses = [];\n\t\
    let max_level = 0;\n\tlet opening_char = '(';\n\tlet closing_bracket_char = ')';\n\
    \tlet next_opening_char = opening_char;\n\tlet next_closing_bracket_char = closing_bracket_char;\n\
    \n\tfor (let i=0; i<paren_string.length; i++){\n\t\tif (paren_string[i] == '('){\n\
    \t\t\tparentheses.push(0);\n\t\t\topening_char = next_opening_char;\n\t\t\tclosing_bracket_char\
    \ = next_closing_bracket_char;\n\t\t\tnext_opening_char = paren_string[i+1];\n\
    \t\t\tnext_closing_bracket_char = paren_string[i+2];\n\t\t}\n\t\telse if (paren_string[i]\
    \ == closing_bracket_char){\n\t\t\tif (paren_string.length-1-i == 0){\n\t\t\t\t\
    return [];\n\t\t\t}\n\t\t\tparentheses[parentheses.length-1] ++;\n\t\t}\n\t\t\
    else {\n\t\t\tparentheses.push(0);\n\t\t}\n\t}\n\n\tfor (let i=0; i<parentheses.length;\
    \ i++){\n\t\tif (max_level < parentheses[i]){\n\t\t\tmax_level = parentheses[i];\n\
    \t\t}\n\t}\n\n\treturn max_level;\n}\n", "    var nested_paren_level = 0;\n  \
    \  var paren_levels_stack = [];\n    var paren_level_stack = [];\n    var paren_start_pos\
    \ = 0;\n    var paren_end_pos = 0;\n    var paren_group = [];\n\n    //find length\
    \ of parens\n    paren_string = paren_string.replace(/[()]/g, \"\"); //remove\
    \ parens\n    var paren_length = paren_string.length;\n\n    //iterate through\
    \ characters\n    for(var i=0; i<paren_length; i++){\n        //check for open\
    \ paren\n        if (paren_string[i] == \"(\"){\n            //increment paren\
    \ counter\n            paren_level_stack.push(paren_levels_stack.length);\n  \
    \          paren_levels_stack.push(nested_paren_level);\n            nested_paren_level\
    \ += 1;\n            //reset paren end pos\n            paren_end_pos = i;\n \
    \       } else if (paren_string[i] == \")\"){\n            //decrement paren counter\n\
    \            nested_paren_level = paren_levels_stack.pop();\n            paren_level\
    \ = paren_level_stack.pop();\n            //reset paren start pos\n          \
    \  paren_start_pos = paren_end_pos + 1;\n            //add group to paren group\n\
    \            paren_group.push(paren_string.substring(paren_start_pos,paren_end_pos\
    \ + 1));\n            //reset paren end pos\n            paren_end_pos = i;\n\
    \            //reset paren counter\n            nested_paren_level -= 1;\n   \
    \     } else if (paren_string[i] == \" \" && paren_level_stack.length > 0) {\n\
    \            //decrement paren counter\n            nested_paren_level = paren_levels_stack.pop();\n\
    \            paren_level = paren_level_stack.pop();\n            //reset paren\
    \ start pos\n            paren_start_pos = paren_end_pos + 1;\n            //add\
    \ group to paren group\n            paren_group.push(paren_string.substring(paren_start_pos,paren_end_pos\
    \ + 1));\n            //reset paren end pos\n            paren_end_pos = i;\n\
    \            //reset paren counter\n            nested_paren_level -= 1;\n   \
    \     } else if (paren_string[i] == \" \" && paren_level_stack.length == 0) {\n\
    \            //add group to paren group\n            paren_group.push(paren_string.substring(paren_start_pos,paren_end_pos\
    \ + 1));\n            //reset paren start pos\n            paren_start_pos = i;\n\
    \            //reset paren counter\n            nested_paren_level -= 1;\n   \
    \     }\n    }\n    return paren_group;\n}\n</code>\n<|/ a dscore=1 tags=javascript,regex\
    \ |>\n<| a tags=javascript,regex |>\nI believe that my answer to a similar question\
    \ solves this problem - check out this fiddle. \nHere's the code I use", "   \
    \ var nested_level = 0;\n    var max_level = 0;\n    var results = [];\n    for(var\
    \ i = 0, len = paren_string.length; i < len; i++){\n        var char = paren_string[i];\n\
    \        switch(char){\n            case \"(\":\n                nested_level++;\n\
    \                break;\n            case \")\":\n                nested_level--;\n\
    \                if (max_level < nested_level){\n                    max_level\
    \ = nested_level;\n                    results = [];\n                }\n    \
    \            break;\n            default:\n                if (max_level > 0){\n\
    \                    results.push(max_level);\n                }\n           \
    \     max_level = -1;\n                results.push(char);\n        }\n    }\n\
    \    return results;\n}\n", "\tlet group_strings = paren_string.split(' ')\n\t\
    let nested_depth = group_strings.length\n\tlet max_nesting = 0\n\tfor (let i =\
    \ 0; i < group_strings.length; i++){\n\t\tlet group_string = $.trim(group_strings[i])\n\
    \t\tif (group_string.includes('(')){\n\t\t\tlet open_paren_index = group_string.indexOf('(')\n\
    \t\t\tlet close_paren_index = group_string.indexOf(')')\n\t\t\tlet open_parens\
    \ = group_string.substring(0,open_paren_index)\n\t\t\tlet close_parens = group_string.substring(close_paren_index+1)\n\
    \t\t\tlet nested_depth = parseInt(open_parens)\n\t\t\tlet max_nesting = Math.max(max_nesting,\
    \ parseInt(close_parens))\n\t\t} else {\n\t\t\tlet nested_depth = parseInt(group_string)\n\
    \t\t\tlet max_nesting = Math.max(max_nesting, parseInt(nested_depth))\n\t\t}\n\
    \t}\n\treturn max_nesting\n}\n", "    var depth = 0;\n    var paren_stack = [];\n\
    \    var paren_max_depth;\n    var paren_max;\n    var curr_paren_level;\n   \
    \ \n    for (var i = 0; i <paren_string.length; i++){\n        var c = paren_string[i];\n\
    \        if (c == '('){\n            if (paren_stack.length > 0){\n          \
    \      if (paren_stack[paren_stack.length-1] < paren_max_depth){\n           \
    \         paren_max_depth = paren_stack[paren_stack.length-1];\n             \
    \   }\n            }\n            paren_stack.push(depth);\n            depth++;\n\
    \        } else if (c == ')'){\n            depth--;\n        } else if (c ==\
    \ ' '){\n            paren_max = paren_stack.pop();\n            paren_max_depth\
    \ = paren_stack[paren_stack.length-1];\n            if (paren_max < paren_max_depth){\n\
    \                paren_max_depth = paren_max;\n            }\n        }\n    }\n\
    \    if (paren_stack.length > 0){\n        if (paren_stack[paren_stack.length-1]\
    \ < paren_max_depth){\n            paren_max_depth = paren_stack[paren_stack.length-1];\n\
    \        }\n    }\n    paren_max_depth++;\n    return paren_max_depth;\n}\n",
  "  var nested_parens=[];\n  var num_groups=paren_string.match(/[^\\(\\)]+/g);\n\
    \  for(var i=0;i<num_groups.length;i++){\n    var levels=0;\n    var group_level=0;\n\
    \    var curgroup_index=i;\n    var paren_string_count=0;\n    var open_curgroup\
    \ = false;\n    while(curgroup_index<num_groups.length){\n      if(curgroup_index==i){\n\
    \        open_curgroup = true;\n      }\n      else if(open_curgroup && curgroup_index<num_groups.length){\n\
    \        var currgroup= num_groups[curgroup_index];\n        var next_paren_index=curgroup_index+1;\n\
    \        if(next_paren_index==num_groups.length){\n          next_paren_index=0;\n\
    \        }\n        if(open_curgroup){\n          if(next_paren_index<num_groups.length){\n\
    \            levels++;\n            curgroup_index++;\n            next_paren_index++;\n\
    \          }\n          else{\n            open_curgroup = false;\n          }\n\
    \        }\n        else{\n          if(next_paren_index<num_groups.length){\n\
    \            levels++;\n            curgroup_index++;\n          }\n         \
    \ else{\n            open_curgroup = false;\n          }\n        }\n      }\n\
    \      else if(open_curgroup){\n        levels++;\n        curgroup_index++;\n\
    \      }\n      else{\n        curgroup_index++;\n      }\n    }\n    if(levels>0){\n\
    \      nested_parens.push(levels);\n    }\n  }\n  return nested_parens;\n}\n",
  "    var level = 0;\n    var paren_count = 0;\n    var paren_groups = new Array();\n\
    \    for(var i=0; i<paren_string.length; i++){\n        switch(paren_string[i]){\n\
    \            case \")\": paren_groups[level-1].push(paren_count); paren_count\
    \ = 0; level--;\n            case \"(\": paren_count++; paren_groups[level-1].push(paren_count);\n\
    \        }\n    }\n    return paren_groups;\n}\n", "  var max_level = 0;\n  var\
    \ nested_level = [];\n  var level = 0;\n  var paren_level = 0;\n  var len = paren_string.length;\n\
    \  var cur = len;\n  var c;\n  while(cur > 0){\n    c = paren_string[--cur];\n\
    \    if(c == '('){\n      paren_level++;\n      nested_level.push(level);\n  \
    \    level++;\n    }\n    else if(c == ')'){\n      paren_level--;\n      if(paren_level\
    \ == 0){\n        max_level = Math.max(max_level, level);\n      }\n      level--;\n\
    \    }\n  }\n  return max_level;\n}\n", "    var nested_level = 0;\n    var nested_paren_count\
    \ = 0;\n    var current_index = 0;\n    var paren_stack = [];\n\n    // Iterate\
    \ through all the groups in the paren string\n    paren_string.replace(/^[^()]+/,\
    \ function (group) {\n        // If we are at a new level of nesting, push the\
    \ paren count onto the stack\n        nested_paren_count += group.match(/\\(|\\\
    )/g).length;\n        nested_level = nested_paren_count;\n\n        // If we are\
    \ at a deeper level of nesting, pop one level of nesting from the stack\n    \
    \    if (nested_level > current_index) {\n            paren_stack.pop();\n   \
    \     }\n        // Otherwise, push one level of nesting onto the stack\n    \
    \    else {\n            paren_stack.push(nested_level);\n        }\n\n      \
    \  // Keep track of the index on which we are currently at\n        current_index\
    \ = nested_level;\n    });\n\n    // The last group in the paren string should\
    \ have 1 level of nesting\n    nested_paren_count += paren_string.match(/\\(|\\\
    )/g).length;\n    nested_level = nested_paren_count;\n\n    // Return the count\
    \ of deepest level of nesting of parens\n    return paren_stack[paren_stack.length\
    \ - 1];\n}\n</code>\nAnd here is my original solution written using recursion.\n\
    <code>", "    var paren_regex = /(\\((?:[^()]+|(?:\\([^()]*\\))*?\\))*)\\)/g;\n\
    \    var parens = [];\n    var matches = paren_regex.exec(paren_string);\n   \
    \ while(matches){\n        parens.push(matches[1].length);\n        matches =\
    \ paren_regex.exec(paren_string);\n    }\n    return parens;\n}", "  var nested_paren_depth\
    \ = 0;\n  var nested_paren_levels = [];\n  var nested_paren_chars = [];\n  for(var\
    \ i=0; i < paren_string.length; i++){\n    if(paren_string[i] === '('){\n    \
    \  nested_paren_chars.push(paren_string[i]);\n      nested_paren_levels.push(nested_paren_depth);\n\
    \    } else if(paren_string[i] === ')'){\n      nested_paren_depth = nested_paren_levels.pop();\n\
    \      nested_paren_chars.pop();\n    }\n  }\n  return nested_paren_chars.length;\n\
    }\n", "    var nest = 0;\n    var parens = new Array();\n    var levels = new\
    \ Array();\n    for(var i = 0; i < paren_string.length; i++){\n        var p =\
    \ paren_string[i];\n        var level = 0;\n        while(levels[level] >= 0 &&\
    \ levels[level] != level){\n            level++;\n        }\n        levels[level]\
    \ = level;\n        level++;\n        while(p == parens[level]){\n           \
    \ level++;\n        }\n        parens[level] = p;\n        nest = level;\n   \
    \ }\n    return nest;\n}", "\tvar group_count=0; //count of number of groups of\
    \ parentheses in the string\n\tvar max_level=0; //number of levels of parentheses\n\
    \tvar current_level=0; //level of parentheses within one group\n\tvar paren_stack=[];\
    \ //Stack for counting number of parentheses inside groups\n\tvar paren_count=0;\
    \ //counting number of parentheses inside groups\n\tvar paren_char=''; //current\
    \ parentheses character\n\tfor(var i=0; i<paren_string.length; i++){\n\t\t//if\
    \ the current character is a open paren\n\t\tif(paren_string[i]==\"(\"){\n\t\t\
    \t//push the current level to paren_stack\n\t\t\tparen_stack.push(current_level);\n\
    \t\t\t//increment the paren_count \n\t\t\tparen_count++;\n\t\t\t//set current_level\
    \ to the current level\n\t\t\tcurrent_level=paren_stack.length;\n\t\t\t//increment\
    \ the group_count\n\t\t\tgroup_count++;\n\t\t\t//if the current group has more\
    \ levels of parentheses\n\t\t\tif(group_count>1){\n\t\t\t\t//update max_level\n\
    \t\t\t\tmax_level=Math.max(max_level,current_level);\n\t\t\t}\n\t\t}\n\t\telse\
    \ if(paren_string[i]==\")\"){\n\t\t\t//pop the level of parentheses inside group\n\
    \t\t\tcurrent_level=paren_stack.pop();\n\t\t\t//if the level of parentheses inside\
    \ group is equal to max_level\n\t\t\tif(current_level==max_level){\n\t\t\t\t//push\
    \ the level of parentheses inside group to paren_stack\n\t\t\t\tparen_stack.push(current_level);\n\
    \t\t\t\t//decrement the paren_count \n\t\t\t\tparen_count--;\n\t\t\t\t//if the\
    \ paren_count is zero\n\t\t\t\tif(paren_count==0){\n\t\t\t\t\t//update the max_level\n\
    \t\t\t\t\tmax_level=Math.max(max_level,current_level);\n\t\t\t\t}\n\t\t\t}\n\t\
    \t}\n\t}\n\treturn paren_stack;\n}\n", "\tlet paren_count=0\n\tlet open_count=0\n\
    \tlet close_count=0\n\tlet level=[]\n\tfor (let i=0; i<paren_string.length; i++){\n\
    \t\tlet letter=paren_string.charAt(i)\n\t\tif (letter==')'){\n\t\t\tclose_count\
    \ +=1\n\t\t}\n\t\tif (letter==')'){\n\t\t\tlevel[close_count] -= 1\n\t\t}\n\t\t\
    if (letter=='('){\n\t\t\topen_count+=1\n\t\t}\n\t\tif (letter=='('){\n\t\t\tlevel[open_count]\
    \ += 1\n\t\t}\n\t\tif (letter==')' && level[open_count]>0){\n\t\t\tlevel[open_count]\
    \ -= 1\n\t\t}\n\t\tif (letter=='(' && level[close_count]<0){\n\t\t\tlevel[close_count]\
    \ += 1\n\t\t}\n\t\tif (letter=='(' && level[close_count]<0 && level[open_count]>0){\n\
    \t\t\tlevel[open_count] -= 1\n\t\t}\n\t\tif (letter==')' && level[close_count]==0){\n\
    \t\t\topen_count-=1\n\t\t}\n\t\tif (letter=='(' && level[open_count]==0){\n\t\t\
    \tclose_count -=1\n\t\t}\n\t}\n\treturn level.length\n}\n", "  var stacks = [];\n\
    \  var result = [];\n  var groups = paren_string.match(/(\\((?>[^()]+|\\((?R)?\\\
    )))+/g);\n  if(groups != null){\n    groups.forEach(function(group){\n      var\
    \ cur = stacks[stacks.length - 1];\n      var stack = [];\n      var maxlevel\
    \ = 0;\n      group.split(\"\").forEach(function(char){\n        if(char == '(')\
    \ stack.push(cur);\n        else if(char == ')'){\n          var last = stack.pop();\n\
    \          if(stack.length > maxlevel){\n            maxlevel = stack.length;\n\
    \          }\n          cur.push(last);\n        }\n        cur.push(char);\n\
    \      });\n      stacks.push(stack);\n      result.push(maxlevel);\n    });\n\
    \  }\n  return result;\n}", "  var nested_paren_groups = [];\n  var paren_level;\n\
    \  var paren_nesting;\n  for (var i = 0; i < paren_string.length; i++){\n    if\
    \ (paren_string[i] === '('){\n      paren_nesting = 1;\n      paren_level = 0;\n\
    \    }\n    if (paren_string[i] === '(' && paren_nesting === 1){\n      paren_level++;\n\
    \    }\n    if (paren_string[i] === ')' && paren_nesting > 1){\n      paren_level--;\n\
    \    }\n    if (paren_level !== 0){\n      nested_paren_groups.push(paren_level);\n\
    \    }\n  }\n  return nested_paren_groups;\n}\n", "    const paren_pairs = paren_string.trim().split('\
    \ ');\n    \n    let paren_levels = [];\n    let paren_chars = [];\n    \n   \
    \ for(let i = 0; i < paren_pairs.length; i++){\n        let current_char = paren_pairs[i];\n\
    \        \n        for(let j = 0; j < current_char.length; j++){\n           \
    \ paren_levels[j] = 0;\n        }\n        \n        paren_levels[current_char.charCodeAt(0)]\
    \ = 1;\n        paren_chars.push(current_char);\n    }\n    \n    let max_level\
    \ = 0;\n    for(let i = 0; i < paren_chars.length; i++){\n        let current_level\
    \ = paren_levels[i];\n        \n        max_level = j > max_level ? j : max_level;\n\
    \    }\n    \n    return max_level;\n}\n", "    var nested_paren_array = [];\n\
    \    var open_bracket = 0;\n    var bracket_count = 0;\n    var open_brackets_count\
    \ = paren_string.match(/\\(/g).length; //To keep track of how many open brackets\
    \ we have.\n    var closed_brackets_count = open_brackets_count + paren_string.match(/\\\
    )/g).length; //To keep track of how many closed brackets we have.\n    var paren_counter\
    \ = 1;\n    var current_depth = 0;\n    for (var i=0; i<paren_string.length; i++){\n\
    \        if (paren_string.charAt(i) === \"(\" && paren_counter < open_brackets_count){\
    \ //Look for a closing parenthesis\n            current_depth++;\n           \
    \ paren_counter++;\n        } else if (paren_string.charAt(i) === \"(\" && current_depth\
    \ === 0){ //Found a new opening parenthesis\n            open_bracket++;\n   \
    \         open_brackets_count++;\n        } else if (paren_string.charAt(i) ===\
    \ \")\" && paren_counter > open_brackets_count){\n            current_depth--;\n\
    \            paren_counter--;\n        } else if (paren_string.charAt(i) === \"\
    )\" && current_depth === 0){\n            open_bracket--;\n            open_brackets_count--;\n\
    \        } else if (paren_string.charAt(i) === \"(\" && current_depth === 0){\n\
    \            open_brackets_count -= closed_brackets_count;\n            closed_brackets_count--;\n\
    \        }\n        \n        if (current_depth !== 0){\n            nested_paren_array.push(current_depth);\n\
    \        }\n    }\n    return nested_paren_array;\n}", "\tvar level = 0;\n\tvar\
    \ depth = 0;\n\tfor(var i = 0; i<paren_string.length; i++){\n\t\tif(paren_string[i]=='('){\n\
    \t\t\tdepth++;\n\t\t} else if(paren_string[i]==')'){\n\t\t\tdepth--;\n\t\t} else\
    \ if(paren_string[i]==' ' && depth!=0){\n\t\t\tlevel++;\n\t\t}\n\t}\n\treturn\
    \ level;\n}\n", "  var nested_parens = [];\n  paren_string.split(\" \").forEach(function(ele){\n\
    \    var levels = ele.match(/(\\(\\(.*?\\))\\))/g);\n    if(levels != null){\n\
    \      for(var i=0;i<levels.length;i++){\n        nested_parens.push(levels[i].match(/\\\
    ((.*?)\\)/g)[0].length);\n      }\n    }\n  });\n  return nested_parens;\n}\n",
  "    let groups = []\n    // Use a stack to keep track of nested parentheses.\n\
    \    let stack = []\n    for(let i = 0; i < paren_string.length; i++){\n     \
    \   // Pop the top stack item and push it into the group array\n        if(paren_string[i]\
    \ === '('){\n            while(stack.length){\n                groups.push(stack.pop())\n\
    \            }\n            // Push the current item into the stack.\n       \
    \     stack.push(paren_string[i])\n        } else if(paren_string[i] === ')'){\n\
    \            // Pop the top stack item and push it into the group array\n    \
    \        while(stack.length){\n                groups.push(stack.pop())\n    \
    \        }\n            // Pop the top stack item and push it into the group array\n\
    \            stack.push(paren_string[i])\n        } else {\n            // Push\
    \ the current item into the stack.\n            stack.push(paren_string[i])\n\
    \        }\n    }\n    // Push any remaining items in the stack to the group array\n\
    \    while(stack.length){\n        groups.push(stack.pop())\n    }\n\n    // Return\
    \ the maximum level count\n    return Math.max(...groups)\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>\nlet str = '(((())))(()()())';\nlet count = 0;\n\
    for(let i = 0; i < str.length; i++)\n    if(str[i] === '('){\n        count++;\n\
    \    }\n    else{\n        if(str[i] === ')'){\n            count--;\n       \
    \ }\n    }\n    ", "\tvar nested_parens=[];\n\tvar max_level = 0;\n\n\tparen_string=paren_string.split('\
    \ ').join('');\n\n\t// Count the number of parentheses\n\tvar paren_count = 0;\n\
    \tfor (var i = 0; i < paren_string.length; i++){\n\t\tif (paren_string.charAt(i)\
    \ == '('){\n\t\t\tparen_count++;\n\t\t}\n\t\tif (paren_string.charAt(i) == ')'){\n\
    \t\t\tparen_count--;\n\t\t}\n\t}\n\n\t// Get the deepest level of nesting from\
    \ the number of parentheses\n\tfor (var i = 0; i < paren_count; i++){\n\t\tif\
    \ (paren_string.charAt(i) == '('){\n\t\t\tnested_parens.push(paren_count);\n\t\
    \t}\n\t\tif (paren_string.charAt(i) == ')'){\n\t\t\tnested_parens.pop();\n\t\t\
    }\n\t}\n\n\t// Get the deepest level of nesting from the number of parentheses\n\
    \tfor (var i = 0; i < paren_count; i++){\n\t\tif (paren_string.charAt(i) == '('){\n\
    \t\t\tmax_level = Math.max(max_level, nested_parens.pop());\n\t\t}\n\t\tif (paren_string.charAt(i)\
    \ == ')'){\n\t\t\tmax_level = Math.max(max_level, nested_parens.pop());\n\t\t\
    }\n\t}\n\n\treturn max_level;\n}\n", "\tlet paren_stack = [];\n\tparen_string\
    \ = paren_string.replace(/[\\(\\)]/g,\"\");\n\tlet max_level = 0;\n\tfor (let\
    \ i = 0; i < paren_string.length; i++){\n\t\tlet char = paren_string[i];\n\t\t\
    if (char === \"(\"){\n\t\t\tparen_stack.push(max_level);\n\t\t\tmax_level += 1;\n\
    \t\t} else if (char === \")\"){\n\t\t\tlet current_level = paren_stack.pop();\n\
    \t\t\tif (current_level > max_level){\n\t\t\t\tmax_level = current_level;\n\t\t\
    \t}\n\t\t}\n\t}\n\treturn max_level;\n}\n", "    let parenStack = [];\n    paren_string\
    \ = paren_string.split(' ');\n\n    for(const paren of paren_string){\n      \
    \  if(parenStack.length == 0){\n            parenStack.push(paren);\n        }else{\n\
    \            let last_pos = -1;\n            for(let i = 0; i < parenStack.length;\
    \ i++){\n                last_pos = parenStack[i].lastIndexOf(paren);\n      \
    \          if(last_pos != -1){\n                    parenStack.splice(last_pos,\
    \ 1);\n                    break;\n                }\n            }\n        }\n\
    \    }\n\n    let level = 0;\n    for(let i = parenStack.length - 1; i >= 0; i--){\n\
    \        if(parenStack[i].includes('(')){\n            level++;\n        }\n \
    \       if(parenStack[i].includes(')')){\n            level--;\n        }\n  \
    \  }\n    return level;\n}", "    for(var i = 0; i < paren_string.split(/\\s+/).length;\
    \ i++){\n        switch(paren_string.split(/\\s+/)[i]){\n            case '(':\n\
    \                nested_parens.push(0);\n                break;\n            case\
    \ ')':\n                nested_parens.pop();\n                break;\n       \
    \ }\n    }\n    return nested_parens;\n}\n", "\tif(!paren_string){return [];}\n\
    \tvar nested_parens_arr=[];\n\tvar temp_paren_string=paren_string;\n\tvar parens_counter=0;\
    \ //Counts the number of nested parentheses.\n\twhile(temp_paren_string.length>0){\n\
    \t\tvar new_nested_parens_arr=[];\n\t\t//If number of opened parentheses is greater\
    \ than the counter value, then it is a nested parentheses group. \n\t\tvar is_nested_parentheses_group=parens_counter<paren_string.length;\n\
    \t\tif(is_nested_parentheses_group){\n\t\t\tparens_counter++;\n\t\t}\n\t\tvar\
    \ new_paren_string=temp_paren_string.substr(0,paren_string.length-parens_counter);\n\
    \t\t//If number of opened parentheses is equal to the counter value, then it is\
    \ a nested parentheses group and there are no more parentheses. \n\t\tif(!is_nested_parentheses_group){\n\
    \t\t\ttemp_paren_string=temp_paren_string.substr(paren_string.length-parens_counter);\n\
    \t\t}\n\t\tnew_nested_parens_arr.push(parse_nested_parens(new_paren_string));\n\
    \t\t//If there are any opened parentheses left, un-increment the counter value.\n\
    \t\tif(is_nested_parentheses_group){\n\t\t\tparens_counter--;\n\t\t}\n\t\tnested_parens_arr=new_nested_parens_arr.concat(nested_parens_arr);\n\
    \t}\n\treturn nested_parens_arr;\n}\n", "  var groups = paren_string.match(/\\\
    (([^)(]+)\\)/);\n  var level = 0;\n  if(groups){\n    var group_levels = groups[0].match(/\\\
    (([^)(]+)\\)/);\n    level = group_levels ? group_levels.length - 1 : 0;\n  }\n\
    \  return level;\n}\n", "\tlet depth = 0;\n\tlet result = [];\n\tfor (let i of\
    \ paren_string.split(\" \")){\n\t\tlet j = i;\n\t\twhile (j.length >= 2){\n\t\t\
    \tlet k = j;\n\t\t\twhile (k.length >= 2){\n\t\t\t\tresult.push(depth);\n\t\t\t\
    \tk = k.substr(0, k.length - 1);\n\t\t\t}\n\t\t\tj = j.substr(0, j.length - 1);\n\
    \t\t}\n\t}\n\treturn result;\n}\n", "    if(paren_string.trim().length <= 0) return\
    \ [];\n    var groups = [];\n    var curr_index = 0;\n    while(paren_string[curr_index]\
    \ != ')' && paren_string[curr_index] != '('){\n        //Get rid of the parentheses\
    \ and then see if this is a group\n        var trimmed_string = paren_string.slice(curr_index).trim();\n\
    \        var num_opening_parentheses = trimmed_string.split('(').length - 1; //If\
    \ there are any openings, then there will be one opening.\n        //Check if\
    \ the trimmed string has more opening parentheses\n        var has_more = trimmed_string.split('(').length\
    \ > num_opening_parentheses;\n        if(has_more) groups.push(num_opening_parentheses);\n\
    \        //Update the index\n        curr_index += has_more ? trimmed_string.split('(').length\
    \ - 1 : 1;\n    }\n    //Add the last group\n    groups.push(curr_index);\n  \
    \  return groups;\n}\n", "    var levels = paren_string.match(/\\(.*?\\)/g);\n\
    \    for(var i in levels){\n        if(levels[i].match(/\\(.*?\\)/)){\n      \
    \      var max_level = levels[i].match(/[^()]+/g);\n            levels[i] = max_level.length;\n\
    \        }\n    }\n    return levels;\n}\n", "  paren_string = paren_string.trim().toLowerCase();\n\
    \  var nested_paren_count = 0;\n  var opening_paren_count = 0;\n  var counting_paren_open\
    \ = false;\n  var counting_nested_paren_open = false;\n  var levels_of_nested_paren\
    \ = 0;\n  var levels_of_paren = 0;\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] === '('){\n      if(!counting_paren_open){\n \
    \       counting_paren_open = true;\n      }else{\n        if(levels_of_paren\
    \ === levels_of_nested_paren){\n          levels_of_nested_paren++;\n        \
    \  opening_paren_count++;\n          counting_nested_paren_open = false;\n   \
    \     }else{\n          levels_of_nested_paren++;\n        }\n      }\n    }else\
    \ if(paren_string[i] === ')'){\n      if(counting_paren_open){\n        if(levels_of_paren\
    \ === levels_of_nested_paren){\n          levels_of_nested_paren--;\n        \
    \  opening_paren_count--;\n          counting_nested_paren_open = false;\n   \
    \     }else{\n          levels_of_nested_paren--;\n        }\n      }else{\n \
    \       if(levels_of_paren === levels_of_nested_paren){\n          levels_of_nested_paren--;\n\
    \        }\n      }\n    }else if(paren_string[i] === '\\'' || paren_string[i]\
    \ === '\"'){\n      counting_nested_paren_open = false;\n    }\n    else if(paren_string[i]\
    \ === '{'){\n      levels_of_paren++;\n      counting_paren_open = false;\n  \
    \  }\n    else if(paren_string[i] === '}'){\n      levels_of_paren--;\n      counting_paren_open\
    \ = false;\n    }\n  }\n  var result_array = [];\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] === '('){\n      if(opening_paren_count === nested_paren_count){\n\
    \        if(levels_of_nested_paren > levels_of_paren){\n          result_array.push(levels_of_nested_paren);\n\
    \        }\n      }\n      opening_paren_count++;\n    }else if(paren_string[i]\
    \ === ')'){\n      opening_paren_count--;\n      if(opening_paren_count === nested_paren_count){\n\
    \        if(levels_of_nested_paren > levels_of_paren){\n          result_array.push(levels_of_nested_paren);\n\
    \        }\n      }\n    }else if(paren_string[i] === '\\'' || paren_string[i]\
    \ === '\"'){\n      counting_nested_paren_open = false;\n    }\n  }\n  return\
    \ result_array;\n}\n", "    //This regex parses the string by first finding all\
    \ groups of parentheses in paren_string.\n    //Then it iterates over each group\
    \ of parentheses and finds out the deepest level by looking back at the group\
    \ of parentheses.\n    //If there are no parentheses in group, the deepest level\
    \ is 1 and the level becomes 0 when there are no parentheses left in the group.\n\
    \    //If there is only one parentheses left in the group, the deepest level is\
    \ 2 and the level becomes 1 when there is only one parentheses left in the group.\n\
    \    //If there are multiple parentheses left in the group, the deepest level\
    \ is max(2 levels of nesting) and the level becomes 1 when there are multiple\
    \ parentheses left in the group.\n    //In any case, the deepest level is returned.\n\
    \    var group_count = 0; //Number of groups parsed. We have to restart this every\
    \ time we find a new group.\n    var group_level = 0; //Level of nesting parsed\
    \ so far. We have to restart this every time we find a new group.\n    var group_index\
    \ = 0;\n    var group_indexes = []; //Store the indexes of all the groups we encounter\
    \ in the paren_string.\n    var max_level = 1;\n    var max_level_indexes = [];\n\
    \n    var paren_array = [];\n    var paren_count = 0;\n    var paren_index = 0;\n\
    \    paren_string.match(/([()]*)/); //First step is to find all groups of parentheses\
    \ in paren_string.\n    while(paren_count != paren_string.length){\n        var\
    \ paren_regex = new RegExp(paren_string.substr(paren_index,paren_count), 'g');\n\
    \        var paren_match = paren_string.match(paren_regex);\n        paren_array\
    \ = paren_array.concat(paren_match);\n        paren_index += paren_count;\n  \
    \      paren_count += paren_match.length - 1;\n    }\n\n    paren_array = paren_array.map(function(paren_char){\n\
    \        paren_char = paren_char.replace(/\\(/,'').replace(/\\)/,'').trim();\n\
    \        if(paren_char.length > 0){\n            return paren_char;\n        }else{\n\
    \            return false;\n        }\n    });\n\n    while(paren_array.length\
    \ != 0){\n        paren_array.forEach(function(paren_string){\n            var\
    \ group_level = paren_string.match(/\\(/g).length;\n            if(paren_string.match(/\\\
    (/g) == false){\n                group_level = 1;\n            }\n           \
    \ group_indexes.push(paren_string.match(/\\(/g)[0].length);\n            if(paren_string\
    \ != false){\n                group_indexes[group_indexes.length-1]++;\n     \
    \       }\n            if(group_indexes.length > group_count){\n             \
    \   group_count = group_indexes.length;\n            }\n            group_level\
    \ = group_", "  var max_nesting = 0;\n  var nesting_level = [];\n  var paren_strings\
    \ = paren_string.split(' ');\n  for(var i=0; i<paren_strings.length; i++){\n \
    \   var cur_str = paren_strings[i];\n    var par_strings = cur_str.split('(');\n\
    \    for(var j=0; j<par_strings.length; j++){\n      var par_string = par_strings[j];\n\
    \      var par_strings_2 = par_string.split(')');\n      var cur_nesting = 1;\n\
    \      for(var k=0; k<par_strings_2.length; k++){\n        var cur_par_string\
    \ = par_strings_2[k];\n        var cur_par_strings = cur_par_string.split('(');\n\
    \        for(var l=0; l<cur_par_strings.length; l++){\n          var cur_par_string\
    \ = cur_par_strings[l];\n          var cur_par_strings_2 = cur_par_string.split(')');\n\
    \          if(cur_par_strings_2.length > cur_nesting){\n            cur_nesting\
    \ = cur_par_strings_2.length;\n          }\n        }\n      }\n      nesting_level.push(cur_nesting);\n\
    \      if(cur_nesting > max_nesting){\n        max_nesting = cur_nesting;\n  \
    \    }\n    }\n  }\n  return nesting_level;\n}\n", "  var nested_paren_level =\
    \ [];\n  for(var i=0; i<paren_string.length; i++){\n    switch(paren_string[i]){\n\
    \      case ')':\n        if(nested_paren_level.length > 0) nested_paren_level.pop();\n\
    \        break;\n      case '(':\n        nested_paren_level.push(0);\n      \
    \  break;\n      case ' ':\n        nested_paren_level.push(0);\n        break;\n\
    \      default:\n        nested_paren_level[nested_paren_level.length-1] += 1;\n\
    \    }\n  }\n  return nested_paren_level;\n}\n</code>\n<|/ a dscore=2 tags=regex,javascript\
    \ |>\n<| a tags=regex,javascript |>\nYou can do this with a regex and a lookahead.\n\
    Regex: /(^|\\s)\\((?=.*?\\(\\))(?!\\))/g\nExplanation:\n\n^ match the beginning\
    \ of the line\n| OR\n\\s match a whitespace character\n( Start the capture group\n\
    (?=.*?\\(\\)) Assert that the regex below can be matched, starting from the current\
    \ position (\\(\\)) until the end of the string \\(\\)\n(?!\\)) Negative lookahead\
    \ to assert that the regex above cant match\n\nCode:\n\n<code>\nvar str = '(()())\
    \ ((())) () ((())()())';\n\nvar re = /(?:^|\\s)\\((?=.*?\\(\\))(?!\\))/g;\n\n\
    var result = str.match(re);\n", "  // TODO: Implement this function.\n  return\
    \ null;\n}\n", "    let nested_parens = [];\n    let index = 0;\n    paren_string\
    \ = paren_string.trim();\n    while (paren_string.substr(index, 1) == \")\"){\n\
    \        index = paren_string.indexOf(\"(\", index+1);\n        nested_parens.push(paren_string.length\
    \ - index);\n        index++;\n    }\n    return nested_parens;\n}\n", "\tvar\
    \ paren_levels = [];\n\tvar max_level = 0;\n\tvar current_level = 0;\n\tvar paren_string_list\
    \ = paren_string.split(/\\s+/);\n\tfor (var i = 0; i < paren_string_list.length;\
    \ i++){\n\t\tvar par = paren_string_list[i];\n\t\tif (par){\n\t\t\tif (par.length\
    \ == 0) continue;\n\t\t\tcurrent_level = paren_levels[par];\n\t\t\tif (current_level\
    \ == undefined) current_level = 0;\n\t\t\tif (current_level > max_level) max_level\
    \ = current_level;\n\t\t}\n\t\tparen_levels[par] = current_level + 1;\n\t}\n\t\
    return max_level;\n}\n", "\treturn paren_string.split(' ').map(function(str){\n\
    \t\treturn parens_depth(str);\n\t});\n}\n", "\tvar level = 0,\n\t\tnest_level\
    \ = 0,\n\t\tnum_nest_levels = 0,\n\t\tstack = [paren_string],\n\t\tcurr_level\
    \ = paren_string.length,\n\t\tcurr_depth_stack = [];\n\twhile(stack.length){\n\
    \t\tvar new_level = stack.shift().length;\n\t\twhile(curr_level < new_level){\n\
    \t\t\tstack.unshift(stack.shift());\n\t\t\tcurr_level++;\n\t\t}\n\t\tstack.push(new_level);\n\
    \t\tcurr_level = new_level;\n\t\tcurr_depth_stack.push(level);\n\t\tlevel++;\n\
    \t}\n\twhile(curr_depth_stack.length > 0){\n\t\tnest_level = curr_depth_stack.pop();\n\
    \t\tnum_nest_levels++;\n\t}\n\treturn num_nest_levels;\n}\n", "    var paren_array\
    \ = [];\n    var paren_level = 0;\n    for (var i=0; i<paren_string.length; i++){\n\
    \        if (paren_string[i] == '('){\n            paren_level++;\n        } else\
    \ if (paren_string[i] == ')'){\n            paren_level--;\n        }\n\n    \
    \    if (paren_level == 0){\n            paren_array.push(i);\n        }\n   \
    \ }\n    return paren_array;\n}\n", "    var nested_parens_levels = [];\n    var\
    \ current_level = 0;\n\n    var paren_string = paren_string.replace(/\\s{2,}/g,\
    \ ' ').trim();\n\n    if(paren_string.search(/\\(/g) === 0){\n        current_level++;\n\
    \    }\n\n    for(var i = 0; i < paren_string.length; i++){\n        for(var j\
    \ = current_level; j <= 3; j++){\n            if(paren_string[i] === '('){\n \
    \               nested_parens_levels[j] = j;\n                break;\n       \
    \     }\n        }\n\n        if(!nested_parens_levels[j]){\n            return\
    \ 0;\n        }\n    }\n\n    return nested_parens_levels;\n}\n", "\tvar groups\
    \ = paren_string.split(\" \");\n\tvar max_level = 0;\n\tvar max_level_groups =\
    \ groups.length;\n\tvar max_level_group_length = null;\n\tvar max_level_group_position\
    \ = null;\n\tvar i;\n\tfor(i = 0; i < groups.length; i++){\n\t\tvar group = groups[i];\n\
    \t\tvar group_length = group.length;\n\t\tif(group_length >= max_level_group_length){\n\
    \t\t\tmax_level_group_length = group_length;\n\t\t\tmax_level_group_position =\
    \ i;\n\t\t}\n\t\tif(group_length > max_level){\n\t\t\tmax_level = group_length;\n\
    \t\t}\n\t}\n\tvar output_groups = [];\n\tvar last_index = -1;\n\tfor(i = 0; i\
    \ < groups.length; i++){\n\t\tvar group = groups[i];\n\t\tif(group.length > max_level){\n\
    \t\t\tvar new_group = \"\";\n\t\t\tfor(j = 0; j < max_level_group_length; j++){\n\
    \t\t\t\tnew_group += group[j];\n\t\t\t}\n\t\t\toutput_groups.push(new_group);\n\
    \t\t} else {\n\t\t\toutput_groups.push(group);\n\t\t}\n\t}\n\treturn output_groups;\n\
    }\n", "    var paren_array = paren_string.match(/[^()]+/g)\n    if (paren_array\
    \ == null) return []\n    var max_level = 0\n    var max_level_index = 0\n   \
    \ for(var i=0; i<paren_array.length; i++){\n        if(paren_array[i].match(/[^()]/g).length\
    \ > max_level){\n            max_level = paren_array[i].match(/[^()]/g).length\n\
    \            max_level_index = i\n        }\n    }\n    var nested_levels = []\n\
    \    for (var j = max_level_index; j > -1; --j){\n        nested_levels.push(j\
    \ - max_level_index - 1)\n    }\n    return nested_levels\n}", "\t// Convert string\
    \ '(' and ')' into array of tokens as described at http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm\n\
    \tvar tokens = paren_string.match(/[()]/g);\n\tvar stack = [tokens];\n\tvar max_level_of_nesting\
    \ = 0;\n\tfor (var i = 0; i < tokens.length; i++){\n\t\t// When current token\
    \ is a left parenthesis, add to the stack\n\t\tif(tokens[i] == \"(\"){\n\t\t\t\
    stack.push([]);\n\t\t}\n\t\t// When current token is a right parenthesis, pop\
    \ one level from the stack\n\t\telse if(tokens[i] == \")\"){\n\t\t\t// If popped\
    \ token is empty string or right parenthesis, stop the loop\n\t\t\tif (stack.length\
    \ == 0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t// Otherwise, get the deepest level of\
    \ nesting from top of the stack\n\t\t\tvar last_token_of_last_stack = stack.pop();\n\
    \t\t\t\n\t\t\t// If the deepest level of nesting is greater than max_level_of_nesting\n\
    \t\t\tif(last_token_of_last_stack.length >= max_level_of_nesting){\n\t\t\t\tmax_level_of_nesting\
    \ = last_token_of_last_stack.length;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// When current\
    \ token is a left parenthesis, push the current token to the top of the stack\n\
    \t\telse if(tokens[i] == \"(\"){\n\t\t\tstack.push(tokens[i]);\n\t\t}\n\t}\n\t\
    \n\t// Return maximum level of nesting\n\treturn max_level_of_nesting;\n}\n",
  "\tvar levels = [0,0,0];\n\tvar level = 0;\n\tvar group = [];\n\tparen_string =\
    \ paren_string.split(' ').join('');\n\tvar para = paren_string.match(/\\(/g);\n\
    \tvar parb = paren_string.match(/\\)/g);\n\tvar parc = paren_string.match(/\\\
    {/g);\n\tvar pard = paren_string.match(/\\}/g);\n\tvar pare = paren_string.match(/\\\
    [/g);\n\tvar parf = paren_string.match(/\\]/g);\n\tvar ppa = paren_string.match(/\\\
    ,/g);\n\tvar ppb = paren_string.match(/\\;/g);\n\tvar ppc = paren_string.match(/\\\
    :/g);\n\tvar ppd = paren_string.match(/\\;/g);\n\tvar ppg = paren_string.match(/\\\
    >/g);\n\tvar pph = paren_string.match(/\\</g);\n\tvar ppj = paren_string.match(/\\\
    ;/g);\n\tvar ppk = paren_string.match(/\\;/g);\n\tvar ppn = paren_string.match(/\\\
    ;/g);\n\tvar ppp = paren_string.match(/\\;/g);\n\tvar ppq = paren_string.match(/\\\
    ;/g);\n\tvar pps = paren_string.match(/\\;/g);\n\tvar ppt = paren_string.match(/\\\
    ;/g);\n\tvar ppu = paren_string.match(/\\;/g);\n\tvar ppv = paren_string.match(/\\\
    ;/g);\n\tvar ppw = paren_string.match(/\\;/g);\n\tvar ppx = paren_string.match(/\\\
    ;/g);\n\tvar ppy = paren_string.match(/\\;/g);\n\tvar ppa = paren_string.match(/\\\
    )/g);\n\tvar pbb = paren_string.match(/\\{/g);\n\tvar pbc = paren_string.match(/\\\
    }/g);\n\tvar pbd = paren_string.match(/\\]/g);\n\tvar pbh = paren_string.match(/\\\
    }/g);\n\tvar pbi = paren_string.match(/\\{/g);\n\tvar pbj = paren_string.match(/\\\
    }/g);\n\tvar pbk = paren_string.match(/\\[/g);\n\tvar pbm = paren_string.match(/\\\
    ]/g);\n\tvar pbe = paren_string.match(/\\;/g);\n\tvar pbf = paren_string.match(/\\\
    ;/g);\n\tvar pbg = paren_string.match(/\\>/g);\n\tvar pbh = paren_string.match(/\\\
    </g);\n\tvar pbj = paren_string.match(/\\;/g);\n\tvar pbk = paren_string.match(/\\\
    ;/g);\n\tvar pbl = paren_string.match(/\\", "    var max_level = 0;\n    var num_opens\
    \ = 0, num_closes = 0, currLevel = 0;\n    var paren_stack = [], currParenString\
    \ = '';\n    for(var i=0;i<paren_string.length;i++){\n        if(paren_string[i]\
    \ == '('){\n            paren_stack.push(currParenString);\n            num_opens++;\n\
    \            if(num_opens > max_level){\n                max_level = num_opens;\n\
    \            }\n            currParenString = paren_string.substr(0,i);\n    \
    \    }else if(paren_string[i] == ')'){\n            num_closes += 1;\n       \
    \     if(num_closes == currLevel){\n                currParenString += paren_stack.pop();\n\
    \                num_closes = 0;\n                currLevel = paren_stack.length;\n\
    \            }\n        }else{\n            currParenString += paren_string[i];\n\
    \        }\n    }\n    return max_level;\n}\n\n", "\tvar level = 0;\n\tvar paren_depth\
    \ = 0;\n\tvar levels = [];\n\tvar parens = [];\n\tfor(var i=0;i<paren_string.length;i++){\n\
    \t\tvar c = paren_string[i];\n\t\tif(c == '('){\n\t\t\tparen_depth++;\n\t\t}\n\
    \t\telse if(c == ')'){\n\t\t\tparen_depth--;\n\t\t}\n\t\telse{\n\t\t\tif(paren_depth\
    \ > level){\n\t\t\t\tlevels.push(level);\n\t\t\t}\n\t\t\tlevel++;\n\t\t\tparens.push(c);\n\
    \t\t}\n\t}\n\tif(paren_depth > level){\n\t\tlevels.push(level);\n\t}\n\treturn\
    \ levels;\n}\n", "\tvar levels_of_interest = [];\n\tvar paren_level = 0;\n\n\t\
    // Iterate through the string and count the levels of nesting\n\tfor (var i=0;\
    \ i<paren_string.length; i++){\n\t\t// If it's a parenthesis, increase the parenthesis\
    \ level.\n\t\t// Otherwise, decrease the level by 1.\n\t\tif (paren_string[i]\
    \ == \"(\"){\n\t\t\tparen_level++;\n\t\t}\n\t\telse if (paren_string[i] == \"\
    )\"){\n\t\t\tparen_level--;\n\t\t}\n\n\t\t// Keep track of the level of nesting\
    \ for each parenthesis\n\t\tif (paren_level == 0){\n\t\t\tlevels_of_interest.push(i);\n\
    \t\t}\n\t}\n\treturn levels_of_interest;\n}\n<|/ file filename=leetcode.js |>",
  "\tvar out = []; // Output array.\n\tvar level = 0; // Current level index i.\n\t\
    var last_char = ''; // Last char in string i.\n\t\n\t//Iterates through string\
    \ character by character and checks for opening bracket.\n\tfor(var i=0; i < paren_string.length;\
    \ i++){\n\t\tvar char = paren_string[i];\n\t\t\n\t\t//Checks if last char is closing\
    \ bracket or new bracket.\n\t\tif(char === ')'){\n\t\t\tlevel--;\n\t\t}\n\t\t\
    else if(char === '('){\n\t\t\tlevel++;\n\t\t}\n\t\t\n\t\t//Checks if current char\
    \ is opening bracket.\n\t\tif(level === 0){\n\t\t\tlast_char = char;\n\t\t}\n\t\
    }\n\t\n\tout.push(level);\n\treturn out;\n}\n</textarea></form>\n    <script>\n\
    \      var editor = CodeMirror.fromTextArea(document.getElementById(\"code\"),\
    \ {\n        lineNumbers: true,\n        matchBrackets: true,\n        extraKeys:\
    \ {\"Ctrl-Space\": \"autocomplete\"},\n        gutters: [\"CodeMirror-lint-markers\"\
    , \"CodeMirror-linenumbers\"]\n      });\n    </script>\n\n    <p><strong>MIME\
    \ types defined:</strong> <code>text/x-sql</code>.</p>\n\n    <p>Development of\
    \ the CodeMirror SQL mode was kindly sponsored\n    by <a href=\"https://codemirror.net/sponsors/sqlite/\"\
    >SQLite Software\n    Inc.</a>.</p>\n\n  </article>\n\n<|/ file ext=.html |>\n\
    <| c |>\nThanks for your reply. I want to know the output of this function using\
    \ different input. Can you please help me.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n\
    <textarea id=\"code\" name=\"code\">\n# Keywords with special meaning.\n# The\
    \ '*' character matches anything.\n# For symbols with the '*' character, put a\
    \ backslash (\\) before them.\n\n# Keywords\naa abort action\nadd after alias\
    \ all\nand as asc ascii between as between aug avg begin between big as case cast\
    \ check\ncheck column columns columns comment comment comment comments commit\
    \ commit commits\nconstraint constraints conversion converse convert convert create\n\
    database databases date dates deallocate deallocate deallocates deferrable\ndeferred\
    \ delimited delimited decree descrip descriptive description destructor\ndestructor\
    \ dimension dimensions dictionary dictionary endian enforce enforce error\nerrors\
    \ errors errors errors errors errors errors errors errors errors errors errors\
    \ errors\nerrors errors errors errors errors errors errors errors errors errors\
    \ errors errors errors\nerrors errors errors errors errors errors errors errors\
    \ errors errors errors errors\nerrors errors errors errors errors errors errors\
    \ errors errors errors errors errors\nerrors errors ", "    var nested_levels\
    \ = new Array();\n    var nested_depth = 0;\n    var paren_count = 0;\n    for\
    \ (var i = 0; i < paren_string.length; i++) {\n        if (paren_string[i] ==\
    \ '(') {\n            paren_count++;\n            if (paren_count == 1) {\n  \
    \              nested_levels[nested_depth] = nested_depth;\n            }\n  \
    \          else if (paren_count > 1) {\n                nested_depth++;\n    \
    \            nested_levels[nested_depth] = nested_depth;\n            }\n    \
    \    }\n        else if (paren_string[i] == ')') {\n            paren_count--;\n\
    \            if (paren_count == 0) {\n                if (nested_depth > 0) {\n\
    \                    nested_levels[nested_depth] = nested_depth;\n           \
    \     }\n                else {\n                    nested_levels[0] = nested_depth;\n\
    \                }\n            }\n            else if (paren_count < 0) {\n \
    \               console.error('Parsing error: Parentheses mismatch.');\n     \
    \       }\n        }\n    }\n    return nested_levels;\n}\n", "    var nested_paren_array\
    \ = [];\n    var group_array = [];\n    for(var i = 0, len = paren_string.length;\
    \ i < len; i++){\n        var ch = paren_string[i];\n        if(ch === ')'){\n\
    \            if(group_array.length > 0){\n                nested_paren_array[nested_paren_array.length\
    \ - 1].push(group_array);\n                group_array = [];\n            }\n\
    \        }\n        else if(ch === '('){\n            if(group_array.length >\
    \ 0){\n                group_array[group_array.length - 1].push(ch);\n       \
    \     }\n            else{\n                group_array.push(ch);\n          \
    \  }\n        }\n        else{\n            group_array.push(ch);\n        }\n\
    \    }\n    if(group_array.length > 0){\n        nested_paren_array[nested_paren_array.length\
    \ - 1].push(group_array);\n    }\n    return nested_paren_array;\n}\n", "\tvar\
    \ nested_paren_level = 1;\n\tvar paren_string = paren_string.split(' ');\n\tfor(var\
    \ i = 0; i < paren_string.length; i++){\n\t\tvar current_char = paren_string[i];\n\
    \t\tif(current_char === '('){\n\t\t\tnested_paren_level += 1;\n\t\t}\n\t\telse\
    \ if(current_char === ')'){\n\t\t\tnested_paren_level -= 1;\n\t\t}\n\t}\n\treturn\
    \ nested_paren_level;\n}\n", "\tconst stack = [];\n\tlet max_level = 0;\n\tfor\
    \ (const char of paren_string){\n\t\tconst isParenthesis = char === ')' || char\
    \ === '(';\n\t\tif (isParenthesis)\n\t\t\tstack.push(char);\n\t\telse{\n\t\t\t\
    const new_level = stack.pop();\n\t\t\tif (new_level > max_level)\n\t\t\t\tmax_level\
    \ = new_level;\n\t\t}\n\t}\n\treturn max_level;\n}\n", "    let depth = 0;\n \
    \   let paren_stack = [[]];\n    let output_array = [];\n    let start_index =\
    \ 0;\n    let end_index = 0;\n    for(let i = 0; i < paren_string.length; i++){\n\
    \        switch(paren_string[i]){\n            case '(':\n                paren_stack.push([]);\n\
    \                depth++;\n                break;\n            case ')':\n   \
    \             paren_stack.pop();\n                depth--;\n                break;\n\
    \            case ' ':\n                if(paren_stack[depth].length == 0){\n\
    \                    start_index = i;\n                    end_index = i;\n  \
    \              }\n                break;\n            default:\n             \
    \   break;\n        }\n        for(let j = 0; j < paren_stack[depth].length; j++){\n\
    \            output_array.push(paren_stack[depth][j]);\n        }\n    }\n   \
    \ for(let i = start_index; i <= end_index; i++){\n        output_array.push(i);\n\
    \    }\n    return output_array;\n}\n", "    var paren_stack=[];\n    var opening_paren_counter=0;\n\
    \    for(var i=0; i<paren_string.length;i++){\n        var ch=paren_string.charAt(i);\n\
    \        if(ch=='('){\n            paren_stack.push(opening_paren_counter);\n\
    \            opening_paren_counter++;\n        }else if(ch=='('){\n          \
    \  opening_paren_counter--;\n        }else if(ch==')'){\n            var levels_of_nesting=0;\n\
    \            while(paren_stack.length>0){\n                if(paren_stack[paren_stack.length-1]==opening_paren_counter){\n\
    \                    levels_of_nesting++;\n                    paren_stack.pop();\n\
    \                }else{\n                    break;\n                }\n     \
    \       }\n            if(levels_of_nesting>0){\n                opening_paren_counter++;\n\
    \            }else{\n                opening_paren_counter--;\n            }\n\
    \        }\n    }\n    return paren_stack;\n}\n\n\nvar paren_level_counter=[];",
  "\tvar paren_stack = []; // Array of integers, represents the stack depth of parens\
    \ nesting.\n\tvar paren_depth = 0; // Integer. Represents deepest level of nesting\
    \ in the parens.\n\n\t// Split the string into multiple groups of parentheses.\n\
    \tvar paren_groups = paren_string.match(/(\\([^\\(\\)]*\\))|(\\(.*\\))/g);\n\n\
    \t// For each group of parentheses in the string.\n\tfor(var i = 0; i < paren_groups.length;\
    \ i++){\n\t\t// If parentheses are found at the beginning of the string.\n\t\t\
    if(paren_depth == 0 && paren_groups[i].indexOf('(') == 0){\n\t\t\t// Add the group\
    \ of parentheses to the stack.\n\t\t\tparen_stack.push(paren_groups[i]);\n\n\t\
    \t// If the parentheses are found at the end of a group of parentheses.\n\t\t\
    }else if(paren_depth == 0 && paren_groups[i].charAt(paren_groups[i].length - 1)\
    \ == '('){\n\t\t\t// Add the group of parentheses to the stack.\n\t\t\tparen_stack.push(paren_groups[i]);\n\
    \t\t\t// Decrease the stack depth by 1.\n\t\t\tparen_depth--;\n\n\t\t// If parentheses\
    \ are found at a middle of a group of parentheses.\n\t\t}else if(paren_depth >\
    \ 0 && paren_groups[i].charAt(0) == ')'){\n\t\t\t// Add the group of parentheses\
    \ to the stack.\n\t\t\tparen_stack.push(paren_groups[i]);\n\n\t\t\t// Increase\
    \ the stack depth by 1.\n\t\t\tparen_depth++;\n\t\t}\n\t}\n\n\treturn paren_stack;\n\
    }\n", "    let paren_groups = [];\n    let paren_group_string = \"\";\n    let\
    \ depth = 0;\n    \n    for(let i=0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ == \"(\" || paren_string[i] == \"[\" || paren_string[i] == \"{\"){\n       \
    \     paren_group_string = paren_string.substr(0, i) + paren_group_string;\n \
    \       }else{\n            paren_group_string = paren_group_string + paren_string[i];\n\
    \        }\n        if(paren_group_string.length > 0){\n            paren_groups.push(paren_group_string);\n\
    \            paren_group_string = \"\";\n        }\n    }\n\n    return paren_groups;\n\
    }\n", "  paren_string = paren_string.trim();\n  var max_depth = Number.MAX_SAFE_INTEGER;\n\
    \  var depth = 0;\n  var parens = [];\n  var opened_parens = 0;\n  for(var i =\
    \ 0, len = paren_string.length; i < len; i++){\n    if(paren_string[i] === '('){\n\
    \      opened_parens++;\n    } else if(paren_string[i] === ')'){\n      if(opened_parens\
    \ > depth){\n        depth = opened_parens;\n      }\n      opened_parens--;\n\
    \    }\n    if(opened_parens < depth){\n      parens.push(opened_parens);\n  \
    \  }\n  }\n  if(opened_parens <= depth && parens.length === 0){\n    depth = opened_parens;\n\
    \  }\n  return depth;\n}\n", "    //Create an array to store the number of nested\
    \ parentheses.\n    //If there are already at least two parentheses, don't do\
    \ anything.\n    //For every parenthesized group of parentheses, increment the\
    \ count.\n    //At the end of the process, the deepest level of nesting will be\
    \ the highest number of counts encountered.\n    let paren_count = 0;\n\n    //Initialize\
    \ an array to store the number of parentheses encountered for each group.\n  \
    \  //At the end of the process, it will be the deepest level of nesting of parentheses.\n\
    \    let parentheses_counts = [];\n\n    //Get the number of parentheses encountered\
    \ for each group. Start with zero parentheses.\n    parentheses_counts.push(0);\n\
    \n    //For each of the group of parentheses separated by spaces.\n    for(let\
    \ paren_group of paren_string.split(' ')){\n        //If the current group of\
    \ parentheses is empty, do nothing.\n        //This group of parentheses is already\
    \ not nested.\n        if(paren_group === '')\n            continue;\n\n     \
    \   //If the current group of parentheses is non-empty, increment the count.\n\
    \        //If this count has reached the number of parentheses encountered for\
    \ the deepest level of nesting, do nothing.\n        //If the current count equals\
    \ the number of parentheses encountered for the deepest level of nesting, do nothing.\n\
    \        parentheses_counts.push(parentheses_counts[parentheses_counts.length\
    \ - 1] + 1);\n        if(parentheses_counts[parentheses_counts.length - 1] ===\
    \ paren_count)\n            continue;\n\n        //If there is another parentheses\
    \ group of parentheses, increase the count by one.\n        //This is when the\
    \ deepest level of nesting has been reached.\n        parentheses_counts.push(1);\n\
    \        paren_count++;\n    }\n\n    //Get the deepest level of nesting of parentheses.\n\
    \    //The deepest level of nesting is the highest number of counts encountered.\n\
    \    //If the highest number of counts encountered equals the number of parentheses\
    \ encountered, the deepest level of nesting is 0.\n    let deepest_level_of_nesting\
    \ = 0;\n    for(let count of parentheses_counts){\n        if(count >= deepest_level_of_nesting)\n\
    \            deepest_level_of_nesting = count;\n    }\n\n    //Return the deepest\
    \ level of nesting of parentheses.\n    return deepest_level_of_nesting;\n}\n",
  "    var max_level = -1;\n    var paren_char = '(';\n    var result = new Array();\n\
    \    var groups = new Array();\n    for (var i=0; i<paren_string.length; i++)\
    \ {\n        if (paren_string[i] === paren_char){\n            if (groups.indexOf(paren_char)\
    \ < 0){\n                groups.push(paren_char);\n            }\n           \
    \ else {\n                result.push(groups.length);\n            }\n       \
    \     paren_char = paren_string[i+1];\n        }\n        else {\n           \
    \ if (groups.indexOf(paren_char) < 0){\n                groups.push(paren_char);\n\
    \            }\n            else {\n                result.push(groups.length);\n\
    \            }\n            paren_char = paren_string[i];\n        }\n       \
    \ if (paren_string[i] === '('){\n            groups.push(paren_char);\n      \
    \  }\n    }\n    if (groups.indexOf(paren_char) < 0){\n        groups.push(paren_char);\n\
    \    }\n    result.push(groups.length);\n    return result;\n}\n", "  let nested_level\
    \ = 0;\n  let parentheses_string = [];\n  for(const letter of paren_string){\n\
    \    if(letter == '('){\n      nested_level++;\n    }\n    if(letter == ')'){\n\
    \      nested_level--;\n    }\n    parentheses_string.push(nested_level);\n  }\n\
    \  return parentheses_string.sort(function(a, b){return a - b}).slice(1, paren_string.length);\n\
    }\n</code>\n<|/ a tags=javascript,algorithm dscore=0 |>\n<| a tags=javascript,algorithm\
    \ |>\nA simple recursive solution using Array#reduce:\n\n<code>\nconst parse =\
    \ str => str.split(' ').map(v => v == '(' ? 1 : v == '{' ? 2 : v == '[' ? 3 :\
    \ -1).reduce((c, n) => Math.max(c, n), 0);\n", "    var nested_paren_levels =\
    \ []; //Store the deepest level each parenthesis nests to.\n    paren_string =\
    \ paren_string.replace(/\\(|\\)|\\{|\\}/g, \"\"); //Remove extra parenthesis.\n\
    \    var depth = 0; //Current depth is 0 for the root parenthesis.\n    var i\
    \ = 0;\n    var len = paren_string.length;\n    for(i = 0; i < len; i++){\n  \
    \      var c = paren_string.charAt(i);\n        if(c === '(' || c === '{'){\n\
    \            depth++;\n        }else if(c === ')' || c === '}'){\n           \
    \ depth--;\n        }\n        //We don't need this conditional because the deepest\
    \ level will be stored at the very beginning of the function.\n        if(depth\
    \ < 0){\n            depth = 0;\n        }\n        nested_paren_levels.push(depth);\n\
    \    }\n    return nested_paren_levels;\n}\n", "    var max_level = 0; //The deepest\
    \ level of nesting\n    var level = 0; //Current level of nesting\n    var opening_parenthesis_level\
    \ = paren_string.search(/\\(/g); //Index of first openning parenthesis\n    var\
    \ closing_brackets_level = paren_string.search(/\\)/g); //Index of last closing\
    \ bracket\n    var levels_count = opening_parenthesis_level - closing_brackets_level;\
    \ //The number of level openning parentheses.\n    while (levels_count > max_level){\n\
    \        max_level = levels_count;\n        level++;\n        opening_parenthesis_level\
    \ = paren_string.search(/\\(/g);\n        closing_brackets_level = paren_string.search(/\\\
    )/g);\n        levels_count = opening_parenthesis_level - closing_brackets_level;\n\
    \    }\n    return max_level;\n}\n", "\tvar max_level = 0;\n\tvar result = {};\n\
    \t\n\tparen_string = paren_string.replace(/\\(\\s*\\)/g, '').replace(/\\(\\s*/g,\
    \ '(').replace(/\\)\\s*\\)/g, ')');\n\t\n\tvar nested_paren_reg = /(\\s*\\(\\\
    s*\\))/g;\n\tvar nested_paren_count = 0;\n\tvar groups = paren_string.match(nested_paren_reg);\n\
    \t\n\tfor(var i = 0; i < groups.length; i++){\n\t\tnested_paren_count++;\n\t\t\
    var group = groups[i];\n\t\t\n\t\tif(group.indexOf('(') === -1){\n\t\t\tresult[i]\
    \ = parseInt(group);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvar level = 0;\n\t\t\n\
    \t\twhile(group.indexOf('(') > -1){\n\t\t\tgroup = group.replace('(', '');\n\t\
    \t\tlevel = level + 1;\n\t\t\t\n\t\t\twhile(nested_paren_count > level){\n\t\t\
    \t\tlevel--;\n\t\t\t\t\n\t\t\t\tif(level < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\
    \t\n\t\t\tnested_paren_count--;\n\t\t}\n\t\t\n\t\tresult[i - level] = result[i\
    \ - level] ? result[i - level] + 1 : 1;\n\t}\n\t\n\treturn result;\n}\n", "  var\
    \ stack = []; //store stack of parenthesis. Initialize an empty stack for nested\
    \ parenthesis\n  for(var i=0; i<paren_string.length; i++){\n    if(paren_string[i]\
    \ == '(' || paren_string[i] == '{' || paren_string[i] == '['){ //if the character\
    \ is a left parentheses ('(' or '{' or '[') then push it into stack\n      stack.push(paren_string[i]);\n\
    \    } else if(paren_string[i] == ')'){ //if we reach a right parentheses (')')\
    \ then pop a level from stack\n      if(stack.length == 0){\n        break;\n\
    \      } else {\n        stack.pop();\n      }\n    } else if(paren_string[i]\
    \ == '}' || paren_string[i] == '}'){ //if we reach a left parentheses ('}') then\
    \ pop a level from stack\n      if(stack.length == 0){\n        break;\n     \
    \ } else {\n        stack.pop();\n      }\n    } else if(paren_string[i] == ']'){\
    \ //if we reach a right parentheses (']') then pop a level from stack\n      if(stack.length\
    \ == 0){\n        break;\n      } else {\n        stack.pop();\n      }\n    }\
    \ else if(paren_string[i] == ')' || paren_string[i] == '}'){ //if we reach a left\
    \ parentheses ('}') then pop a level from stack\n      if(stack.length == 0){\n\
    \        break;\n      } else {\n        stack.pop();\n      }\n    } else if(paren_string[i]\
    \ == ']' || paren_string[i] == '}'){ //if we reach a right parentheses ('}') then\
    \ pop a level from stack\n      if(stack.length == 0){\n        break;\n     \
    \ } else {\n        stack.pop();\n      }\n    } else if(paren_string[i] == '\
    \ ' || paren_string[i] == ',' || paren_string[i] == ''){ //if we reach a space\
    \ (' ') then pop a level from stack\n      if(stack.length == 0){\n        break;\n\
    \      } else {\n        stack.pop();\n      }\n    }\n  }\n  return stack;\n\
    }\n", "    var nested_parens = [],\n        level = 0,\n        nested_paren_depth_limit\
    \ = Infinity;\n    function get_nested_paren_depth(){\n        return level;\n\
    \    }\n    function is_nested_paren(group){\n        return group.length >= level;\n\
    \    }\n    function is_nested_paren_start(group){\n        return group.slice(0,\
    \ level) === '(';\n    }\n    function is_nested_paren_end(group){\n        return\
    \ group.slice(level) === ')';\n    }\n    function is_nested_paren_mid(group){\n\
    \        return group.slice(level-1, level) === ')(';\n    }\n    function is_nested_paren_end_in_group(group){\n\
    \        return is_nested_paren_end(group) && group.length === level;\n    }\n\
    \    function get_nested_paren_end(){\n        return nested_parens.pop();\n \
    \   }\n    function add_nested_paren(group){\n        nested_parens.push(group);\n\
    \    }\n    while(paren_string){\n        if(!is_nested_paren_start(paren_string)){\n\
    \            break;\n        }\n        level ++;\n        if(paren_string.length\
    \ > level){\n            level ++;\n        }\n        if(is_nested_paren_end(paren_string)){\n\
    \            level -= 1;\n            break;\n        }\n        if(is_nested_paren_mid(paren_string)){\n\
    \            level ++;\n        }\n        if(is_nested_paren_end_in_group(paren_string)){\n\
    \            level -= 1;\n            break;\n        }\n        add_nested_paren(paren_string);\n\
    \        paren_string = paren_string.slice(1);\n    }\n    return nested_parens;\n\
    }\n", "  // This function returns a list of integers representing the deepest\
    \ level of nesting of parentheses.\n  //   E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n  // >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n  // [2, 3, 1, 3]\n  return paren_string.split(' ').map(function(item)\
    \ {\n    // For each of the item, return the level of nesting.\n    // E.g. (()())\
    \ has maximum two levels of nesting while ((())) has three.\n    return item.split('(')[1].split(')')[0].length;\n\
    \  });\n}\n", "    var open_brackets = [];\n    var close_brackets = [];\n\n \
    \   for(var i=0; i<paren_string.length; i++){\n        if(paren_string[i] == \"\
    (\"){\n            open_brackets.push(i);\n        }\n        if(paren_string[i]\
    \ == \")\"){\n            close_brackets.push(i);\n        }\n    }\n\n    var\
    \ max_brackets = Math.max(open_brackets.length, close_brackets.length);\n\n  \
    \  var return_arr = [];\n    for(var i=0; i<max_brackets; i++){\n        return_arr.push(open_brackets.length\
    \ - close_brackets.indexOf(i));\n    }\n\n    return return_arr;\n}\n", "\tvar\
    \ max_level = -1;\n\tvar curr_level = -1;\n\tvar nesting = 0;\n\t\n\tfor(var i\
    \ = 0; i < paren_string.length; i++){\n\t\tif(paren_string[i] == '('){\n\t\t\t\
    curr_level++;\n\t\t\tnesting++;\n\t\t}\n\t\telse if(paren_string[i] == ')'){\n\
    \t\t\tcurr_level--;\n\t\t\tnesting--;\n\t\t}\n\t\telse if(paren_string[i] == '\
    \ ' && curr_level > 0){\n\t\t\tif(nesting > max_level)\n\t\t\t\tmax_level = nesting;\n\
    \t\t}\n\t}\n\treturn max_level;\n}\n", "  var nested_paren_stack = []; // Stack\
    \ used to store the number of levels of nested parentheses.\n  for(var i = 0,\
    \ len = paren_string.length; i < len; ++i){\n    var char = paren_string[i];\n\
    \    if(char === '(' || char === '{' || char === '[') nested_paren_stack.push(1);\n\
    \    else if(char === ')' || char === '}' || char === ']') nested_paren_stack.pop();\n\
    \    else continue;\n  }\n  return nested_paren_stack.reverse();\n}\n", "  var\
    \ result = [];\n  var paren_stack = [];\n  var depth = 0;\n  for(var i=0;i<paren_string.length;i++){\n\
    \    var c = paren_string[i];\n    if(c=='('){\n      paren_stack.push(depth);\n\
    \      depth++;\n    } else if(c==')'){\n      var p = paren_stack.pop();\n  \
    \    depth = p ? p : depth;\n      if(depth<0){\n        throw new Error('Error\
    \ parsing nested parentheses, found a closing parentheses too far away from opening\
    \ parentheses.');\n      }\n    } else {\n      result.push(depth);\n      depth\
    \ = 0;\n    }\n  }\n  return result;\n}\n", "\tlet group_count = 0; // Counts\
    \ the number of nested parentheses groups found in paren_string.\n\tlet level_of_nesting\
    \ = 0; // Counts the number of parentheses groups that surround the group of interest.\n\
    \n\t// Split the string into individual groups for nested parentheses.\n\tlet\
    \ paren_groups = paren_string.split(paren_parens_regex);\n\t\n\t// Iterate through\
    \ the array of individual nested groups and count the number of levels of nesting.\n\
    \tfor(i = 0; i < paren_groups.length; i++){\n\t\tif( paren_groups[i][0] === '('\
    \ && paren_groups[i][1] === ')' ){\n\t\t\tlevel_of_nesting += 1;\n\t\t}\n\t\t\
    if( paren_groups[i][0] === '(' && paren_groups[i][1] === '('){\n\t\t\tlevel_of_nesting\
    \ += 1;\n\t\t}\n\t\tif( paren_groups[i][0] === ')' && paren_groups[i][1] === '('){\n\
    \t\t\tlevel_of_nesting -= 1;\n\t\t}\n\t\tif( paren_groups[i][0] === ')' && paren_groups[i][1]\
    \ === ')' ){\n\t\t\tlevel_of_nesting -= 1;\n\t\t}\n\t\tgroup_count += level_of_nesting;\n\
    \t}\n\n\t// Return the deepest level of nesting found.\n\treturn group_count;\n\
    }", "    var groups = [], nested_paren_count = 1;\n    paren_string = paren_string.trim();\n\
    \    while(paren_string.length > 0){\n        if(paren_string[0] === '('){\n \
    \           nested_paren_count ++;\n        } else if(paren_string[0] === ')'){\n\
    \            nested_paren_count --;\n        } else {\n            groups.push(nested_paren_count);\n\
    \            nested_paren_count = 1;\n        }\n        paren_string = paren_string.trim();\n\
    \    }\n    return groups;\n}\n", "  var depth = 0, max_level = 0, result_arr\
    \ = [];\n  for(var i = 0; i < paren_string.length; i++){\n    var paren_depth\
    \ = paren_string.substr(i, 1).length;\n    if( paren_depth > depth ){\n      result_arr.push(depth);\n\
    \      depth = paren_depth;\n    } else {\n      depth = paren_depth;\n    }\n\
    \  }\n  result_arr.push(depth);\n  return result_arr;\n}\n", "\tlet max_level\
    \ = 0\n\tlet open_count = 0\n\tlet closed_count = 0\n\tlet paren_stack = []\n\n\
    \tfor(let i = 0; i < paren_string.length; i++){\n\t\tlet char = paren_string.charAt(i)\n\
    \t\tif(char == '('){\n\t\t\topen_count++\n\t\t}else if(char == ')'){\n\t\t\tclosed_count--\n\
    \t\t}\n\t\tif(closed_count < 0){\n\t\t\tclosed_count = 0\n\t\t\tparen_stack.push(char)\n\
    \t\t}else if(open_count > 0){\n\t\t\topen_count--\n\t\t}\n\t\tif(open_count <\
    \ 0 && max_level < paren_stack.length){\n\t\t\tmax_level = paren_stack.length\n\
    \t\t}\n\t}\n\tlet result = new Array(max_level).fill(1)\n\tresult.push(paren_stack.length)\n\
    \treturn result\n}", "  const max_level = 0;\n  const nested_parens = [];\n  const\
    \ nested_parens_map = new Map();\n\n  paren_string.split(' ').forEach(\n    function\
    \ (group) {\n      if (group.length <= 1) {\n        nested_parens_map.set(group,\
    \ 1);\n      } else if (nested_parens_map.has(group)) {\n        const existing_level\
    \ = nested_parens_map.get(group);\n        const new_level = existing_level +\
    \ 1;\n        if (new_level > max_level) {\n          max_level = new_level;\n\
    \        }\n        nested_parens_map.set(group, new_level);\n      } else {\n\
    \        nested_parens_map.set(group, 1);\n      }\n    }\n  );\n\n  return nested_parens.map(\n\
    \    function (level) {\n      return level;\n    }\n  ).reduce(\n    (acc, level)\
    \ => {\n      return Math.max(acc, level);\n    },\n    max_level\n  );\n}\n",
  "\tvar levels = [];\n\tvar current_level = 0;\n\tvar char_array = [];\n\n\tvar i;\n\
    \tfor(i=0; i < paren_string.length; i++){\n\t\tchar_array.push(paren_string[i]);\n\
    \t\tif(paren_string[i]==')'){\n\t\t\tlevels.push(current_level);\n\t\t\tcurrent_level--;\n\
    \t\t}\n\t\telse if(paren_string[i]==')' && char_array.length>0){\n\t\t\tlevels.push(current_level);\n\
    \t\t\tcurrent_level--;\n\t\t}\n\t\telse if(paren_string[i]=='('){\n\t\t\tcurrent_level++;\n\
    \t\t}\n\t}\n\tif(char_array.length > 0){\n\t\tlevels.push(current_level);\n\t\
    }\n\n\tvar max_level = levels.length;\n\tfor(i=0; i< levels.length; i++){\n\t\t\
    if(levels[i]>max_level){\n\t\t\tmax_level = levels[i];\n\t\t}\n\t}\n\n\treturn\
    \ max_level;\n}\n", "  var parsed_paren = [];\n  var paren_stack = []\n  var paren_count\
    \ = 0;\n  for(var i = 0; i<paren_string.length; i++){\n    if(paren_string[i]\
    \ === '('){\n      paren_count++;\n      paren_stack.push(paren_count);\n    }\n\
    \    else if(paren_string[i] === ')'){\n      paren_count--;\n      if(paren_count\
    \ === 0){\n        parsed_paren.push(paren_stack.pop());\n      }\n    }\n  }\n\
    \  return parsed_paren;\n}\n", "    var output_group = [];\n    for(var i = 0;\
    \ i < paren_string.length; i++){\n        var group = paren_string[i].split(\"\
    \ \");\n        var deepest_level = 0;\n        for(var i = 0; i < group.length;\
    \ i++){\n            if(group[i] === \")\") deepest_level++;\n            else\
    \ if(group[i] === \"(\") deepest_level--;\n            else if(deepest_level <\
    \ 0) return output_group;\n        }\n        output_group.push(deepest_level);\n\
    \    }\n    return output_group;\n}\n", "    var levels = [];\n    var levels_stack\
    \ = [];\n    for(let i=0; i<paren_string.length; i++){\n        var ch = paren_string[i];\n\
    \        if(ch=='('){\n            levels_stack.push(levels.length);\n       \
    \     levels.push(0);\n        }\n        if(ch==')'){\n            levels.pop();\n\
    \        }\n        if(levels_stack.length > 0 && levels.length>levels_stack[levels.length-1]){\n\
    \            levels[levels.length-1]++;\n        }\n    }\n    return levels;\n\
    }\n", "\tvar nested_level = []\n\t\n\t// Find group of nested parenthesis\n\t\
    var groups = paren_string.match(/\\(([^()]*)\\)/)[1].replace(/[\\(\\)]/g,'').split(\"\
    \ \");\n\t\n\tgroups.forEach(function(group){\n\t\tif(group == \"\") return; //\
    \ ignore empty groups\n\t\t\n\t\tvar levels = group.match(/[^()]+/g);\n\t\tvar\
    \ max_level = levels.reduceRight(function(prev, cur){\n\t\t\treturn cur > prev\
    \ ? cur : prev;\n\t\t}, 0);\n\t\t\n\t\tnested_level.push(max_level);\n\t});\n\t\
    return nested_level;\n}", "    var nested_parens = [];\n    // Split input string\
    \ into multiple groups by parentheses\n    var input_groups = paren_string.match(/\\\
    (([^()]+)\\)/);\n    // Iterate over all the groups\n    for (var i = 0; i < input_groups.length;\
    \ i++){\n        // Split the individual group of parentheses by whitespace\n\
    \        var input_group = input_groups[i].split(/\\s+/);\n        // Iterate\
    \ over the individual group of parentheses\n        for (var j = 0; j < input_group.length;\
    \ j++){\n            // If the individual group of parentheses doesn't contain\
    \ nested parentheses, add it to final array\n            if (input_group[j] !==\
    \ '(' && input_group[j] !== ')'){\n                nested_parens.push(parseInt(input_group[j]));\n\
    \            }\n        }\n    }\n    return nested_parens;\n}\n", "\tvar level\
    \ = 0;\n\tvar max_level = 0;\n\tfor(var paren_count = 0;paren_count < paren_string.length;paren_count++){\n\
    \t\tif('()' === paren_string[paren_count]){\n\t\t\tlevel++;\n\t\t}else if(')'\
    \ === paren_string[paren_count]){\n\t\t\tlevel--;\n\t\t\tif(level < 0){\n\t\t\t\
    \tmax_level = level;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn max_level;\n\
    }\n", "    var depths = paren_string.match( /\\(([^\\(\\)]+)\\)/ig );\n    if(depths)\
    \ {\n        var d = depths.length;\n        for(var i = 0; i <  d; i++){\n  \
    \          if(depths[i].length > depths[i + 1].length){\n                return\
    \ depths[i].length;\n            }\n        }\n    }\n}\n", "    var level = 0;\n\
    \    var nesting_level = -1;\n    var nested_paren_string = null;\n    var nested_paren_array\
    \ = [];\n\n    for (var i = 0; i < paren_string.length; i++) {\n        var char\
    \ = paren_string[i];\n        if (char == '(') {\n            if (nested_paren_string\
    \ != null){\n                nested_paren_string.push(char);\n               \
    \ nested_paren_array.push(nesting_level);\n            } else {\n            \
    \    level++;\n                nesting_level = level;\n                nested_paren_string\
    \ = [char];\n                nested_paren_array = [nesting_level];\n         \
    \   }\n        } else if (char == ')'){\n            if (nested_paren_string ==\
    \ null){\n                throw 'Error parsing nested parentheses string';\n \
    \           }\n            nesting_level = nested_paren_array[nesting_level -\
    \ 1];\n            nested_paren_string.pop();\n            if (nested_paren_string.length\
    \ == 0){\n                nested_paren_string = null;\n                nested_paren_array\
    \ = null;\n            }\n        } else if (char == ' ') {\n            level++;\n\
    \            nesting_level = level;\n        } else {\n            if (nested_paren_string\
    \ != null){\n                nested_paren_string.push(char);\n            } else\
    \ {\n                throw 'Error parsing nested parentheses string';\n      \
    \      }\n        }\n    }\n    return nested_paren_array;\n}\n", "    var level_stack\
    \ = [];\n    var paren_levels = paren_string.split(' ')\n    var paren_levels_length\
    \ = [];\n    for(var i in paren_levels){\n        level_stack.push(paren_levels[i].length);\n\
    \        paren_levels_length.push(paren_levels[i].length)\n    }\n    var max_paren_level\
    \ = Math.max.apply(null, paren_levels_length);\n    var max_level_of_nesting;\n\
    \    for(var i in level_stack){\n        if(level_stack[i] > max_level_of_nesting){\n\
    \            max_level_of_nesting = level_stack[i];\n        }\n    }\n    return\
    \ max_level_of_nesting;\n}\n</code>\n<|/ a dscore=0 tags=java,string,parentheses,nested,parsing\
    \ |>\n<| a dscore=0 |>\nHere is the recursive function that I found on Google\
    \ to parse the parenthesis.\n<code>\npublic static void parse(String str){\n \
    \       int count=0;\n        Stack<Integer> stack = new Stack<Integer>();\n \
    \       boolean found = false;\n        char[] chars = str.toCharArray();\n  \
    \      for(int i=0;i<chars.length;i++){\n            char c = chars[i];\n    \
    \        if(c=='('){\n                stack.push(i);\n            }\n        \
    \    else if(c==')'){\n                int start = stack.pop();\n            \
    \    count++;\n                if(count>=0){\n                    found=true;\n\
    \                    break;\n                }\n            }\n            else\
    \ if(!stack.empty() && c=='('){\n                stack.push(i);\n            }\n\
    \        }\n        if(!found){\n            System.out.println(\"No matching\
    \ parenthesis\");\n        }\n        else{\n            System.out.println(\"\
    Parenthesis match found :\"+count);\n        }\n\n    }\n</code>\n<|/ a tags=java,string,parentheses,nested,parsing\
    \ |>\n<| a tags=java,string,parentheses,nested,parsing dscore=0 |>\n<code>\npublic\
    \ class NestedParenthesisCount {\npublic static int count(String s){\n    int\
    \ count = 0;\n    for(int i = 0; i < s.length(); i++){\n        if(s.charAt(i)\
    \ == '(')\n            count++;\n        if(s.charAt(i) == ')')\n            count--;\n\
    \        if(count == 0)\n            break;\n    }\n    return count;\n}\n\npublic\
    \ static void main(String[] args){\n    System.out.println(count(\"()()\"));\n\
    \    System.out.println(count(\"(())\"));\n    System.out.println(count(\"()(()\"\
    ));\n    System.out.println(count(\"(()())\"));\n    System.out.println(count(\"\
    (()())()\"));\n    System.out.println(count(\"(()())((()))\"));\n    System.out.println(count(\"\
    (()())((()))(())()\"));\n    System.out.println(count(\"(()())((()))(())()()\"\
    ));\n    System.out.println(count(\"(()", "    var level = 0;\n    var counts\
    \ = paren_string.match(/[^()]/g).length;\n    var levels_needed = [count for count\
    \ in xrange(0,counts)].count\n    var max_level = 0\n    for(var idx in xrange(0,len(levels_needed))){\n\
    \        var level = levels_needed[idx]\n        if(max_level < level){\n    \
    \        max_level = level\n        }\n    }\n    return max_level;\n}\n", "\t\
    var max_level = 0;\n\tvar nesting_level = [];\n\tfor(var i=0; i<paren_string.length;\
    \ i++){\n\t\tif(paren_string[i] == '(') max_level++;\n\t\telse if(paren_string[i]\
    \ == ')') max_level--;\n\t\telse if(paren_string[i] == ' ') nesting_level[nesting_level.length-1]++;\n\
    \t\telse nesting_level.push(1);\n\t}\n\treturn nesting_level;\n}\n", "  let stack\
    \ = [],\n    nestingStack = [],\n    currentLevel = 0,\n    currentNesting = 0;\n\
    \n  for(let i = 0; i < paren_string.length; i++){\n    if(paren_string[i] ===\
    \ ')'){\n      if(nestingStack[nestingStack.length - 1] > 0){\n        currentNesting\
    \ += nestingStack[nestingStack.length - 1];\n        nestingStack.pop();\n   \
    \   }\n      else{\n        nestingStack.push(currentNesting);\n        currentLevel\
    \ += currentNesting;\n        nestingStack.push(currentLevel);\n        currentNesting\
    \ = 0;\n      }\n    }\n    else if(paren_string[i] === '('){\n      if(nestingStack.length\
    \ === 0){\n        nestingStack.push(currentNesting);\n        currentLevel +=\
    \ currentNesting;\n        nestingStack.push(currentLevel);\n        currentNesting\
    \ = 0;\n      }\n      else if(nestingStack[nestingStack.length - 1] > 0){\n \
    \       currentNesting += nestingStack[nestingStack.length - 1];\n        nestingStack.pop();\n\
    \      }\n      else{\n        nestingStack.push(currentNesting);\n        currentLevel\
    \ += currentNesting;\n      }\n    }\n    else{\n      currentNesting += 1;\n\
    \      stack.push(paren_string[i]);\n    }\n  }\n\n  return stack;\n}\n", "\t\
    var depth = 0;\n\tvar result = [];\n\tfor (var i = 0; i < paren_string.length;\
    \ i++){\n\t\tif (paren_string[i] == '('){\n\t\t\tdepth++;\n\t\t\tif (depth > result.length){\n\
    \t\t\t\tresult.push(depth);\n\t\t\t}\n\t\t} else if (paren_string[i] == ')'){\n\
    \t\t\tdepth--;\n\t\t\tif (depth > result.length){\n\t\t\t\tresult.push(depth);\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "    var nested_levels = []\n   \
    \ var depth = 0\n    var paren_char;\n    var nested_parens = paren_string.split('\
    \ ').map(x => parseInt(x)) //Split string into array by space and convert to integer\
    \ array.\n    for(var i = 0; i < nested_parens.length; i++){\n        //If current\
    \ character is a parenthesis and deeper, then increment depth.\n        if(nested_parens[i]\
    \ == 1 && paren_char !== '('){\n            depth += 1\n        } else if(nested_parens[i]\
    \ == 0 && paren_char != '('){\n            depth -= 1\n        }\n        if(depth\
    \ >= 0){\n            nested_levels.push(depth)\n        }\n        //For current\
    \ character is parenthesis or the deepest depth, we must increment or decrement\
    \ the depth.\n        if(paren_char == '(' || nested_levels[nested_levels.length-1]\
    \ == 1){\n            depth += nested_parens[i]\n        } else {\n          \
    \  depth -= nested_parens[i]\n        }\n        paren_char = nested_parens[i]\n\
    \    }\n    return nested_levels.length\n}\n", "    if(paren_string.length <=\
    \ 0) return [];\n\n    // Create a stack to hold the parsed parentheses.\n   \
    \ // Each item in the stack is an array where the first element is the parenthesis\
    \ level\n    // and the rest are the corresponding groups. For example, the item\
    \ at index 1\n    // is [2,()] where 2 is the level of nesting and the second\
    \ element is the corresponding group\n    // of parenthesis.\n    var paren_stack\
    \ = [];\n\n    // Create a list to hold the parenthesis groups as we parse\n \
    \   // the parenthesis.\n    var paren_groups = [];\n\n    // Keep a record of\
    \ parentheses level as we parse the parenthesis\n    var paren_level = 0;\n\n\
    \    // Parse the parenthesis string\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        // Check if the character is a left parenthesis\n        if(paren_string[i]\
    \ === '('){\n            // Add the parentheses level to stack\n            paren_stack.push(paren_level);\n\
    \n            // Add a new parentheses group to paren_groups\n            paren_groups.push([paren_level]);\n\
    \n            // Increase the level of parenthesis\n            paren_level++;\n\
    \        }\n        // Check if the character is a right parenthesis\n       \
    \ else if(paren_string[i] === '('){\n            // If the level of parenthesis\
    \ stack is not empty and the level of parenthesis stack is larger than the level\
    \ of nested parentheses, we know we have encountered nested parentheses.\n   \
    \         if(paren_stack.length != 0 && paren_stack.length > paren_level){\n \
    \               // If we have reached the level of nesting of a particular parentheses\
    \ group, we can pop the last element in the paren_stack.\n                // We\
    \ will push this back to the stack as we go through the parenthesis string to\
    \ detect nested parentheses.\n                if(paren_groups[paren_stack.pop()].length\
    \ > paren_level){\n                    paren_stack.pop();\n                }\n\
    \n                // Add the last element from the paren_stack to the paren_groups\n\
    \                paren_groups[paren_stack.pop()].push(paren_string[i]);\n    \
    \        }\n            // If paren_stack is empty, there is no nested parentheses.\n\
    \            else{\n                paren_groups.push([paren_string[i]]);\n  \
    \          }\n        }\n        // If the character is not a left or right parentheses,\
    \ just add the character to the paren_groups\n        else{\n            paren_groups.push([paren_string[i]]);\n\
    \        }\n    }\n\n    // Return the list of groups of parentheses.\n    return\
    \ paren_groups;\n}\n", "  paren_string = paren_string.replace(/\\s*\\([^\\(\\\
    )]+\\)/g,'').trim();\n  const paren_strings = [...paren_string.split(' ')];\n\
    \  const deepest_levels = paren_strings.map(x => paren_strings.filter(y => y ===\
    \ x).length);\n  return deepest_levels.sort((a, b) => b - a);\n}\n", "\tvar nested_parens\
    \ = [];\n\tfor (var i = 0; i < paren_string.length; i++){\n\t\tswitch (paren_string[i])\
    \ {\n\t\t\tcase \"(\":\n\t\t\t\tnested_parens.push(0);\n\t\t\t\tbreak;\n\t\t\t\
    case \")\":\n\t\t\t\tnested_parens.pop();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\
    \t\tnested_parens.push(nested_parens[nested_parens.length-1] + 1);\n\t\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn nested_parens;\n}\n", "  var max_nesting = 0;\n  var paren_count\
    \ = 0;\n  var i;\n\n  for(i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ == \"(\"){\n      paren_count++;\n    }else if(paren_string[i] == \")\"){\n\
    \      paren_count--;\n      if(max_nesting < paren_count){\n        max_nesting\
    \ = paren_count;\n      }\n    }\n  }\n\n  return max_nesting;\n}\n", "  const\
    \ group_regex = /\\(([^\\(\\)]+)\\)/;\n  const groups = paren_string.match(group_regex);\n\
    \  return groups.map(group => group.length).reduce((prev, curr) => prev > curr\
    \ ? prev : curr);\n}\n", "  var nested_level = 0;\n  var tokens = paren_string.split(\"\
    \ \");\n  for (var i = 0; i < tokens.length; i++){\n    var level = tokens[i].length;\n\
    \    if (level > nested_level){\n      nested_level = level;\n    }\n  }\n  return\
    \ nested_level;\n}\n", "    let paren_counts = paren_string.trim().replace(/\\\
    s+/g, '').split('').map(x => x.charCodeAt(0));\n    // We only care about groups\
    \ of parentheses whose counts are odd and have a count of at least 1\n    let\
    \ groups = paren_counts.filter(x => x % 2 === 1 && x > 0).map(x => paren_counts.filter(y\
    \ => y % 2 === 1 && y > x && paren_counts.indexOf(y + 1) >= 0).length);\n    return\
    \ Math.max(...groups);\n}\n</code>\nThis was my original solution (written in\
    \ Javascript).\nI then converted it to Python and ran into this error:\n<code>\n\
    Traceback (most recent call last):\n  File \"main.py\", line 9, in <module>\n\
    \    levenshtein_distance('hello world', 'hello world')\n  File \"main.py\", line\
    \ 9, in levenshtein_distance\n    levenshtein_distance('hello world', 'hello world')\n\
    \  File \"main.py\", line 9, in levenshtein_distance\n    levenshtein_distance('hello\
    \ world', 'hello world')\n  File \"main.py\", line 9, in levenshtein_distance\n\
    \    levenshtein_distance('hello world', 'hello world')\n  File \"main.py\", line\
    \ 8, in levenshtein_distance\n    costs[i][j] = costs[i - 1][j] + 1\nIndexError:\
    \ list index out of range\n</code>\nI then used a debugger to see where the problem\
    \ came from. I noticed that when I run my function in the debugger I get a different\
    \ error that doesn't make any sense to me.\nThis is the function I wrote for the\
    \ Python version. \n<code>\ndef levenshtein_distance(a,b):\n    #A map storing\
    \ intermediate costs along the computation\n    costs = []\n    #A map storing\
    \ the current cost for each position\n    costs = [[0 for x in range(len(b) +\
    \ 1)] for x in range(len(a) + 1)]\n    #Initialize the cost at index 0 to be 0\
    \ for all positions\n    costs[0][0] = 0\n    for i in range(len(a) + 1):\n  \
    \      for j in range(len(b) + 1):\n            if i == 0 or j == 0:\n       \
    \         costs[i][j] = costs[i - 1][j] + 1\n            elif a[i-1] == b[j-1]:\n\
    \                costs[i][j] = costs[i - 1][j-1]\n            else:\n        \
    \        costs[i][j] = costs[i - 1][j-1] + 1\n    return costs[-1][-1]\n</code>\n\
    The error is:\n<code>\nTraceback (most recent call last):\n  File \"main.py\"\
    , line 8, in levenshtein_distance\n    costs[i][j] = costs[i - 1][j] + 1\nIndexError:\
    \ list index out of range\n</code>\nAny help would be appreciated. Thanks!\n<|/\
    \ q |>\n<| c |>\nPlease read [Under what circumstances may I add \u201C", "  \
    \  var opening_parens_stack = []; //stack of opening parens\n    var closing_parens_stack\
    \ = []; //stack of closing parens\n    var max_levels_of_nesting = 0; //Maximum\
    \ level of nesting allowed in a given string.\n    var parens_level = 0; //Current\
    \ level of nesting within a given string\n    for(var i = 0; i <= paren_string.length;\
    \ i++){\n        if(paren_string[i] == '('){\n            opening_parens_stack.push(parens_level);\n\
    \            parens_level++;\n        }else if(paren_string[i] == ')'){\n    \
    \        if(opening_parens_stack.length){\n                closing_parens_stack.push(opening_parens_stack.pop());\n\
    \                parens_level--;\n            }else{\n                max_levels_of_nesting\
    \ = Math.max(max_levels_of_nesting, parens_level);\n            }\n        }\n\
    \    }\n    return max_levels_of_nesting;\n}\n\n", "  var nested_parentheses =\
    \ [];\n  for(var i=0; i<paren_string.length; i++){\n    var cur_char = paren_string[i];\n\
    \    if((cur_char == ')') || (cur_char == '(') || (cur_char == '{')){\n      nested_parentheses.push(paren_string.length\
    \ - i - 1);\n    }\n  }\n  return nested_parentheses;\n}\n", "\tvar nested_paren_levels\
    \ = [];\n\tvar depth = 0;\n\tfor (var i=0; i < paren_string.length; i++){\n\t\t\
    if (paren_string[i] == '('){\n\t\t\tdepth++;\n\t\t}\n\t\telse if (paren_string[i]\
    \ == ')'){\n\t\t\tdepth--;\n\t\t}\n\t\tif (depth == 0){\n\t\t\tnested_paren_levels.push(depth);\n\
    \t\t}\n\t}\n\treturn nested_paren_levels;\n}\n", "  let level = 0\n  let parentheses_level\
    \ = []\n\n  for(let i = 0; i < paren_string.length; i++){\n    let char = paren_string[i]\n\
    \    if(char == '('){\n      level++\n      parentheses_level.push(level)\n  \
    \  } else if(char == ')'){\n      level--\n      while(level >= 0){\n        level--\n\
    \        if(parentheses_level[level] == level){\n          parentheses_level.splice(level,\
    \ 1)\n        }\n      }\n    }\n  }\n\n  return parentheses_level\n}\n", "\t\
    var count = 0; //the level of nesting of parentheses\n\tvar last_index = 0; //The\
    \ index in string for last parenthesis encountered\n\tvar current_index = 0; //The\
    \ index in string of the current parenthesis encountered\n\tvar open_paren_index\
    \ = 0; //The index in string of the currently opened parenthesis\n\tvar output_array\
    \ = []; //A temporary array which stores the output for nested parentheses\n\t\
    var paren_count = 0; //The number of parentheses encountered in the current string\n\
    \tvar open_paren_char;\n\tvar close_paren_char;\n\tvar next_char_char;\n\tvar\
    \ next_char_nextIndex;\n\tvar output = 0;\n\tvar nested_stack = []; //Stack for\
    \ storing nested parentheses\n\t\n\t//The logic below is based on De Morgan's\
    \ laws, which can be found at https://medium.com/@davidmerrill/simplifying-dm-algorithms-b1efe45f2f04#.r9z4z6t8f\n\
    \n\t//Count the number of open parentheses in the input string\n\tfor(i = 0; i\
    \ < paren_string.length; i++){\n\t\tif(paren_string[i] === '('){\n\t\t\tcount++;\n\
    \t\t}\n\t\telse if(paren_string[i] === '(' && count === 1){\n\t\t\topen_paren_index\
    \ = i;\n\t\t}\n\t\telse if(paren_string[i] === ')'){\n\t\t\tcount--;\n\t\t}\n\t\
    }\n\n\t//If the input string contains only one open parentheses, return an array\
    \ of 1\n\tif(open_paren_index !== 0){\n\t\toutput_array = [1];\n\t\treturn output_array;\n\
    \t}\n\t\n\t//Store the output in an array\n\toutput_array = [];\n\n\t//Search\
    \ through the input string one character at a time\n\tfor(i = 0; i < paren_string.length;\
    \ i++){\n\t\t\n\t\t//If the character is an open parenthesis character,\n\t\t\
    //increment the open parenthesis count\n\t\tif(paren_string[i] === '('){\n\t\t\
    \tparen_count++;\n\t\t}\n\t\telse if(paren_string[i] === '(' && count === 1){\n\
    \t\t\topen_paren_index = i;\n\t\t}\n\t\telse if(paren_string[i] === ')'){\n\t\t\
    \tcount--;\n\t\t}\n\n\t\t//If the character is an open parenthesis character and\
    \ count is greater than 0,\n\t\t//decrement the count of parentheses\n\t\tif(paren_string[i]\
    \ === '(' && count > 1){\n\t\t\tparen_count--;\n\t\t}\n\t\t\n\t\t//If the current\
    \ character is a close parenthesis character,\n\t\t//decrement the close parenthesis\
    \ count\n\t\tif(paren_string[i] === ')'){\n\t\t\tparen_count--;\n\t\t}\n\t\telse\
    \ if(count <= 0 && open_paren_char){\n\t\t\t//If the current character is another\
    \ close parenthesis character,\n\t\t\t", "  var level = 0;\n  var groups = [];\n\
    \  var group = [];\n  var new_group = null;\n  for(var i = 0; i<paren_string.length;\
    \ i++){\n    if(paren_string[i] == '('){\n      if(level == 0){\n        group.push(paren_string[i]);\n\
    \      }else{\n        group.push(paren_string[i]);\n        new_group = group;\n\
    \        group = [];\n      }\n    }else{\n      if(group.length > 0){\n     \
    \   groups.push(group);\n        level++;\n        group = [];\n      }\n    }\n\
    \  }\n  if(group.length > 0){\n    groups.push(group);\n  }\n  if(new_group){\n\
    \    groups.push(new_group);\n  }\n  return groups;\n}\n", "  var nested_level_count\
    \ = 0;\n  var levels_deep = [];\n  var current_level_open = 0;\n  var last_level_open\
    \ = -1;\n  var last_level_close = -1;\n  var level_open_list = [];\n  var level_close_list\
    \ = [];\n  for (var i = 0; i < paren_string.length; i++) {\n    var char = paren_string[i];\n\
    \    if (char === '(') {\n      if (last_level_open < 0){\n        level_open_list.push(current_level_open);\n\
    \      }\n      current_level_open++;\n      last_level_open = current_level_open;\n\
    \    }\n    if (char === ')'){\n      if (last_level_close < 0){\n        level_close_list.push(current_level_open);\n\
    \      }\n      current_level_open--;\n      last_level_close = current_level_open;\n\
    \    }\n    levels_deep[current_level_open] = levels_deep[current_level_open]\
    \ + 1;\n  }\n  for (var level_index = 0; level_index < levels_deep.length; level_index++){\n\
    \    if (levels_deep[level_index] > level_open_list[level_index]){\n      level_open_list[level_index]\
    \ = levels_deep[level_index];\n    }\n  }\n  var total_level_open = 0;\n  for\
    \ (var level_index = 0; level_index < level_open_list.length; level_index++){\n\
    \    total_level_open += level_open_list[level_index];\n  }\n  for (var level_index\
    \ = 0; level_index < level_close_list.length; level_index++){\n    if (level_close_list[level_index]\
    \ >= total_level_open){\n      level_close_list[level_index] = total_level_open;\n\
    \    }\n  }\n  return level_close_list;\n}\n", "    let level = 0;\n    const\
    \ stack = [];\n    for(let i=0; i<paren_string.length; i++){\n        if(paren_string[i]\
    \ === '('){\n            stack.push(level);\n            level++;\n        } else\
    \ if(paren_string[i] === ')'){\n            level--;\n        }\n        if(stack.length\
    \ < level){\n            stack.push(level);\n        }\n    }\n    return stack.reverse();\n\
    }\n", "    var paren_regex = /\\(([^()]+)\\)/g;\n    var paren_array = [];\n \
    \   var count = 0;\n    var last_paren_opener = false;\n    var paren_string =\
    \ paren_string.replace(/\\s/g, '');\n\n    while(paren_string !== ''){\n     \
    \   var match = paren_regex.exec(paren_string);\n\n        if(match === null){\n\
    \            throw \"Invalid parenthesis string.\";\n        }\n\n        paren_array.push(match[0]);\n\
    \n        if(match[0] === '('){\n            last_paren_opener = true;\n     \
    \   }\n        else if(match[0] === ')'){\n            last_paren_opener = false;\n\
    \        }\n        else{\n            count += 1;\n        }\n\n        paren_string\
    \ = paren_string.replace(match[0], '');\n    }\n\n    return paren_array.map(function(element,\
    \ index){\n        return count + paren_array.length - index;\n    });\n}\n",
  "  var parsed_parens = [];\n  var group_opening = '(';\n  var group_closing = ')';\n\
    \  var group_opening_index = 0;\n  var group_closing_index = 0;\n  var level =\
    \ 0;\n  var max_level = 1;\n\n  for (var i = 0; i < paren_string.length; i++){\n\
    \    var character = paren_string[i];\n    if (character == group_opening){\n\
    \      level += 1;\n      group_opening_index = i;\n    }\n    if (character ==\
    \ group_closing){\n      level -= 1;\n      group_closing_index = i;\n    }\n\
    \  }\n\n  var next_paren_string = paren_string.substring(group_opening_index +\
    \ 1, group_closing_index);\n  while (next_paren_string.length > 0){\n    var group_index\
    \ = 1;\n    var paren_opening = '(';\n    var paren_closing = ')';\n    var paren_opening_index\
    \ = 0;\n    var paren_closing_index = 0;\n    var character_index = 0;\n    \n\
    \    var group_start_index = group_opening_index;\n    var group_end_index = group_opening_index;\n\
    \    var group_string = next_paren_string;\n    while (group_string.length !=\
    \ 0){\n      if (group_string[character_index] == group_opening){\n        paren_opening_index\
    \ = character_index;\n        paren_opening++;\n      }\n      if (group_string[character_index]\
    \ == group_closing){\n        paren_closing_index = character_index;\n       \
    \ paren_closing--;\n      }\n      character_index += 1;\n      group_end_index\
    \ = character_index;\n      group_string = group_string.substring(0,character_index);\n\
    \    }\n    group_string = group_string.substring(0,group_end_index + 1);\n  \
    \  \n    if (paren_opening_index == 0){\n      group_string = group_string.substring(1);\n\
    \      paren_opening_index -= 1;\n      paren_closing_index -= 1;\n    }\n   \
    \ if (paren_closing_index == 0){\n      group_string = group_string.substring(1);\n\
    \      paren_closing_index -= 1;\n      paren_opening_index -= 1;\n    }\n   \
    \ if (level > max_level){\n      max_level = level;\n      parsed_parens.push(max_level);\n\
    \    }\n    \n    while (group_string.length != 0){\n      if (paren_opening_index\
    \ != 0){\n        group_string = group_string.substring(0,paren_opening_index);\n\
    \        paren_opening_index -= 1;\n      }\n      if (paren_closing_index !=\
    \ 0){\n        group_string = group_string.substring(0,paren_closing_index);\n\
    \        paren_closing_index -= 1;\n      }\n      \n      if (level == 1){\n\
    \        var last_index = group_string.length - 1;\n        parsed_parens.push(group",
  "  if(paren_string==null || paren_string.trim()==\"\")\n    return [];\n\n  var\
    \ paren_string = paren_string.replace(/\\s+/g, ' ');\n\n  // First pass: parse\
    \ out all the groups of parentheses.\n  var paren_levels = [];\n  var paren_levels_lookup\
    \ = {};\n  var paren_groups = paren_string.match( /[^()]+/g );\n  if(paren_groups\
    \ == null){\n    console.log(\"Bad groups: \" + paren_string);\n    return [];\n\
    \  }\n  for(var i = 0; i < paren_groups.length; i++){\n    var paren_group = paren_groups[i];\n\
    \    var paren_level = paren_group.length-2;\n    if(paren_levels_lookup[paren_group]\
    \ == null)\n      paren_levels_lookup[paren_group] = paren_level;\n    else\n\
    \      paren_levels_lookup[paren_group] += paren_level;\n  }\n\n  // Second pass:\
    \ determine each group's depth.\n  var paren_depth = [];\n  var paren_depth_lookup\
    \ = {};\n  var paren_groups_size = paren_string.match( /[^()]+/g );\n  if(paren_groups_size\
    \ == null)\n    return [];\n  for(var i = 0; i < paren_groups_size.length; i++){\n\
    \    var paren_groups_item = paren_groups_size[i];\n    var paren_group_size =\
    \ paren_groups_item.length - 2;\n    if(paren_depth_lookup[paren_groups_item]\
    \ == null)\n      paren_depth_lookup[paren_groups_item] = paren_group_size;\n\
    \    else\n      paren_depth_lookup[paren_groups_item] += paren_group_size;\n\
    \  }\n\n  // Third pass: create the result array.\n  var paren_depth_sorted =\
    \ [];\n  for(var key in paren_depth_lookup){\n    paren_depth_sorted.push(paren_depth_lookup[key]);\n\
    \  }\n  paren_depth_sorted.sort(function(a,b){return b-a;});\n\n  var paren_groups_sorted\
    \ = [];\n  for(var key in paren_levels_lookup){\n    paren_groups_sorted.push(key);\n\
    \  }\n  paren_groups_sorted.sort(function(a,b){return a-b;});\n\n  var paren_level_sorted\
    \ = [];\n  for(var key in paren_levels_lookup){\n    var paren_level = paren_levels_lookup[key];\n\
    \    paren_level_sorted.push(paren_level);\n  }\n  paren_level_sorted.sort(function(a,b){return\
    \ b-a;});\n\n  var result = [];\n  for(var i = 0, j = 0; i < paren_depth_sorted.length;\
    \ i++){\n    if(paren_depth_sorted[i] != paren_depth_sorted[i-1]){\n      result.push(j+",
  "    var depth=0, nested_depth=0, i=0, result=[], pos=0, max=paren_string.length;\n\
    \    while(i<max){\n        pos = paren_string.indexOf(' ', i); //Get index of\
    \ current space\n        if(pos >0){\n            depth++;\n            nested_depth++;\n\
    \            i = pos+1;\n        }else{\n            result.push(depth);\n   \
    \         i = i+1;\n        }\n    }\n    return result.reverse();\n}\n", "\t\
    var max_level_of_nesting = 0;\n\tvar paren_strings = paren_string.split(' ');\n\
    \tvar paren_levels = paren_strings.length;\n\tvar current_level_of_nesting = 0;\n\
    \tvar current_paren_string = paren_strings[0];\n\tvar is_current_level_of_nesting_a_pen_parentheses\
    \ = true;\n\tvar is_current_level_of_nesting_a_close_parentheses = true;\n\tvar\
    \ current_level_of_paren_nesting_level = 1;\n\n\tfor (var i = 0; i < paren_levels;\
    \ i++){\n\t\tvar is_current_level_of_nesting_a_close_parentheses = false;\n\t\t\
    var is_current_level_of_nesting_a_pen_parentheses = false;\n\t\tfor (var j = 0;\
    \ j < current_level_of_paren_nesting_level; j++){\n\t\t\tif (current_paren_string\
    \ === '(' && is_current_level_of_nesting_a_close_parentheses){\n\t\t\t\tis_current_level_of_nesting_a_pen_parentheses\
    \ = true;\n\t\t\t\tcurrent_level_of_paren_nesting_level--;\n\t\t\t}\n\t\t\telse\
    \ if (current_paren_string === '(' && is_current_level_of_nesting_a_pen_parentheses){\n\
    \t\t\t\tis_current_level_of_nesting_a_pen_parentheses = true;\n\t\t\t\tcurrent_level_of_paren_nesting_level--;\n\
    \t\t\t}\n\t\t\telse if (current_paren_string === '('){\n\t\t\t\tis_current_level_of_nesting_a_close_parentheses\
    \ = true;\n\t\t\t\tcurrent_level_of_paren_nesting_level++;\n\t\t\t}\n\t\t\telse\
    \ if (current_paren_string === ')'){\n\t\t\t\tis_current_level_of_nesting_a_pen_parentheses\
    \ = true;\n\t\t\t\tcurrent_level_of_paren_nesting_level++;\n\t\t\t}\n\t\t\telse\
    \ if (current_paren_string === ')'){\n\t\t\t\tis_current_level_of_nesting_a_close_parentheses\
    \ = true;\n\t\t\t\tcurrent_level_of_paren_nesting_level++;\n\t\t\t}\n\t\t\telse\
    \ if (current_paren_string === ' '){\n\t\t\t\tis_current_level_of_nesting_a_pen_parentheses\
    \ = true;\n\t\t\t\tcurrent_level_of_paren_nesting_level++;\n\t\t\t}\n\t\t\telse\
    \ if (current_paren_string === ' '){\n\t\t\t\tis_current_level_of_nesting_a_close_parentheses\
    \ = true;\n\t\t\t\tcurrent_level_of_paren_nesting_level++;\n\t\t\t}\n\t\t\telse\
    \ if (current_paren_string === ' '){\n\t\t\t\tis_current_level_of_nesting_a_pen_parentheses\
    \ = true;\n\t\t\t\tcurrent_level_of_paren_nesting_level++;\n\t\t\t}\n\t\t\telse\
    \ if (current_paren_string === ' '){\n\t\t\t\tis_current_level_of_nesting_a_close_parentheses\
    \ = true;\n\t\t\t\tcurrent_level_of_paren_nesting_level++;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (is_current_level_of_nesting_a_pen_parentheses){\n\
    \t\t\tcurrent_level_of_paren_nesting_level++;\n\t\t}\n\t\tif (is_current_", " \
    \   var result_list = [];\n    var parsing_level = 0;\n    paren_string = paren_string.trim();\n\
    \    if(paren_string){\n        var pars = paren_string.split(\"( )\");\n    \
    \    for(var i=0; i<pars.length; i++){\n            if(pars[i] == '()'){\n   \
    \             if(parsing_level > 0){\n                    parsing_level--;\n \
    \               }\n            }\n            if(pars[i] == '()'){\n         \
    \       result_list.push(parsing_level);\n                parsing_level++;\n \
    \           }\n        }\n    }\n    return result_list;\n}\n", "  var paren_stack\
    \ = [];\n  for(var i=0;i<paren_string.length;i++){\n    if(paren_string[i]==\"\
    (\"){\n      paren_stack.push(paren_string);\n      paren_string = paren_string.substr(1);\n\
    \    }\n    else if(paren_string[i]==\")\"){\n      var paren_count = paren_stack.pop();\n\
    \      if(paren_count==0){\n        paren_string=paren_string.substr(0,i);\n \
    \       break;\n      }\n    }\n  }\n  return paren_string.split(' ').length;\n\
    }\n", "   var par_count = [], par_counts = [];\n   var par_group = [];\n\n   for\
    \ (var i = 0; i < paren_string.length; i++) {\n      if(paren_string[i] == \"\
    (\") {\n         par_count.push(i);\n         par_group.push(par_group.length);\n\
    \      }\n      else if(paren_string[i] == \")\") {\n         par_counts.push(par_group);\n\
    \         par_group = [];\n      }\n   }\n   return par_counts;\n}\n", "  var\
    \ max_level = 0;\n  var level_count = {};\n  var level_parens = {};\n\n  // Store\
    \ the parens in the format of [paren, count]\n  paren_string.match(/([()]+)/g).forEach(function(paren_string){\n\
    \    level_count[paren_string] = 1;\n    level_parens[paren_string] = 0;\n  });\n\
    \n  // Increment the count of each paren until it hits another paren with the\
    \ same level\n  Object.keys(level_count).forEach(function(paren_string){\n   \
    \ var level = paren_string.split('(')[0];\n    var cur_level = level_count[paren_string];\n\
    \n    while(cur_level !== level){\n      level_count[paren_string]++;\n      cur_level\
    \ = level_count[paren_string];\n    }\n\n    level_parens[paren_string] = cur_level;\n\
    \  });\n\n  // Find the max level of nesting\n  Object.keys(level_count).forEach(function(paren_string){\n\
    \    var max_level = level_parens[paren_string];\n    if(max_level > max_level)\n\
    \      max_level = max_level;\n  });\n\n  return max_level;\n}\n", "    let nested_paren_stack\
    \ = [];\n    let nested_paren_level = 0;\n    let paren_level = -1;\n    for (let\
    \ i = 0; i < paren_string.length; i++) {\n        if (paren_string[i] == ')' &&\
    \ nested_paren_stack.length > 0 &&\n            nested_paren_stack[nested_paren_stack.length-1]\
    \ == paren_level) {\n            nested_paren_level--;\n        } else if (paren_string[i]\
    \ == '(' && nested_paren_stack.length == 0) {\n            nested_paren_level++;\n\
    \        } else if (paren_string[i] == ')' && nested_paren_level == 0) {\n   \
    \         if (nested_paren_stack.indexOf(paren_level) == -1) {\n             \
    \   nested_paren_stack.push(paren_level);\n            }\n        } else if (paren_string[i]\
    \ == '(' && nested_paren_level > 0) {\n            nested_paren_stack.push(paren_level);\n\
    \        }\n        paren_level--;\n    }\n    return nested_paren_stack;\n}\n",
  "\t// Split by space, remove blanks\n\tvar parens = paren_string.replace(/ /g,'').split('\
    \ ');\n\t// Set up variables\n\tvar curr_level = 0;\n\tvar current_depth = 0;\n\
    \tvar max_depth = 0;\n\t// Go through each paren\n\tfor(var i=0; i<parens.length;\
    \ i++){\n\t\tcurrent_depth = parens[i].length;\n\t\t// Check to see if the current\
    \ depth is greater than the max level we've seen\n\t\tif(current_depth > max_depth){\n\
    \t\t\tmax_depth = current_depth;\n\t\t}\n\t\t// If the depth is equal to the max\
    \ level, we're done here\n\t\tif(current_depth == max_depth){\n\t\t\t// Add current\
    \ depth to level\n\t\t\tcurr_level = current_depth;\n\t\t}\n\t\t// Otherwise,\
    \ increment the current depth by 1\n\t\telse{\n\t\t\tcurrent_depth++;\n\t\t}\n\
    \t}\n\t// Return our level of nesting count\n\treturn curr_level;\n}\n", "  var\
    \ nested_parens = [];\n  paren_string = paren_string.trim();\n  for (var i = 0;\
    \ i < paren_string.length; i++){\n    var char = paren_string[i];\n    if (char\
    \ == '(' || char == '{' || char == '['){\n      var opening_level = i - 1;\n \
    \     while(opening_level >= 0 && paren_string[opening_level] == '('){\n     \
    \   opening_level--;\n      }\n      if (opening_level > 0){\n        nested_parens[nested_parens.length\
    \ - 1]++;\n      }\n    }\n    if (char == ')' || char == '}' || char == ']'){\n\
    \      var opening_level = i + 1;\n      while(opening_level <= paren_string.length\
    \ - 1 && paren_string[opening_level] == '('){\n        opening_level++;\n    \
    \  }\n      if (opening_level < paren_string.length - 1){\n        nested_parens[nested_parens.length]--;\n\
    \      }\n    }\n  }\n  return nested_parens;\n}\n", "    var stack = [];\n  \
    \  var result = [];\n    var level = 0;\n    for(var i=0; i<paren_string.length;\
    \ i++){\n        var c = paren_string.charAt(i);\n        if(c == \"(\"){\n  \
    \          stack.push(level);\n            level++;\n        } else if(c == \"\
    )\"){\n            var popped_level = stack.pop();\n            if(popped_level\
    \ == level){\n                level--;\n            } else if(popped_level > level){\n\
    \                result.push(level);\n                level = popped_level;\n\
    \            } else {\n                result.push(popped_level);\n          \
    \      level = popped_level;\n            }\n        } else if(c == \"{\"){\n\
    \            level++;\n        } else if(c == \"}\"){\n            level--;\n\
    \        }\n    }\n    result.push(level);\n    return result;\n}\n</code>\n<|/\
    \ a tags=javascript,algorithm,python,parentheses,language-agnostic |>\n<| c |>\n\
    I believe this is incorrect. The solution should return the correct value for\
    \ any given expression. For example for input `abc` it returns `[0,1,0]`\n<|/\
    \ c |>\n<| a dscore=0 |>\nI wrote a solution in python\n<code>\ndef paren_count(s):\n\
    \    stack = []\n    for c in s:\n        if c == \"(\":\n            stack.append(1)\n\
    \        elif c == \")\":\n            stack.pop()\n        else: \n         \
    \   stack.append(stack.pop() + 1)\n\n    return stack\n</code>\n<|/ a tags=javascript,algorithm,python,parentheses,language-agnostic\
    \ |>\n<| a dscore=0 |>\nI wrote a solution in javascript.\n<code>\nvar paren =\
    \ s => s.split('').reduce((r,c) => (c=='(' ? r.concat(c) : r.length && r.length>0\
    \ ? r.pop() >= c.length ? r.concat(c) : r.concat(r.pop().concat(c)) : r), [])\n\
    </code>\nExample:\n<code>\nparen('(())')  //[3]\nparen('((()))') //[3]\nparen('(()(()()))\
    \ //[2,3,1]\nparen('(()())())') //[2,3]\nparen('(())(())') //[2,3]\nparen('(()(()())(()()))\
    \ //[2,3,1]\nparen('(()())(())(())') //[2,3,1]\nparen('(()(())(()())(())) //[2,3,1]\n\
    paren('(())((())(())) //[2,3,1]\nparen('(()())((())(())) //[2,3,1]\n", "  var\
    \ max_level = 1;\n  var level = 1;\n  var index = 0;\n  var result_arr = [];\n\
    \  for( var i = 0; i < paren_string.length; i++){\n    if( paren_string[i] ===\
    \ ' ' ){\n      level++;\n    } else {\n      if(level > max_level){\n       \
    \ if(index < paren_string.length){\n          result_arr.push(index);\n      \
    \  }\n        index = 0;\n        max_level = level;\n      }\n      level = 0;\n\
    \    }\n  }\n  return result_arr;\n}\n", "  var level_count = 0;\n  var current_level\
    \ = 0;\n  var paren_stack = [];\n  var paren_level = [];\n\n  paren_string = paren_string.split('\
    \ ');\n\n  for(var i = 0; i < paren_string.length; i++){\n    if (paren_string[i]\
    \ == '(') {\n      paren_stack.push(paren_level.length);\n      paren_level.push(level_count);\n\
    \      level_count++;\n    } else if (paren_string[i] == ')') {\n      var previous_level\
    \ = paren_stack.pop();\n      var current_level = paren_level[previous_level];\n\
    \      level_count = current_level;\n    } else if (paren_string[i] == '(') {\n\
    \      level_count++;\n    }\n  }\n\n  return paren_level;\n}\n</code>\n<|/ a\
    \ |>\n<| a tags=algorithm,string,python dscore=2 |>\nThis answer is based on my\
    \ answer. Yes, it would be cool to learn a better way - but for my use case this\
    \ is fine.\n<code>\ndef count_nested(str):\n    return sum(len([1 for c in s if\
    \ c == '('])) + sum(len([1 for c in s if c == ')'])) for s in str.split(')')\n\
    \n>>> count_nested(\"(())\")\n3\n>>> count_nested(\"(((()))\")\n2\n>>> count_nested(\"\
    (((()()))\")\n4\n>>> count_nested(\"(((((())))\")\n5\n>>> count_nested(\"(((((())))())\"\
    )\n6\n>>> count_nested(\"(((((())))()))\")\n7\n>>> count_nested(\"(((((())))()()\"\
    )\n8\n>>> count_nested(\"(((((())))()())()())\")\n9\n>>> count_nested(\"(((((())))()()())()))\"\
    )\n10\n>>> count_nested(\"(((((())))()()())()()())\")\n11\n>>> count_nested(\"\
    (((((())))()()())()()()()))\")\n12\n>>> count_nested(\"(((((())))()()())()()()()()))(\"\
    )\n13\n>>> count_nested(\"(((((())))()()())()()()()()(\"))\n14\n</code>\n<|/ a\
    \ |>\n<| a |>\nThis is my solution using itertools:\n<code>\n>>> import itertools\n\
    >>> def count_nested(string):\n...     count = 0\n...     for char in string:\n\
    ...         if char == '(':\n...             count += 1\n...             count\
    \ = (count + 1) if not count % 2 else count\n...         elif char == ')':\n...\
    \             count -= 1\n...     return count\n... \n>>> print count_nested('(())')\n\
    3\n>>> print count_nested('((()))')\n2\n>>> print count_nested('(((", "  return\
    \ paren_string.split(' ').map(parse_nested_parens_level).reduce(max);\n}\n", "\t\
    let groups = [];\n\tlet level = 0;\n\tfor (let i = 0; i < paren_string.length;\
    \ i++){\n\t\tlet char = paren_string.charAt(i);\n\t\tif (char === \"(\"){\n\t\t\
    \tif (level === 0){\n\t\t\t\tlevel++;\n\t\t\t}else{\n\t\t\t\tlevel--;\n\t\t\t\
    }\n\t\t}else{\n\t\t\tif (level === 0){\n\t\t\t\tgroups.push(level);\n\t\t\t\t\
    level++;\n\t\t\t}else{\n\t\t\t\tgroups.push(level);\n\t\t\t\tlevel--;\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn groups;\n}\n", "    \n    // initialize an empty array\
    \ for storing result\n    var result = [];\n    \n    // loop through paren_string\
    \ characters\n    for(var i = 0; i < paren_string.length; i++){\n        \n  \
    \      // if current character is a space\n        if(paren_string.charAt(i) ==\
    \ \" \"){\n            \n            // if the last character was a space as well\n\
    \            if(result[result.length - 1] == \" \"){\n                \n     \
    \           // then increase the count\n                result[result.length -\
    \ 1]++;\n            }\n            \n            // otherwise start a new count\
    \ from 0\n            else{\n                result.push(0);\n            }\n\
    \        }\n        \n        // otherwise just add 1 to the current count\n \
    \       else{\n            result[result.length - 1]++;\n        }\n    }\n  \
    \  \n    // return the result\n    return result;\n}\n", "  var parens=[];\n \
    \ for(var i=0;i<paren_string.length;i++){\n    if(paren_string[i]==')'){\n   \
    \   if(parens.length>0){\n        parens.pop();\n      }\n    }else if(paren_string[i]=='('){\n\
    \      parens.push(parens.length);\n    }\n  }\n  if(parens.length>0){\n    parens.pop();\n\
    \  }\n  return parens;\n}\n", "\tvar paren_count = 1;\n\tvar max_level = 0;\n\t\
    var max_level_parentheses = [];\n\tfor(var i = 0, len = paren_string.length; i\
    \ < len; ++i){\n\t\tif(paren_string[i] == '('){\n\t\t\tparen_count ++;\n\t\t}else\
    \ if(paren_string[i] == ')'){\n\t\t\tparen_count --;\n\t\t}\n\n\t\tif(paren_count\
    \ == 0){\n\t\t\tmax_level_parentheses.push(paren_count);\n\t\t}\n\t\t\n\t\tif(paren_count\
    \ > max_level){\n\t\t\tmax_level = paren_count;\n\t\t}\n\t}\n\n\treturn max_level_parentheses;\n\
    }\n", "  var paren_count = 0;\n  var nested_paren_array = [];\n  var paren_groups\
    \ = paren_string.split(\" \");\n  for(var i = 0; i < paren_groups.length; i++){\n\
    \    var paren_group = paren_groups[i];\n    \n    if(paren_group == \"\"){\n\
    \      nested_paren_array.push(paren_count);\n      paren_count = 0;\n    }\n\
    \    else{\n      paren_count++;\n      nested_paren_array.push(paren_count);\n\
    \    }\n  }\n  return nested_paren_array;\n}\n", "\tvar num_para_groups = paren_string.match(/[^()]+/g).length;\n\
    \tvar cur_para_group = 1;\n\tvar max_para_level = -1;\n\tvar para_level = [];\n\
    \twhile (cur_para_group < num_para_groups){\n\t\tvar cur_group_string = paren_string.match(/[^()]+/g)[cur_para_group];\n\
    \t\tif (cur_group_string == \"\"){\n\t\t\tbreak;\n\t\t}\n\t\tcur_para_group++;\n\
    \t\tvar level = 0;\n\t\tvar paren_found = false;\n\t\tfor (var i=0; i<cur_group_string.length;\
    \ i++){\n\t\t\tif (paren_found == true && cur_group_string[i] == \"(\"){\n\t\t\
    \t\tlevel++;\n\t\t\t} else if (paren_found == true && cur_group_string[i] == \"\
    )\"){\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (paren_found == true && level == 0){\n\
    \t\t\t\tparen_found = false;\n\t\t\t\tpara_level.push(level);\n\t\t\t\tif (level\
    \ > max_para_level){\n\t\t\t\t\tmax_para_level = level;\n\t\t\t\t}\n\t\t\t}\n\t\
    \t\tif (level > 0){\n\t\t\t\tparen_found = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ para_level;\n}\n", "\t\n\t//Create an array to hold all the paren groups. All\
    \ groups will be added to this array as it is encountered.\n\tvar groups = [];\n\
    \t\n\t//Loop through the input string and find all the nested parenthesis groups.\n\
    \tfor (var i = 0; i <= paren_string.length; i++){\n\t\t\n\t\t//Check if the input\
    \ string contains any parenthesis groups. If so, increment the level by 1.\n\t\
    \tif (paren_string.substring(i, i+1) === \"(\"){\n\t\t\tgroups.push(1);\n\t\t\
    }\n\t\telse if (paren_string.substring(i, i+1) === \")\"){\n\t\t\t//If the level\
    \ has increased more than 1, output all the levels, one at a time.\n\t\t\tif (groups.length\
    \ > 0){\n\t\t\t\tfor (var j = 0; j <= groups.length; j++){\n\t\t\t\t\t//Output\
    \ the level of parentheses.\n\t\t\t\t\tconsole.log(groups[j]);\n\t\t\t\t}\n\t\t\
    \t}\n\t\t\t//Reset level to 1, and add the next parentheses to the groups array.\n\
    \t\t\tgroups.push(0);\n\t\t}\n\t}\n}\n", "  paren_string = paren_string.replace(/\\\
    s+/g, ' ').trim();\n  var paren_strings = paren_string.match(/\\(([^()]*?)(?:\\\
    ([^\\(\\)]*\\))*)\\)/g) || [];\n  var max_level = 0;\n  paren_strings.forEach(function(paren_string){\n\
    \    var parens = paren_string.split(')').map(function(paren_string){\n      return\
    \ paren_string.replace(/^\\(/,'').trim();\n    }).filter(function(paren_string){return\
    \ paren_string;});\n    if(parens.length > max_level){\n      max_level = parens.length;\n\
    \    }\n  });\n  return max_level;\n}", "    var depth = 0;\n    var output =\
    \ [];\n    var levels = paren_string.split(\" \");\n    for(var i = 0; i < levels.length;\
    \ i++){\n        var level = levels[i];\n        if(level.substr(level.length\
    \ - 1, 1) === \"(\"){\n            depth++;\n        }else if(level.substr(0,\
    \ level.length - 1) === \")\"){\n            depth--;\n        }\n\n        if(depth\
    \ > 0){\n            output.push(depth);\n        }\n    }\n    return output;\n\
    }\n", "\tparen_string = paren_string.replace(/\\s+/g, ''); // remove all the white\
    \ spaces\n\tvar levels = paren_string.match(/\\(+\\)/g) || []; // find the matching\
    \ group of parens\n\tvar max_level = levels.length; //Store the deepest level\
    \ count in max_level\n\tvar result = []; //Store the result\n\tfor(var level =\
    \ 0; level < levels.length; level++){\n\t\tvar sub_level = levels[level].match(/[^()]*/g)\
    \ || [];\n\t\tif(sub_level.length >= max_level){\n\t\t\tmax_level = sub_level.length;\n\
    \t\t}\n\t}\n\tfor(var level = 0; level < levels.length; level++){\n\t\tvar sub_level\
    \ = levels[level].match(/[^()]*/g) || [];\n\t\tif(sub_level.length >= max_level){\n\
    \t\t\tvar index = result.length;\n\t\t\tresult.push(sub_level.length);\n\t\t\t\
    for(var i = index; i < index + max_level; i++){\n\t\t\t\tresult[i] = result[i]\
    \ + sub_level[i - index];\n\t\t\t}\n\t\t\tresult[index] = result[index] + sub_level[0];\n\
    \t\t}\n\t}\n\treturn result;\n}\n", "    var max_level = 0;\n    var nested_parens\
    \ = [];\n    var paren_level = [];\n    var open_ps = [];\n    var level = 0;\n\
    \    var ps = paren_string.trim().replace(/( +)/, ' ').split(/[ ()]+/);\n    ps.forEach(function(p){\n\
    \        var p = p.trim();\n        var open = 0;\n        if(p[0] == '('){\n\
    \            open_ps.push(open);\n            open_ps[open_ps.length-1] += 1;\n\
    \        }\n        level += open_ps.indexOf(open);\n        level -= open_ps.indexOf(0);\n\
    \        nested_parens.push(level);\n        max_level = max(max_level, level);\n\
    \    });\n    return max_level;\n}\n", "    var level_count = 0;\n    var max_level\
    \ = 0;\n    var max_level_parens = 1;\n    var parens = paren_string.replace(/[^\\\
    (\\)]/g, ' ').split(' ');\n    for (var i = 0; i < parens.length; i++){\n    \
    \    var level = 0;\n        while (parens[i] === parens[parens[i]]){\n      \
    \      level++;\n        }\n        if (level > max_level){\n            max_level\
    \ = level;\n            max_level_parens = parens[i];\n        }\n    }\n    return\
    \ max_level_parens;\n}\n", "  var max_level = 0;\n  var level = 0;\n  var parens\
    \ = [];\n  var i;\n  for (i = 0; i < paren_string.length; i++) {\n    if (paren_string[i]\
    \ === '(') {\n      parens.push(parens.length);\n    } else if (paren_string[i]\
    \ === '(') {\n      level = parens.length - 1;\n    } else if (paren_string[i]\
    \ === ')') {\n      parens.pop();\n    } else if (paren_string[i] === ')' && parens[parens.length\
    \ - 1] === level) {\n      level--;\n    } else {\n      console.log('Invalid\
    \ paren string: ', paren_string);\n    }\n    if (level > max_level) {\n     \
    \ max_level = level;\n    }\n  }\n  return max_level;\n}\n", "    var groups =\
    \ paren_string.split(\" \");\n    var max_depth = 0;\n\n    for(var i = 0; i <\
    \ groups.length; i++){\n        var group = groups[i];\n        var depth = parse_nested_parens_level(group);\n\
    \        max_depth = Math.max(max_depth, depth);\n    }\n\n    return max_depth;\n\
    }\n", "    var paren_stack = [];\n    var paren_depths = [];\n    var brace_stack\
    \ = [];\n    var depth = 0;\n    var brace_count = 0;\n    var paren_count = 0;\n\
    \    for(var i=0; i < paren_string.length; i++){\n        if(paren_string[i]==')'){\n\
    \            paren_stack.push(brace_count);\n            paren_depths.push(brace_count);\n\
    \            depth = paren_depths[paren_depths.length-1] + 1;\n            brace_count\
    \ = 0;\n        }\n        else if(paren_string[i]==')'){\n            brace_count\
    \ = paren_stack.pop();\n            paren_depths.pop();\n        }\n        else\
    \ if(paren_string[i]=='('){\n            brace_count += 1;\n        }\n      \
    \  else{\n            depth += 1;\n        }\n    }\n    return paren_depths;\n\
    }\n", "\tlet paren_stack = [];\n\tlet paren_count = 0;\n\tfor(let i = 0; i<paren_string.length;i++){\n\
    \t\tlet char = paren_string[i];\n\t\tif(char == ')'){\n\t\t\tlet last_index =\
    \ paren_stack.length - 1;\n\t\t\tif(paren_count > 0){\n\t\t\t\tlet last_item =\
    \ paren_stack[last_index];\n\t\t\t\tif(paren_count > last_item.count){\n\t\t\t\
    \t\tlast_item.count = paren_count;\n\t\t\t\t\tlast_item.index = i;\n\t\t\t\t}\n\
    \t\t\t\telse {\n\t\t\t\t\tif(last_item.index != i){\n\t\t\t\t\t\tparen_stack.push(last_item);\n\
    \t\t\t\t\t\tparen_count = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\
    \t\t\tparen_count++;\n\t\t\t\tlet last_item = paren_stack[last_index];\n\t\t\t\
    \tlast_item.count = paren_count;\n\t\t\t\tlast_item.index = i;\n\t\t\t\tparen_stack.push(last_item);\n\
    \t\t\t}\n\t\t}\n\t\telse if(char == '('){\n\t\t\tparen_count++;\n\t\t}\n\t\telse\
    \ {\n\t\t\tlet last_index = paren_stack.length - 1;\n\t\t\tif(paren_count > 0){\n\
    \t\t\t\tlet last_item = paren_stack[last_index];\n\t\t\t\tif(paren_count > last_item.count){\n\
    \t\t\t\t\tlast_item.count = paren_count;\n\t\t\t\t\tlast_item.index = i;\n\t\t\
    \t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(last_item.index != i){\n\t\t\t\t\t\tparen_stack.push(last_item);\n\
    \t\t\t\t\t\tparen_count = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\
    return paren_stack;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
