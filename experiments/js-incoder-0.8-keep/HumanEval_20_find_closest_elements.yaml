name: HumanEval_20_find_closest_elements
language: js
prompt: "//From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n// other and return them in order (smaller number,\
  \ larger number).\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
  // (2.0, 2.2)\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n//\
  \ (2.0, 2.0)\nfunction find_closest_elements(numbers){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = find_closest_elements;\n  assert.deepEqual(candidate([1.0, 2.0, 3.9, 4.0, 5.0,\
  \ 2.2]),[3.9, 4.0]);\n  assert.deepEqual(candidate([1.0, 2.0, 5.9, 4.0, 5.0]),[5.0,\
  \ 5.9]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),[2.0, 2.2]);\n\
  \  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),[2.0, 2.0]);\n  assert.deepEqual(candidate([1.1,\
  \ 2.2, 3.1, 4.1, 5.1]),[2.2, 3.1]);\n}\n\ntest();"
completions: ["    let minDiff = Number.MAX_VALUE;\n    let min = Number.MAX_VALUE;\n\
    \    let max = Number.MIN_VALUE;\n    let closest = [];\n    let i = 0;\n    while(i\
    \ < numbers.length){\n        let diff = Math.abs(numbers[i] - numbers[(i+1)%numbers.length]);\n\
    \        if(diff < minDiff){\n            min = numbers[i];\n            minDiff\
    \ = diff;\n            closest.push(numbers[i]);\n        }\n        else if(diff\
    \ > minDiff){\n            max = numbers[i];\n            minDiff = diff;\n  \
    \          closest.push(numbers[i]);\n        }\n        i++;\n    }\n    if(min\
    \ == Number.MAX_VALUE && max == Number.MIN_VALUE){\n        return [closest[0],\
    \ closest[1]];\n    }\n    else if(min == Number.MAX_VALUE){\n        return closest.reverse();\n\
    \    }\n    else{\n        return closest;\n    }\n}\n", "  var smallest_diff;\n\
    \  for(var i=numbers.length-1; i>=0; i--){\n    var diff = numbers[i]-numbers[i-1];\n\
    \    if(smallest_diff===undefined||diff<smallest_diff){\n      smallest_diff =\
    \ diff;\n    }\n  }\n  if(smallest_diff===undefined){\n    return(undefined);\n\
    \  }\n  return [numbers[numbers.length-2], numbers[numbers.length-1]];\n}\n",
  "  // Get the middle point\n  var m = (numbers.length - 1) * 0.5;\n  var mid = Math.round(m)\
    \ + 0.5;\n\n  // Calculate squared distance from middle point\n  var distances\
    \ = numbers.map(function (x) {\n    return Math.pow((x - mid), 2);\n  });\n  //\
    \ Sort distances from middle point\n  distances.sort(function(a,b) { return a\
    \ - b; });\n  // Get middle point\n  var middle = Math.round(distances.slice(0,\
    \ m).reduce(function(x, y) { return x + y; })) + 0.5;\n\n  // Return two numbers\
    \ in order of the closest ones\n  return numbers.slice(m).sort(function (a, b)\
    \ {\n    return Math.abs(a - middle) - Math.abs(b - middle);\n  });\n}\n", " \
    \   numbers.sort(function(a, b){\n        return a - b;\n    });\n    var l =\
    \ numbers.length - 1;\n    if (l < 2){\n        return numbers[l];\n    }\n  \
    \  var n1 = numbers[l];\n    var n2 = numbers[0];\n    var delta1 = Math.abs(n1\
    \ - n2);\n    var delta2 = Math.abs(n1 - numbers[l - 1]);\n    if (delta1 < delta2){\n\
    \        return n1;\n    }\n    return n2;\n}\n", "\tvar numbers_sorted_array=numbers.slice().sort(function(a,\
    \ b){return a-b;}); //Sort the given list ascending\n\tvar smaller_index=0, larger_index=numbers.length-1,\
    \ closest=[], current_element=numbers[0];\n\tfor(var index=1; index<numbers.length;\
    \ index++){\n\t\tvar difference=numbers[index];\n\t\twhile(current_element<difference){\n\
    \t\t\tcurrent_element+=numbers_sorted_array[smaller_index];\n\t\t\tif(smaller_index==larger_index){\n\
    \t\t\t\tcurrent_element=difference;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsmaller_index++;\n\
    \t\t}\n\t\twhile(current_element>difference){\n\t\t\tcurrent_element-=numbers_sorted_array[larger_index];\n\
    \t\t\tif(smaller_index==larger_index){\n\t\t\t\tcurrent_element=difference;\n\t\
    \t\t\tbreak;\n\t\t\t}\n\t\t\tlarger_index--;\n\t\t}\n\t\tclosest.push(current_element);\n\
    \t}\n\treturn closest;\n}\n", "\tvar sorted_numbers = numbers.slice().sort(function(a,\
    \ b){\n\t\treturn a - b;\n\t});\n\n\tvar low = sorted_numbers[0];\n\tvar high\
    \ = sorted_numbers[sorted_numbers.length - 1];\n\twhile(low != high){\n\t\tvar\
    \ mid = Math.floor((low + high) / 2);\n\t\tif(sorted_numbers[mid] < low){\n\t\t\
    \tlow = mid;\n\t\t}\n\t\telse{\n\t\t\thigh = mid;\n\t\t}\n\t}\n\treturn [low,\
    \ high];\n}\n", "\tvar closest_element_index = 0;\n\tvar closest_element_dist\
    \ = 0;\n\tvar closest_element = numbers[0];\n\n\tfor (var i = 1; i < numbers.length;\
    \ i++){\n\t\tvar current_element = numbers[i];\n\n\t\tif (current_element < numbers[closest_element_index]){\n\
    \t\t\tclosest_element_index = i;\n\t\t\tclosest_element_dist = current_element;\n\
    \t\t}\n\n\t\tif (current_element > numbers[closest_element_index]){\n\t\t\tclosest_element_index\
    \ = 0;\n\t\t\tclosest_element_dist = current_element;\n\t\t}\n\t}\n\n\treturn\
    \ [closest_element_dist, numbers[closest_element_index]];\n}\n", "    var results\
    \ = [],\n        smallest = Number.MAX_VALUE,\n        biggest = Number.MIN_VALUE,\n\
    \        numbers_len = numbers.length,\n        i;\n\n    for (i = 0; i < numbers_len;\
    \ i++){\n        if (numbers[i] < smallest){\n            smallest = numbers[i];\n\
    \        }\n        if (numbers[i] > biggest){\n            biggest = numbers[i];\n\
    \        }\n    }\n\n    for (i = 0; i < numbers_len; i++){\n        if (numbers[i]\
    \ < biggest && numbers[i] >= smallest){\n            results.push(numbers[i]);\n\
    \        }\n        if (numbers[i] > biggest && numbers[i] <= smallest){\n   \
    \         results.push(numbers[i]);\n        }\n    }\n\n    results.sort(function(a,\
    \ b){return a - b});\n    return results;\n}\n", "    var a = numbers.slice(0);\n\
    \    a.sort(function(x,y){return x - y});\n    return a[Math.floor(Math.sqrt(a.length))];\n\
    }\n", "  numbers.sort(function(a, b){return a-b;});\n  for (var i = 0; i < numbers.length-1;\
    \ i++){\n    if (numbers[i] + numbers[i+1] > numbers[i+1]){\n      return [numbers[i],\
    \ numbers[i+1]];\n    }\n  }\n  return [numbers[numbers.length-1], numbers[0]];\n\
    }\n", "    // We have to make sure there's at least one number so we can compare\
    \ them.\n    if (numbers.length < 2)\n        numbers = [numbers[0], numbers[0]];\n\
    \n    // Find the smallest number in the array (we'll start with it)\n    var\
    \ smallest_num = numbers[0];\n    var smallest_num_distance = null;\n\n    for\
    \ (var i = 1; i < numbers.length; i++){\n        if (numbers[i] > smallest_num){\n\
    \            smallest_num = numbers[i];\n            smallest_num_distance = null;\n\
    \        }\n        else if (numbers[i] < smallest_num){\n            // This\
    \ is the new smallest number we've found so far.\n            smallest_num_distance\
    \ = numbers[i];\n            smallest_num = numbers[i];\n        }\n    }\n\n\
    \    // Now we've found the smallest number. Let's compare it to every other number\n\
    \    // to find the two closest. We'll start with the second one we have.\n  \
    \  var closest_1 = smallest_num;\n    var closest_1_distance = null;\n    var\
    \ closest_2 = smallest_num;\n    var closest_2_distance = null;\n\n    for (var\
    \ i = 1; i < numbers.length; i++){\n        // If we've found a new smallest number\
    \ then save the distance to it.\n        if (closest_1_distance == null)\n   \
    \         closest_1_distance = numbers[i] - smallest_num;\n        else if(closest_2_distance\
    \ == null)\n            closest_2_distance = numbers[i] - smallest_num;\n\n  \
    \      // Check if we're closer to the second number.\n        if (closest_1_distance\
    \ > closest_2_distance){\n            closest_1 = smallest_num;\n            closest_2\
    \ = smallest_num;\n        }\n        else if (closest_1_distance < closest_2_distance){\n\
    \            closest_2 = smallest_num;\n        }\n        else\n            closest_1\
    \ = smallest_num;\n    }\n\n    // Return the two numbers in order of the distance\
    \ to the smallest.\n    return [closest_1, closest_2];\n}\n", "\t\n\t//If there\
    \ is only 1 element return it\n\tif(numbers.length == 1)\n\t\treturn numbers;\n\
    \t\n\t//Get two closest numbers from given numbers\n\tvar smallest = Math.min.apply(null,\
    \ numbers);\n\tvar largest = Math.max.apply(null, numbers);\n\tvar result = [];\n\
    \t\n\t//If two numbers are close, return them in order\n\tif(smallest == largest)\n\
    \t\treturn [ smallest, smallest ];\n\t\n\tfor(var i = numbers.length-1; i >= 0;\
    \ i--){\n\t\tvar closest = Math.abs(smallest - numbers[i]);\n\t\tif(closest <\
    \ Math.abs(largest - numbers[i]))\n\t\t\tresult.unshift(numbers[i]);\n\t\t\n\t\
    \tclosest = Math.abs(smallest - numbers[i]);\n\t\tif(closest == Math.abs(largest\
    \ - numbers[i]))\n\t\t\tresult.unshift(numbers[i]);\n\t}\n\t\n\treturn result;\n\
    }\n", "\tlet closest_smaller = numbers[0]\n\tlet closest_larger = numbers[0]\n\
    \t\n\tfor(let i = 1; i < numbers.length; i++){\n\t\tif(numbers[i] < closest_smaller){\n\
    \t\t\tclosest_smaller = numbers[i]\n\t\t}\n\t\telse if(numbers[i] > closest_larger){\n\
    \t\t\tclosest_larger = numbers[i]\n\t\t}\n\t}\n\treturn [closest_smaller, closest_larger]\n\
    }\n", "  var smallest_difference = Number.MAX_VALUE;\n  var smallest_difference_index\
    \ = 0;\n  var smallest_number = numbers[0];\n  var second_smallest_number = numbers[1];\n\
    \  var difference;\n  var i;\n  for(i=0;i<numbers.length;i++){\n    difference\
    \ = numbers[i] - smallest_number;\n    if(smallest_difference_index === 0){\n\
    \      smallest_difference = difference;\n      smallest_difference_index = i;\n\
    \      smallest_number = numbers[i];\n      continue;\n    } else if(difference\
    \ < smallest_difference){\n      smallest_difference = difference;\n      smallest_difference_index\
    \ = i;\n      smallest_number = numbers[i];\n    } else if(difference > smallest_difference\
    \ && i !== smallest_difference_index){\n      second_smallest_number = smallest_number;\n\
    \      smallest_difference = difference;\n      smallest_difference_index = i;\n\
    \      smallest_number = numbers[i];\n    }\n  }\n  return [smallest_number, second_smallest_number];\n\
    }\n", "    var smallest = Math.min(numbers[0], numbers[1]);\n    var largest =\
    \ Math.max(numbers[0], numbers[1]);\n    return smallest+\",\"+largest;\n}\n",
  "\tvar smallest, largest;\n\tvar best_ones = [];\n\tfor(var i = 1; i < numbers.length;\
    \ i++){\n\t\tvar d = Math.abs(numbers[i] - numbers[i - 1]);\n\t\tif(d < smallest){\n\
    \t\t\tsmallest = d;\n\t\t\tbest_ones = [numbers[i - 1]];\n\t\t}else if(smallest\
    \ < d){\n\t\t\tbest_ones.push(numbers[i - 1]);\n\t\t}\n\t\tif(largest < d){\n\t\
    \t\tlargest = d;\n\t\t}\n\t}\n\tif(smallest === undefined){\n\t\treturn [numbers[0]];\n\
    \t}\n\tbest_ones.push(numbers[numbers.length - 1]);\n\tbest_ones.push(numbers[0]);\n\
    \treturn best_ones;\n}\n", "  var distances = [];\n  var smallest;\n  var closest;\n\
    \  var smallest_distance;\n  var closest_distance;\n  var i;\n\n  for(i = 0; i\
    \ < numbers.length; i++){\n    smallest = numbers[i];\n    smallest_distance =\
    \ i;\n    for(j = i + 1; j < numbers.length; j++){\n      if(numbers[j] < smallest){\n\
    \        smallest = numbers[j];\n        smallest_distance = j;\n      }\n   \
    \ }\n    distances.push(smallest_distance);\n  }\n\n  closest = [];\n  closest_distance\
    \ = 0;\n\n  for(i = 0; i < numbers.length; i++){\n    smallest = numbers[i];\n\
    \    smallest_distance = distances[i];\n    for(j = i + 1; j < numbers.length;\
    \ j++){\n      if(numbers[j] == smallest){\n        closest_distance = smallest_distance;\n\
    \        break;\n      }\n      if(numbers[j] < smallest){\n        smallest_distance\
    \ = distances[j];\n        smallest = numbers[j];\n      }\n    }\n    if(closest_distance\
    \ < smallest_distance){\n      closest = [smallest, smallest_distance];\n    \
    \  closest_distance = smallest_distance;\n    }\n  }\n\n  return closest;\n}\n",
  "    \n    //Make sure numbers is at least of length 2\n    if(numbers.length <\
    \ 2) return [];\n\n    //Find the two closest numbers to each other\n    var closest_to_one\
    \ = Math.min.apply(Math, numbers);\n    var closest_to_two = Math.max.apply(Math,\
    \ numbers);\n\n    //Return the two numbers in order\n    return [closest_to_one,\
    \ closest_to_two];\n};\n", "  let numbers = numbers.map((n) => [n, n]);\n\n  numbers.sort((n1,\
    \ n2) => {\n    return n1[0] - n2[0];\n  });\n\n  return numbers[0];\n}\n", " \
    \   numbers = numbers.sort((a,b) => a - b);\n    let low = numbers[0];\n    let\
    \ high = numbers[numbers.length-1];\n    if (numbers[0] > numbers[numbers.length-1])\
    \ {\n        return [high, low];\n    }\n    else {\n        return [low, high];\n\
    \    }\n}\n", "    var smallest = numbers[0];\n    var largest = numbers[0];\n\
    \n    for(var i = 0; i < numbers.length; i++){\n        if(numbers[i] > largest){\n\
    \            largest = numbers[i];\n        }\n        else if(numbers[i] < smallest){\n\
    \            smallest = numbers[i];\n        }\n    }\n\n    return [smallest,\
    \ largest];\n}\n\nmodule.exports = find_closest_elements;\n\n},{}],35:[function(require,module,exports){\n\
    'use strict';\n\nvar defaults = require('./defaults');\n", "  let smallest = Math.min(...numbers);\n\
    \  let largest = Math.max(...numbers);\n  let range = largest-smallest;\n  numbers.sort((a,b)\
    \ => b-a);\n  return [smallest+range/2, smallest+range/2];\n}\n</cell>\n<cell>",
  "\tnumbers = numbers.sort();\n\tvar min1 = numbers[0];\n\tvar min2 = numbers[0];\n\
    \tfor(var i = 1; i < numbers.length; i++){\n\t\tvar d = Math.abs(min1 - numbers[i]);\n\
    \t\tif(d < Math.abs(min2 - numbers[i])){\n\t\t\tmin2 = min1;\n\t\t\tmin1 = numbers[i];\n\
    \t\t}else{\n\t\t\tmin2 = numbers[i];\n\t\t}\n\t}\n\treturn [min1, min2];\n}\n\n",
  "\tvar closest_numbers = [];\n\tvar smallest_number = numbers[0];\n\tvar largest_number\
    \ = numbers[0];\n\tfor(var i = 1; i < numbers.length; i++){\n\t\tvar current_number\
    \ = numbers[i];\n\t\tif(current_number < smallest_number){\n\t\t\tsmallest_number\
    \ = current_number;\n\t\t}\n\t\tif(current_number > largest_number){\n\t\t\tlargest_number\
    \ = current_number;\n\t\t}\n\t}\n\tclosest_numbers.push(smallest_number);\n\t\
    closest_numbers.push(largest_number);\n\treturn closest_numbers;\n}\n", "    for(let\
    \ i in numbers){\n        if(!numbers.hasOwnProperty(i)) continue;\n        let\
    \ diff = numbers[i] - numbers[numbers.length - 1];\n        if(diff) {\n     \
    \       numbers.push(numbers[numbers.length - 1]);\n            numbers.push(numbers[i]);\n\
    \        }\n    }\n    return numbers;\n}\n", "\tvar min_distance = Number.MAX_VALUE;\n\
    \tvar min_number = numbers[0];\n\t\n\tvar numbers_to_sort = numbers.slice();\n\
    \tnumbers_to_sort.sort();\n\t\n\tvar previous_number = numbers_to_sort[0];\n\t\
    var previous_distance = distance_between(previous_number, min_number);\n\tvar\
    \ current_number = numbers_to_sort[1];\n\tvar current_distance = distance_between(current_number,\
    \ min_number);\n\n\t//If there are no more numbers to check return min_number\n\
    \twhile(numbers_to_sort.length > 2){\n\t\tvar next_number = numbers_to_sort[numbers_to_sort.length\
    \ - 1];\n\t\tvar next_distance = distance_between(next_number, min_number);\n\t\
    \t\n\t\tif(previous_distance >= current_distance){\n\t\t\tbreak;\n\t\t}\n\t\t\n\
    \t\tif(current_distance < min_distance){\n\t\t\tmin_number = current_number;\n\
    \t\t\tmin_distance = current_distance;\n\t\t}\n\n\t\tcurrent_number = next_number;\n\
    \t\tcurrent_distance = next_distance;\n\t\t\n\t\tnumbers_to_sort.pop();\n\t}\n\
    \t\n\treturn min_number;\n}\n", "\tif (numbers.length < 2) return;\n\t\n\tvar\
    \ closest_index = 0;\n\tvar closest_distance = Math.abs(numbers[0] - numbers[1]);\n\
    \tfor (var i = 1; i < numbers.length; i++){\n\t\tvar distance = Math.abs(numbers[i]\
    \ - numbers[closest_index]);\n\t\tif (distance < closest_distance){\n\t\t\tclosest_index\
    \ = i;\n\t\t\tclosest_distance = distance;\n\t\t}\n\t}\n\treturn [numbers[closest_index],\
    \ numbers[closest_index + 1]];\n}\n\n", "\tlet len = numbers.length;\n\tif(len\
    \ < 2) return false;\n\tlet minDiff = numbers[1] - numbers[0];\n\tfor(let i =\
    \ len-1; i >= 0; i--){\n\t\tlet diff = numbers[i] - numbers[i+1];\n\t\tif(diff\
    \ < minDiff){\n\t\t\tminDiff = diff;\n\t\t}\n\t}\n\treturn [numbers[len-1], numbers[len-3]];\n\
    }\n\n", "  var min_diff = Number.MAX_VALUE;\n  var closest_index = -1;\n  for(var\
    \ i=0; i< numbers.length; i++){\n    var diff = abs(numbers[i] - numbers[closest_index]);\n\
    \    if(diff < min_diff){\n      min_diff = diff;\n      closest_index = i;\n\
    \    }\n  }\n  return [numbers[closest_index], numbers[closest_index+1]];\n}\n",
  "\tvar n = numbers.length;\n\tif(n<2) return numbers;\n\tvar sorted_numbers = numbers.slice();\n\
    \tsorted_numbers.sort();\n\tvar diffs = [];\n\tfor(var i=0; i<n-1; i++){\n\t\t\
    var diff = sorted_numbers[i]-sorted_numbers[i+1];\n\t\tdiffs.push(diff);\n\t}\n\
    \tvar closest_numbers = sorted_numbers.slice(0);\n\tvar closest_diff = 0;\n\t\
    for(var i=0; i<n-1; i++){\n\t\tvar diff = Math.abs(diffs[i]);\n\t\tif(diff<closest_diff){\n\
    \t\t\tclosest_diff=diff;\n\t\t\tclosest_numbers[i] = sorted_numbers[i];\n\t\t\
    }\n\t}\n\treturn closest_numbers;\n}\n", "    var smallestNumber = numbers.shift();\n\
    \    var largestNumber = numbers.pop();\n    var closestNumbers = [];\n\n    numbers.sort(function(a,\
    \ b){\n        return Math.pow(a-b,2);\n    });\n\n    for(var i = 0; i < numbers.length;\
    \ i++){\n        var element = numbers[i];\n        if(element < smallestNumber\
    \ ){\n            smallestNumber = element;\n        }\n        else if(element\
    \ > largestNumber ){\n            largestNumber = element;\n        }\n      \
    \  else{\n            closestNumbers.push(element);\n        }\n    }\n\n    return\
    \ {\n        smaller: smallestNumber,\n        larger: largestNumber,\n      \
    \  close: closestNumbers\n    };\n}", "\tnumbers.sort(function(a, b){\n\t\treturn\
    \ Math.abs(b - a);\n\t});\n\treturn numbers;\n}\n\t", "  var biggest = numbers[0];\n\
    \  var smallest = numbers[0];\n  for (var i = 0; i < numbers.length; i++){\n \
    \   if (numbers[i] < smallest){\n      smallest = numbers[i];\n    }\n    if (numbers[i]\
    \ > biggest){\n      biggest = numbers[i];\n    }\n  }\n  return [biggest, smallest];\n\
    }\n", "\tconst min = Math.min(...numbers);\n\tconst max = Math.max(...numbers);\n\
    \tconst mid = Math.floor(numbers.length / 2);\n\treturn [\n\t\tmin > numbers[mid]\n\
    \t\t\t? numbers[mid]\n\t\t\t: max\n\t\t\t? max\n\t\t\t: mid\n\t];\n}\n", "   \
    \ var min_difference = numbers[0] - numbers[1];\n    var smallest;\n    var closest;\n\
    \n    for(var i=1; i<numbers.length; i++){\n        var difference = numbers[i]\
    \ - numbers[i-1];\n        if(difference < 0){\n            smallest = numbers[i-1];\n\
    \            closest = numbers[i];\n        }else{\n            if(difference\
    \ < min_difference){\n                smallest = numbers[i-1];\n             \
    \   closest = numbers[i];\n            }else{\n                if(difference ==\
    \ min_difference){\n                    if(numbers[i-1] == numbers[i]){\n    \
    \                    closest = numbers[i-1];\n                        smallest\
    \ = numbers[i-1];\n                    }\n                }\n            }\n \
    \       }\n    }\n    return {\n        closest: closest,\n        smallest: smallest\n\
    \    };\n}\n", "    var smallest = -Infinity,\n        closest;\n    _.each(numbers,\
    \ function(num){\n        if (smallest < num){\n            smallest = num;\n\
    \            closest = [num, smallest];\n        }\n    });\n    _.each(numbers,\
    \ function(num){\n        if (closest && Math.abs(closest - num) < 0.1){\n   \
    \         closest = [num, num];\n        }\n    });\n    return closest;\n}\n",
  "\tvar arr = [].concat(numbers);\n\tvar min_diff, min_diff_idx, min_diffs;\n\tvar\
    \ prev_min_diff = Number.MAX_VALUE;\n\t\n\tmin_diffs = arr.map(function(val, idx){\n\
    \t\treturn Math.abs(val - arr[0]);\n\t});\n\tmin_diffs.forEach(function(val, idx){\n\
    \t\tmin_diff = val;\n\t\tmin_diff_idx = idx;\n\t});\n\t\n\tmin_diffs = arr.map(function(val,\
    \ idx){\n\t\treturn Math.abs(val - arr[min_diff_idx]);\n\t});\n\tmin_diffs.forEach(function(val,\
    \ idx){\n\t\tif(val < min_diff){\n\t\t\tmin_diff = val;\n\t\t\tmin_diff_idx =\
    \ idx;\n\t\t}\n\t});\n\t\n\treturn [arr[min_diff_idx], arr[min_diff_idx]];\n}\n\
    \n", "    if (numbers.length < 2) return numbers;\n    let minimum = Math.min.apply(null,\
    \ numbers),\n        maximum = Math.max.apply(null, numbers);\n    let closest_to_min\
    \ = numbers[0] - minimum;\n    let closest_to_max = numbers[0] - maximum;\n  \
    \  return [ \n        closest_to_min, \n        Math.max(minimum, closest_to_max)\n\
    \    ];\n}\n\n", "    numbers = numbers.sort(sortNumber);\n    for(var i = numbers.length\
    \ - 1; i > 0; i--){\n        var closest_to = Math.abs(numbers[i] - numbers[i\
    \ - 1]);\n        if(closest_to == 0){\n            throw new Error(\"No elements\
    \ found\");\n        }\n        if(closest_to > 1 || Math.abs(numbers[i - 1] -\
    \ numbers[i / 2]) < closest_to){\n            return [i, numbers[i - 1]];\n  \
    \      }\n    }\n    return [1, numbers[numbers.length - 1]];\n}\n", "    console.log(\"\
    Finding closest numbers to \" + numbers.join(\", \"));\n    \n    var lowest =\
    \ Math.min(numbers);\n    var highest = Math.max(numbers);\n    var low_num =\
    \ 0;\n    var high_num = 0;\n    var mid = 0;\n    var mid_num = 0;\n    var mid_diff\
    \ = lowest - highest;\n    \n    //Loop through the numbers looking for the closer\n\
    \    for(var i = 0; i < numbers.length; i++){\n        if(numbers[i] === lowest){\n\
    \            low_num = i;\n        } else if(numbers[i] === highest){\n      \
    \      high_num = i;\n        } else {\n            //Get a median point between\
    \ the current minimum and maximum\n            mid = numbers[i] + (mid_diff /\
    \ 2);\n            //If the median is further away from the current minimum or\
    \ maximum\n            if(((mid - lowest) > 0) || ((mid - highest) > 0)){\n  \
    \              //Reset the difference and current minimum & maximum numbers to\
    \ the current median value\n                mid_num = mid;\n                mid_diff\
    \ = numbers[i] - mid;\n            } else {\n                //If they're in the\
    \ right range\n                if(mid_num < mid && mid_num > lowest){\n      \
    \              mid_num = mid;\n                    mid_diff = mid - lowest;\n\
    \                } else if (mid_num > mid && mid_num < highest){\n           \
    \         mid_num = mid;\n                    mid_diff = mid - highest;\n    \
    \            }\n            }\n        }\n    }\n    console.log(\"Lowest number\
    \ found is \" + lowest);\n    console.log(\"Highest number found is \" + highest);\n\
    \    \n    //Return the numbers in order from closest to furthest\n    var closest\
    \ = [];\n    closest[0] = lowest;\n    closest[1] = highest;\n    \n    console.log(\"\
    Returning \" + closest[0] + \" and \" + closest[1] + \" from \" + numbers.join(\"\
    , \"));\n    return closest;\n}", "    for(var i = 0; i < numbers.length; i++){\n\
    \        for(var j = 0; j < numbers.length; j++){\n            if(i !== j){\n\
    \                var d = distance_squared(numbers[i],numbers[j]);\n          \
    \      if(d < distance_squared(numbers[i],numbers[j+1])){\n                  \
    \  return {\n                        number1: numbers[i],\n                  \
    \      number2: numbers[j],\n                        distance: d,\n          \
    \              index: j\n                    };\n                }\n         \
    \   }\n        }\n    }\n    return {\n        number1: numbers[0],\n        number2:\
    \ numbers[numbers.length-1],\n        distance: distance_squared(numbers[0],numbers[numbers.length-1]),\n\
    \        index: numbers.length - 1\n    };\n}", "\t// Convert to an array of numbers\
    \ if it is not already\n\tif(!is_number(numbers[0])){\n\t\tnumbers = numbers.map(Number);\n\
    \t}\n\t// Sort from smallest to largest\n\tnumbers.sort(sort_numbers);\n\t// Return\
    \ the closest two numbers that match\n\tvar closest_pair = (numbers[0] < numbers[1])\
    \ ? numbers[0] : numbers[1];\n\treturn [numbers[numbers.length - 1], closest_pair];\n\
    }\n", "  if (numbers.length === 0) return [];\n\n  var best_two = numbers[0];\n\
    \  var best_one = numbers[0];\n  var best_difference = Math.abs(best_one - best_two);\n\
    \n  numbers.forEach(function(item){\n    var difference = Math.abs(item - best_one);\n\
    \n    if (best_difference >= difference){\n      best_difference = difference;\n\
    \      best_two = item;\n      best_one = item;\n    } else {\n      best_two\
    \ = best_one;\n      best_one = item;\n    }\n  })\n\n  return [best_one, best_two];\n\
    }\n", "  var bestDistance = 1e9;\n  var bestNumbers = [];\n  \n  for(var i = numbers.length\
    \ - 1, sum = 0; i >= 0; i--){\n    sum += numbers[i];\n    \n    var distance\
    \ = Math.abs(sum - numbers[i - 1]);\n    if (distance < bestDistance){\n     \
    \ bestDistance = distance;\n      bestNumbers = [numbers[i]];\n    } else if (distance\
    \ === bestDistance){\n      bestNumbers.push(numbers[i]);\n    }\n  }\n  \n  return\
    \ bestNumbers;\n}\n", "\t\n\t// Sort the numbers so that smallest is first\n\t\
    numbers = numbers.sort((a,b) => a-b);\n\t\n\t// Find two numbers in numbers that\
    \ is closest to each other\n\tlet closest_1 = numbers[0];\n\tlet closest_2 = numbers[0];\n\
    \tfor(let i = 1; i < numbers.length; i++){\n\t\t\n\t\t// If the next number is\
    \ too close to the previous number, replace it\n\t\tif(Math.abs(numbers[i] - closest_1)\
    \ < Math.abs(numbers[i] - closest_2)){\n\t\t\tclosest_1 = numbers[i];\n\t\t} else\
    \ {\n\t\t\tclosest_2 = numbers[i];\n\t\t}\n\t}\n\t\n\t// Return the two numbers\
    \ in order\n\treturn [closest_1, closest_2];\n}", "\tvar smallest = Math.min(numbers[0],\
    \ numbers[1]);\n\tvar largest = Math.max(numbers[0], numbers[1]);\n\tvar result\
    \ = [];\n\tif(smallest == largest){\n\t\treturn [smallest, smallest];\n\t}\n\t\
    for(var i = 2; i < numbers.length; i++){\n\t\tvar x = numbers[i];\n\t\tif(x !=\
    \ smallest && x != largest){\n\t\t\tvar x2 = numbers[i];\n\t\t\tif(x2 < smallest\
    \ && x > largest){\n\t\t\t\tx2 = largest;\n\t\t\t\tx2 = x;\n\t\t\t}\n\t\t\tif(x2\
    \ > smallest && x < largest){\n\t\t\t\tx2 = smallest;\n\t\t\t\tx2 = x;\n\t\t\t\
    }\n\t\t\tif(Math.abs(x2 - x) < Math.abs(smallest - largest)){\n\t\t\t\treturn\
    \ [smallest, x2];\n\t\t\t}\n\t\t}\n\t}\n\treturn [smallest, largest];\n}\nexports.find_closest_elements\
    \ = find_closest_elements;\n", "  // Find the closest number\n  var closestNum\
    \ = numbers[0]\n  var closestDiff = numbers[0]\n  var closestDistance = numbers[0]\n\
    \  for(var i = 1; i < numbers.length; i++){\n    var thisDiff = Math.abs(numbers[i]\
    \ - closestNum)\n    if (thisDiff < closestDiff){\n      closestNum = numbers[i]\n\
    \      closestDiff = thisDiff\n      closestDistance = i\n    }\n  }\n\n  // Sort\
    \ and return it from the closest to the furthest\n  numbers.sort(function(a, b){\n\
    \    return a - b\n  })\n  var returnArray = []\n  for (var i = 0; i < closestDistance;\
    \ i++){\n    returnArray.push(numbers[i])\n  }\n  returnArray.push(closestNum)\n\
    \  return returnArray\n}\n", "  var min_number = numbers[0]\n  var max_number\
    \ = numbers[0]\n  var closest_number = numbers[0]\n  var closest_index = 0\n \
    \ for(var i = 1; i < numbers.length; i++){\n    if(numbers[i] < min_number){\n\
    \      min_number = numbers[i]\n      closest_index = i\n    }\n    if(numbers[i]\
    \ > max_number){\n      max_number = numbers[i]\n      closest_index = i\n   \
    \ }\n    if(min_number == max_number){\n      if(Math.abs(min_number - numbers[i])\
    \ < Math.abs(max_number - numbers[i])){\n        closest_number = numbers[i]\n\
    \        closest_index = i\n      }\n    }\n  }\n  return [closest_number, numbers[closest_index]]\n\
    }", "  var i;\n  if(numbers.length === 0){\n    throw new Error(\"Can't select\
    \ an element from an empty list of numbers\");\n  }\n  for(i = 1; numbers.length\
    \ > i; i++){\n    if(numbers[i-1] > numbers[i]){\n      var t = numbers[i-1];\n\
    \      numbers[i-1] = numbers[i];\n      numbers[i] = t;\n    }\n  }\n  return\
    \ numbers;\n}", "    if(numbers.length < 2){\n        return [];\n    }\n    var\
    \ closest_first  = numbers[0];\n    var closest_second = numbers[0];\n    var\
    \ closest_second2 = numbers[0];\n    for(var i = 1; i < numbers.length; i++){\n\
    \        if(numbers[i] < closest_first){\n            closest_second = closest_first;\n\
    \            closest_second2 = closest_first;\n            closest_first = numbers[i];\n\
    \        }else if(numbers[i] > closest_second){\n            closest_second =\
    \ numbers[i];\n            closest_second2 = numbers[i];\n        }\n        if(numbers[i]\
    \ < closest_second2){\n            closest_second2 = numbers[i];\n        }\n\
    \    }\n    return [closest_first, closest_second];\n}\n", "    // first find\
    \ closest two numbers\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for (var i = 1; i < numbers.length; i++){\n        var thisNumber = numbers[i]\n\
    \        if (thisNumber < smallest && smallest != 0){\n            smallest =\
    \ thisNumber\n        } else if (thisNumber > largest && largest != 0){\n    \
    \        largest = thisNumber\n        }\n    }\n    // if no numbers found, return\
    \ 0\n    if (smallest == 0 || largest == 0){\n        return [smallest, largest]\n\
    \    }\n    // otherwise, return closest two numbers\n    var mid = Math.floor((smallest\
    \ + largest) / 2)\n    var closest = (smallest < largest) ? smallest : largest\n\
    \    if (mid == largest){\n        return [mid, mid]\n    } else if (mid == smallest){\n\
    \        return [mid - 1, mid]\n    } else {\n        return [mid - 1, mid + 1]\n\
    \    }\n}", "\tvar smallest = -Infinity;\n\tvar largest = Infinity;\n\tvar smallestIndex;\n\
    \tvar largestIndex;\n\t\n\tfor(var i = 0; i < numbers.length; i++){\n\t\tif(numbers[i]\
    \ < smallest){\n\t\t\tsmallest = numbers[i];\n\t\t\tsmallestIndex = i;\n\t\t}\n\
    \t\t\n\t\tif(numbers[i] > largest){\n\t\t\tlargest = numbers[i];\n\t\t\tlargestIndex\
    \ = i;\n\t\t}\n\t}\n\t\n\treturn [numbers[smallestIndex], numbers[largestIndex]];\n\
    }\n", "\tvar largest = numbers[0];\n\tvar smallest = numbers[0];\n\tvar found\
    \ = true;\n\tfor(var i = 1; i < numbers.length; i++){\n\t\tif((numbers[i] >= largest)\
    \ && (numbers[i] < smallest)){\n\t\t\tsmallest = numbers[i];\n\t\t} else if((numbers[i]\
    \ <= smallest) && (numbers[i] > largest)){\n\t\t\tlargest = numbers[i];\n\t\t\
    }\n\t}\n\tif(smallest === undefined){\n\t\treturn undefined;\n\t}\n\treturn [smallest,\
    \ largest];\n}\n", "\tlet min_number = numbers[0];\n\tlet max_number = numbers[0];\n\
    \tfor (let i = 0; i < numbers.length; i++){\n\t\tlet cur_number = numbers[i];\n\
    \t\tif (cur_number < min_number){\n\t\t\tmin_number = cur_number;\n\t\t}\n\t\t\
    if (cur_number > max_number){\n\t\t\tmax_number = cur_number;\n\t\t}\n\t}\n\t\
    return [min_number, max_number];\n}\n", "  // Return an empty array if only two\
    \ numbers are provided\n  if(numbers.length < 2){\n    return []\n  }\n  // Create\
    \ an empty set for storing sorted numbers and index\n  const sorted_numbers =\
    \ new Set(numbers)\n  const index = new Map()\n  // Loop over all numbers in the\
    \ sorted set\n  for (const num of sorted_numbers){\n    // If the set already\
    \ has a number with the same value, remove it and continue to next number in loop\n\
    \    if (index.has(num)){\n      sorted_numbers.delete(num)\n      continue\n\
    \    }\n    // Otherwise add it to the set and set its index in an index\n   \
    \ index.set(num, sorted_numbers.length)\n  }\n  // Return an array of the two\
    \ closest numbers\n  return [sorted_numbers.get(sorted_numbers.values().sort((a,b)\
    \ => b-a))\n    || sorted_numbers.get(sorted_numbers.values().sort((a,b) => a-b))\n\
    \    || numbers[0]]\n}\n", "\tif (numbers.length < 2){\n\t\treturn;\n\t}\n\n\t\
    var smallest = numbers[0];\n\tvar largest = numbers[0];\n\n\tfor (var i = 0; i\
    \ < numbers.length; i++){\n\t\tif (numbers[i] < smallest){\n\t\t\tsmallest = numbers[i];\n\
    \t\t}\n\t\telse if (numbers[i] > largest){\n\t\t\tlargest = numbers[i];\n\t\t\
    }\n\t}\n\n\treturn [smallest, largest];\n}\n\n", "  var smaller = numbers[0];\n\
    \  var larger = numbers[0];\n  for(var i=1; i<numbers.length; i++){\n    smaller\
    \ = Math.min(numbers[i], smaller);\n    larger = Math.max(numbers[i], larger);\n\
    \  }\n  return [smaller, larger];\n}", "\tif(!Array.isArray(numbers) || numbers.length\
    \ < 2){\n\t\treturn numbers;\n\t}\n\tvar min = Math.min.apply(Math, numbers);\n\
    \tvar max = Math.max.apply(Math, numbers);\n\tvar diff = Math.abs(min - max);\n\
    \tvar closest_numbers = [];\n\tfor(var i = 0; i < numbers.length; i++){\n\t\t\
    if(numbers[i] === min){\n\t\t\tclosest_numbers = [min];\n\t\t\treturn closest_numbers;\n\
    \t\t}\n\t\telse if(numbers[i] === max){\n\t\t\tclosest_numbers = [max];\n\t\t\t\
    return closest_numbers;\n\t\t}\n\t\telse{\n\t\t\tvar dif_val = Math.abs(numbers[i]\
    \ - min);\n\t\t\tif(dif_val > diff){\n\t\t\t\tclosest_numbers = [numbers[i]];\n\
    \t\t\t}\n\t\t\telse{\n\t\t\t\tclosest_numbers = [numbers[i]]\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn closest_numbers;\n}\n", "\tnumbers = numbers.map(function(el){\n\
    \t\treturn el - Number.EPSILON;\n\t});\n\tvar sorted = numbers.sort(function(a,\
    \ b){\n\t\treturn a - b;\n\t});\n\treturn sorted[sorted.length - 2], sorted[sorted.length\
    \ - 1];\n}\n", "\tvar best_pair = numbers[0];\n\tvar best_distance = Math.abs(best_pair[0]\
    \ - best_pair[1]);\n\tfor (var i=1; i<numbers.length; i++){\n\t\tvar pair = numbers[i];\n\
    \t\tvar distance = Math.abs(pair[0] - pair[1]);\n\t\tif (distance < best_distance){\n\
    \t\t\tbest_pair[0] = pair[0];\n\t\t\tbest_pair[1] = pair[1];\n\t\t\tbest_distance\
    \ = distance;\n\t\t}\n\t}\n\treturn best_pair;\n}\n", "    var min = numbers[0];\n\
    \    var max = numbers[1];\n    for(var i in numbers){\n        if(min > numbers[i]){\n\
    \            min = numbers[i];\n        }\n        else if(max < numbers[i]){\n\
    \            max = numbers[i];\n        }\n    }\n    return (max,min);\n}\n",
  "\tvar sortedNumbers = numbers.sort(function(a, b){return a-b});\n\tvar bestDistance\
    \ = sortedNumbers[0];\n\tvar bestElement = numbers[0];\n\n\tfor (var i = 1; i\
    \ < numbers.length; i++){\n\t\tvar newDistance = Math.abs(sortedNumbers[i] - bestDistance);\n\
    \t\tif (newDistance < bestDistance){\n\t\t\tbestDistance = newDistance;\n\t\t\t\
    bestElement = numbers[i];\n\t\t}\n\t}\n\n\treturn [bestElement, bestDistance];\n\
    }\n", "    var results = [];\n    var smallest = 0;\n    var largest = 0;\n  \
    \  var num;\n    for(var i=0; i < numbers.length; i++){\n        num = numbers[i];\n\
    \        if(smallest > num){\n            smallest = num;\n        }\n       \
    \ if(largest < num){\n            largest = num;\n        }\n    }\n    results.push(smallest);\n\
    \    results.push(largest);\n    return results;\n}\n", "    numbers = numbers.slice();\n\
    \    numbers.sort((a,b) => Math.abs(a - b));\n    var closest = []\n    while\
    \ (numbers.length >= 2){\n        closest.push(numbers[numbers.length - 1]);\n\
    \        numbers.pop();\n    }\n    if (numbers.length)\n        closest.push(numbers[0]);\n\
    \    return closest;\n}\n", "\tvar closest = numbers[0];\n\tvar smallest = numbers[0];\n\
    \tvar largest = numbers[0];\n\t\n\tfor (var i = 1; i < numbers.length; i++){\n\
    \t\tif (numbers[i] < smallest){\n\t\t\tsmallest = numbers[i];\n\t\t}\n\t\t\n\t\
    \tif (numbers[i] > largest){\n\t\t\tlargest = numbers[i];\n\t\t}\n\t\t\n\t\tif\
    \ (numbers[i] == closest){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (numbers[i] <\
    \ closest){\n\t\t\tclosest = numbers[i];\n\t\t}\n\t}\n\t\n\treturn [smallest,\
    \ largest];\n}\n", "\tvar closest = [];\n\tvar closest = numbers[0];\n\t\n\tfor(var\
    \ i = 0; i < numbers.length; i++){\n\t\tif(numbers[i] > closest){\n\t\t\tclosest\
    \ = numbers[i];\n\t\t}\n\t}\n\t\n\tfor(var i = numbers.length - 1; i >= 0; i--){\n\
    \t\tif(numbers[i] < closest){\n\t\t\tclosest = numbers[i];\n\t\t}\n\t}\n\t\n\t\
    return (closest);\n}\n", "\t\n\tif(numbers.length < 2)\n\t\treturn [];\n\t\n\t\
    numbers.sort(function(d1, d2){\n\t\t\n\t\tif(d1 < d2)\n\t\t\treturn -1;\n\t\t\
    else if(d1 > d2)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t});\n\t\n\tvar\
    \ closest = [];\n\t\n\tfor(var i = 0; i < numbers.length-1; i++){\n\t\t\n\t\t\
    if(i == 0)\n\t\t\tclosest.push(numbers[i]);\n\t\telse if(Math.abs(numbers[i] -\
    \ numbers[i-1]) <= Math.abs(numbers[i] - numbers[i+1]))\n\t\t\tclosest.push(numbers[i]);\n\
    \t\telse\n\t\t\tclosest.push(numbers[i-1]);\n\t\t\t\n\t}\n\t\n\treturn closest;\n\
    }", "  let min_diff = Number.POSITIVE_INFINITY;\n  let closest_1 = numbers[0];\n\
    \  let closest_2 = numbers[0];\n  for (let i = 1; i < numbers.length; i++){\n\
    \    let diff = numbers[i] - closest_1;\n    if (diff > min_diff){\n      min_diff\
    \ = diff;\n      closest_1 = numbers[i];\n    }\n  }\n  for (let i = 0; i < numbers.length;\
    \ i++){\n    let diff = numbers[i] - closest_2;\n    if (diff > min_diff){\n \
    \     min_diff = diff;\n      closest_2 = numbers[i];\n    }\n  }\n  return [closest_1,\
    \ closest_2];\n}", "  var smaller, larger, smallest, largest;\n  smallest = numbers[0];\n\
    \  largest = numbers[0];\n  for(var i = 1; i < numbers.length; i++){\n    if(numbers[i]\
    \ > largest && largest !== undefined){\n      largest = largest;\n    }\n    if(numbers[i]\
    \ < smallest && smallest !== undefined){\n      smallest = smallest;\n    }\n\
    \    if(numbers[i] > largest && numbers[i] < smallest || largest === undefined){\n\
    \      largest = numbers[i];\n      smallest = numbers[i];\n    }\n  }\n  return\
    \ [smallest, largest];\n}\n", "    var smallest = numbers[0]; //Initialize smallest\
    \ number to first number\n    var largest = numbers[0]; //Initialize largest number\
    \ to first number\n\n    for(var i in numbers){\n        if(numbers[i] < smallest\
    \ || (numbers[i] == smallest && numbers[i] > largest)){\n            smallest\
    \ = numbers[i];\n        }\n        else if(numbers[i] > largest){\n         \
    \   largest = numbers[i];\n        }\n    }\n\n    if(smallest == largest){\n\
    \        return (smallest, smallest); //Return only two numbers if two numbers\
    \ are identical\n    }\n\n    var closest = [smallest, largest]; //Create array\
    \ to store results\n    smallest = smallest - 0.5; //Subtract 0.5 from number\
    \ to make sure we don't compare the number with itself.\n    largest = largest\
    \ + 0.5; //Add 0.5 to number to make sure we don't compare the number with itself.\n\
    \    for(var i in numbers){\n        if(numbers[i] == smallest || numbers[i] ==\
    \ largest){\n            continue; //Skip comparing numbers if they are the number\
    \ we are currently comparing with\n        }\n\n        if(numbers[i] < smallest){\n\
    \            smallest = numbers[i];\n        }\n        else if(numbers[i] > largest){\n\
    \            largest = numbers[i];\n        }\n    }\n\n    closest[0] = smallest\
    \ + 0.5; //Make sure smallest is not rounded up by adding 0.5\n    closest[1]\
    \ = largest - 0.5; //Make sure largest is not rounded down by subtracting 0.5\n\
    \n    return (closest); //Return results\n}\n</code>\n<|/ a |>\n<| a tags=sorting,algorithm\
    \ |>\nHere's a Java implementation. Not sure if it satisfies the same requirements\
    \ as your code or not. Also not sure if it would be faster or not.\n<code>\npublic\
    \ static int[] findClosestPair(int[] numbers, int minDiff) {\n    Arrays.sort(numbers);\n\
    \    int smallestNumber = numbers[0];\n    int biggestNumber = numbers[0];\n \
    \   int smallestDistance = 0;\n    int biggestDistance = 0;\n    for (int i =\
    \ 1; i < numbers.length; i++) {\n        int currentNumber = numbers[i];\n   \
    \     int currentDistance = currentNumber - smallestNumber;\n        if (currentDistance\
    \ > minDiff) {\n            smallestDistance = currentDistance;\n            smallestNumber\
    \ = currentNumber;\n        }\n        if (currentDistance < minDiff) {\n    \
    \        biggestDistance = currentDistance;\n            biggestNumber = currentNumber;\n\
    \        }\n    }\n    int[] ret = new int[] {smallestNumber, biggestNumber};\n\
    \    return ret;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=sorting,algorithm\
    \ |>\nThis question really came up on a code review site when there was a code\
    \ that was trying to find the smallest and largest values in a given ", "  var\
    \ smallest = Math.min.apply(Math, numbers);\n  var largest = Math.max.apply(Math,\
    \ numbers);\n  return [\n    smallest,\n    largest\n  ];\n}\n\n", "\tnumbers.sort();\n\
    \tvar smaller = numbers[0];\n\tvar larger = numbers[numbers.length-1];\n\tvar\
    \ smaller_index = numbers.length-1;\n\tvar larger_index = 0;\n\tvar mid;\n\n\t\
    while (smaller_index < numbers.length && smaller_index !== larger_index) {\n\t\
    \tmid = Math.round((larger_index+smaller_index)/2);\n\t\tif (numbers[mid] < smaller)\
    \ {\n\t\t\tsmaller_index = mid;\n\t\t} else if (numbers[mid] > larger) {\n\t\t\
    \tlarger_index = mid;\n\t\t}\n\t}\n\treturn {smaller_number: smaller, larger_number:\
    \ larger};\n}", "    var smallest_difference = find_smallest_difference(numbers);\n\
    \    var smallest_number = numbers[0];\n    var second_smallest_number = numbers[1];\n\
    \n    for(var i = 0; i < numbers.length; i++){\n        if(numbers[i] - smallest_difference\
    \ < second_smallest_number){\n            second_smallest_number = smallest_difference;\n\
    \            smallest_number = numbers[i];\n        }else{\n            smallest_difference\
    \ = find_smallest_difference(numbers);\n            smallest_number = numbers[i];\n\
    \        }\n    }\n\n    return [smallest_number, second_smallest_number];\n}\n",
  "  // Create a table of distance between numbers and sort the table.\n  let distances\
    \ = numbers.map(function (x) {\n    return Math.abs(x - numbers[0])\n  })\n  distances.sort(function\
    \ (a, b) {\n    return a - b\n  })\n  // Get the two numbers from this list that\
    \ correspond to the two closest distances.\n  let two_closest_numbers = distances.map(function\
    \ (x) {\n    return distances[0] < x ? numbers[0] : numbers[1]\n  })\n  return\
    \ two_closest_numbers\n}\n", "    let closest_1 = [];\n    let closest_2 = [];\n\
    \    let closest_diff;\n    let closest_number = numbers[0];\n\n    for (let i\
    \ = 1; i < numbers.length; i++){\n        closest_diff = Math.abs(closest_number\
    \ - numbers[i]);\n\n        if (closest_diff <= closest_1){\n            closest_1.push(closest_number);\n\
    \            closest_2.push(numbers[i]);\n        }\n        else if (closest_diff\
    \ <= closest_2){\n            closest_2.push(closest_number);\n            closest_1.push(numbers[i]);\n\
    \        }\n        else{\n            if (closest_2 < closest_1){\n         \
    \       closest_2.push(closest_number);\n                closest_1.push(numbers[i]);\n\
    \            }\n            else{\n                closest_1.push(closest_number);\n\
    \                closest_2.push(numbers[i]);\n            }\n        }\n    }\n\
    \n    return [closest_1, closest_2];\n}\n", "\tlet [smallest_element, largest_element]\
    \ = numbers;\n\n\tlet current_number = smallest_element;\n\tlet current_index\
    \ = 0;\n\tlet current_index2 = 0;\n\n\tlet distance_between_elements = largest_element\
    \ - smallest_element;\n\n\tlet distance_between_elements_squared = distance_between_elements\
    \ * distance_between_elements;\n\n\tlet number_of_elements_to_search_for = 2;\n\
    \n\tlet numbers_two_to_search_for = [smallest_element, largest_element];\n\tlet\
    \ current_index2 = 0;\n\tlet current_index3 = 0;\n\n\twhile(numbers_two_to_search_for.length\
    \ > 0){\n\t\tcurrent_index2 = 0;\n\t\tcurrent_index3 = 0;\n\t\twhile(current_index2\
    \ < number_of_elements_to_search_for){\n\t\t\tcurrent_index3++;\n\t\t\t//console.log(current_index3);\n\
    \t\t\tcurrent_index2++;\n\n\t\t\tcurrent_number = numbers_two_to_search_for[current_index2];\n\
    \n\t\t\tlet distance = current_number - smallest_element;\n\n\t\t\tlet distance_sqr\
    \ = distance * distance;\n\n\t\t\tlet distances_squared = distance_sqr - distance_between_elements_squared;\n\
    \n\t\t\tlet distance_abs_sqrt = Math.sqrt(distances_squared);\n\n\t\t\tlet distance_abs_sqrt_divided_by_two\
    \ = distance_abs_sqrt / 2;\n\n\t\t\tlet distance_abs_sqrt_divided_by_four = distance_abs_sqrt\
    \ / 4;\n\n\t\t\tlet distance_abs_sqrt_divided_by_five = distance_abs_sqrt / 5;\n\
    \n\t\t\tlet distance_abs_sqrt_divided_by_six = distance_abs_sqrt / 6;\n\n\t\t\t\
    let distance_abs_sqrt_divided_by_seven = distance_abs_sqrt / 7;\n\n\t\t\tlet distance_abs_sqrt_divided_by_eight\
    \ = distance_abs_sqrt / 8;\n\n\t\t\tlet distance_abs_sqrt_divided_by_nine = distance_abs_sqrt\
    \ / 9;\n\n\t\t\tlet distance_abs_sqrt_divided_by_ten = distance_abs_sqrt / 10;\n\
    \n\t\t\tlet distance_abs_sqrt_divided_by_ten_plus_four = distance_abs_sqrt_divided_by_ten\
    \ + distance_abs_sqrt_divided_by_four;\n\n\t\t\tlet distance_abs_sqrt_divided_by_ten_plus_six\
    \ = distance_abs_sqrt_divided_by_ten + distance_abs_sqrt_divided_by_six;\n\n\t\
    \t\tlet distance_abs_sqrt_divided_by_ten_plus_eight = distance_abs_sqrt_divided_by_ten\
    \ + distance_abs_sqrt_divided_by_eight;\n\n\t\t\tlet distance_abs_sqrt_divided_by_ten_plus_nine\
    \ = distance_abs_sqrt_divided_by_ten + ", "\t//get two biggest numbers\n\tvar\
    \ max_1 = Math.max(numbers[0])\n\tvar max_2 = Math.max(numbers[1])\n\n\t//if numbers\
    \ are the same return them in order (smaller number, larger number)\n\tif(max_1\
    \ == max_2){\n\t\tvar result = [max_1, max_2]\n\t\tfor(var i = 1; i < numbers.length;\
    \ i++){\n\t\t\tvar number = numbers[i]\n\t\t\t//get two biggest numbers except\
    \ number\n\t\t\tvar tmp_1 = Math.max(numbers[i - 1])\n\t\t\tvar tmp_2 = Math.max(numbers[i\
    \ - 2])\n\t\t\t//if one of them is bigger return it\n\t\t\tif(tmp_1 > tmp_2){\n\
    \t\t\t\tresult[i] = tmp_1\n\t\t\t}else{\n\t\t\t\tresult[i] = tmp_2\n\t\t\t}\n\t\
    \t}\n\t\treturn result\n\t}\n\n\t//else we need to check if first and second number\
    \ are bigger or second and third bigger\n\tvar bigger_1 = false\n\tvar bigger_2\
    \ = false\n\n\tif(numbers[0] > max_1){\n\t\tbigger_1 = true\n\t\tmax_1 = numbers[0]\n\
    \t}\n\tif(numbers[1] > max_2){\n\t\tbigger_2 = true\n\t\tmax_2 = numbers[1]\n\t\
    }\n\n\t//if first number is bigger return it\n\tif(bigger_1){\n\t\treturn [max_1,\
    \ max_2]\n\t}\n\n\t//else second number is bigger\n\tif(bigger_2){\n\t\treturn\
    \ [max_2, max_1]\n\t}\n\n\t//else if two first numbers are equal, we can only\
    \ check the third one\n\tvar bigger_3 = false\n\n\tif(numbers[0] == numbers[1]){\n\
    \t\tif(numbers[2] > max_2){\n\t\t\tbigger_3 = true\n\t\t\tmax_2 = numbers[2]\n\
    \t\t}\n\t\tif(numbers[2] > max_1){\n\t\t\tbigger_3 = true\n\t\t\tmax_1 = numbers[2]\n\
    \t\t}\n\t}\n\t//if third number is bigger return it\n\tif(bigger_3){\n\t\treturn\
    \ [max_2, max_1]\n\t}\n\n\t//else return smallest number in list (bigger than\
    \ all other numbers)\n\tvar smallest_number = Math.min.apply(null, numbers)\n\t\
    for(var i = 1; i < numbers.length; i++){\n\t\tvar number = numbers[i]\n\t\tif(number\
    \ > smallest_number){\n\t\t\treturn [smallest_number, number]\n\t\t}\n\t}\n\n\t\
    //if we get here something is really wrong...\n\treturn [-100, -100]\n}\n", "\t\
    let minimum = numbers[0]\n\tlet maximum = numbers[0]\n\tfor(let i = 1; i < numbers.length;\
    \ i++){\n\t\tif (numbers[i] < minimum) {\n\t\t\tminimum = numbers[i]\n\t\t}\n\t\
    \tif (numbers[i] > maximum) {\n\t\t\tmaximum = numbers[i]\n\t\t}\n\t}\n\treturn\
    \ [minimum, maximum]\n}\n", "  if(numbers.length < 2)\n    return numbers;\n \
    \ var numbers_sorted = numbers.slice();\n  numbers_sorted.sort(function(a, b){return\
    \ a-b});\n  numbers_sorted = [numbers_sorted[0], numbers_sorted[numbers_sorted.length\
    \ - 1]];\n  return numbers_sorted;\n}\n", "  var smallest = null,\n    largest\
    \ = null;\n\n  numbers.sort(function (a, b) {\n    if (a < b) return -1;\n   \
    \ if (a > b) return 1;\n    return 0;\n  });\n\n  for (var i = 0; i < numbers.length;\
    \ i++){\n    if (numbers[i] === numbers[smallest + 1]){\n      smallest = i;\n\
    \    }\n    if (numbers[i] === numbers[largest - 1]){\n      largest = i;\n  \
    \  }\n  }\n\n  return (smallest === null ? numbers[0] : numbers[smallest]), \n\
    \    (largest === null ? numbers[numbers.length - 1] : numbers[largest]);\n}\n",
  "\tvar smallest = numbers[0];\n\tvar largest = numbers[0];\n\t\n\tfor(var i = 1;\
    \ i < numbers.length; i++){\n\t\tvar number = numbers[i];\n\t\t\n\t\tif(number\
    \ < smallest){\n\t\t\tsmallest = number;\n\t\t}\n\t\t\n\t\tif(number > largest){\n\
    \t\t\tlargest = number;\n\t\t}\n\t}\n\t\n\treturn [smallest, largest];\n}\n",
  "  var min2 = numbers[0];\n  var max2 = numbers[0];\n  numbers.forEach(function(number){\n\
    \    min2 = Math.min(min2, number);\n    max2 = Math.max(max2, number);\n  });\n\
    \  return [min2, max2];\n}\n", "  var smallest_number = numbers[0];\n  var second_smallest_number\
    \ = numbers[0];\n  var larger_number = numbers[0];\n  var second_larger_number\
    \ = numbers[0];\n\n  for(var i = 1; i < numbers.length; i++){\n    if(Math.abs(numbers[i])\
    \ < Math.abs(smallest_number)){\n      smallest_number = numbers[i];\n    }else{\n\
    \      second_smallest_number = smallest_number;\n      smallest_number = numbers[i];\n\
    \    }\n    if(Math.abs(numbers[i] > larger_number)){\n      larger_number = numbers[i];\n\
    \    }else{\n      second_larger_number = larger_number;\n      larger_number\
    \ = numbers[i];\n    }\n  }\n\n  if(Math.abs(smallest_number) > Math.abs(second_smallest_number)){\n\
    \    return [smallest_number, larger_number];\n  }else{\n    return [second_smallest_number,\
    \ second_larger_number];\n  }\n}", "\tlet smallest = numbers[0];\n\tlet largest\
    \ = numbers[0];\n\tfor(let i = 1; i < numbers.length; i++){\n\t\tif(numbers[i]\
    \ < smallest) smallest = numbers[i];\n\t\tif(numbers[i] > largest) largest = numbers[i];\n\
    \t}\n\treturn [smallest, largest];\n}\n", "\tlet smallest;\n\tlet largest;\n\n\
    \tnumbers.sort((a, b) => a - b);\n\n\tfor(let i = numbers.length - 1; i >= 0;\
    \ i--){\n\t\tsmallest = i;\n\t\tlargest = i;\n\n\t\tfor(let j = i; j < numbers.length;\
    \ j++){\n\t\t\tif(numbers[j] < numbers[smallest]){\n\t\t\t\tsmallest = j;\n\t\t\
    \t}\n\n\t\t\tif(numbers[largest] > numbers[j]){\n\t\t\t\tlargest = j;\n\t\t\t\
    }\n\t\t}\n\n\t\tif(smallest != i) return [numbers[smallest], numbers[i]];\n\t\
    }\n\n\treturn [numbers[0], numbers[0]];\n}\n", "\tif (numbers.length < 2)\n\t\
    {\n\t\tthrow \"Not enough numbers\";\n\t}\n\tnumbers = numbers.slice();\n\tif\
    \ (numbers.length == 2)\n\t{\n\t\treturn numbers;\n\t}\n\t// Sort the array\n\t\
    numbers.sort(function(a, b)\n\t{\n\t\treturn a - b;\n\t});\n\t// Go through each\
    \ item in the list and find the two closest numbers\n\tvar small = numbers[0];\
    \ // The number in the middle of the array\n\tvar large = numbers[1];\n\tfor (var\
    \ i = 0; i < numbers.length - 1; i++) // Iterate through the whole array and find\
    \ two numbers that are close to each other\n\t{\n\t\tif (Math.abs(small - numbers[i])\
    \ < Math.abs(large - numbers[i]))\n\t\t{\n\t\t\tsmall = numbers[i];\n\t\t}\n\t\
    \telse\n\t\t{\n\t\t\tlarge = numbers[i];\n\t\t}\n\t}\n\treturn [small, large];\n\
    }\n\n", "  var lower = numbers[0];\n  var upper = numbers[0];\n  for(var i=0;i<numbers.length;i++){\n\
    \    if(numbers[i]<lower){lower = numbers[i];}\n    if(numbers[i]>upper){upper\
    \ = numbers[i];}\n  }\n  lower = Math.ceil(lower);\n  upper = Math.floor(upper);\n\
    \  return [lower, upper];\n}\n", "\tvar sorted = numbers.sort(function(a, b){return\
    \ a - b});\n\tvar low = sorted[0], high = sorted[sorted.length - 1];\n\n\tif(sorted[1]\
    \ - low > high - sorted[0]){\n\t\treturn sorted;\n\t}\n\telse{\n\t\tvar middle_point\
    \ = sorted[Math.floor(sorted.length / 2)];\n\t\treturn [sorted_mid(sorted, low),\
    \ sorted_mid(sorted, middle_point)];\n\t}\n}\n", "    var closest, closest, index1,\
    \ index2, delta;\n    for(var i=0; i < numbers.length-2; i++){\n        closest\
    \ = Math.abs(numbers[i] - numbers[i+1]);\n        index1 = i;\n        index2\
    \ = i+1;\n        while(index2 < numbers.length){\n            delta = Math.abs(numbers[index1]\
    \ - numbers[index2]);\n            if(delta < closest){\n                closest=delta;\n\
    \                index2 = index2 + 1;\n            }\n            else {\n   \
    \             index2 = index2 + 1;\n            }\n        }\n        closest\
    \ = Math.abs(numbers[index1] - numbers[index2]);\n        if(closest < Math.abs(numbers[index1]\
    \ - numbers[index])){\n            closest = Math.abs(numbers[index1] - numbers[index]);\n\
    \            index1 = index1;\n        }\n        if(closest < Math.abs(numbers[index2]\
    \ - numbers[index+1])){\n            closest = Math.abs(numbers[index2] - numbers[index+1]);\n\
    \            index2 = index2;\n        }\n        if(closest > Math.abs(numbers[index1]\
    \ - numbers[index])){\n            closest=Math.abs(numbers[index1] - numbers[index]);\n\
    \            index1=index1;\n        }\n        if(closest > Math.abs(numbers[index2]\
    \ - numbers[index+1])){\n            closest=Math.abs(numbers[index2] - numbers[index+1]);\n\
    \            index2=index2;\n        }\n        if(closest<0.01) break;\n    }\n\
    \    return [index1, index2];\n}", "  var smallest = numbers[0];\n  var largest\
    \ = numbers[0];\n  \n  for(var i = 1; i < numbers.length; i++){\n    if (numbers[i]\
    \ > largest){\n      largest = numbers[i];\n    }\n    if (numbers[i] < smallest){\n\
    \      smallest = numbers[i];\n    }\n  }\n  \n  return [smallest, largest];\n\
    }\n", "\tnumbers = numbers.sort(function(a, b){return a - b});\n\tvar low = numbers[0];\n\
    \tvar high = numbers[0];\n\tfor (var i = 1; i < numbers.length; i++){\n\t\tif\
    \ (low > numbers[i]){\n\t\t\tlow = numbers[i];\n\t\t}\n\t\tif (high < numbers[i]){\n\
    \t\t\thigh = numbers[i];\n\t\t}\n\t}\n\treturn [low, high];\n}", "    var min_index\
    \ = 0;\n    var min_value = numbers[0];\n    var max_index = 0;\n    var max_value\
    \ = numbers[0];\n    for (var i = 1; i < numbers.length; i++){\n        if (numbers[i]\
    \ < min_value){\n            min_value = numbers[i];\n            min_index =\
    \ i;\n        } else if (numbers[i] > max_value){\n            max_value = numbers[i];\n\
    \            max_index = i;\n        }\n    }\n    return [min_value, numbers[min_index],\
    \ max_value, numbers[max_index]];\n}\n", "\tif (numbers.length < 2)\n\t\treturn\
    \ numbers;\n\t\n\tnumbers = numbers.sort(function(a, b){\n\t\treturn a - b;\n\t\
    });\n\t\n\tvar smallest_number = numbers[0],\n\t\tlargest_number = numbers[numbers.length\
    \ - 1],\n\t\tsmallest_index = numbers.indexOf(smallest_number),\n\t\tlargest_index\
    \ = numbers.indexOf(largest_number);\n\t\n\treturn [smallest_number, largest_number];\n\
    }\nexports.find_closest_elements = find_closest_elements;\n\n", "    if (numbers.length\
    \ < 2){\n        return numbers;\n    }\n\n    let sorted_numbers = numbers.slice().sort();\n\
    \    let last_number = sorted_numbers.pop();\n\n    return sorted_numbers.filter((number,\
    \ i) => {\n        return number >= last_number;\n    });\n}\n", "    let smaller\
    \ = numbers.reduce(function(a,b){\n        return a > b ? a : b\n    })\n    let\
    \ larger = numbers.reduce(function(a,b){\n        return a > b ? b : a\n    })\n\
    \    let result = numbers.filter(function(number){\n        return Math.abs(number\
    \ - smaller) < Math.abs(number - larger)\n    })\n    if (result.length > 1){\n\
    \        return [result[0], result[1]]\n    }\n    else{\n        return result\n\
    \    }\n}\n", "\tvar lower = numbers.shift(), higher = numbers.pop();\n\twhile(numbers.length){\n\
    \t\tvar mid = Math.round((lower + higher) / 2);\n\t\tlower = higher;\n\t\thigher\
    \ = mid;\n\t\tif( numbers[mid] > numbers[mid - 1]){\n\t\t\tlower = mid + 1; \n\
    \t\t}\n\t\tif( numbers[mid] < numbers[mid + 1]){\n\t\t\thigher = mid - 1;\n\t\t\
    }\n\t\tif( numbers[mid] > numbers[mid]){\n\t\t\thigher = mid;\n\t\t}\n\t\tif(\
    \ numbers[mid] < numbers[mid]){\n\t\t\tlower = mid;\n\t\t}\n\t}\n\treturn [lower,\
    \ higher];\n}\n", "\tif (numbers.length < 2)\n\t\treturn numbers;\n\n\t// Sort\
    \ the numbers in ascending order \n\tvar sorted_numbers = numbers.slice().sort(function(a,b){\n\
    \t\treturn a-b;\n\t});\n\n\t// Store the closest pair\n\tvar closest_pair = sorted_numbers[0];\n\
    \tvar closest_index = sorted_numbers.length - 1;\n\n\t// Iterate through all numbers\
    \ and find the smallest pair\n\tfor (var i = 0; i < sorted_numbers.length - 1;\
    \ i++){\n\t\tif (sorted_numbers[i+1] - sorted_numbers[i] < closest_pair){\n\t\t\
    \tclosest_pair = sorted_numbers[i+1] - sorted_numbers[i];\n\t\t\tclosest_index\
    \ = i;\n\t\t}\n\t}\n\n\t// Return the sorted value\n\treturn [sorted_numbers[closest_index],\
    \ sorted_numbers[closest_index + 1]];\n}\n", "\tlet results = {};\n\tlet minDistance\
    \ = Infinity;\n\tlet minValue = null;\n\tlet minIndex = null;\n\tlet minValueIndex\
    \ = null;\n\t\n\tnumbers.forEach((value, index)=>{\n\t\tlet distance = Math.abs(value\
    \ - numbers[0]);\n\t\t\n\t\tif(minIndex == null || distance < minDistance){\n\t\
    \t\tminDistance = distance;\n\t\t\tminValue = value;\n\t\t\tminIndex = index;\n\
    \t\t\tminValueIndex = index;\n\t\t}\n\t\t\n\t\tif(distance < minDistance){\n\t\
    \t\tminDistance = distance;\n\t\t\tminValue = value;\n\t\t\tminIndex = index;\n\
    \t\t\tminValueIndex = index;\n\t\t}\n\t\t\n\t\tresults[minIndex] = minValue;\n\
    \t\tresults[minValueIndex] = minValue;\n\t});\n\t\n\treturn results;\n}\n", "\t\
    var smallest = numbers[0], largest = numbers[0];\n\tvar smallest_number = numbers[1];\n\
    \tvar largest_number = numbers[1];\n\n\tfor (var i = 2; i < numbers.length; i++){\n\
    \t\tif (numbers[i] < smallest){\n\t\t\tsmallest = numbers[i];\n\t\t\tsmallest_number\
    \ = numbers[i];\n\t\t}\n\t\tif (numbers[i] > largest){\n\t\t\tlargest = numbers[i];\n\
    \t\t\tlargest_number = numbers[i];\n\t\t}\n\t}\n\n\treturn [smallest, smallest_number,\
    \ largest, largest_number];\n}\n\n", "\t// First we sort the numbers from smallest\
    \ to largest\n\tnumbers.sort(function(a, b){return a-b})\n\tvar closest = {\n\t\
    \tfirst : numbers[0]\n\t}\n\tvar diff = 10e99;\n\tfor(var i = 1; i < numbers.length;\
    \ i++){\n\t\tvar a = numbers[i];\n\t\tvar b = numbers[i-1];\n\t\tvar abs_diff\
    \ = Math.abs(a - b);\n\t\tif(abs_diff < diff){\n\t\t\tdiff.abs = abs_diff;\n\t\
    \t\tclosest.first = b;\n\t\t\tclosest.second = a;\n\t\t}\n\t}\n\treturn closest;\n\
    }\n", "    if(numbers.length<=2){\n        throw Error(\"No points supplied\"\
    )\n    }\n    var result=[]\n    var i=0, j=0, delta=0, smaller=0, larger=0, index=0\n\
    \    while(numbers.length>i){\n        smaller=numbers[i]\n        larger=numbers[++i]\n\
    \        if(smaller>larger){\n            smaller, larger = larger, smaller\n\
    \        }\n        delta=larger-smaller\n        if(delta<0){\n            delta=-delta\n\
    \            larger++\n        }\n        if(delta>0){\n            delta=delta\n\
    \            smaller++\n        }\n        if(delta>larger){\n            index=i\n\
    \            larger=delta\n        }\n        if(delta<smaller){\n           \
    \ index=i\n            smaller=delta\n        }\n        result.push([larger,\
    \ smaller])\n    }\n    return result\n}", "    var smallest, largest, small_index;\n\
    \n    // Sort the array so that largest becomes first and smallest last.\n   \
    \ numbers.sort(function(a, b){return a - b});\n\n    smallest = numbers[0];\n\
    \    largest = numbers[0];\n    small_index = 0;\n\n    for(var i = 0; i < numbers.length;\
    \ i++){\n        if(numbers[i] < smallest || smallest){\n            smallest\
    \ = numbers[i];\n            small_index = i;\n        }\n        else if(numbers[i]\
    \ > largest || largest){\n            largest = numbers[i];\n        }\n    }\n\
    \n    // Return both the smallest and the largest so that's easy in the callback\
    \ below.\n    return [smallest, largest];\n}\n", "    let min = Math.min(...numbers);\n\
    \    let max = Math.max(...numbers);\n    return [\n        numbers[numbers.findIndex((number)\
    \ => number == min) - 1],\n        numbers[numbers.findIndex((number) => number\
    \ == max) - 1],\n    ];\n}\n", "  numbers.sort((a,b) => a-b);\n  let smallest\
    \ = numbers[0];\n  let largest = numbers[0];\n  for (let i=1; i<numbers.length;\
    \ i++){\n    if (numbers[i] < smallest) smallest = numbers[i];\n    if (numbers[i]\
    \ > largest) largest = numbers[i];\n  }\n  return [smallest, largest];\n}\n",
  "    var max_dist = Number.MIN_VALUE;\n    var max_index = -1;\n    var min = Number.MAX_VALUE;\n\
    \    for(var i = 0; i < numbers.length; i++){\n        var dist = numbers[i];\n\
    \        var index = i;\n        var current_min = Number.MAX_VALUE;\n       \
    \ for(var j = i + 1; j < numbers.length; j++){\n            var next = numbers[j];\n\
    \            if(next < dist){\n                index = j;\n                dist\
    \ = next;\n            }\n            if(dist < current_min){\n              \
    \  current_min = dist;\n            }\n        }\n        if(max_dist < dist){\n\
    \            max_dist = dist;\n            max_index = index;\n        }\n   \
    \     if(min > dist){\n            min = dist;\n        }\n    }\n    return [max_index,\
    \ max_dist];\n}\n", "    if (numbers.length < 2)\n        return null;\n\n   \
    \ // Sort numbers smallest to largest\n    numbers.sort(function(a,b){\n     \
    \   return a - b;\n    });\n\n    // Now that numbers are in sorted order, the\
    \ number we're interested in is\n    // the last number in the array.  For instance,\
    \ with numbers=[1.0, 2.0, 3.0, 4.0,\n    // 5.0, 2.2] the closest number to 2.0\
    \ is 5.0, since it's larger than 2.0.\n    var last = numbers[numbers.length-1];\n\
    \    var closest;\n    var difference;\n\n    // Start at the second last number.\
    \  We don't want to look at the\n    // smallest or largest numbers because they\
    \ may have just been added, or\n    // subtracted (by another number in the same\
    \ array), or multiplied (by a\n    // larger number).\n    for( var i=numbers.length-2;\
    \ i>=0; i-- ){\n        // Get the difference between the current number and the\
    \ last number in\n        // the sorted array.\n        difference = Math.abs(\
    \ numbers[i]-last );\n\n        // If this is closer to zero than the previous\
    \ minimum, store it as\n        // the new minimum.\n        if ( difference<closest\
    \ )\n            closest = difference;\n\n        // If this is closer to the\
    \ last number in the array than the previous\n        // minimum, store it as\
    \ the new minimum.\n        if ( difference>closest  )\n            closest =\
    \ difference;\n    }\n\n    // Return the two numbers in order of closest to furthest\
    \ away from zero.\n    return [numbers[numbers.length-2], closest];\n}\n", " \
    \   var results = [];\n    for(var i = 1; i < numbers.length; i++){\n        var\
    \ smallest_dist = Infinity;\n        var smallest_number = numbers[i];\n     \
    \   for(var j = 0; j < i; j++){\n            var dist = Math.abs(numbers[j] -\
    \ smallest_number);\n            if(dist < smallest_dist){\n                smallest_number\
    \ = numbers[j];\n                smallest_dist = dist;\n            }\n      \
    \  }\n        results.push([smallest_number, smallest_dist]);\n    }\n    return\
    \ results;\n}\n", "    if (numbers.length < 2) return [];\n    var closest_numbers\
    \ = [], closest_dist = Number.MAX_VALUE, closest_index = null;\n    for (var i\
    \ = 0; i < numbers.length; i++){\n        var dist = math.abs(numbers[i] - numbers[closest_index]);\n\
    \        if (dist < closest_dist){\n            closest_index = i;\n         \
    \   closest_dist = dist;\n        }\n    }\n    closest_numbers.unshift(numbers[closest_index]);\n\
    \    closest_numbers.push(numbers[closest_index]);\n    return closest_numbers;\n\
    }\n", "    //Create a set of all numbers from the input list\n    var set = create_set(numbers);\n\
    \    //Look for numbers in the set that are within a specified distance of each\
    \ other\n    //using binary search method\n    var closest_numbers = binary_search([...set]);\n\
    \    //Return the two closest numbers\n    return [...closest_numbers];\n}\n",
  "  var max_index = numbers.length - 1,\n    smallest,\n    closest;\n  if(numbers.length\
    \ === 1){\n    return [numbers[0], numbers[0]];\n  }\n  if(numbers.length ===\
    \ 2){\n    return numbers;\n  }\n\n  smallest = numbers[0];\n  closest = numbers[0];\n\
    \  for(var i = 1; i < numbers.length; i++){\n    if(numbers[i] < smallest){\n\
    \      smallest = numbers[i];\n    }\n    if(numbers[i] > closest){\n      closest\
    \ = numbers[i];\n    }\n  }\n  return [closest, smallest];\n}\n},{}],5:[function(require,module,exports){\n\
    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n\
    });\nexports.findClosestElement = findClosestElement;\nexports.findClosestPoint\
    \ = findClosestPoint;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n",
  "    //Check if numbers are provided\n    if(!numbers || numbers.length < 2){\n\
    \        throw new Error(\"find_closest_elements expects at least 2 numbers to\
    \ work with.\")\n    }\n\n    //Sort the numbers\n    numbers.sort(function(a,\
    \ b){\n        return a-b\n    })\n\n    //Find the closest numbers to the first\
    \ two\n    var closest = numbers[0], difference = numbers[1]-numbers[0]\n    for(var\
    \ i = 0; i < numbers.length; i++){\n        if(numbers[i] > closest){\n      \
    \      closest = numbers[i]\n        }\n    }\n\n    //Return the difference and\
    \ closest number in sorted order\n    return difference, closest\n}\n", "    var\
    \ largestNumber = Math.max.apply(null, numbers);\n    var smallerNumbers = numbers.filter(function(number){\n\
    \        return number != largestNumber;\n    });\n    var smallestNumber = Math.min.apply(null,\
    \ smallerNumbers);\n    var closestNumbers = [largestNumber, smallestNumber];\n\
    \    var smallestIndex = numbers.indexOf(smallestNumber);\n    var largestIndex\
    \ = numbers.indexOf(largestNumber);\n    while(smallestIndex > -1 && largestIndex\
    \ > -1){\n        closestNumbers = [numbers[largestIndex], numbers[smallestIndex]];\n\
    \        smallestIndex = numbers.indexOf(closestNumbers[0], smallestIndex + 1);\n\
    \        largestIndex = numbers.indexOf(closestNumbers[1], largestIndex + 1);\n\
    \    }\n    return closestNumbers;\n}\n</code>\n<|/ a tags=java,javascript dscore=3\
    \ |>\n<| c |>\nI like this method. Thanks a lot for the code snippet.\n<|/ c |>\n\
    <| c |>\n, did you test the result? I'm pretty sure it won't produce the right\
    \ answer. I think it will find `0`, not `1`.\n<|/ c |>\n<| c |>\nIt's almost right\
    \ but in case of array [1.0, 2.0, 3.0, 4.0, 5.0, 2.2] the method returns wrong\
    \ results. The closest one should by (2.0, 2.2) but this method returns (1.0,\
    \ 2.0).\n<|/ c |>\n<| c |>\nI've edited my answer to account for that.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nTo implement the same logic in pure Java:\n<code>\npublic\
    \ static void main(String[] args) {\n    System.out.println(findClosestElements(new\
    \ double[]{1.0, 2.0, 3.0, 4.0, 5.0, 2.2}));\n    System.out.println(findClosestElements(new\
    \ double[]{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}));\n}\n\npublic static Double findClosestElements(Double[]\
    \ values) {\n    double smallestElement = values[0];\n    double largestElement\
    \ = values[0];\n    for (double value : values) {\n        if (smallestElement\
    \ > value) {\n            smallestElement = value;\n        }\n        if (largestElement\
    \ < value) {\n            largestElement = value;\n        }\n    }\n    double\
    \ difference = smallestElement - largestElement;\n    double closestElement =\
    \ largestElement;\n    while (Math.abs(difference) > 0.000000001) {\n        double\
    \ nextElement = (difference<0 ? largestElement : smallestElement) + difference;\n\
    \        difference = nextElement - closestElement;\n        closestElement =\
    \ nextElement;\n    }\n    return closestElement;\n}\n</code>\nOutput:\n<code>\n\
    2.0\n2.0\n</code>", "  if(!numbers.length)\n    return [];\n  if(numbers.length\
    \ === 1)\n    return [numbers[0], numbers[0]];\n\n  var max = numbers[0], min\
    \ = numbers[0];\n  for(var i = 1; i < numbers.length; ++i){\n    var current =\
    \ numbers[i];\n    if(current){\n      if(current > max){\n        max = current;\n\
    \      }else if(current < min){\n        min = current;\n      }\n    }\n  }\n\
    \  return [max, min];\n}", "\tlet closest_elements = [numbers[0]];\n\tlet closest_dist\
    \ = numbers[0];\n\tlet closest_index = 0;\n\tfor(let i=1; i<numbers.length; i++){\n\
    \t\tlet this_dist = numbers[i]-numbers[closest_index];\n\t\tlet this_is_closest\
    \ = this_dist < closest_dist;\n\t\tlet this_is_better = this_dist > closest_dist;\n\
    \t\t\n\t\tif(this_is_better){\n\t\t\tclosest_dist = this_dist;\n\t\t\tclosest_index\
    \ = i;\n\t\t}\n\t\t\n\t\tif(this_is_closest){\n\t\t\tclosest_elements.push(numbers[i]);\n\
    \t\t}\n\t}\n\treturn closest_elements;\n}\n", "\tvar largest = numbers[0];\n\t\
    var smallest = numbers[0];\n\tvar i, j, new_number;\n\tvar length = 0;\n\tfor(i\
    \ = 1; i < numbers.length; i++){\n\t\tnew_number = numbers[i];\n\t\tif((smallest\
    \ > new_number) && (new_number > largest)){\n\t\t\tlargest = smallest;\n\t\t\t\
    smallest = new_number;\n\t\t\tlength = i;\n\t\t}else{\n\t\t\tsmallest = new_number;\n\
    \t\t}\n\t}\n\tvar returnArray = [];\n\tfor(i = 0; i < length; i++){\n\t\treturnArray[returnArray.length]\
    \ = smallest;\n\t}\n\treturnArray[returnArray.length] = largest;\n\treturnArray.reverse();\n\
    \treturn returnArray;\n}\n", "\tif (numbers.length < 2) return [numbers[0], numbers[0]];\n\
    \tif (numbers.length === 1) return [numbers[0], numbers[0]];\n\tvar sorted_numbers\
    \ = numbers.slice().sort();\n\treturn [sorted_numbers[Math.ceil(numbers.length/2-0.5)],\
    \ sorted_numbers[numbers.length-Math.ceil(numbers.length/2)]];\n}\n", "    var\
    \ smallest, largest;\n    var largestIndex = 0;\n    var smallestIndex = numbers.length\
    \ - 1;\n    \n    for(var i = 0; i < numbers.length; i++){\n        var num =\
    \ numbers[i];\n        var num2 = numbers[(i + 1) % numbers.length];\n       \
    \ var diff = Math.abs(num - num2);\n        \n        if(diff < smallest || smallest\
    \ === undefined){\n            smallest = diff;\n            smallestIndex = i;\n\
    \        }\n        \n        if(diff > largest){\n            largest = diff;\n\
    \            largestIndex = i;\n        }\n    }\n    \n    return numbers[smallestIndex],\
    \ numbers[largestIndex];\n}\n", "  var best_so_far = numbers[0];\n  var best_distance\
    \ = Math.abs(numbers[0]);\n  var best_index = 0;\n  var index = 0;\n  var smallest_difference\
    \ = Number.MAX_VALUE;\n\n  while (index < numbers.length){\n    var difference\
    \ = Math.abs(numbers[index] - best_so_far);\n    if (difference < smallest_difference){\n\
    \      best_so_far = numbers[index];\n      best_distance = difference;\n    \
    \  best_index = index;\n      smallest_difference = difference;\n    }else{\n\
    \      index++;\n    }\n  }\n\n  return [best_so_far, best_index];\n}\n", "\t\
    var min = Math.sqrt(numbers[0]*numbers[0]+numbers[1]*numbers[1]),\n\t\tindex =\
    \ 0, \n\t\tclosest = [];\n\n\tnumbers = numbers.slice(2);\n\t//find two numbers\
    \ that are closest to each other\n\twhile (numbers.length > 1){\n\t\tmin = Math.min(numbers[0],\
    \ numbers[1]);\n\t\tindex = numbers.indexOf(min);\n\t\tnumbers.splice(index, 1);\n\
    \t\tclosest.push([index, min]);\n\t}\n\treturn closest;\n}", "    var best_result\
    \ = {\n        number: numbers[0],\n        distance: Math.abs(numbers[0] - numbers[1])\n\
    \    };\n\n    var best_result_index = 1;\n    for(var i = 1; i < numbers.length;\
    \ i++){\n        var result = Math.abs(numbers[i] - numbers[best_result_index\
    \ - 1]);\n        if(result < best_result.distance){\n            best_result.distance\
    \ = result;\n            best_result.number = numbers[i];\n            best_result_index\
    \ = i;\n        }\n    }\n    return best_result;\n}\n", "\tvar sorted_numbers\
    \ = numbers.sort(function(a, b){\n\t\treturn Math.abs(a - b);\n\t});\n\n\treturn\
    \ sorted_numbers.splice(0, 2);\n}\n", "\tvar closest = numbers.reduce(function(a,\
    \ b){\n\t\treturn Math.abs(a - b);\n\t}, numbers[0]);\n\tvar closestIndex = -1;\n\
    \tnumbers.forEach(function(value, index){\n\t\tif(Math.abs(value - closest) <\
    \ Math.abs(value - numbers[0])){\n\t\t\tclosest = value;\n\t\t\tclosestIndex =\
    \ index;\n\t\t}\n\t});\n\treturn [numbers[closestIndex], closest];\n}\n", "\t\n\
    \tvar closest_numbers = [];\n\tclosest_numbers[0] = numbers[0];\n\tclosest_numbers[1]\
    \ = numbers[1];\n\t\n\tif(numbers.length == 2){\n\t\treturn closest_numbers;\n\
    \t}\n\t\n\tfor(var i = 0; i < numbers.length-1; i++){\n\t\tvar difference = numbers[i+1]\
    \ - numbers[i];\n\t\t\n\t\tif( Math.abs(difference) < Math.abs(closest_numbers[i+1]\
    \ - closest_numbers[i])){\n\t\t\tclosest_numbers[i] = numbers[i];\n\t\t}\n\t\t\
    else{\n\t\t\tclosest_numbers[i+1] = numbers[i];\n\t\t}\n\t}\n\t\n\treturn closest_numbers;\n\
    }\n", "\tvar closests = [numbers[0]];\n\tfor(var i = 0; i < numbers.length; i++){\n\
    \t\tfor(var j = i + 1; j < numbers.length; j++){\n\t\t\tvar d1 = Math.abs(numbers[i]\
    \ - numbers[j]);\n\t\t\tif(d1 < closests[j - 1]){\n\t\t\t\tclosests[j - 1] = d1;\n\
    \t\t\t\tclosests[j] = numbers[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn closests;\n}\n",
  "\tvar smallest;\n\tvar largest;\n\tfor(var n=0; n < numbers.length; ++n){\n\t\t\
    if(smallest === undefined || numbers[n] < smallest){\n\t\t\tsmallest = numbers[n];\n\
    \t\t}\n\t\tif(largest === undefined || numbers[n] > largest){\n\t\t\tlargest =\
    \ numbers[n];\n\t\t}\n\t}\n\tif(smallest === undefined) smallest = 0;\n\tif(largest\
    \ === undefined) largest = 1;\n\tvar result = [smallest, largest];\n\tvar mid;\n\
    \tfor(var n=0; n < numbers.length; ++n){\n\t\tmid = (smallest + largest) / 2;\n\
    \t\tif(numbers[n] > mid){\n\t\t\tlargest = mid;\n\t\t}else if(numbers[n] < mid){\n\
    \t\t\tsmallest = mid;\n\t\t}else{\n\t\t\t//Found a number that is close\n\t\t\t\
    result.push(mid);\n\t\t}\n\t}\n\treturn result;\n}\n\n", "  if(numbers.length\
    \ <= 2) return numbers;\n  var closest_pair = null;\n  var smallest_distance =\
    \ Number.MAX_SAFE_INTEGER;\n  for(var i = 0; i < numbers.length; i++){\n    var\
    \ d = Math.abs(numbers[i] - numbers[(i + 1) % numbers.length]);\n    if(closest_pair\
    \ === null || d < smallest_distance){\n      smallest_distance = d; closest_pair\
    \ = [numbers[i], numbers[(i + 1) % numbers.length]];\n    }\n  }\n  return closest_pair;\n\
    }\nexports.find_closest_elements = find_closest_elements;\n", "\tvar smallest\
    \ = numbers[0];\n\tvar largest = numbers[0];\n\tfor(var i = 0; i < numbers.length;\
    \ i++){\n\t\tif(numbers[i] > largest){\n\t\t\tlargest = numbers[i];\n\t\t}\n\t\
    \telse if(numbers[i] < smallest){\n\t\t\tsmallest = numbers[i];\n\t\t}\n\t}\n\t\
    return [smallest, largest];\n}\n", "  var sorted_numbers = numbers.slice().sort(function(a,\
    \ b) {\n    return a - b;\n  });\n  return sorted_numbers.slice(0, Math.ceil(sorted_numbers.length\
    \ / 2));\n}\n  ", "  var sorted_numbers = numbers.slice().sort(function(a, b)\
    \ {\n    return a - b;\n  });\n  var closest_pair = sorted_numbers[0];\n  var\
    \ closest_distance = sorted_numbers[1];\n  var smallest_distance = sorted_numbers[0];\n\
    \  for (var i = 0; i < sorted_numbers.length; ++i) {\n    if (sorted_numbers[i]\
    \ > closest_distance) {\n      closest_pair = sorted_numbers[i];\n      closest_distance\
    \ = sorted_numbers[i];\n    }\n    if (sorted_numbers[i] < smallest_distance)\
    \ {\n      smallest_distance = sorted_numbers[i];\n    }\n  }\n  return [closest_pair,\
    \ closest_distance];\n}\nexports.find_closest_elements = find_closest_elements;\n",
  "  if(!numbers.length){\n    return [numbers[0], numbers[0]]\n  }\n  var pairs =\
    \ [];\n  for(var i = 0; i < numbers.length; i++){\n    pairs.push([numbers[i],\
    \ numbers[i]]);\n  }\n  pairs = pairs.sort(function(a, b){\n    return (a[0] -\
    \ b[0]);\n  });\n  return [pairs[0][1], pairs[1][1]];\n}\n", "  numbers = numbers.slice()\n\
    \  return numbers.length ? find_closest_numbers(numbers) : null\n}\n", "    numbers\
    \ = numbers.sort(function(a, b){\n        return a - b;\n    });\n    \n    var\
    \ closest1 = numbers[0], closest2 = numbers[1];\n    \n    for (var i = 2; i <\
    \ numbers.length; i++){\n        if (numbers[i-1] > numbers[i]){\n           \
    \ closest1 = numbers[i];\n        } else {\n            closest2 = numbers[i];\n\
    \            break;\n        }\n    }\n    \n    return [closest1, closest2];\n\
    }\n", "    //Take the numbers array and find the closest numbers to each\n   \
    \ var smallest = Math.min.apply(Math, numbers);\n    var largest = Math.max.apply(Math,\
    \ numbers);\n    //Find the numbers closest to eachother\n    for (var i=0; i<numbers.length;\
    \ i++){\n        if (numbers[i] !== smallest && numbers[i] !== largest){\n   \
    \         console.log(\"The number \" + numbers[i] + \" is not close to \" + smallest\
    \ + \"and\" + largest);\n            break;\n        }\n    }\n    return numbers;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI like your solution. Simple and straightforward.\
    \ However, the \"numbers\" array can be long and I want to avoid the repetition.\
    \ Does your solution allow for that?\n<|/ c |>\n<| c |>\nSure, just change the\
    \ `var smallest = Math.min.apply(Math, numbers);\n    var largest = Math.max.apply(Math,\
    \ numbers);` to `var smallest = numbers[0];\n    var largest = numbers[0];` and\
    \ it works exactly the same.  If you had an array of length `3` it would get the\
    \ first 2 numbers, not the first 3 numbers.\n<|/ c |>\n<| c |>\nAh yes, I see\
    \ what you mean now. Your solution does exactly what I needed. Thank you!\n<|/\
    \ c |>\n<| c |>\nGreat answer! But your `if(numbers[i] !== smallest && numbers[i]\
    \ !== largest)` doesn't work in the case where there are 2 elements with the same\
    \ value\n<|/ c |>\n<| c |>\nThis isn't working for me in Javascript. Can you please\
    \ have a look?\n\nhttps://jsfiddle.net/j8vk4u4c/\n<|/ c |>\n<| a dscore=4 tags=arrays,javascript\
    \ |>\nI wrote a JS library which you can use for finding any nearest element in\
    \ array/object with a few simple lines of code. You can find the demo here.\n\n\
    <code>\nlet arr = [\n  {\"name\": \"john\", \"age\": 20},\n  {\"name\": \"mark\"\
    , \"age\": 30},\n  {\"name\": \"bob\", \"age\": 18},\n  {\"name\": \"rob\", \"\
    age\": 25}\n]\nlet searchValue = \"bob\"\nlet nearestElement = nearestElement(arr,\
    \ searchValue)\n", "\tif(numbers.length < 2){\n\t\tthrow \"find_closest_elements()\
    \ expects at least two numbers\"\n\t}\n\tvar min = numbers[0];\n\tvar max = numbers[0];\n\
    \tfor(var i = 0; i < numbers.length; i++){\n\t\tvar number = numbers[i];\n\t\t\
    if(number < min){\n\t\t\tmin = number;\n\t\t}else if(number > max){\n\t\t\tmax\
    \ = number;\n\t\t}\n\t}\n\tvar closest = [];\n\tvar i = numbers.length - 1;\n\t\
    while(i--){\n\t\tvar value = numbers[i];\n\t\tif(Math.abs(value - max) < Math.abs(value\
    \ - min)){\n\t\t\tclosest.push(value);\n\t\t}else if(Math.abs(value - min) < Math.abs(value\
    \ - max)){\n\t\t\tclosest.push(value);\n\t\t}\n\t}\n\tclosest.push(max);\n\tclosest.push(min);\n\
    \treturn closest;\n}", "\tif(numbers.length < 2){\n\t\tthrow new Error(\"Numbers\
    \ argument must be of length at least two\");\n\t}\n\n\t// We are going to keep\
    \ track of the closest two points to avoid redundant\n\t// calculations.\n\tlet\
    \ closest_1 = numbers[0], closest_2 = numbers[0], smallest_difference = Infinity;\n\
    \tlet i;\n\tfor(i = 1; i < numbers.length; i++){\n\t\t// Calculate the difference\
    \ between the current point and the current closest points\n\t\tlet current_difference\
    \ = numbers[i] - closest_1;\n\t\tlet current_difference2 = numbers[i] - closest_2;\n\
    \t\t// If we are closer than the current closest points\n\t\tif(current_difference\
    \ < smallest_difference){\n\t\t\t// Set the closest points\n\t\t\tclosest_1 =\
    \ closest_2;\n\t\t\tclosest_2 = numbers[i];\n\t\t}\n\t\telse{\n\t\t\t// We are\
    \ still closer than the closest points.\n\t\t\t// Increment the smallest difference\
    \ and move onto the next closest points.\n\t\t\tsmallest_difference = current_difference;\n\
    \t\t}\n\t}\n\t// Return the two closest points\n\treturn {closest_1: closest_1,\
    \ closest_2: closest_2};\n}\n", "  if(numbers.length < 2){\n    return numbers;\n\
    \  }\n  let smallest = numbers[0];\n  let biggest = numbers[0];\n  for(let i =\
    \ 1; i < numbers.length; i++){\n    if(numbers[i] < smallest){\n      smallest\
    \ = numbers[i];\n    }\n    if(numbers[i] > biggest){\n      biggest = numbers[i];\n\
    \    }\n  }\n  return [smallest, biggest];\n}\n", "    var closest_numbers = numbers.sort(function(a,\
    \ b){\n        return Math.abs(a-b); //Sort in ascending order - closest first\n\
    \    }).slice(0,2); //Return first two numbers\n    return closest_numbers;\n\
    }\n", "  if(numbers.length === 2){\n    return numbers;\n  }\n\n  // Create a\
    \ sorted array of the absolute values of the original numbers\n  var abs_numbers\
    \ = numbers.map(function (x) {\n    return Math.abs(x);\n  });\n  // Get the two\
    \ smallest values\n  var smallest_one = Math.min.apply(this, abs_numbers);\n \
    \ var second_smallest_one = Math.max.apply(this, abs_numbers);\n  // Find their\
    \ indexes\n  var first_idx = abs_numbers.indexOf(smallest_one);\n  var second_idx\
    \ = abs_numbers.indexOf(second_smallest_one);\n\n  return [numbers[first_idx],\
    \ numbers[second_idx]];\n}\n", "\tvar closest_one,\n\t\tclosest_two,\n\t\tclosest_diff,\n\
    \t\tdistance;\n\n\tif(numbers.length < 2){\n\t\treturn {\n\t\t\tnumbers: numbers,\n\
    \t\t\tdistance: 0\n\t\t};\n\t}\n\n\tclosest_one = Math.min.apply(null, numbers);\n\
    \tclosest_two = Math.max.apply(null, numbers);\n\tclosest_diff = Math.abs(closest_one\
    \ - closest_two);\n\n\tfor(var i = 0; i < numbers.length; i++){\n\t\tdistance\
    \ = closest_diff - Math.abs(numbers[i] - closest_one);\n\n\t\tif(distance < 0){\n\
    \t\t\tclosest_diff = distance;\n\t\t\tclosest_one = numbers[i];\n\t\t}else if(distance\
    \ > 0){\n\t\t\tclosest_diff = distance;\n\t\t\tclosest_two = numbers[i];\n\t\t\
    }\n\t}\n\n\treturn {\n\t\tnumbers: [closest_one, closest_two],\n\t\tdistance:\
    \ closest_diff\n\t};\n}\n", "    var smallest_one = numbers[0];\n    var closest_one\
    \ = numbers[0];\n    var second_smallest = numbers[1];\n    var second_closest_one\
    \ = numbers[1];\n    for(var i = 1; i < numbers.length; i++){\n        if(numbers[i]\
    \ < smallest_one){\n            smallest_one = numbers[i];\n            closest_one\
    \ = numbers[i];\n        }\n        if(numbers[i] > second_smallest){\n      \
    \      second_smallest = numbers[i];\n            second_closest_one = numbers[i];\n\
    \        }\n    }\n    return closest_one < second_closest_one ? [smallest_one,\
    \ second_closest_one] : [second_closest_one, smallest_one];\n}\n", "    //Convert\
    \ numbers to a set of ordered numbers\n    var numSet = numbers.reduce(function\
    \ (a, b) {\n        return a.concat([b]);\n    }, []);\n    //Get the list of\
    \ elements and convert it to a map of numbers\n    var numMap = numSet.reduce(function\
    \ (a, b) {\n        a[b] = true;\n        return a;\n    }, {});\n    //Use a\
    \ set and filter to get the two numbers closest to each other\n    return numSet.reduce(function\
    \ (a, b) {\n        var minDistance = Number.MAX_VALUE;\n        var closestNum\
    \ = null;\n        var closestIndex = -1;\n        for(var i in numMap){\n   \
    \         var dist = distance(a, b);\n            if(dist < minDistance){\n  \
    \              closestNum = i;\n                minDistance = dist;\n        \
    \        closestIndex = i;\n            }\n        }\n        return [closestNum,\
    \ closestIndex];\n    }, [0, 1]);\n}", "  var closest = [numbers[0]];\n  for(var\
    \ i = 0; i < numbers.length; i++){\n    var diff = Math.abs(numbers[i] - closest[0]);\n\
    \    for(var j = 0; j < closest.length; j++){\n      if(diff > Math.abs(closest[j]\
    \ - numbers[i])){\n        closest = numbers.slice(i, j);\n        break;\n  \
    \    }\n    }\n  }\n  return closest;\n}\n", "    var closest_vals;\n    var closest_index;\n\
    \    var closest_distance;\n    var smallest_diff = Number.MAX_VALUE;\n    \n\
    \    closest_vals = numbers.slice();\n    closest_index = 0;\n    closest_distance\
    \ = closest_vals[closest_index];\n    \n    for (var i=1; i<numbers.length; i++){\n\
    \        var curr_distance = numbers[i] - closest_distance;\n        if(curr_distance\
    \ < smallest_diff){\n            closest_index = i;\n            closest_distance\
    \ = curr_distance;\n            smallest_diff = curr_distance;\n        }\n  \
    \  }\n    return [closest_vals[closest_index], closest_distance];\n}\n", "   \
    \ //If the array is empty return nothing\n    if(numbers.length < 2) return undefined;\n\
    \n    //Get the sum\n    let total = numbers.reduce((a,b)=>a+b, 0);\n    \n  \
    \  //Get the difference of each from the total\n    let diff = numbers.map((v)=>v-total);\n\
    \n    //Get the average by dividing by the length of numbers\n    let avg = diff.length/numbers.length;\n\
    \n    //Get the index of the average in the diff array\n    let idx = diff.indexOf(avg);\n\
    \    \n    //If there was an avg return the two numbers in that order\n    if(idx\
    \ !== -1){\n        let a = numbers[idx];\n        let b = numbers[idx+1];\n \
    \       return [a, b];\n    }\n\n    //No close to avg in the diff array so return\
    \ undefined\n    return undefined;\n}\n", "  var closest_pair = []\n  var smallest_distance\
    \ = Number.MAX_VALUE;\n  var smallest = 0;\n  var largest = 1;\n\n  for (var i\
    \ = 0; i < numbers.length - 1; ++i) {\n    smallest_distance = Math.abs(numbers[i]\
    \ - numbers[i + 1]);\n\n    if (smallest_distance < smallest) {\n      smallest\
    \ = smallest_distance;\n      smallest = i;\n    }\n\n    largest = Math.max(largest,\
    \ i + 1);\n  }\n\n  closest_pair[0] = numbers[smallest];\n  closest_pair[1] =\
    \ numbers[largest];\n\n  return closest_pair;\n}\n", "  // sort by absolute value\n\
    \  var sortednumbers = numbers.sort(function(a,b){\n    return Math.abs(a) - Math.abs(b)\n\
    \  });\n\n  //Find the two numbers closest to each other\n  var smallest = sortednumbers[0];\n\
    \  var largest = sortednumbers[sortednumbers.length - 1];\n  var smallestIdx =\
    \ 0;\n  var largestIdx = sortednumbers.length - 1;\n\n  while(smallestIdx <= largestIdx){\n\
    \    var currentIdx = smallestIdx + largestIdx;\n    if(currentIdx < sortednumbers.length\
    \ - 1 && currentIdx > 1){\n      var currentDiff = Math.abs(sortednumbers[currentIdx]\
    \ - sortednumbers[currentIdx - 1]);\n      //the smallest two numbers have diff\
    \ of at most 1 between the two\n      if(currentDiff <= 1){\n        //if the\
    \ difference between the current two numbers is more than 1\n        //then it\
    \ is the smallest pair\n        var smallestDiff = Math.abs(sortednumbers[currentIdx]\
    \ - sortednumbers[currentIdx + 1]);\n        //If the two smallest numbers are\
    \ equal, they are the closest to each other\n        if(smallestDiff == 0){\n\
    \          smallestIdx = currentIdx;\n          break;\n        }\n        //If\
    \ the two smallest numbers are different, then which of the two is closest to\
    \ each\n        //other\n        if(smallestDiff < currentDiff){\n          largestIdx\
    \ = currentIdx;\n        }\n        else{\n          smallestIdx = currentIdx;\n\
    \        }\n      }\n      else{\n        //If the smallest number has no smaller\
    \ two numbers then they are the closest to each other\n        if(currentDiff\
    \ == 0){\n          smallestIdx = currentIdx;\n          break;\n        }\n \
    \       //if the largest number has no smaller two numbers, then they are the\
    \ closest\n        //to each other\n        if(currentDiff < 1){\n          smallestIdx\
    \ = currentIdx;\n        }\n        else{\n          largestIdx = currentIdx;\n\
    \        }\n      }\n    }\n    else if(currentIdx > 1){\n      if(sortednumbers[currentIdx\
    \ - 1] - sortednumbers[currentIdx] > 1){\n        largestIdx = currentIdx;\n \
    \     }\n      else{\n        smallestIdx = currentIdx;\n      }\n    }\n    else{\n\
    \      //if smallest and largest have only 1 number in common, then they are the\
    \ closest\n      //to each other\n      if(sortednumbers[currentIdx] - sortednumbers[currentIdx\
    \ - 1] <= 1){\n        smallestIdx = currentIdx;\n        largestIdx = currentIdx;\n\
    \      }\n      //If smallest and largest have no common number in common, then\
    \ they are ", "\tvar n = numbers.length, largest = numbers[0];\n\tfor (var i=1;\
    \ i<n; i++)\n\t{\n\t\tif (largest > numbers[i])\n\t\t{\n\t\t\tlargest = numbers[i];\n\
    \t\t}\n\t}\n\tfor (var i=0; i<n; i++)\n\t{\n\t\tif (numbers[i] <= largest)\n\t\
    \t{\n\t\t\treturn (numbers[i], numbers[i+1]);\n\t\t}\n\t}\n\treturn (largest,\
    \ largest);\n}\n", "    var closest = numbers[0];\n    var closestSquare = closest*closest;\n\
    \    var closest_idx = 0;\n\n    for(var i = 1; i < numbers.length; i++){\n  \
    \      var number = numbers[i];\n        var square = number*number;\n       \
    \ if(square < closestSquare){\n            closestSquare = square;\n         \
    \   closest_idx = i;\n        }\n    }\n\n    return [closest, closest_idx];\n\
    }\n", "  var smallest = numbers[0]\n  var largest = numbers[0]\n  var index =\
    \ 0\n  for(var i = 1; i < numbers.length; i++){\n    var number = numbers[i]\n\
    \    if(number < smallest && number > largest){\n      smallest = number\n   \
    \   index = i\n    }\n    if(number > smallest && number < largest){\n      largest\
    \ = number\n    }\n  }\n  return [largest, smallest]\n}\n", "    // Store the\
    \ numbers in an array.\n    let numberArray = numbers.map(n => n);\n    let closestToIndex\
    \ = {};\n\n    // Iterate over the array.\n    for(let i = 0; i < numberArray.length;\
    \ i++){\n        // If the current number is less than the two numbers in the\
    \ array then swap\n        // them.\n        if(numberArray[i] < numberArray[i\
    \ + 1]){\n            swap(numberArray, i, i + 1);\n        }\n\n        // Store\
    \ the index of the current number in our dictionary.\n        closestToIndex[numberArray[i]]\
    \ = i;\n    }\n\n    // Return an array of two numbers in the array that are the\
    \ closest to each other.\n    return [numberArray[closestToIndex[numberArray[0]]],\
    \ numberArray[closestToIndex[numberArray[1]]]];\n}\n", "    var smallest = Math.min(...numbers);\n\
    \    var largest = Math.max(...numbers);\n    var midpoint = Math.floor(numbers.length\
    \ / 2);\n    \n    //If the number of elements is too small, return just the largest\
    \ element\n    if (numbers.length <= 2){\n        return [largest, largest];\n\
    \    }\n    \n    //If the number of elements is too large, return the smallest\
    \ element and the largest element\n    if (numbers.length <= 1){\n        return\
    \ [smallest, largest];\n    }\n    \n    //If there are more than two elements,\
    \ find the midpoint between them\n    if (numbers.length > 2){\n        return\
    \ find_closest_elements(numbers.slice(0, midpoint)).concat(find_closest_elements(numbers.slice(midpoint)));\n\
    \    }\n    \n    //If the length of the supplied list is 1, just return the first\
    \ element\n    //If the length of the supplied list is 2, return the two elements\n\
    \    //If the length of the supplied list is greater than 2, return the closest\
    \ two elements\n    if (numbers.length === 1) {\n        return [numbers[0], numbers[0]];\n\
    \    }\n    \n    //If there are exactly two elements, return them both\n    if\
    \ (numbers.length === 2){\n        return [numbers[0], numbers[1]];\n    }\n \
    \   \n    //If there are exactly three elements, return the smallest element\n\
    \    //and the closest element to it (smallest element should be returned first)\n\
    \    \n    var closestToMiddleOne = find_closest_elements(numbers.slice(0, midpoint));\n\
    \    var closestToMiddleTwo = find_closest_elements(numbers.slice(midpoint));\n\
    \    \n    return [smallest, smallest];\n}\n\n", "  var minimums = []\n    , minimum\n\
    \n  //go through each of the given numbers, find the closest one and store it\
    \ for later\n  for(var i = 0; i < numbers.length; i++){\n    minimum = numbers[i]\n\
    \    for(var j = i + 1; j < numbers.length; j++){\n      if(Math.abs(minimum -\
    \ numbers[j]) < Math.abs(minimum - numbers[i])){\n        minimum = numbers[i]\n\
    \      }else{\n        minimum = numbers[j]\n      }\n    }\n    minimums.push(minimum)\n\
    \  }\n\n  //return the two closest numbers\n  return minimums\n}\n\n},{\"../common/safe_number\"\
    :66}],82:[function(require,module,exports){\n'use strict';\n\nvar utils = require('./utils')\n\
    \  , to_number = require('./to_number')\n  , $ = require('./../plotly')\n  , clamp\
    \ = require('./clamp');\n\nvar BADNUM = $.plotly.utils.BADNUM;\n", "    var n\
    \ = numbers.length,\n        distances = zeros(2*(n-1));\n    for(var i=0; i<n;\
    \ i++){\n        distances[i] = Math.pow(numbers[i] - numbers[i-1], 2);\n    }\n\
    \    var closest = zeros(n-1);\n    var min = Infinity;\n    for(var i=0; i<n-1;\
    \ i++){\n        if(distances[i] < min){\n            min = distances[i];\n  \
    \          closest[i] = numbers[i-1];\n        }\n    }\n    closest.push(numbers[n-1]);\n\
    \    return closest;\n}\n", "\tvar min_diff = Number.MAX_VALUE;\n\tvar min1 =\
    \ Number.MAX_VALUE;\n\tvar min2 = Number.MAX_VALUE;\n\tvar number1 = numbers[0];\n\
    \tvar number2 = numbers[0];\n\tfor (var i = 1; i < numbers.length; i++){\n\t\t\
    var diff = Math.abs(number1 - numbers[i]);\n\t\tif (diff < min_diff){\n\t\t\t\
    min2 = number2;\n\t\t\tmin1 = number1;\n\t\t\tnumber1 = numbers[i];\n\t\t\tnumber2\
    \ = numbers[i];\n\t\t\tmin_diff = diff;\n\t\t} else if (diff == min_diff){\n\t\
    \t\tnumber2 = numbers[i];\n\t\t}\n\t}\n\treturn [number1, number2];\n}\n", " \
    \   \n    function find_closest(target, numbers){\n        return target.map(\
    \ function(num){\n            return find_closest_number(num, numbers);\n    \
    \    });\n    }\n    \n    function find_closest_number(target, numbers){\n  \
    \      var min_dist = Number.POSITIVE_INFINITY;\n        var min_num = undefined;\n\
    \        for(var i = 0; i < numbers.length; i++){\n            var d = distance(target,\
    \ numbers[i]);\n            if(d < min_dist){\n                min_dist  = d;\n\
    \                min_num = numbers[i];\n            }\n        }\n        return\
    \ min_num;\n    }\n    \n    return find_closest(numbers, numbers);\n}\n", "\t\
    var min_diff = Number.MAX_VALUE;\n\tvar min_diff_index;\n\tvar current_diff;\n\
    \tvar current_index;\n\tvar previous_index;\n\tvar previous_value;\n\tvar current_value\
    \ = numbers[0];\n\tvar previous_value;\n\t\n\tfor(var i = 0; i < numbers.length\
    \ - 1; i++){\n\t\tcurrent_value = numbers[i];\n\t\tcurrent_index = i;\n\t\tprevious_value\
    \ = numbers[i+1];\n\t\tprevious_index = i;\n\t\tcurrent_diff = previous_value\
    \ - current_value;\n\t\t\n\t\tfor(var j = i + 2; j < numbers.length; j++){\n\t\
    \t\tprevious_value = numbers[j];\n\t\t\tprevious_index = j;\n\t\t\tcurrent_value\
    \ = numbers[j];\n\t\t\tcurrent_diff = current_value - previous_value;\n\t\t\t\n\
    \t\t\tif(current_diff < min_diff){\n\t\t\t\tmin_diff = current_diff;\n\t\t\t\t\
    min_diff_index = current_index;\n\t\t\t}\n\t\t}\n\t}\n\treturn [numbers[min_diff_index],\
    \ numbers[min_diff_index+1]];\n}\n", "  var smallest = Math.min(numbers);\n  var\
    \ largest = Math.max(numbers);\n  var smallest2 = smallest;\n  var largest2 =\
    \ largest;\n  var smallestIndex = -1;\n  var largestIndex = -1;\n  var smallestDistance;\n\
    \  var largestDistance;\n  var currentIndex;\n  for(var i = 0, len = numbers.length;\
    \ i < len; i++){\n    var difference = Math.abs(smallestIndex - largestIndex);\n\
    \    if(difference > 1){\n      if(smallest == largest){\n        //if we have\
    \ only one number in the list its in the smallestIndex and largestIndex\n    \
    \    //if there are two numbers in the list the smallest in the middle is the\
    \ smallest number in the list\n        //we simply return the middle value\n \
    \       return numbers[((largestIndex + smallestIndex) / 2)];\n      }\n     \
    \ return (largest + smallest) / 2; //return the middle number in the list which\
    \ is the closest to both\n    }\n    smallest2 = smallest;\n    largest2 = largest;\n\
    \    currentIndex = i;\n    smallestIndex = numbers[i];\n    largestIndex = numbers[currentIndex];\n\
    \    smallestDistance = smallest2;\n    largestDistance = largest2;\n    for(var\
    \ j = i; j < len; j++){\n      var difference = Math.abs(currentIndex - j);\n\
    \      var distance = Math.abs(smallestIndex - largestIndex);\n      if(difference\
    \ > 1){\n        if(distance < smallestDistance){\n          smallestDistance\
    \ = distance;\n          smallest2 = smallest;\n          smallestIndex = currentIndex;\n\
    \        }\n        if(distance < largestDistance){\n          largestDistance\
    \ = distance;\n          largest2 = largest;\n          largestIndex = currentIndex;\n\
    \        }\n      }\n    }\n  }\n  return (smallest + largest) / 2; //return the\
    \ middle number in the list which is the closest to both\n}\n", "  for(var i =\
    \ 0; i < numbers.length; i++){\n    var dist = numbers[i];\n    var index = 0;\n\
    \    for(var j = 0; j < numbers.length; j++){\n      if(j != i){\n        var\
    \ d2 = dist*dist;\n        if(d2 < numbers[j]){\n          index = j;\n      \
    \    dist = d2;\n        }\n      }\n    }\n    var num1 = numbers[index];\n \
    \   var num2 = numbers[index+1];\n    if(num2 != null){\n      return [num1, num2];\n\
    \    }\n  }\n  return null;\n}\n", "    var closest = numbers[0];\n    var closest_to\
    \ = 0;\n\n    for(var i = 0; i < numbers.length; i++){\n        var current =\
    \ numbers[i];\n        if(closest > current){\n            closest = current;\n\
    \            closest_to = i;\n        }\n    }\n\n    return (closest != numbers[closest_to])\
    \ ? [closest, closest_to] : [numbers[0], 0];\n}\n\nmodule.exports = find_closest_elements;\n\
    \n},{}],12:[function(_dereq_,module,exports){\n'use strict';\n\nvar parse = _dereq_('./parse');\n\
    var find_closest_points = _dereq_('./find_closest_points');\nvar is_point_in_polygon\
    \ = _dereq_('./is_point_in_polygon');\n\nvar polygon = _dereq_('./polygon');\n\
    var is_polygon = _dereq_('./is_polygon');\n\nvar contains = _dereq_('./contains');\n\
    var merge = _dereq_('./merge');\n\nmodule.exports = assign_points_to_polygons;\n",
  "  if(numbers.length < 2){\n    throw Error('Expected two or more numbers')\n  }\n\
    \  var result = [];\n  var smallest_number = numbers[0];\n  var larger_number\
    \ = numbers[1];\n  for(var i = 2; i < numbers.length; i++){\n    var current =\
    \ numbers[i];\n    if(current < smallest_number){\n      smallest_number = current;\n\
    \    }\n    if(current > larger_number){\n      larger_number = current;\n   \
    \ }\n  }\n  result.push(smallest_number);\n  result.push(larger_number);\n  return\
    \ result;\n}\n", "\tvar min_diff = Math.abs(numbers[0] - numbers[1]);\n\tvar closest_index\
    \ = 0, closest_element = 0;\n\tfor (var i = 1; i < numbers.length; i++){\n\t\t\
    var diff = Math.abs(numbers[i] - numbers[i - 1]);\n\t\tif(diff < min_diff){\n\t\
    \t\tclosest_element = i;\n\t\t\tclosest_index = i;\n\t\t\tmin_diff = diff;\n\t\
    \t}\n\t}\n\treturn [numbers[closest_index], numbers[closest_element + 1]];\n}\n",
  "    var a = numbers.sort((a, b) => a - b);\n    var b = numbers.sort((a, b) =>\
    \ a - b);\n    var c = [];\n    var d;\n    while (b.length || a.length){\n  \
    \      d = b.length ? b.pop() : a.pop();\n        c.push(d);\n    }\n    return\
    \ c;\n}\n</code>\n<|/ a tags=java,c#,math |>\n<| c |>\nThis doesn't work, in the\
    \ case of a sorted input array, it should return the first two elements. Try it\
    \ for `[3.0, 4.0, 5.0]`.\n<|/ c |>\n<| c |>\nThanks, fixed now.\n<|/ c |>\n<|\
    \ c |>\nThis fails when there is an exact match (like [1.0, 2.0]). You could change\
    \ the condition in the while loop to `b.length >= a.length`.\n<|/ c |>\n<| c |>\n\
    It works with your example. But it fails when we have an array like this: [2.3,\
    \ 2.5, 2.7, 3.9, 3.1, 3.4]. It returns [2.7, 3.1].\n<|/ c |>\n<| a tags=java,c#,math\
    \ |>\nThis is a simple O(n) solution, based on binary search:\n\nIf there are\
    \ n numbers, there are exactly n-1 comparisons\nIf there are exactly two numbers,\
    \ there are exactly two comparisons\nIf there are exactly three numbers, there\
    \ are exactly 3 comparisons\nEtc.\n\nHere is a recursive implementation:\n<code>\n\
    private static int binarySearch(int[] sorted) {\n    if (sorted.length == 1)\n\
    \        return sorted[0];\n    int min = 0;\n    int max = sorted.length - 1;\n\
    \    return binarySearch(sorted, min, max, sorted[0]);\n}\n\nprivate static int\
    \ binarySearch(int[] sorted, int min, int max, int value) {\n    if (min > max)\n\
    \        return -1;\n    int mid = (min + max) / 2;\n    if (value == sorted[mid])\n\
    \        return mid;\n    else if (value < sorted[mid])\n        return binarySearch(sorted,\
    \ min, mid - 1, value);\n    else\n        return binarySearch(sorted, mid + 1,\
    \ max, value);\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work in the\
    \ case of an input array that's sorted.  Try it for `[3.0, 4.0, 5.0]`.\n<|/ c\
    \ |>\n<| c |>\nIt does. Try it out with `int[] numbers = new int[] { 3, 5, 7,\
    \ 9, 11, 13 }`\n<|/ c |>\n<| c |>\nIt doesn't work if there are more than two\
    \ numbers: `binarySearch({2, 4, 6})` returns 3, where it should return 2. Try\
    \ it with `int[] numbers = new int[] { 3, 3, ", "    var closest_distance;\n \
    \   var closest_number = numbers[0];\n    var closest_second_number = numbers[0];\n\
    \n    for(var i = 1; i < numbers.length; i++){\n        var distance = calculate_distance(closest_number,\
    \ numbers[i]);\n        if(distance < closest_distance){\n            closest_distance\
    \ = distance;\n            closest_number = numbers[i];\n        }\n\n       \
    \ if(i === 1){\n            closest_second_number = numbers[i];\n        }\n \
    \   }\n\n    return [closest_number, closest_second_number];\n}\n", "\tvar minimum\
    \ = numbers[0];\n\tvar maximum = numbers[0];\n\tfor(var i = 0; i < numbers.length;\
    \ i++){\n\t\tif(numbers[i] < minimum){\n\t\t\tminimum = numbers[i];\n\t\t} else\
    \ if(numbers[i] > maximum){\n\t\t\tmaximum = numbers[i];\n\t\t}\n\t}\n\treturn\
    \ [minimum, maximum];\n}\n", "  var n1 = numbers[0];\n  var n2 = numbers[1];\n\
    \  for(var i = 0; i < numbers.length; i++){\n    var n3 = numbers[i];\n    if(n2\
    \ < n3){\n      n2 = n3;\n    }else if(n1 > n3){\n      n1 = n3;\n    }\n  }\n\
    \  return [n1, n2];\n}\n", "\t// Get the two smallest numbers\n\tvar smallest\
    \ = numbers[0];\n\tvar secondSmallest = numbers[0];\n\tfor(var i = 1; i < numbers.length;\
    \ i++){\n\t\tif(numbers[i] < smallest || smallest===secondSmallest){\n\t\t\tsmallest\
    \ = numbers[i];\n\t\t\tsecondSmallest = numbers[i];\n\t\t}\n\t\telse{\n\t\t\t\
    secondSmallest = smallest;\n\t\t}\n\t}\n\t// Return an array with the two numbers\n\
    \treturn [secondSmallest, smallest];\n}\n", "    numbers = _.clone(numbers);\n\
    \n    var smallest = Math.min.apply(null, numbers);\n    var largest = Math.max.apply(null,\
    \ numbers);\n\n    var result = [largest, smallest];\n\n    numbers.forEach(function\
    \ (n) {\n        var dist = n - smallest;\n        smallest = largest - dist;\n\
    \        largest = n;\n    });\n    return [smallest, largest];\n}\n", "  var\
    \ closest_pair = []\n  closest_pair[0] = Math.min.apply(Math, numbers)\n  closest_pair[1]\
    \ = Math.max.apply(Math, numbers)\n  return closest_pair\n}\n", "\tif(numbers.length\
    \ < 2){\n\t\treturn numbers;\n\t}\n\tvar closest_pair = [numbers[0], numbers[1]];\n\
    \tfor(var i = 2; i < numbers.length; i++){\n\t\tvar diff = Math.abs(numbers[i]\
    \ - closest_pair[1]);\n\t\tif(diff < closest_pair[0]){\n\t\t\tclosest_pair = [numbers[i],\
    \ numbers[i]];\n\t\t}else if(diff == closest_pair[0]){\n\t\t\tclosest_pair[1]\
    \ += numbers[i];\n\t\t}else if(diff == closest_pair[1]){\n\t\t\tclosest_pair[0]\
    \ = closest_pair[1];\n\t\t\tclosest_pair[1] = numbers[i];\n\t\t}\n\t}\n\treturn\
    \ [closest_pair[0], closest_pair[1]];\n}\n", "  var best_one = numbers[0];\n \
    \ var best_two = numbers[1];\n  for(var i=2; i<numbers.length; i++){\n    if(numbers[i]\
    \ > best_one){\n      best_two = best_one;\n      best_one = numbers[i];\n   \
    \ }\n    if(numbers[i] < best_two){\n      best_two = numbers[i];\n    }\n  }\n\
    \  return [best_one, best_two];\n}", "\tif (numbers.length < 2) return numbers;\n\
    \n\tvar smallest_diff = Number.MAX_VALUE;\n\tvar closest_number = numbers[0];\n\
    \tvar closest_pair = [closest_number, closest_number];\n\tfor (var i = 1; i <\
    \ numbers.length; i++){\n\t\tvar diff = numbers[i] - closest_number;\n\t\tif (diff\
    \ < smallest_diff){\n\t\t\tsmallest_diff = diff;\n\t\t\tclosest_number = numbers[i];\n\
    \t\t\tclosest_pair = [closest_number, numbers[i]];\n\t\t}\n\t}\n\treturn closest_pair;\n\
    }\n\n", "    var closest_distances = numbers.reduce(function(accum, num){\n  \
    \      accum.push(Math.pow(Math.abs(num - numbers[0]), 2));\n        return accum;\n\
    \    }, []);\n    var min_distance = closest_distances[0];\n    var result = [numbers[0],\
    \ numbers[0]];\n    for(var i = 1; i < closest_distances.length; i++){\n     \
    \   var new_distance = closest_distances[i];\n        if(new_distance < min_distance){\n\
    \            numbers[0] = result;\n            min_distance = new_distance;\n\
    \            result = [numbers[0], numbers[0]];\n        } else {\n          \
    \  result[1] = numbers[i];\n        }\n    }\n    return result;\n}\n", "  var\
    \ smallest, largest, largest2, smallest2, smallest_diff, diff, i;\n\n  smallest_diff=Number.MAX_VALUE;\n\
    \  smallest=numbers[0];\n  smallest2=numbers[0];\n  largest=numbers[0];\n  largest2=numbers[0];\n\
    \n  for(var i=0; i < numbers.length-1; i++){\n    smallest_diff=Math.min(smallest_diff,Math.abs(numbers[i]-smallest));\n\
    \    smallest2=Math.min(smallest2,Math.abs(numbers[i]-smallest2));\n    smallest=Math.min(\
    \ smallest, numbers[i]);\n    largest=Math.max(largest, numbers[i]);\n    largest2=Math.max(largest2,\
    \ numbers[i]);\n  }\n\n  smallest_diff=Math.min( smallest_diff, Math.abs( numbers[numbers.length-1]-smallest\
    \ ));\n  smallest2=Math.min( smallest2, Math.abs( numbers[numbers.length-1]-smallest2\
    \ ));\n  smallest=Math.min( smallest, numbers[numbers.length-1]);\n  largest=Math.max(\
    \ largest, numbers[numbers.length-1]);\n  largest2=Math.max( largest2, numbers[numbers.length-1]);\n\
    \n  return (smallest+largest2) / 2.0;\n}\n", "    if(numbers.length === 1){\n\
    \        return numbers;\n    }\n    else if(numbers.length === 2){\n        return\
    \ [numbers[0], numbers[1]];\n    }\n    else if(numbers.length === 3){\n     \
    \   var min_val = numbers[0], max_val = numbers[0];\n        for(var i = 1; i\
    \ < numbers.length; i++){\n            if(numbers[i] < min_val){\n           \
    \     min_val = numbers[i];\n            }\n            else if(numbers[i] > max_val){\n\
    \                max_val = numbers[i];\n            }\n        }\n        return\
    \ [min_val, max_val];\n    }\n    else{\n        var min_val = numbers[0], max_val\
    \ = numbers[0];\n        for(var i = 1; i < numbers.length; i++){\n          \
    \  if(numbers[i] < min_val){\n                min_val = numbers[i];\n        \
    \    }\n            else if(numbers[i] > max_val){\n                max_val =\
    \ numbers[i];\n            }\n        }\n        var middle_val = (min_val + max_val)\
    \ / 2;\n        return [min_val, middle_val, max_val];\n    }\n}\n", "  var smallest_number\
    \ = numbers[0], greatest_number = numbers[0];\n  for(var i = 1; i < numbers.length;\
    \ i++){\n    if(numbers[i] > greatest_number){\n      greatest_number = numbers[i];\n\
    \    }\n    if(numbers[i] < smallest_number){\n      smallest_number = numbers[i];\n\
    \    }\n  }\n  return [smallest_number, greatest_number];\n}\n", "  if(numbers.length\
    \ < 3){\n    throw new Error('find_closest_elements called with ' + numbers.length\
    \ + ' numbers instead of at least 3.')\n  }\n  var smallest = numbers[0], largest\
    \ = numbers[0]\n  for(var i = 1; i < numbers.length; i++){\n    var number = numbers[i]\n\
    \    if(number < smallest || smallest == undefined){\n      smallest = number\n\
    \    } else if(number > largest){\n      largest = number\n    }\n  }\n  if(smallest\
    \ == largest){\n    return smallest\n  }\n  var closest_pair = find_closest_pair(numbers,\
    \ smallest, largest)\n  return smallest\n}\n", "\tvar closest_pair = null;\n\t\
    for(var i=0; i<numbers.length; i++){\n\t\tfor(var j=i+1; j<numbers.length; j++){\n\
    \t\t\tvar abs_diff = numbers[j] - numbers[i];\n\t\t\tvar rel_diff = abs_diff /\
    \ numbers[i];\n\t\t\tif(rel_diff < 0){\n\t\t\t\trel_diff *= -1;\n\t\t\t}\n\t\t\
    \tif(abs_diff < rel_diff){\n\t\t\t\tclosest_pair = [numbers[i], numbers[j]];\n\
    \t\t\t}\n\t\t}\n\t}\n\tif(closest_pair){\n\t\treturn closest_pair;\n\t} else {\n\
    \t\treturn [numbers[0], numbers[1]];\n\t}\n}\n", "  //We want to find two numbers\
    \ in array that have distance greater than or equal to minimum distance between\
    \ them and at the same time\n  //have no smaller numbers afterwards (so all numbers\
    \ come before the last number in array).\n  var closest_to_previous_number; //first\
    \ number in array that does not have smaller numbers afterwards (so is closest\
    \ to previous number).\n  var closest_to_current_number; //last number in array\
    \ that does not have smaller numbers afterwards (so is closest to current number).\n\
    \  for(var i = 0; i<numbers.length-1; i++){\n    //Check whether the numbers are\
    \ closer to each other than the previous number and to the current number\n  \
    \  if(Math.abs(numbers[i]-numbers[i+1]) <= Math.abs(closest_to_previous_number-numbers[i])){\n\
    \      closest_to_previous_number = numbers[i];\n    }else{\n      closest_to_current_number\
    \ = numbers[i];\n    }\n  }\n  return [closest_to_previous_number,closest_to_current_number];\n\
    }</code>\n<|/ a tags=arrays,javascript |>\n<| c |>\nThis is a great solution!\
    \ I like your use of the absolute value function. You don't even need the if,\
    \ else statement in the while loop\n<|/ c |>\n<| a tags=arrays,javascript |>\n\
    I like Nikki's answer, so here's a solution using a for loop:\n<code>\nvar findClosest\
    \ = function(arr) {\n    var closest = null;\n    for (var i = 0; i < arr.length;\
    \ i++) {\n        var next = Math.abs(arr[i] - arr[(i + 1) % arr.length]);\n \
    \       if (closest == null || next < closest) {\n            closest = next;\n\
    \            closestIndex = i;\n        }\n    }\n    return [arr[closestIndex],\
    \ arr[closestIndex + 1]];\n}\n</code>\nThis has the benefit of not using any additional\
    \ functions (although you still might want to use Math.abs anyway).\n<|/ a dscore=3\
    \ |>\n<| a tags=arrays,javascript dscore=2 |>\nHere's an interesting one using\
    \ recursion to go through the array.\n<code>", "\tvar smallestDistance = Number.MAX_VALUE;\n\
    \tvar smallestIndex = 0;\n\tvar element;\n\tvar i;\n\tvar currentDistance;\n\t\
    \n\tfor(i = 1; i < numbers.length; i++){\n\t\telement = numbers[i];\n\t\tcurrentDistance\
    \ = Math.abs(element - numbers[smallestIndex]);\n\t\tif(smallestDistance > currentDistance){\n\
    \t\t\tsmallestDistance = currentDistance;\n\t\t\tsmallestIndex = i;\n\t\t}\n\t\
    }\n\t\n\treturn [numbers[smallestIndex], numbers[smallestIndex + 1]];\n}\n", " \
    \ var results = [],\n    smallest = numbers.sort(function(a,b){return a - b})[0],\n\
    \    largest = numbers.sort(function(a,b){return b - a})[0];\n  for(var i = 0;\
    \ i < numbers.length; i++){\n    var element = numbers[i];\n    if(element >=\
    \ smallest && element <= largest){\n      results.push(element);\n    }\n  }\n\
    \  return results;\n}\n", "\tvar sorted_numbers = numbers.slice().sort();\n\t\
    var closest_to_zero, closest_to_one;\n\tif(sorted_numbers[0] > sorted_numbers[1]){\n\
    \t\tclosest_to_zero = sorted_numbers[0];\n\t\tclosest_to_one = sorted_numbers[1];\n\
    \t}else{\n\t\tclosest_to_zero = sorted_numbers[1];\n\t\tclosest_to_one = sorted_numbers[0];\n\
    \t}\n\tvar result = [];\n\tfor(var i=0;i<numbers.length;i++){\n\t\tif(numbers[i]\
    \ == closest_to_zero){\n\t\t\tresult.push(closest_to_zero);\n\t\t\tbreak;\n\t\t\
    }else if(numbers[i] == closest_to_one){\n\t\t\tresult.push(closest_to_one);\n\t\
    \t\tbreak;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n", "  var i, number, result;\n\
    \  result = [];\n  for(i = 0; i < numbers.length - 1; i++){\n    number = numbers[i];\n\
    \    if(numbers[i + 1] - number > 0.5){\n      result.push(number);\n    }\n \
    \ }\n  return result;\n}\n", "    numbers = numbers.sort(function(a, b){\n   \
    \     return a - b;\n    });\n    var smallest = numbers[0];\n    var largest\
    \ = numbers[0];\n    numbers.forEach(function(number){\n        if (number > largest)\n\
    \            largest = number;\n        if (number < smallest)\n            smallest\
    \ = number;\n    });\n    return smallest;\n}\n</code>\n<|/ a |>\n<| a tags=list,python-3.x,python\
    \ |>\nJust for fun, here are a couple of other ways.\n<code>\ndef find_closest_elements(numbers):\n\
    \    numbers.sort()\n    smallest = numbers[0]\n    largest = numbers[-1]\n  \
    \  for i in range(1, len(numbers)):\n        current = numbers[i]\n        if\
    \ current > largest:\n            largest = current\n        elif current < smallest:\n\
    \            smallest = current\n    return smallest, largest\n\ndef find_closest_elements(numbers):\n\
    \    numbers.sort()\n    smallest, largest = numbers[0], numbers[-1]\n    for\
    \ i in range(len(numbers)):\n        current = numbers[i]\n        if current\
    \ > largest:\n            largest = current\n        elif current < smallest:\n\
    \            smallest = current\n    return smallest, largest\n\ndef find_closest_elements(numbers):\n\
    \    numbers.sort()\n    return numbers[0], numbers[-1]\n\n# usage\nprint(find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]))\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=list,python-3.x,python\
    \ |>\nThe Python stdlib has a heapq module for this:\n<code>\nimport heapq\n\n\
    def find_closest_elements(numbers):\n    numbers = sorted(numbers)\n    heapq.heapify(numbers)\n\
    \    return heapq.heappop(numbers), heapq.heappop(numbers)\n</code>\nThis runs\
    \ in O(log(n)) time, which is pretty much the fastest solution I can think of.\
    \ Plus, it's pretty pythonic, too.\n<|/ a |>\n<| c |>\nYou don't need `sorted()`\
    \ in your case because you sort anyway. Also, `heapq.heappop()` can take a negative\
    \ index without raising any exceptions.\n<|/ c |>\n<| a |>\n<code>\n>>> lst =\
    \ [1,2,3,4,5]\n>>> min(zip(lst, lst[1:]))\n(1, 4)\n</code>\n<|/ a dscore=1 tags=list,python-3.x,python\
    \ |>\n<| c |>\nThis also returns `(5,5)` instead of `(2, 2)` as the OP asked.\n\
    <|/ c |>\n<| c |>\nThat is an odd requirement... :-)\n<|/ c |>\n<| a tags=", " \
    \ var pairs = []\n  var diffs = []\n  var smallest\n  var smallest_number\n  var\
    \ current_smallest\n  var current_largest_number\n  var current_largest_diff\n\
    \  var index\n  \n  for(var i = 0; i < numbers.length; i++){\n    pairs[i] = []\n\
    \    diffs[i] = 0\n    smallest = numbers[i]\n    current_smallest = numbers[i]\n\
    \    current_largest_diff = 0\n    \n    for(var j = i + 1; j < numbers.length;\
    \ j++){\n      var diff = numbers[j] - current_smallest\n      if(diff < 0){\n\
    \        pairs[i].push(numbers[j])\n        diffs[i] = diff\n        if(diff <\
    \ current_largest_diff){\n          current_largest_diff = diff\n          current_largest_number\
    \ = numbers[j]\n        }\n      }else{\n        if(diff > current_largest_diff){\n\
    \          current_largest_diff = diff\n          current_largest_number = numbers[j]\n\
    \        }\n      }\n      \n      if(diff < current_smallest){\n        current_smallest\
    \ = diff\n        current_smallest_number = numbers[j]\n      }\n      \n    \
    \  if(diff < diffs[i]){\n        diffs[i] = diff\n      }\n    }\n    \n    if(smallest_number\
    \ == undefined){\n      smallest_number = current_smallest_number\n    }\n   \
    \ \n    if(current_smallest_number == undefined){\n      current_smallest_number\
    \ = current_largest_number\n    }\n    \n    var smallest_diff = current_smallest_number\
    \ - smallest_number\n    var largest_diff = current_largest_number - smallest_number\n\
    \    \n    if(smallest_diff < largest_diff){\n      smallest_number = current_smallest_number\n\
    \      smallest_diff = current_smallest_number - smallest_number\n    }else{\n\
    \      smallest_number = current_largest_number\n      smallest_diff = current_largest_number\
    \ - smallest_number\n    }\n    \n    pairs[i].push(smallest_number)\n    pairs[i].push(smallest_diff)\n\
    \  }\n  \n  return pairs\n}\n", "\tvar min_closest = numbers[0];\n\tvar max_closest\
    \ = numbers[0];\n\t\n\tfor(var i = 1; i < numbers.length; i++){\n\t\tvar current_min\
    \ = numbers[i];\n\t\tvar current_max = numbers[i];\n\t\t\n\t\tfor(var j = 0; j\
    \ < i; j++){\n\t\t\tvar current_max = Math.max(numbers[j], numbers[i]);\n\t\t\t\
    if(current_min > current_max)\n\t\t\t\tcurrent_min = current_max;\n\t\t}\n\t\t\
    \n\t\tif(current_min < min_closest){\n\t\t\tmin_closest = current_min;\n\t\t}\
    \ else if(current_max > max_closest){\n\t\t\tmax_closest = current_max;\n\t\t\
    }\n\t}\n\t\n\treturn [min_closest, max_closest];\n}\n", "    if(numbers.length\
    \ < 2){\n        return null;\n    }\n    var closest_numbers = [];\n    var closest_number\
    \ = numbers[0];\n    var closest_index = 0;\n    var current_index = 1;\n    var\
    \ found_close_number = numbers[closest_index];\n    for(var i = closest_index;\
    \ i < numbers.length; i++){\n        var next_number = numbers[i];\n        if(Math.abs(closest_number\
    \ - next_number) < Math.abs(closest_number - found_close_number)){\n         \
    \   closest_number = next_number;\n            closest_index = i;\n          \
    \  found_close_number = next_number;\n        }\n    }\n    closest_numbers.unshift(closest_number);\n\
    \    closest_numbers.push(found_close_number);\n    return closest_numbers;\n\
    }\n\n", "\t// First sort the list of numbers. \n\t// If two numbers are equal\
    \ then pick the larger number.\n\t// If the numbers are the same then pick the\
    \ smaller number.\n\tnumbers.sort(function(a, b){return a - b});\n\tvar min =\
    \ numbers[0], max = numbers[0];\n\tvar min_index = 0;\n\tvar max_index = 0;\n\t\
    numbers.forEach(function(number){\n\t\tif(number < min){\n\t\t\tmin = number;\n\
    \t\t\tmin_index = numbers.length;\n\t\t}\n\t\tif(number > max){\n\t\t\tmax = number;\n\
    \t\t\tmax_index = numbers.length;\n\t\t}\n\t});\n\treturn [numbers[min_index],\
    \ numbers[max_index]];\n}", "    numbers = numbers.slice();\n    var n = numbers.length,\n\
    \        min = -Infinity,\n        max = +Infinity;\n    for(var i = 0; i < n;\
    \ i++){\n        var m = numbers[i];\n        if(m > max){\n            max =\
    \ m;\n        }\n        else if(m < min){\n            min = m;\n        }\n\
    \    }\n    if(max > min){\n        var delta = (max - min);\n        if(delta\
    \ === 0){\n            return [max, max];\n        }\n        else{\n        \
    \    var d = (numbers[1] - numbers[0])/delta;\n            return [numbers[0]\
    \ + d*((numbers[1] + numbers[2] - min)/delta), numbers[1] + d*((numbers[0] + numbers[2]\
    \ - min)/delta)];\n        }\n    }\n}", "\tconst first_number = numbers[0];\n\
    \tconst second_number = numbers[1];\n\tconst distance_of_two = Math.abs(first_number\
    \ - second_number);\n\n\tif (distance_of_two == 0)\n\t{\n\t\treturn [first_number,\
    \ second_number];\n\t}\n\n\tif (distance_of_two < 0)\n\t{\n\t\t// Swap the two\
    \ numbers to put the smaller in the middle\n\t\tconst tmp = first_number;\n\t\t\
    first_number = second_number;\n\t\tsecond_number = tmp;\n\t}\n\n\tlet third =\
    \ Math.max(first_number, second_number);\n\tlet fourth = Math.min(first_number,\
    \ second_number);\n\n\tif (Math.abs(fourth - third) < Math.abs(second_number -\
    \ third))\n\t{\n\t\tthird = fourth;\n\t}\n\n\treturn [third, fourth];\n}\n", " \
    \ var closest_numbers = [];\n  for(var i = 0; i < numbers.length; i++){\n    for(var\
    \ j = i + 1; j < numbers.length; j++){\n      var diff = Math.abs(numbers[i] -\
    \ numbers[j]);\n      if(diff < closest_numbers.length){\n        var smallest_index\
    \ = closest_numbers.length;\n        closest_numbers[smallest_index] = Math.min(numbers[i],\
    \ numbers[j]);\n      }else if(diff === closest_numbers.length){\n        closest_numbers.push(Math.min(numbers[i],\
    \ numbers[j]));\n      }\n    }\n  }\n  return closest_numbers;\n}\n", "  var\
    \ results = [];\n  var smallest = null;\n  var largest = null;\n  for(var i =\
    \ 0, l = numbers.length; i < l; i++){\n    var n = numbers[i];\n    if(smallest\
    \ === null || n < smallest){\n      smallest = n;\n    }\n    if(largest === null\
    \ || n > largest){\n      largest = n;\n    }\n  }\n  if(smallest === null ||\
    \ largest === null){\n    return results;\n  }\n  if(smallest < largest){\n  \
    \  results.push([smallest, largest]);\n  } else {\n    results.push([largest,\
    \ smallest]);\n  }\n  return results;\n}\n", "  // Ensure all numbers passed are\
    \ of the same type\n  if(typeof numbers[0] != \"number\" || typeof numbers[1]\
    \ != \"number\")\n    throw new Error(\"find_closest_elements(): Arguments must\
    \ be of types 'number'\");\n  \n  var best_distance = Infinity;\n  var best_i\
    \ = 0;\n  var best_j;\n  \n  for(var i = 0, j = numbers.length - 1; i < numbers.length;\
    \ i++){\n    var distance = Math.abs(numbers[i] - numbers[j]);\n    if(distance\
    \ < best_distance){\n      best_distance = distance;\n      best_i = i;\n    \
    \  best_j = j;\n    }\n  }\n  \n  return [numbers[best_i], numbers[best_j]];\n\
    }\n", "\tnumbers = numbers.slice();\n\tif (numbers.length < 2){\n\t\treturn numbers;\n\
    \t}\n\tnumbers.sort(function(a, b){\n\t\treturn Math.abs(b - a);\n\t});\n\tvar\
    \ a = numbers[0];\n\tvar b = numbers[numbers.length - 1];\n\tvar index = 0;\n\t\
    while (index <= numbers.length - 2){\n\t\tif (Math.abs(numbers[index + 1] - numbers[index])\
    \ < Math.abs(a - numbers[index + 1])){\n\t\t\tindex++;\n\t\t}else{\n\t\t\tif (Math.abs(numbers[index\
    \ + 1] - numbers[index]) < Math.abs(b - numbers[index + 1])){\n\t\t\t\tindex++;\n\
    \t\t\t}else{\n\t\t\t\treturn numbers[index];\n\t\t\t}\n\t\t}\n\t}\n\treturn numbers[index];\n\
    }", "    numbers.sort(function(x,y){\n        return Math.sqrt(x*x+y*y);\n   \
    \ });\n    return numbers[numbers.length-1], numbers[0];\n}\n</code>\nI didn't\
    \ test it but this should work\n<|/ a dscore=3 |>\n<| a tags=javascript,jquery\
    \ |>\nI think you can try this one:\n<code>", "  console.log(\"Finding closest\
    \ to each other...\");\n  var closest_1 = numbers[0];\n  var closest_2 = numbers[0];\n\
    \  for(var i = 1; i < numbers.length; i++){\n    var d = distance_between(closest_1,\
    \ closest_2, numbers[i]);\n    console.log(\"Numbers \" + numbers[i] + \" and\
    \ \" + closest_1 + \" have distance of \" + d + \" and are close.\");\n    if(d\
    \ < closest_1.distance){\n      closest_1.number = numbers[i];\n      closest_1.distance\
    \ = d\n    } else if(d < closest_2.distance){\n      closest_2.number = numbers[i];\n\
    \      closest_2.distance = d\n    } else {\n      console.log(\"Error: Not sure\
    \ how to find the closest two numbers when numbers.length = \" + numbers.length\
    \ + \". Exiting...\")\n    }\n  }\n  console.log(\"Closest numbers are: \" + closest_1.number\
    \ + \", \" + closest_2.number + \", \" + closest_1.distance + \", \" + closest_2.distance)\n\
    \  return [closest_1, closest_2]\n}\n", "  if(numbers.length < 2){\n    throw\
    \ new TypeError('At least two numbers are required for the find_closest_elements\
    \ function');\n  }\n  let min = numbers[0];\n  let max = numbers[0];\n  let min_index\
    \ = -1;\n  let max_index = -1;\n  for(let i = 1; i < numbers.length; i++){\n \
    \   if(numbers[i] < min){\n      min = numbers[i];\n      min_index = i;\n   \
    \ }\n    else if(numbers[i] > max){\n      max = numbers[i];\n      max_index\
    \ = i;\n    }\n  }\n  return [min, max];\n}\n", "  var indexes, closest;\n  indexes\
    \ = _.zip(numbers, numbers).map(function(pair){\n    return [Math.abs(pair[0]-pair[1]),\
    \ pair[1]];\n  });\n  closest = _.minBy(indexes, function(i){\n    return i[0];\n\
    \  });\n  return closest;\n}\n\n", "\t\n\tvar smallest = numbers[0];\n\tvar biggest\
    \ = numbers[0];\n\t\n\tfor (var i = 1; i < numbers.length; i++){\n\t\tif (numbers[i]\
    \ < smallest){\n\t\t\tsmallest = numbers[i];\n\t\t}\n\t\tif (numbers[i] > biggest){\n\
    \t\t\tbiggest = numbers[i];\n\t\t}\n\t}\n\t\n\treturn {\n\t\tclosest: smallest,\n\
    \t\tsecondClosest: biggest\n\t};\n}\n\n", "  if(numbers.length <= 2)return numbers;\n\
    \  var pairs = [];\n  var smallest = numbers[0];\n  var largest = numbers[0];\n\
    \  for(var i = 0; i < numbers.length; i++){\n    if(numbers[i] < smallest){\n\
    \      smallest = numbers[i];\n    }\n    if(numbers[i] > largest){\n      largest\
    \ = numbers[i];\n    }\n  }\n  pairs.push([smallest, largest]);\n  for(var i =\
    \ 0; i < numbers.length; i++){\n    if(numbers[i] >= smallest){\n      pairs.push([numbers[i],\
    \ numbers[i]]);\n    }\n  }\n  pairs.sort(function(a, b){\n    return b[0] - a[0];\n\
    \  });\n  return pairs;\n}\n", "\tnumbers.sort(function(a, b){\n\t\treturn a-b\n\
    \t});\n\tfor(var i=0; i<numbers.length-1; i++){\n\t\tvar current = numbers[i];\n\
    \t\tfor(var j=i+1; j<numbers.length; j++){\n\t\t\tvar next = numbers[j];\n\t\t\
    \tif(next - current < 1e-16){\n\t\t\t\treturn {current:current, next:next};\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn {current:numbers[numbers.length-1], next:numbers[0]};\n\
    }"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
