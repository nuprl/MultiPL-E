name: HumanEval_49_modp
language: js
prompt: "//Return 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n\
  // >>> modp(1101, 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n//\
  \ 8\n// >>> modp(100, 101)\n// 1\nfunction modp(n, p){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = modp;\n  assert.deepEqual(candidate(3, 5),3);\n  assert.deepEqual(candidate(1101,\
  \ 101),2);\n  assert.deepEqual(candidate(0, 101),1);\n  assert.deepEqual(candidate(3,\
  \ 11),8);\n  assert.deepEqual(candidate(100, 101),1);\n  assert.deepEqual(candidate(30,\
  \ 5),4);\n  assert.deepEqual(candidate(31, 5),3);\n}\n\ntest();"
completions: ["  var m = (p-1)|0;\n  var left = numBits(p);\n  var r = n%left;\n \
    \ if(r){\n    r = left-r; // force truncation of division\n  }\n  if(m>0){\n \
    \   while(true){\n      m--; // make m<0\n      if((n%m) == 0){\n        return\
    \ m;\n      }\n      n >>= 1; // normalize for non-even vs. even\n    }\n  }else{\n\
    \    while(true){\n      m++; // make m>0\n      if((n%m) == 0){\n        return\
    \ m;\n      }\n      n >>= 1; // normalize for non-even vs. even\n    }\n  }\n\
    }\n", "\tvar res = n % p;\n\twhile (res){\n\t\tres = Math.floor(res/p);\n\t\t\
    n--;\n\t}\n\treturn n+1;\n}\n", "\tvar res = 0;\n\twhile (n > 0){\n\t\tif (n%p\
    \ === 0) res = (p*res + n)%p; \n\t\tn = Math.floor(n/p);\n\t\tp *= 2;\n\t}\n\t\
    return res;\n}\n", "  var negate = n < 0\n  if (negate) n = -n\n  if (n < 2) return\
    \ 1\n  if (n < 9) return modpow2(n, 1)\n  if (n < 27) return modpow2(n - 3, 2)\n\
    \  return modpow2(n - 3, 3)\n}\n", "  var res = 1;\n  while(true){\n    if(n &\
    \ 1) res = (res * p) % p;\n    n >>= 1;\n    if(n < 1) return res;\n  }\n}\n",
  "  var r = n;\n  while(r !== 0){\n    r = r%p;\n  }\n  return r;\n}\n", "    var\
    \ res = 1;\n    while(n>0){\n        res = res * p + (n%p);\n        n = Math.floor(n/p);\n\
    \    }\n    return res;\n}\n", "    var i = p|0, d = isInt32(p) ? BigInt(1) :\
    \ BigInt(0);\n    if(n < 0){\n        if(!isPositive(n) || BigInt(n) >= d){\n\
    \            return 0;\n        }\n        if(-n < d){\n            return modp(BigInt(n)\
    \ - BigInt(d), p);\n        }\n        return modp((-n + d) | 0, p);\n    }\n\
    \    while(i < 0){\n        if(i++ < -d){\n            return 0;\n        }\n\
    \        if(!isPositive(i) || BigInt(i) >= d){\n            return 0;\n      \
    \  }\n        if(-i < d){\n            return modp(BigInt(i) - BigInt(d), p);\n\
    \        }\n    }\n    if(i < d){\n        return modp(BigInt(i) | 0, p);\n  \
    \  }\n    if(BigInt(n) <= p && n >= 1){\n        return modp(BigInt(n), p);\n\
    \    }\n    return modp(BigInt(n) - BigInt(d) | 0, p);\n}\n", "  return n%p;\n\
    }\n", "  return ((n % p) + p) % p;\n}\n", "    if(isInfinite(p) || n !== n ||\
    \ p !== p){\n        throw new Error('Modulus must be defined and finite');\n\
    \    }\n\n    // Find GCD\n    var gcd = function gcd(a, b) {\n        if(b ==\
    \ 0) {\n            return a;\n        }\n        else if(b < 0) {\n         \
    \   return gcd(-a, b);\n        }\n        else {\n            return gcd(b, a\
    \ % b);\n        }\n    };\n\n    // Calculate GCD of the modulus and the GCD\
    \ of the original numbers\n    var gcdModulus = gcd(p, n);\n    var gcdNotModulus\
    \ = gcd(n, p);\n\n    // If there is no remainder, n and p are coprime\n    //\
    \ Find the greatest common divisor of the two GCDs\n    var gcd = function gcd(a,\
    \ b) {\n        if(b == 0) {\n            return a;\n        }\n        else if(b\
    \ < 0) {\n            return gcd(-a, b);\n        }\n        else {\n        \
    \    return gcd(b, a % b);\n        }\n    };\n\n    // Calculate the GCD of the\
    \ modulus and the GCD of the original numbers\n    var gcdModulus = gcd(p, n);\n\
    \    var gcdNotModulus = gcd(n, p);\n\n    // Return false if they are the same\
    \ or\n    // If both numbers have the same remainder\n    if((n === p) || (gcdNotModulus\
    \ == gcdModulus)) {\n        return false;\n    }\n\n    // Return true if the\
    \ remainder of n / p can be evenly divided by p.\n    // This check will catch\
    \ remainders of 2.\n    if(!Number.isInteger(p / gcd)) {\n        return false;\n\
    \    }\n\n    // Return true if the remainder of n / p is exactly divisible by\
    \ p.\n    // This check will catch remainders of 2.\n    if(Number.isInteger(p\
    \ / gcd % p)) {\n        return false;\n    }\n\n    // The numbers are coprime,\
    \ therefore the remainder of n / p is evenly divisible by p.\n    return true;\n\
    }\n", "  var result = 1;\n  while(n){\n    if(n & 1){\n      result *= p;\n  \
    \  }\n    n >>>= 1;\n    p *= p;\n  }\n  return result;\n}", "  var d = Math.pow(p,\
    \ n-1),\n      m = !isInteger(d);\n  return m ? p : n==0 ? 0 : (p == 0) ? 1 :\
    \ (m - 1) * Math.floor(d / p);\n}", "\tvar sum = 0;\n\twhile(n){\n\t\tsum += n%p;\n\
    \t\tn = Math.floor(n/p);\n\t}\n\treturn sum;\n}\n", "    var k = Math.ceil(Math.log(n)/Math.log(p));\n\
    \    return ((n*p) + (k/p)*(1/p)) % p;\n}\n", "  if (n < 0){\n    // The % operator\
    \ on negative numbers throws a RangeError.\n    throw new Error('Negative number,\
    \ expecting non-negative number');\n  }\n  n = n % p;\n  // From http://en.wikipedia.org/wiki/Modulo_operation\n\
    \  if(n < 1 || (n >= p && n < p-1)){\n    return 1;\n  }\n  return n % p;\n}\n",
  "    var ret=1;\n    while(n>0){\n        if((n&1)==0) ret=(ret*p)%p;\n        n>>>=1;\n\
    \        p>>>=1;\n    }\n    return ret;\n}\n", "  var x = 0\n  while(1){\n  \
    \  x = x*n % p\n    if((x|0) < p) break\n    x /= p\n  }\n  return x\n}\n", "\t\
    return ( (n % p) + p ) % p;\n};\n\n},{}],475:[function(_dereq_,module,exports){\n\
    'use strict';\n", "  return ((n % p) + p) % p;\n}\n", "  var modulus = BigInt(p);\n\
    \  while (n > modulus){\n    modulus *= BigInt(2);\n  }\n  while (modulus > n){\n\
    \    modulus -= BigInt(2);\n  }\n  return modulus;\n}\n", "    var res = 1;\n\
    \    for(; n > p; n /= p){\n        res++;\n    }\n    return res;\n}\n", "\t\
    var q, r = n%p;\n\tif(r){\n\t\tif(p == 0){\n\t\t\tq = r ? n : 0; //p could be\
    \ almost any value, but it's also very unlikely that a random number is even.\
    \ Hence it is safe to always use 0 as the exponent of the result.\n\t\t}else if(p\
    \ == 1){\n\t\t\tq = n / p;  //The result is a whole number and p is odd. To ensure\
    \ correct rounding when converting decimal numbers to binary strings, we must\
    \ divide the number by this odd number.\n\t\t}else{\n\t\t\tq = (n % p + p) / p;\
    \ //If p is even, we must divide the number by this even number.\n\t\t}\n\t\t\
    r = n - q * p;\n\t}\n\treturn r ? q : 0;\n}\n", "  var i, r = 1;\n  for(i = 1;\
    \ i <= n; i++){\n    r = r * p % i;\n  }\n  return r;\n}\n", "    var res = n;\n\
    \    while (res%p != 0) res = res%p;\n    return res;\n}\n", "  var x = 0;\n \
    \ var r = 1;\n  while(n){\n    x = (n % p + r) % p;\n    r *= p;\n    n /= p;\n\
    \  }\n  return x;\n}\n", "    var ans = 1;\n    for(var i = 0; i < p.length -\
    \ 1; i++){\n        ans = ans * n % (p.charAt(i) + p.charAt(i + 1));\n    }\n\
    \    return ans;\n}\n", "  var ret = n%p;\n  if(ret<0){\n    ret += p;\n  }\n\
    \  return ret;\n}\n", "  var res = 1;\n  while (true){\n    if (n & p) res +=\
    \ 1;\n    n >>>= 1;\n    if (n < 1) return res;\n  }\n}\n", "  var modulus = p\
    \ % 3;\n  return modulus ? n < modulus * 3 ? n : n % modulus * 3 : n;\n}\n</code>\n\
    For a more detailed explanation of what modp(...) does, see this answer: https://stackoverflow.com/a/728148/24874\n\
    <|/ a dscore=5 |>\n<| c |>\nYou just repeated what I wrote. Why?\n<|/ c |>\n<|\
    \ c |>\nI never said it was your answer.\n<|/ c |>\n<| c |>\nI see how it came\
    \ to that. Sorry about the wait.\n<|/ c |>\n<| c |>\n`modp(100,101)` should return\
    \ 1, but it is returning 0.\n<|/ c |>\n<| c |>\nThat's a separate issue. Your\
    \ code assumes integers. A simple fix would be to change: `return n >= modulus\
    \ * 3 ? n : n % modulus * 3` to `return n >= modulus * 3 ? n % modulus * 3 : n`.\n\
    <|/ c |>\n<| a dscore=5 |>\nIn JavaScript, modular exponentiation is done with\
    \ the ^ operator:\n<code>\nvar foo = 123456789; // 1\nvar bar = foo ** 4; // 1213141516171819\n\
    </code>\nIf foo is greater than the largest integer value that can be stored in\
    \ JavaScript's Number, then it isn't going to work. In other words, JavaScript\
    \ will silently truncate its numbers for you. \nThe ^ operator is also the bitwise\
    \ XOR operator:\n<code>\nvar foo = 123456789; // 1\nvar bar = foo ^ 4; // 17\n\
    </code>\nThe ^ operator performs a bitwise XOR on the two operands and returns\
    \ the result.\n<|/ a tags=math,modulus,javascript,exponent |>\n<| c |>\n`foo **\
    \ 4` can result in `Infinity` if the two operands are integers\n<|/ c |>\n<| c\
    \ |>\nI don't understand how `foo ** 4` can result in `Infinity`\n<|/ c |>\n<|\
    \ c |>\n`foo` and `bar` both are integers. `foo` is always less than or equal\
    \ to `Number.MAX_SAFE_INTEGER` (2^53-1) and `bar` is always less than or equal\
    \ to `Number.MAX_SAFE_INTEGER` (2^53-1)\n<|/ c |>\n<| c |>\nThat makes sense.\
    \ Thank you!\n<|/ c |>\n<| a tags=math,modulus,javascript,exponent |>\nYou can\
    \ use the ^ operator for modular exponentiation. This method works for negative\
    \ exponents as ", "  var r = n%p;\n  if(r !== 0) return r;\n  r = p%r;\n  return\
    \ r === 0 ? 0 : r\n}\n", "  var q = new BN(p.toString(), 10);\n  if(q.cmpn(0)\
    \ === 0)\n    return p.subn(1);\n  if(q.cmp(0) === 0) {\n    return q.iadd(p);\n\
    \  }\n\n  var mod = p.clone();\n  var a = p.clone();\n  a.negative = 0;\n  q.divRem(a,\
    \ q, p);\n  if(q.cmpn(0) !== 0)\n    return p.sub(q).iadd(q);\n  else\n    return\
    \ p;\n}\n", "  return ((n % p) + p) % p;\n}\n", "\treturn ( (n % p) + p ) % p;\n\
    }\n", "  return ((n % p) + p) % p;\n}\n\n},{}],26:[function(_dereq_,module,exports){\n\
    'use strict';\n\nvar alphabet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$';\n",
  "  var val = n > p ? n : p;\n  return val - (val % p);\n}\n", "\treturn (p === 0)?\
    \ n : ((p % p) === 0)? p : (p + modp(n - p));\n}\n", "  var res = 1;\n  while(\
    \ n > 0 ){\n    if( n & 1 ){\n      res *= p;\n    }\n    n >>>= 1;\n    if( n==0\
    \ ){\n      break;\n    }\n    p *= p;\n  }\n  return res;\n}\n", "\tvar i, r\
    \ = 1;\n\tfor(i = 1; i <= n; i++){\n\t\tr = r * p % i;\n\t}\n\treturn r;\n}\n",
  "  var v = n < 0 ? -p : p;\n  var f = 1;\n  while(v < p){\n    f *= v;\n    v +=\
    \ 1;\n  }\n  return f;\n}\n\nmodule.exports = modp;\n\n", "  if (n < 0 || p <\
    \ 0){\n    return NaN;\n  }\n  if (p === 0){\n    return 1;\n  }\n\n  var val\
    \ = n%p;\n  if (val === 0){\n    return val;\n  }\n  return Math.pow(val, Math.floor(Math.log(p)\
    \ / Math.LN2 ) - p);\n}\n", "\tvar m = (p*(p-1))>>1;\n\tvar res = n%p;\n\tres\
    \  = ((res*2)%p)+(p-1);\n\tif(res<0) res = p+(res+p);\n\treturn res;\n}\n", " \
    \   var isNeg = (n < 0);\n    if (isNeg) n = -n;\n    if(n < p) return isNeg ?\
    \ -p : p;\n    n = n - p;\n    isNeg = isNeg != (n % 2);\n    n = isNeg ? n :\
    \ n + p;\n    return (isNeg ? -1 : 1) * (n /= p);\n}\n", "  var q = n & -p;\n\
    \  var t = q*q;\n  return t >= p ? q : (t+p)%p;\n}\n", "  var a = 0;\n  var res\
    \ = 1;\n  for (var i = 0; i < p; i++){\n    a <<= 1;\n    a |= n & 1;\n    n >>=\
    \ 1;\n    if (n & 1){\n      res <<= 1;\n      res |= a;\n    }\n  }\n  return\
    \ res;\n}\n\nmodule.exports = modp;\n\n},{}],140:[function(_dereq_,module,exports){\n\
    var hashUtils = _dereq_('./hash-utils');\nvar utils = _dereq_('./utils');\nvar\
    \ g = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ?\
    \ global : typeof self !== 'undefined' ? self : {};\n\nvar HASH = g.crypto &&\
    \ g.crypto.getRandomValues && g.crypto.randomBytes && g.process.versions && g.process.versions.node\
    \ && g.process.versions.node.split('.') || 0;\n", "    return ((n % p) + p) %\
    \ p;\n}", "  var b = p%5;\n  var a = 3*b%7 + (2*b%5)*p;\n  var d = Math.floor(b/7);\n\
    \  return n^(d*3) + (a*d)%p;\n}\n", "\treturn n&-p;\n}", "  var i = 1,\n    val\
    \ = pow(p, n);\n  while(i < p){ val = mod(val, p); i++; }\n  return val;\n}\n",
  "  var q = n % p;\n  var t = p + q;\n  if (t < 1) return 0;\n  if (t > p) return\
    \ p;\n  if (q <= p) return q;\n  if (p <= q) return t;\n  // Repeat with quotient.\n\
    \  do {\n    --q;\n    t = t + q;\n  } while (t % p != 0 || q != 0);\n  return\
    \ q;\n}\n", "\treturn (1 << (n - p)) + mod1(p);\n}\n", "  var k = p.bitLength(),\n\
    \      f = POW_PRECISION,\n      res = 1;\n  if(k <= n)\n    res = 1;\n  else\n\
    \    while(k <= n)\n      res *= (p % k + k) % k;\n  return k != n ? res : res;\n\
    }\n", "  var q = n % p, r = n - q;\n  if(q < 0){\n    q = -p;\n    r = p + (q\
    \ < 0 ? -q :0);\n  }\n  for(var ti=1; ti<10000; ti++){\n    if(ti === 100){\n\
    \      return r % p;\n    }\n    r = r * p % p + 1;\n  }\n  return r;\n}\n", "\t\
    n = n|0;\n\tp = p|0;\n\tif(p < 0) return 1;\n\tif(p < n & -p) return 1;\n\tif(p\
    \ == 0) return 0;\n\tif(p & -p)  return  1;\n\tvar q = p-n;\n\tif((p & q) != 0)\
    \ return q;\n\tp >>= 1;\n\twhile(1){\n\t\tif(p < n){\n\t\t\tif(q == 0) return\
    \ p;\n\t\t\tp = (p << 1) | 1; // shift to left 1 bit.\n\t\t\tq--;\n\t\t} else\
    \ if(p > n){\n\t\t\tif(q == 0) return n;\n\t\t\tp = (p << 1) | 2; // shift to\
    \ left 2 bits.\n\t\t} else {\n\t\t\tbreak; // no change.\n\t\t}\n\t}\n\treturn\
    \ p;\n}\n", "  var res = 1;\n  n = n % p;\n  while(p){\n    if(n & 1){\n     \
    \ res = (res * p + n) % p;\n    }\n    n = n >> 1;\n    p >>= 1;\n  }\n  return\
    \ res;\n}\n", "  var m = (p-1)/Math.pow(2,n);\n  return Math.floor(m+Math.pow(2,\
    \ Math.ceil(Math.log(p)/Math.LN2)));\n}\n", "  if (n < p)\n    return n & (-p);\n\
    \  return p & (n - p);\n}\n\n},{}],3:[function(_dereq_,module,exports){\nmodule.exports\
    \ = {\n  copy: copy,\n  checkField: checkField,\n  checkBlock: checkBlock,\n \
    \ sortField: sortField,\n  copyFields: copyFields,\n  checkFields: checkFields\n\
    };\n", "  var res = n%p;\n  return res<0 ? res+p : res;\n}\n", "\treturn n%p;\n\
    }\n", "  var res = 1;\n  while(n > 0){\n    if(n & 1){\n      res = (res % p)\
    \ + 1;\n    }\n    n = n >> 1;\n  }\n  return res;\n}", "  var q = n < 0 ? -n\
    \ : n;\n  if(p < 0)\n    q -= p;\n  else\n    q |= 0;\n  return q;\n}\n", "  \
    \  var res = 1;\n    while(n%p)\n        res = (res*p+n%p) % p;\n    return res;\n\
    }\n", "  var twopi = 2*Math.PI,\n      d = n % p,\n      r = p / 2; // Fix rounding\
    \ errors\n\n  if((p % 2) == 0) return 0;\n  if(d == 0) return n;\n  if(d==1) return\
    \ n+1;\n  if(r > p) return n*Math.ceil(twopi / p);\n  if(Math.floor(r) == r) return\
    \ n-r; // Round down\n  return n*Math.floor(twopi / p);\n}\n", "    var res =\
    \ 1;\n    for(var i = 0; i < p; i++){\n        res *= n;\n    }\n    return res%p;\n\
    }\n", "  var a = n % p, b = ((a - p) % p) + p;\n  return b ? a - b : a;\n}\n\n\
    },{}],35:[function(require,module,exports){\nmodule.exports = shift\n", "  var\
    \ k = Math.min(n & 31, Math.ceil(p/32));\n  var mask32 = 1 << k;\n  return ((n\
    \ & mask32) >>> k) * mask32 - (n & 32) > 0;\n}\n", "\treturn ((n & -p) ^ n) &\
    \ p;\n}\n", "    return ((p-1)*n%p)+n*p;\n}\n", "    return ((n % p) + p) % p;\n\
    }\n", "\treturn (p - (n % p)) * Math.pow(2, Math.floor(n / p));\n}\n", "  var\
    \ isneg, shift, i, k, r, rmod;\n  if(p<0){\n    p *= -1;\n    isneg = true;\n\
    \  }else{\n    isneg = false;\n  }\n  shift = 0;\n  if(n & 1){\n    shift++;\n\
    \  }\n  i = 2;\n  while(i < 32){\n    k = MODBITS[i];\n    r = n >> k;\n    if((r&0x80)\
    \ && ((r^0x10)&0x01)){\n      rmod = r^0x40;\n      if(rmod>0){\n        if(rmod==r){\n\
    \          if((r&0x80) || ((n <<= 1)&0x80)){\n            return shift+1;\n  \
    \        }\n        }else{\n          if((r&0x80) || ((n <<= 1)&0x80)){\n    \
    \        return 0;\n          }\n        }\n      }\n    }\n    i++;\n  }\n  if((n\
    \ & 1) == 0){\n    return shift+1;\n  }\n  r = 0;\n  if(n & 2){\n    r++;\n  }\n\
    \  if((n & 4) != 0){\n    r += 2;\n  }\n  if((n & 8) != 0){\n    r += 4;\n  }\n\
    \  return isneg ? -shift : shift;\n}\n\nvar INT_BITS = 32;\nvar INT_MASK = ((1<<INT_BITS)-1);\n\
    var INT_MAX = 2**31;\nvar INT_MIN = -INT_MAX;\n", "  var i = 1,\n      res = n;\n\
    \  while(i < p){\n    if(n % p == 0) res = p - res; //If it's already less than\
    \ p, then it's p's prime factor.\n    i++;\n  }\n  return res;\n}\n", "    var\
    \ s = 1;\n    while (s < p)\n        s = s*n;\n    return n-s; // Return value\
    \ from equation n^s % p.\n}\n", "    var ret = n;\n    while(ret && ret % p)\n\
    \        ret = Math.floor(ret/p)+1;\n    return ret % p;\n}\n", "    var res =\
    \ n;\n    while (res%p != 0) res = (res % p + p) % p;\n    return res;\n}\n",
  "\treturn ((n % p) + p) % p;\n}\n", "  var isNeg = (n % 2 == 1 && n % 100 != 11)\
    \ ? false : true;\n  var r = Math.pow(10, Math.abs(~~(Math.log(n) / Math.LN10)));\n\
    \  // Nice trick to round number to 'close' form\n  var m = Math.round(n);\n \
    \ if(isNeg){\n    m = -m\n  }\n  return ((m % p + p) % p) | 0;\n}\n", "\treturn\
    \ (p > 1 && n >= p) ? n*p%p : n;\n}\n", "\treturn ( (n % p) + p ) % p;\n}\n",
  "    var m = (p * p) % n;\n    // Make sure that the value will fit into n.\n  \
    \  return m > n ? n : m;\n}\n", "    var modulus = p % n;\n    return modulus\
    \ < 0 ? modulus + n : modulus;\n}\n", "  var a=0, b=1, t=a; while(b<p){b=b+t;\
    \ t=t*(b-a+1)%p; a=t}\n  return a\n}\n", "  var r = BigInteger.ONE;\n  while(r.compareTo(p)\
    \ >= 0){\n    r = r.add(BigInteger.ONE);\n  }\n  if(p.compareTo(r) > 0){\n   \
    \ //Now r = p + n*q\n    r = BigInteger.addOrSubtract(r, p);\n  }\n  else {\n\
    \    //Now r = p - n*q\n    r = BigInteger.addOrSubtract(r, q);\n  }\n  return\
    \ r.modPowInt(p, n);\n}\n", "  var k = 1, r = n & 3; n = n >> 2;\n  if(p < 0){\n\
    \    if(!((p^r) & 1)){\n      k = (p&3) | 1\n    }\n    p = -p;\n  }\n  while((p>>>1)\
    \ <= k){\n    p >>>= 1;\n    k += 1;\n  }\n  return n ? ((p&1)==1 ? 1 : -1) :\
    \ 0;\n}\n", "  var acc = 0;\n  for(var i = 0; i < p.length; i++){\n    acc = (n\
    \ % p.length + p.length) % p.length;\n    if(acc === 0) break;\n  }\n  return\
    \ acc;\n}\n", "  var ret = (n & 1) ? p + 1 : ((n & 2) ? p + p : p + p);\n  if(n\
    \ < 0){\n    ret = -ret;\n  }\n  return ret;\n}\n", "  var result = n.mod(p);\n\
    \  while (result === 0) {\n    result = n.mod(p);\n  }\n  return result;\n}\n\n\
    },{}],150:[function(require,module,exports){", "    var k = 0;\n    while(p >=\
    \ k)\n        k += n%p;\n    return k;\n}\n", "  var k = Math.ceil(Math.log(p)\
    \ / Math.LN2);\n  return ((p%p)*k+n)%p;\n}\n", "  var x = p%n\n  return (x<n)?\
    \ x : n-x\n}\n", "    var q = 1;\n    while (q <= p){\n        q = 2*q+1;\n  \
    \  }\n    return q - p;\n}\n", "    var res = 0;\n    do {\n        res =  (res\
    \ % p) + n%p;\n        n /= p;\n    } while (n);\n    return res % p;\n};\n",
  "  var ret=1;\n  while(n>0){\n    if(p%n==0)\n      ret*=n;\n    n/=p;\n  }\n  return\
    \ ret;\n}", "  var res = 1;\n  for(var i = 0; i < p; i++){\n    res = (res * (n\
    \ - i - 1)) % (p - i);\n  }\n  return res;\n}\n", "  var m = (n % p + p) % p;\n\
    \  return (m === 0) ? m : modp(m, p);\n}\n", "    var val = p[0];\n    for(var\
    \ i = 0; i < p.length; i++){\n        if(p[i] < val){\n            val = p[i];\n\
    \        }\n    }\n    if(p.length + 1 < val){\n        return val - p.length;\n\
    \    }\n    else{\n        return val;\n    }\n}", "    var res = 1;\n    for(var\
    \ i = n;i >= 0;i--){\n        res = (res % p + n) % p;\n    }\n    return res;\n\
    }\n</code>\nThe only thing remaining is to actually use the number in Java:\n\
    <code>\nBigInteger result = modp(BigInteger.valueOf(123));\n</code>\nand use result.mod(p)\
    \ to get the modulus result.\n<|/ a dscore=1 |>\n<| a |>\nThe best and fastest\
    \ way to calculate modulus is using java.math.BigInteger class. It is slower than\
    \ other ways but not as slow. For example, you calculate modulo 1000000007 by\
    \ division 1000 times so you have 1000000 operations and in total you are doing\
    \ 1000000 multiplications while BigInteger does 1 multiplication and 1000000 multiplications.\n\
    <|/ a dscore=1 tags=modular-arithmetic,java |>\n<| c |>\nBigInteger is not faster\
    \ than other ways because BigInteger uses division which is slower.\n<|/ c |>\n\
    <| a tags=modular-arithmetic,java dscore=0 |>\nThe mod operator will do what you\
    \ want.\n<|/ a |>\n<| c |>\nNo, mod doesn't do it.  It returns modulus of n mod\
    \ p, not mod by n.\n<|/ c |>\n<| c |>\nThat's why I said \"will do what you want\"\
    . Being able to do the math you want is how you do math in programming.\n<|/ c\
    \ |>\n<| c |>\nYou can't do anything useful with the mod operator then.\n<|/ c\
    \ |>\n<| c |>\nI disagree with that. The mod operator is useful if you want to\
    \ know what the remainder is after performing division on a number. For example\
    \ if you divide 4 by 3 and the remainder is 1, the mod operator will return 3.\
    \ If the remainder is 0 then it will return 0 if the number is divisible by 3.\
    \ If the remainder is 1, it returns 1 if the number is divisible by 3. If the\
    \ remainder is 2, it will return 0. If the number is divisible by 3 it will return\
    \ the remainder or 1 if the number is divisible by 3 or more.\n<|/ c |>\n<| c\
    \ |>\nBut you only want a number, not anything else. mod is useful in some cases,\
    \ but in this case it's not what you want to do. Mod returns the remainder, not\
    \ the modulus. You need %. mod is just not what you want.\n<|/ c |>\n<| a tags=modular-arithmetic,java\
    \ |>\n<code>\nimport java.util.Scanner;\n\npublic class Modular {\n\n    public\
    \ static void main(String[] args) {\n        Scan", "\tvar k = 0;\n\twhile(k++\
    \ < n)\n\t\tif((k & p) == 0) return k;\n\treturn 1;\n}\n", "  var ans = 1;\n \
    \ while(n > 0){\n    ans *= n;\n    n &= p-1;\n  }\n  return ans;\n}\n},{}],134:[function(_dereq_,module,exports){\n\
    'use strict';\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n", "\t\
    return ((n % p) + p) % p;\n}", "  var res = 1;\n  for(var i = 0; n > i; i++){\n\
    \    res = (res * p + n%p) % p;\n    n /= p;\n  }\n  return res;\n}\n},{}],463:[function(require,module,exports){\n\
    'use strict';\nvar Promise = require('./promise');\nvar reject = require('./reject');\n\
    var resolve = require('./resolve');\nvar INTERNAL = Symbol('promise/INTERNAL');\n\
    \nvar promise = new Promise(INTERNAL, function(){\n  resolve(promise, arguments);\n\
    });\n\nvar callResolve = function(state, value, args) {\n  var resolveFunc = state\
    \ === 2 ? resolve : reject;\n  resolveFunc(promise, value, args);\n};\n\nmodule.exports\
    \ = promise;\n\npromise.callResolve = callResolve;\n\n},{\"./promise\":464,\"\
    ./resolve\":466,\"./reject\":467}],464:[function(require,module,exports){\n'use\
    \ strict';\nvar canEvaluate = typeof require == 'function';\nvar isHostObject\
    \ = typeof self == 'object' && self && self.Object === Object && self;\nvar undefined;\
    \ // More compressible than void 0.\nvar process = module.exports = {};\n\nprocess.nextTick\
    \ = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n\
    \    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n\
    \    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate)\
    \ {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n\
    \    if (canPost) {\n        var queue = [];\n        window.addEventListener('message',\
    \ function (ev) {\n            var source = ev.source;\n            if ((source\
    \ === window || source === null) && ev.data === 'process-tick') {\n          \
    \      ev.stopPropagation();\n                if (queue.length > 0) {\n      \
    \              var fn = queue.shift();\n                    fn();\n          \
    \      }\n            }\n        }, true);\n\n        return function nextTick(fn)\
    \ {\n            queue.push(fn);\n            window.postMessage('process-tick',\
    \ '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn,\
    \ 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\n\
    process.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n\
    \    throw new Error('process.binding is not supported');\n}\n", "  var i = 1,\n\
    \      result = 1; // Assume n is positive and not equal to 0.\n  \n  if(!isFinite(p)\
    \ || p == 0) return 0;\n  \n  while(i < p){\n    if(n % i == 0) result = i;\n\
    \    i = i + 2;\n  }\n  \n  return result;\n}\n\nmodule.exports = modp;\n\n",
  "  return ((n % p) + p) % p;\n}\n", "  return ((p % n)+n)%p;\n}\n", "    return\
    \ ((n % p) + p) % p;\n}\n", "  var res = 1\n  while (n > p){\n    res = (res *\
    \ n) % p\n    n = (n - res) % p\n  }\n  return res\n}", "\tif(n < 1) return 0;\n\
    \tif(n >= p) return 1;\n\tvar q = p-n, r = n%q;\n\treturn r ? r+q : q;\n}\n",
  "\tvar res = 0;\n\twhile(n > 0){\n\t\tres <<= 1;\n\t\tres |= n & 1;\n\t\tn >>= 1;\n\
    \t}\n\treturn ((res%p) + p) % p;\n}\n", "    var res = n%p;\n    if(res<0){\n\
    \    \treturn res + p;\n    }\n    return res;\n}\n", "  var i, x = p%n, r = n%x;\n\
    \  for(i=x; i>1; i--){\n    r = ((r*x) % p + x) % p;\n  }\n  return r;\n}\n\n\
    },{}],18:[function(_dereq_,module,exports){\nvar BigInteger = _dereq_(\"./lib/node/bigint\"\
    );\n", "    var f = parseInt(p).toString(2),\n        r = '',\n        i,\n  \
    \      x;\n\n    for (i = 0; i < f.length; ++i) {\n        x = n%p; // Convert\
    \ to string and eliminate any trailing zeros.\n        if (parseInt(f[i])) {\n\
    \            x += '.';\n        }\n        r += x;\n        n /= p;\n    }\n \
    \   return r;\n}\n", "    var r = 1;\n    while(n >= p){\n        r = (r*n) %\
    \ p;\n    }\n    return r;\n}\n", "  var r = n%p;\n  if(r){\n    return r;\n \
    \ }\n  if(p == 0){\n    return 1;\n  }\n  if(p > 0){\n    return (p*modp(p-1,\
    \ p))%p;\n  }\n  return modp(p-1, p)%p;\n}\n", "\tvar ret = p%n;\n\twhile (p/=n){}\n\
    \treturn ret+n-1;\n}\n", "  var i = Math.ceil(p * Math.LOG2E);\n  return ((i ===\
    \ 31) ? 1 : i)\n    + ((p & 1) === 1 ? i : modp(n - 2, p))\n    + ((p & 2) ===\
    \ 1 ? i : modp((n & 3) | 2, p))\n    + ((p & 4) === 1 ? i : modp((n & 15) | 4,\
    \ p));\n}\n", "  var q;\n  if((p&1) == 0){\n    return n&1;\n  }\n  if(n < p){\n\
    \    q = n|p|1;\n  }else{\n    q = n % (p|1);\n  }\n  return ((q*q&1)+((q^1)|p|1))\
    \ % p;\n}\n", "  return ((n % p) + p) % p;\n}\n", "  var r = n % (p+1);\n  return\
    \ (r < p) ? r : (p+1-r);\n}\n", "  var i = n % (p.bitLength || BI_DB), d = BI_DV\
    \ + p.DB - i;\n  if(i < 0){\n    if(p.isNeg) return d < 0 ? -p : p;\n    else\
    \ return d < 0 ? p : p;\n  }\n  if(i < p.bitLength) return p.isNeg ? -p.clone()\
    \ : p.clone();\n  if(i < BI_DB){\n    //Get the radix nearest to number not divisible\
    \ by p.bitLength\n    for(n = Math.ceil(BI_DB - i); n <= d; n++) if(n == BI_DV){\n\
    \      if(p.isNeg) return p.sub(new BigInteger()).toSigned();\n      else return\
    \ p.toSigned();\n    }\n    for(; i < BI_DB; i++) if(n <= BI_DB - i){\n      if(p.isNeg){\n\
    \        return p.sub(new BigInteger(dbits(BI_DB-i))).toSigned();\n      }\n \
    \     else return p.toSigned();\n    }\n  }\n  return p.toSigned();\n}\n", " \
    \ var f = n|0, r = f|0, m = f&p;\n  while(m && (r&1) === 0) m >>= 1;\n  return\
    \ m+((f << 1)|0)\n}\n", "  return ((n % p) + p) % p;\n}\n", "  var res = n;\n\
    \  while (res % p !== 0) res = res * p % p;\n  return res;\n}\n", "\tvar x = n%p;\n\
    \treturn x>0 ? x : p+x;\n}\n", "\tvar q = Math.floor((p + n) % p);\n\treturn q;\n\
    }\n", "  var val = n > p ? n : p;\n  return isFinite(val)\n    ? powMod(val, n\
    \ & -p[63], p)\n    : undefined;\n}", "    var result = bigModPow(n, p); // make\
    \ sure result is BigNumber (use isBigNumber from tests)\n    result.isub(p);\n\
    \    return result;\n}\n", "  var k = p == 0 ? 0 : ~~Math.max(-8, Math.min(8,\
    \ Math.floor(Math.log(n)/Math.LN2 >>> 1)));\n  return ((n-k)%p) + k;\n}\n", " \
    \ var result = n % p;\n  return result < 0 ? result + p : result;\n}\n", "  return\
    \ ((n % p) + p) % p;\n}", "  var twopi = Math.PI / 2;\n  var result = 0;\n  var\
    \ a = n;\n  for(var i = 0; a>0;)\n  {\n    if( i%2 == 0 )\n      result = result\
    \ + Math.floor(a / p) * p;\n    a = Math.floor(a / p);\n    i = i+1;\n  }\n  return\
    \ result;\n}\n", "  var i = 1;\n  while(i < Math.floor(Math.log(n)/Math.LN2) &&\
    \ n > p){ i+=1; }\n  return i<Math.pow(2, n.bitLength)/2 ? i+1 : i-1;\n}\n", "\t\
    if (n < 1) return 0;\n\tif (n < 3) return p + n;\n\tif (n === 3) return p;\n\t\
    if (n === 6) return 3 * p + n / 6;\n\treturn p * Math.pow(2 - n, p);\n}\n", "\t\
    var res = 1; // 0^0 % n\n\twhile(p){\n\t\tif(n % p === 0) res += 1;\n\t\tn /=\
    \ p;\n\t}\n\treturn res;\n}\n", "  return n%p;\n}\n", "    if(isZero(n) || isNaN(p))\
    \ return NaN;\n    if(p == 1) return 1;\n    if(isOne(p)) return n;\n    if(isZero(p))\
    \ return 0;\n    if(p == Math.floor(p)) p = Math.floor(p);\n    var q = getBase(p);\n\
    \    if(p != q){ var r = n%p; n = p; p = q; q = r; r = n%p; }\n    var result\
    \ = getBase(n);\n    if(p == 1) return result;\n    if(p == 0) return 0;\n   \
    \ while(true){\n        if((n % p) == 0){\n            result = (result * (n -\
    \ result)) / p;\n        }\n        if((p % p) == 0){\n            result = (result\
    \ * (p - result)) / p;\n        }\n        if(p == 1) return result;\n       \
    \ if(p == 0) return 0;\n        n /= p;\n        p /= p;\n    }\n}", "  var negate\
    \ = n < 0;\n  if (negate) n = -n;\n  if (n < 2) return negate ? p[0] - 2 : 0;\
    \ // Is negative number? Then return negative number, otherwise return\n  // positive\
    \ number (could be 1 or 2).\n  // >>> modp(-7, 5)\n  // -7\n  // >>> modp(-7,\
    \ -5)\n  // 5\n  // >>> modp(-20, -5)\n  // 5\n  var res = n - Math.floor(n);\n\
    \  if (res < 0) return negate ? res - 2 : 0; // n < 0 is false\n  return res.toFixed(10);\n\
    };\n\n", "  var result = BigInteger.ONE.shiftLeft( BigInteger.numberOfTrailingZeros(n,\
    \ p) )\n  result.negative = self.negative ^ self.negative\n  return result\n}\n",
  "    var ret = n;\n    while (p > 0){\n        if (n % 2 == 1) ret = ret / 2;\n\
    \        if (n % 3 == 0) ret = ret / 3;\n        if (n % 5 == 0) ret = ret / 5;\n\
    \        n = n >> 1;\n    }\n    return ret;\n}\n", "    var k = Math.pow(10,\
    \ abs(p));\n    return (math.pow(10, n) <= k) ? 0 : math.pow(n, p) % p;\n}\n},{\"\
    mathjs\":69}],91:[function(require,module,exports){", "  var result = n & p;\n\
    \  result = (result * (2 << (p - 1)) + ((result & p) << 1)) >>> 0;\n  return result\
    \ % p;\n}\n\n},{}],146:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports,\
    \ \"__esModule\", {\n    value: true\n});\nexports.default = modularMultiply;",
  "  var r = n%p;\n  return r < 0 ? r + p : r;\n}\n", "    var ret = 1 << (n - 1);\n\
    \    while (ret < p)\n        ret <<= 1;\n    return ret;\n}\n", "  var modulus\
    \ = n % p;\n  var residual = n % Math.pow(p,2);\n  var result = Math.floor(n/Math.pow(p,2))\
    \ + modulus;\n  return residual < 0 ? result + p : result;\n}\n", "  var r = n;\n\
    \  while(p){\n    r = r - p % 2 ? r : r + 1;\n    p /= 2;\n  }\n  return r;\n\
    }\n", "  var r = n%p;\n  return r<0 ? r+p : r;\n}\n", "\tvar r = n - (n%p);\n\t\
    return r < 0 ? r + p : r;\n}\n},{}],13:[function(require,module,exports){", " \
    \ var v = Math.pow(2 << n, p);\n  return v !== 0 ? v % p : 0;\n}\n\nmodule.exports\
    \ = modp;\n\n},{}],126:[function(require,module,exports){\n'use strict';\n", " \
    \   var m = (n % p + p) % p;\n    return (m < 0 ? m : p) - m;\n}\n", "  var k\
    \ = Math.ceil(Math.log(n) / Math.log(p));\n  return ((p === 1) ? 1 : ((p === -1)\
    \ ? 0 : n-1)) % k;\n}\n", "  var r = bigInt(1);\n  while( n.gte(p) ){\n    r =\
    \ r.multiply(bigInt(2));\n    n.subtract(p);\n  }\n  if( p.compareTo(r) > 0 ){\n\
    \    r = r.mod(p);\n  }\n  return r;\n}\n", "  return ((p === 0) && (n === 0))\
    \ ? 0 :\n    ( pow(2, n)  %  p);\n}\n", "  var q = [];\n  while (n > 0){\n   \
    \ if (n%p == 0) q.unshift(n%p);\n    else q.push(n%p);\n    n = Math.floor(n /\
    \ p);\n  }\n  if(p.length) q.unshift(p);\n  return q;\n}", "  var q, r = 1;\n\
    \  for(p; p < n; p++){\n    q = p / n;\n    if((p + q) > n) r += q - p % q; else\
    \ r += (q - p) % q;\n  }\n  return r;\n}\n", "\tvar ret = 0;\n\tfor(var i = p.length;\
    \ 0 < i;i--) ret += (p.charCodeAt(i-1) - 48) * powMod(n, p.charCodeAt(i-1), p);\n\
    \treturn ret;\n}\n", "  var val = n\n  while (val > 0){\n    var mod = val % p\n\
    \    if (mod > 0){\n      val = val - mod\n    } else {\n      val = val + mod\n\
    \    }\n  }\n  return val\n}", "\treturn ((n % p) + p) % p;\n}\n", "\tvar i, x\
    \ = n-p, r = x % p;\n\tif(r < 0) r += p;\n\treturn r;\n}\n", "\tif(n == 0) return\
    \ 0;\n\tif(n%2 == 0 && n > 2) n -= 1;\n\tif(p % 2 == 0 && p > 2) p -= 1;\n\tif(p\
    \ == 1) return 1;\n\tif(p == 0) return 0;\n\treturn ((n*p)+(p-1))/p;\n}\n", " \
    \   var x = n%p;\n    return (x<0) ? (x + p) : x;\n}\n", "  var k = Math.pow(2,\
    \ n);\n  return (p = p - 1) < 1 ? k : (p = p - 1) % p ? k + p : k;\n}\n", "  var\
    \ res = n;\n  while (res%p !== 0){\n    res = (res/p) | 0;\n  }\n  return res;\n\
    }\n", "\tvar mask1 = (1 << n) - 1, mask2 = (1 << p) - 1;\n\treturn (((n&mask1)|p|~(n&mask2))&mask1)|p|~((n&mask2)|p&~mask1);\n\
    }\n", "  var negate = n < 0;\n  if (n instanceof BigNumber) {\n    var a = n.s;\n\
    \    var b = p.s;\n\n    if (b == null) {\n      //x = exp - 1;\n      a = toFixedString(a);\n\
    \      //x = toFixedString(x);\n      //x = (x.slice(-1) - '0') * (1 << places);\n\
    \n      if ((a.length + (+(a[0] & ((1 << places) - 1))) > 20)) {\n        throw\
    \ Error(a.length + ': Non-base' + places + ' number too large to convert');\n\
    \      }\n\n      return new BigNumber(toFixedString(a), b != null ? b : 10);\n\
    \    }\n\n    a = toFixedString(a);\n    //x = toFixedString(x);\n    //x = (x.slice(-1)\
    \ - '0') * (1 << places);\n\n    if ((a.length + (+(a[0] & ((1 << places) - 1)))\
    \ > 20)) {\n      throw Error(a.length + ': Non-base' + places + ' number too\
    \ large to convert');\n    }\n\n    return new BigNumber(toFixedString(a), b);\n\
    \  }\n\n  if (n < p) {\n    n %= p;\n  } else {\n    n %= (p + p);\n  }\n\n  return\
    \ n ? new BigNumber(n % p, n >= 0 ? 0 : p) : new BigNumber(0);\n}\n", "  if (n\
    \ % p === 0) n = n % (p*p)*p;\n  return n;\n}\n", "  return ((n % p) + p) % p;\n\
    }\n\n},{}],35:[function(require,module,exports){\nmodule.exports = require(\"\
    ./lib/_stream_readable.js\")\n\n},{\"./lib/_stream_readable.js\":34}],36:[function(require,module,exports){\n\
    module.exports = require(\"./lib/_stream_writable.js\")\n\n},{\"./lib/_stream_writable.js\"\
    :35}],37:[function(require,module,exports){", "  var ret=1;\n  while(n>0){\n \
    \   if(n & 1){\n      n--;\n      ret=ret*p+((p=p+1)&1);\n    }\n    p=(p+2)&7;\n\
    \    n=(n-2)&7;\n  }\n  return ret;\n}", "    var ret = 0;\n    while(n){\n  \
    \      ret += n%p;\n        n /= p;\n    }\n    return ret;\n}\n", "  var q =\
    \ n*p + .5;\n  return q >= 1 && q <= p ? n : n%p;\n}\n", "  var v = ((n % p) +\
    \ p) % p;\n  return v === p ? v : v + p;\n}\n", "\tvar a = [],\n\t\tb = [],\n\t\
    \tx = 1,\n\t\tresult = [];\n\tfor(var i = 0; i < n; i++){\n\t\ta[i] = x;\n\t\t\
    b[i] = 0;\n\t\tx = p * x % m;\n\t}\n\tfor(i = 0; i < n; i++){\n\t\tresult[i] =\
    \ a[i] % m + b[i];\n\t}\n\treturn result;\n}\n\n},{}],3:[function(require,module,exports){",
  "\tvar res = 1;\n\twhile (n > p){\n\t\tif (n % p == 0) res++;\n\t\tn /= p;\n\t}\n\
    \treturn res;\n}\n", "  var q = (p-1)/p\n  if(q < 0){\n    q = p\n  }\n  return\
    \ ((q*n) % p)\n}\n", "  var k = Math.ceil(Math.log(n)/Math.LN2);\n  var x = n%p;\n\
    \  var y = p%k;\n  return (x == 0 && y == 0 || y ==0 && x == 0) ? n : ((x < y)\
    \ ? x : y);\n}\n", "\treturn ((n % p) + p) % p;\n}\n\t", "    var ans = 1;\n \
    \   while(n > p){\n        ans = ans * (n - p + 1) / p;\n        n--;\n    }\n\
    \    return ans;\n}\n", "  if (isNaN(p)) throw new TypeError('Invalid modulus');\n\
    \  if (isFinite(p) && !isInteger(n)) throw new TypeError('Numbers cannot be modulated\
    \ using non-integer modulus');\n  if (isNegative(p)) throw new TypeError('Arguments\
    \ must be positive');\n  return p%n;\n}\n", "  var mod = n % p;\n  if(mod) return\
    \ mod;\n  var i = p / 10;\n  if(i == 0) return 1;\n  else if(i == 1) return 9;\n\
    \  else if(i == 2) return 5;\n  else if(i == 3) return 3;\n  else if(i == 4) return\
    \ 1;\n  else if(i == 5) return 9;\n  else if(i == 6) return 5;\n  else if(i ==\
    \ 7) return 3;\n  else if(i == 8) return 1;\n  else if(i == 9) return 9;\n  else\
    \ if(i == 10) return 5;\n  else if(i == 11) return 3;\n  else return 9;\n}\nexports.modp\
    \ = modp;\n", "  return ((n % p) + p) % p;\n}\n", "  var x = 0;\n  while(n){\n\
    \    if(n & 1) x = x*p;\n    n = Math.floor(n/p);\n    p++;\n  }\n  return x;\n\
    }\n", "  var r = n%p;\n  return r === 0 ? r : r+p;\n}\n", "  var result = 1;\n\
    \  while(n){\n    if(result % p === 0) return result;\n    n -= 1;\n    result\
    \ *= p;\n  }\n  return 1;\n}\n", "    var r = n%p;\n    return r === 0 ? r : r+p;\n\
    }\n", "  var x = 0;\n  var y = 1;\n  while(n > 0){\n    x %= n;\n    y *= p;\n\
    \    n /= p;\n  }\n  return y;\n}\n", "  var twopi = math.PI * 2;\n  if(p ===\
    \ 0){\n    return 1;\n  }\n  if(p == 1){\n    return n;\n  }\n\n  var isneg =\
    \ n < 0;\n  if(isneg){ n = -n; }\n  if(p == 2){\n    return isneg ? twopi : -1\
    \ * twopi;\n  }\n\n  if(p < 0){\n    var a = n * (isneg ? -1 : 1),\n      ysqr\
    \ = y * y,\n      xp = x + twopi,\n      lse = isneg ? 1 : -1;\n    if(isneg){\
    \ // calc sqrt\n      a -= ysqr;\n      a += 1;\n      a /= (a < 0 ? 2 : 3);\n\
    \    }\n    a = math.asin(a);\n    return isneg ? lse : a;\n  }\n\n  var y = n\
    \ * (isneg ? -1 : 1),\n    j = 1;\n  while(j < p){\n    y *= y;\n    j++;\n  }\n\
    \  return y * Math.sqrt(2 * Math.PI) / p;\n}\n", "  var result = 1;\n  while(n\
    \ > 0){\n    if(n & 1){\n      result *= p;\n    }\n    n >>= 1;\n    if(n ==\
    \ 0){\n      break;\n    }\n    p *= p;\n  }\n  return result;\n}\n", "  var result\
    \ = 0;\n  while(n){\n    if(n & 1){\n      result += p;\n    }\n    n >>>= 1;\n\
    \    p >>>= 1;\n  }\n  return result;\n}\n", "\tvar q = (n & p.MASK)\n\t, mod\
    \ = (n & p.MOD)\n\t, pow = 1;\n\t\n\twhile (q) {\n\t\tpow *= (q & p.MASK);\n\t\
    \tq = (q >> p.SHIFT);\n\t}\n\t\n\t// Convert to an integer(32 bits).\n\tn = ((n\
    \ >> p.SHIFT) * Math.pow(2, p.SHIFT)) % p.MOD;\n\t\n\t// Return an integer.\n\t\
    return (mod * (int)pow);\n}\n", "    var twopi = 2*Math.PI;\n    var a = 0;\n\
    \    var b = 0;\n    for(var i = 0; i <= n; i++){\n      a = (a + Math.cos(b +\
    \ twopi*i)) % p;\n      b = (b + Math.sin(b + twopi*i)) % p;\n    }\n    return\
    \ (a+b) % p;\n}\n", "  var b = 1;\n  while(n > 0){\n    if(n & 1){ b += p; }\n\
    \    n >>>= 1;\n    p ^= p;\n  }\n  return b;\n}\n", "  var i = n - 1,\n     \
    \ val = 1,\n      m = 1;\n  while(i > 0){\n    if(p & 1){\n      val = (val *\
    \ i) % p;\n    }\n    i >>= 1;\n    m <<= 1;\n  }\n  return val;\n}\n", "\tvar\
    \ res = n;\n\twhile (res%p != 0){\n\t\tres -= res;\n\t}\n\treturn res;\n}\n",
  "\treturn (n - 1) % p + p\n}\n", "  var i, x = p[0];\n  for(i = 1; i <= n; i++){\n\
    \    x = x%p;\n  }\n  return x;\n}\n", "    var i = n & -p;\n    return ((i %\
    \ p) + p) % p;\n}\n", "\treturn ((n % p) + p) % p;\n}\n", "  var i; var res =\
    \ []; var a = 1; // Iterate until BPMF's no longer growing (they hit the modulus\
    \ again).\n\n  for(i=1;i<=p;i++){\n    res.push(n % a);\n    res.push(n % b);\n\
    \    a = b;\n    b = a << 1; \n  }\n\n  if((p & 1) == 0){\n    res.push(p);\n\
    \  }\n\n  return res[1] % p; // The low bits of 'a' are \"sticky\": \n  // we\
    \ always take the high bits of 'a' and add it to 'b'.\n  // This may cause the\
    \ high bit of 'a' to overflow though:\n  // >>> modp(99999999999, 111)\n  // 99\n\
    \  // >>> modp(1, 111)\n  // 0\n  // >>> modp(99999999999, 122)\n  // 99\n  //\
    \ >>> modp(2, 122)\n  // 100\n  // >>> modp(99999999999, 999)\n  // 999\n}\n",
  "    var twopi = n.toInt();\n    var mod = twopi%p;\n    if (mod < 0) return mod;\n\
    \    if (mod > p) return mod;\n    if (twopi === p*(p+1)) mod += (p-1)/6;\n  \
    \  return mod;\n}\nexports.modp = modp;\n\n},{}],30:[function(_dereq_,module,exports){\n\
    'use strict';\n\nvar isNumeric = _dereq_('fast-isnumeric');\n", "\treturn ((n\
    \ % p) + p) % p;\n}\n", "  var ret = 0;\n  while(n){\n    if (n%p === 0) ret =\
    \ p; // more often than not, n < p < 10\n    n = Math.floor(n/p);\n  }\n  return\
    \ ret;\n}", "  var a = n%p;\n  var b = n-p;\n  if(a>0){\n    return a;\n  }else\
    \ if(b>0){\n    return b;\n  }else{\n    return n%p;\n  }\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
