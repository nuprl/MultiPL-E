name: HumanEval_160_do_algebra
language: js
prompt: "//Given two lists operator, and operand. The first list has basic algebra\
  \ operations, and \n// the second list is a list of integers. Use the two given\
  \ lists to build the algebric \n// expression and return the evaluation of this\
  \ expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction\
  \ ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation\
  \ ( ** ) \n// Example:\n// operator['+', '*', '-']\n// array = [2, 3, 4, 5]\n//\
  \ result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator\
  \ list is equal to the length of operand list minus one.\n// Operand is a list of\
  \ of non-negative integers.\n// Operator list has at least one operator, and operand\
  \ list has at least two operands.\nfunction do_algebra(operator, operand){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = do_algebra;\n  assert.deepEqual(candidate([\"**\", \"*\", \"+\"], [2, 3, 4,\
  \ 5]),37);\n  assert.deepEqual(candidate([\"+\", \"*\", \"-\"], [2, 3, 4, 5]),9);\n\
  \  assert.deepEqual(candidate([\"//\", \"*\"], [7, 3, 4]),8);\n}\n\ntest();"
completions: ["  let result = 0;\n  for (let i = 0; i < operator.length; i++){\n \
    \   result = result + operand[i] * operator[i]\n  }\n  return result\n}\n", " \
    \   let result = 0;\n    \n    // Add the operands, starting from the left\n \
    \   for(let i = 0; i < operand.length; i++){\n        let operand = operand[i];\n\
    \        // If we are at the end of the operand list, start adding from the left.\n\
    \        // Otherwise, start adding from the right.\n        result += operand;\n\
    \        if (i >= operator.length - 1){\n            break;\n        }\n     \
    \   result += operator[operator.length - 1](operand);\n    }\n\n    // Return\
    \ the result\n    return result;\n}\n", "  \n  for (var i = 0; i < operand.length;\
    \ i++){\n    //console.log(operand[i], operator[i])\n    operand[i] = Number(operand[i])\n\
    \    \n    switch (operator[i]){\n      case \"+\":\n        operand[i] = operand[i]\
    \ + operand[i + 1]\n      break\n      case \"-\":\n        operand[i] = operand[i]\
    \ - operand[i + 1]\n      break\n      case \"*\":\n        operand[i] = operand[i]\
    \ * operand[i + 1]\n      break\n      case \"/\":\n        operand[i] = operand[i]\
    \ / operand[i + 1]\n      break\n      case \"**\":\n        operand[i] = operand[i]\
    \ ** operand[i + 1]\n      break\n      default:\n        throw \"Error: invalid\
    \ operator\"\n      break\n    }\n    \n  }\n  \n  return operand[0]\n}\n", " \
    \ if(operator.length === 0){\n    return 0; \n  } \n  if(operand.length === 1){\n\
    \    return operand[0]; \n  } \n  if(operand.length === 2){\n    if(operator[0]\
    \ === \"*\"){\n      return operand[0]*operand[1];\n    }\n    else if(operator[0]\
    \ === \"/\"){\n      return operand[0]/operand[1];\n    }\n    else if(operator[0]\
    \ === \"+\"){\n      return operand[0]+operand[1];\n    }\n    else if(operator[0]\
    \ === \"-\"){\n      return operand[0]-operand[1];\n    }\n    else if(operator[0]\
    \ === \"^\"){\n      return Math.pow(operand[0],operand[1]);\n    }\n  }\n  else\
    \ {\n    return -1;\n  }\n}\n", "    let result = 0;\n    for(let i = 0; i < operand.length\
    \ - 1; i++){\n        result += operand[i] * operator[operator.length - (i + 1)]\n\
    \    }\n    return result;\n}\n", "    // Your code here!\n    // Your code here!\n\
    \    // Your code here!\n    // Your code here!\n    // Your code here!\n    //\
    \ Your code here!\n    // Your code here!\n    // Your code here!\n    // Your\
    \ code here!\n    // Your code here!\n    // Your code here!\n    // Your code\
    \ here!\n    // Your code here!\n    // Your code here!\n    // Your code here!\n\
    \    // Your code here!\n    // Your code here!\n    // Your code here!\n    //\
    \ Your code here!\n    // Your code here!\n    // Your code here!\n    // Your\
    \ code here!\n    // Your code here!\n    // Your code here!\n    // Your code\
    \ here!\n    // Your code here!\n    // Your code here!\n    // Your code here!\n\
    \    // Your code here!\n    // Your code here!\n    // Your code here!\n    //\
    \ Your code here!\n    // Your code here!\n    // Your code here!\n    // Your\
    \ code here!\n    // Your code here!\n    // Your code here!\n    // Your code\
    \ here!\n    // Your code here!\n    // Your code here!\n    // Your code here!\n\
    \    // Your code here!\n    // Your code here!\n    // Your code here!\n    //\
    \ Your code here!\n    // Your code here!\n    // Your code here!\n    // Your\
    \ code here!\n    // Your code here!\n    // Your code here!\n    // Your code\
    \ here!\n    // Your code here!\n    // Your code here!\n    // Your code here!\n\
    \    // Your code here!\n    // Your code here!\n    // Your code here!\n    //\
    \ Your code here!\n    // Your code here!\n    // Your code here!\n    // Your\
    \ code here!\n    // Your code here!\n    // Your code here!\n    // Your code\
    \ here!\n    // Your code here!\n    // Your code here!\n    // Your code here!\n\
    \    // Your code here!\n    // Your code here!\n    // Your code here!\n    //\
    \ Your code here!\n    // Your code here!\n    // Your code here!\n    // Your\
    \ code here!\n    // Your code here!\n    // Your code here!\n    // Your code\
    \ here!\n    // Your code here!\n    // Your code here!\n    // Your code here!\n\
    \    // Your code here!\n    // Your code here!\n    // Your code here!\n    //\
    \ Your code here!\n    // Your code here!\n    // Your ", "    // First we must\
    \ convert the operands to integers\n    operand = operand.map(function(num){\n\
    \        return parseInt(num);\n    });\n    // And then we must convert the operator\
    \ to characters\n    operator = operator.toUpperCase();\n    // And then we must\
    \ convert the operator to its corresponding function\n    var operatorFunc = {};\n\
    \    for(var i = 0; i < operator.length; i++){\n        operatorFunc[operator[i]]\
    \ = (i + 2);\n    }\n    // And then we must build a function which will perform\
    \ the algebraic operation\n    var evalFunc = function(operand1, operand2){\n\
    \        var num = 0;\n        for(var i = 0; i<operand.length; i++){\n      \
    \      if(operand1[i] != operand2[i]){\n                num = num + operand1[i]\
    \ * operatorFunc[operand[i]];\n            }\n        }\n        return num;\n\
    \    }\n    // And then we must evaluate the given operands using the evalFunc\n\
    \    return evalFunc(operand, operand);\n}\n", "    var arr = []; \n    var val\
    \ = 0;\n    operand.map(function(item) {\n        if(!operator.length) return\
    \ val += item;\n        switch(operator[0]) {\n            case \"+\": return\
    \ val += item; \n            case \"-\": return val -= item; \n            case\
    \ \"*\": return val *= item; \n            case \"//\": return val /= item; \n\
    \            case \"**\": return val **= item;\n        }\n    });\n    return\
    \ val; \n}", "    // console.log('operator', operator)\n    // console.log('operand',\
    \ operand)\n    // Create an empty object as return result of the computation\n\
    \    let result = {}\n    result.value = 0\n\n    // Iterate through all the operators\
    \ in the operator list\n    for(let i = 0; i < operator.length; i++){\n      \
    \  // console.log('i =', i)\n        // Iterate through all the operands in the\
    \ operand list\n        for(let j = 0; j < operand.length; j++){\n           \
    \ // console.log('j =', j)\n            // Evaluate the current combination of\
    \ operator and operand by doing the algebra operation \n            result.value\
    \ += operator[i](operand[j], operand[j+1])\n        }\n    }\n\n    result.value\
    \ = result.value % 10\n    // console.log('result = ', result)\n    return result\n\
    }\n", "\tlet algebric_expression = \"\";\n\tfor(let i = 0; i < operator.length;\
    \ i++){\n\t\tlet op = operator[i];\n\t\tif(algebric_expression == \"\"){\n\t\t\
    \talgebric_expression = op;\n\t\t}else{\n\t\t\talgebric_expression = algebric_expression\
    \ + op;\n\t\t}\n\t}\n\talgebric_expression = algebric_expression + \"( \";\n\t\
    for(let i = 0; i < operand.length; i++){\n\t\tlet operand1 = operand[i];\n\t\t\
    let operand2 = operand[i];\n\t\tlet operand3 = operand[i];\n\t\tlet operand4 =\
    \ operand[i];\n\t\tlet operand5 = operand[i];\n\t\tlet operand6 = operand[i];\n\
    \t\tlet operand7 = operand[i];\n\t\tlet operand8 = operand[i];\n\t\tlet operand9\
    \ = operand[i];\n\t\tlet operand10 = operand[i];\n\t\talgebric_expression = algebric_expression\
    \ + operand1 + \" \" + op + \" \" + operand2 + \" \" + op + \" \" + operand3 +\
    \ \" \" + op + \" \" + operand4 + \" \" + op + \" \" + operand5 + \" \" + op +\
    \ \" \" + operand6 + \" \" + op + \" \" + operand7 + \" \" + op + \" \" + operand8\
    \ + \" \" + op + \" \" + operand9 + \" \" + op + \" \" + operand10 + \" )\";\n\
    \t}\n\treturn eval(algebric_expression);\n}", "\t// Start by putting the operands\
    \ into an array called result\n\tvar result = [];\n\tfor(var i = 0; i < operand.length;\
    \ i++){\n\t\tresult.push(operand[i]);\n\t}\n\t\n\t// Go through each operator\
    \ in the operator list and make corresponding mathematical operation and \n\t\
    // put the result in result array.\n\tfor(var i = 1; i < operator.length; i++){\n\
    \t\tswitch(operator[i]){\n\t\t\tcase '+': result = do_addition(result, operand);\
    \ break;\n\t\t\tcase '-': result = do_subtraction(result, operand); break;\n\t\
    \t\tcase '*': result = do_multiplication(result, operand); break;\n\t\t\tcase\
    \ '/': result = do_division(result, operand); break;\n\t\t\tcase '**': result\
    \ = do_exponentiation(result, operand); break;\n\t\t\tdefault: console.log(\"\
    Error operator in algebra function\");\n\t\t}\n\t}\n\t\n\t// Return the result\
    \ of the operation.\n\treturn result[0];\n}\n", "    var res = [], op;\n    for(var\
    \ i = 0; i < operator.length; i++){\n        op = operator[i];\n        res[i]\
    \ = operand[op.length]\n        for(var j = 1; j < op.length; j++){\n        \
    \    res[i] = res[i] + operand[j];\n        }\n    }\n    return res[0]\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis does not work. `operator` is an array, so `operator[i]`\
    \ is an array, and `operator[i][i]` will throw an error. `operator.indexOf(operator[i])`\
    \ will return the index, but I doubt that this is what OP wants. OP wants to loop\
    \ through the `operator` array, so `operator.indexOf(operator[i])` will always\
    \ be `-1`\n<|/ c |>\n<| c |>\nThis doesn't work either. `operator` is an array,\
    \ not an object, because that would result in a `TypeError: Cannot read property\
    \ '0' of undefined`. See my answer for a working example\n<|/ c |>\n<| a |>\n\
    I got it working by doing this:\n<code>", "    \n    const operands = operand.slice(0);\n\
    \    \n    //console.log(operands);\n    \n    //console.log(\"do_algebra\", operands);\n\
    \    \n    if(operands.length <= 1){\n        console.log(\"do_algebra: ERROR\
    \ - Not enough operands given\", operands.length);\n        throw Error(\"do_algebra:\
    \ Not enough operands given\");\n    }\n\n    for(let i = 0; i < operands.length;\
    \ i++){\n        \n        if(operands[i] < 0){\n            console.log(\"do_algebra:\
    \ ERROR - Negative number is not an operand\", operands[i]);\n            throw\
    \ Error(\"do_algebra: Negative number is not an operand\");\n        }\n    }\n\
    \n    //console.log(\"do_algebra\", operator, operands);\n\n    let result = 0;\n\
    \n    switch(operator){\n        case \"+\": result = operands[0] + operands[1];\
    \ break;\n        case \"-\": result = operands[0] - operands[1]; break;\n   \
    \     case \"*\": result = operands[0] * operands[1]; break;\n        case \"\
    //\": result = operands[0] / operands[1]; break;\n        case \"**\": result\
    \ = operands[0] ** operands[1]; break;\n    }\n\n    return result;\n}\n</code>\n\
    <|/ a tags=arrays,javascript,math dscore=1 |>\n<| a dscore=0 |>\nI haven't tested\
    \ this, but I'd imagine you could make use of Math.pow to help you get to the\
    \ result.\n\n<code>\nlet operator = ['+', '-', '*', '/', '**'];\nlet array = [2,\
    \ 3, 4, 5];\nlet expArr = [];\n", "\t\n\t// Initialise first operand to 0\n\t\
    let first_operand = 0;\n\t\n\t// Initialise second operand to 1\n\tlet second_operand\
    \ = 1;\n\t\n\t// Loop the first list through the first operand\n\tfor(let i=0;\
    \ i<operand.length; i++){\n\t\tfirst_operand += operator[i] * operand[i];\n\t\
    }\n\t\n\t// Loop the second list through the second operand\n\tfor(let i=0; i<operand.length;\
    \ i++){\n\t\tsecond_operand += operator[i] * operand[i];\n\t}\n\t\n\t// Return\
    \ the result\n\treturn first_operand - second_operand;\n}\n", "    let result=0\n\
    \    for(let i=0; i<operator.length; i++){\n        if(operator[i]==\"+\"){\n\
    \            result = result + operand[i]\n        }\n        else if(operator[i]==\"\
    -\"){\n            result = result - operand[i]\n        }\n        else if(operator[i]==\"\
    *\"){\n            result = result * operand[i]\n        }\n        else if(operator[i]==\"\
    //\"){\n            result = result / operand[i]\n        }\n        else if(operator[i]==\"\
    **\"){\n            result = Math.pow(operand[i], operand[i+1])\n        }\n \
    \       else if(operator[i]==\"%\"){\n            result = Math.trunc(operand[i]/operand[i+1])\n\
    \        }\n        else{\n            alert(\"ERROR! The operation \"+operator[i]+\"\
    \ is not supported!\")\n            console.log(operator)\n            console.log(operand)\n\
    \            return\n        }\n    }\n    return result\n}\n", "\tlet result_list\
    \ = []\n\tlet operator_index = 0\n\tlet operand_index = 0\n\n\t//while there are\
    \ more operands left in operand list\n\twhile(operand_index < operand.length){\n\
    \n\t\t//while there are still operators in operator list\n\t\twhile(operator_index\
    \ < operator.length){\n\t\t\t//if the operators in the operator list match the\
    \ operands in the operand list\n\t\t\tif(operand[operand_index] == operator[operator_index]){\n\
    \t\t\t\t//for each operator in the operator list, perform the corresponding operation\
    \ on operands\n\t\t\t\tswitch(operator[operator_index]){\n\t\t\t\t\t//Addition\
    \ ( + )\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\tresult_list.push(operand[operand_index]\
    \ + operand[operand_index + 1])\n\t\t\t\t\t\toperand_index += 2\n\t\t\t\t\t\t\
    break\n\n\t\t\t\t\t//Subtraction ( - )\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tresult_list.push(operand[operand_index]\
    \ - operand[operand_index + 1])\n\t\t\t\t\t\toperand_index += 2\n\t\t\t\t\t\t\
    break\n\n\t\t\t\t\t//Multiplication ( * )\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tresult_list.push(operand[operand_index]\
    \ * operand[operand_index + 1])\n\t\t\t\t\t\toperand_index += 2\n\t\t\t\t\t\t\
    break\n\n\t\t\t\t\t//Floor division ( // )\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\
    result_list.push(Math.floor(operand[operand_index] / operand[operand_index + 1]))\n\
    \t\t\t\t\t\toperand_index += 2\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\t//Exponentiation\
    \ ( ** )\n\t\t\t\t\tcase '^':\n\t\t\t\t\t\tresult_list.push(Math.pow(operand[operand_index],\
    \ operand[operand_index + 1]))\n\t\t\t\t\t\toperand_index += 2\n\t\t\t\t\t\tbreak\n\
    \t\t\t\t}\n\t\t\t}\n\n\t\t\t//If the operators in the operator list don't match\
    \ the operands in the operand list\n\t\t\telse{\n\t\t\t\t//increment the operator_index\
    \ \n\t\t\t\toperator_index += 1\n\t\t\t}\n\t\t}\n\n\t\t//If the operators in the\
    \ operator list have no more operands\n\t\tif(operator_index >= operator.length){\n\
    \t\t\t//increment the operand_index\n\t\t\toperand_index += 1\n\t\t\t//add the\
    \ result to the result list\n\t\t\tresult_list.push(0)\n\t\t}\n\n\t\t//If the\
    \ operators in the operator list have no more operands\n\t\telse{\n\t\t\t//increment\
    \ the operand_index\n\t\t\toperand_index += 1\n\t\t}\n\t}\n\n\t//return the result\
    \ list\n\treturn result_list\n}\n", "\t\n\tlet operator_index = 0\n\tlet result\
    \ = 0\n\t\n\twhile(operator_index < operator.length && operand[operand_index]\
    \ >= 0){\n\t\tlet op = operator[operator_index]\n\t\tlet operand1 = operand[operand_index]\n\
    \t\toperand_index++\n\t\t\n\t\twhile(operand_index < operand.length && operand[operand_index]\
    \ >= 0){\n\t\t\tresult = result + operand[operand_index] * op\n\t\t\toperand_index++\n\
    \t\t}\n\t}\n\treturn result\n}\n", "\tvar result = operand[0];\n\toperand.forEach(function(value,\
    \ i){\n\t\tswitch(operator[i]){\n\t\t\tcase '+':\n\t\t\t\tresult += value;\n\t\
    \t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tresult -= value;\n\t\t\t\tbreak;\n\t\t\t\
    case '*':\n\t\t\t\tresult *= value;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\t\
    result /= value;\n\t\t\t\tbreak;\n\t\t\tcase '**':\n\t\t\t\tresult **= value;\n\
    \t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.log(\"Invalid operator in expression\"\
    );\n\t\t\t\tbreak;\n\t\t}\n\t});\n\treturn result;\n}\n", "  var result = 0;\n\
    \n  for(var i = 0; i < operator.length; i++){\n    switch(operator[i]){\n    \
    \  case '+': result += operand[i]; break;\n      case '-': result -= operand[i];\
    \ break;\n      case '*': result *= operand[i]; break;\n      case '//': result\
    \ /= operand[i]; break;\n      case '**': result **= operand[i]; break;\n    }\n\
    \  }\n\n  return result;\n}</code>\n<|/ a |>\n<| a dscore=0 |>\nI used a similar\
    \ method to answer this question but used a recursive function to build the mathematical\
    \ expression. \n\n<code>", "\t\n\t//Calculate the number of steps in an iteration,\
    \ or number of times the algebric expression is repeated\n\tvar steps = get_number_step(operator.length,\
    \ operand.length)\n\n\t//Initialize an array for the algebric expression \n\t\
    var algebric_expression = [];\n\n\t//Loop through each step\n\tfor(var i=0; i<steps;\
    \ i++) {\n\t\t\n\t\t//Initialize a counter to keep track of how many times the\
    \ algebric expression has been repeated\n\t\tvar counter = 0;\n\t\t\n\t\t//Loop\
    \ through the operations\n\t\tfor(var j=0; j<operator.length; j++) {\n\t\t\t\n\
    \t\t\t//Get rid of commas between the operands\n\t\t\tvar operand1 = operand[i-1].split(operator[j]);\n\
    \t\t\toperand1 = operand1[0].trim().split(operator[j]);\n\t\t\t\n\t\t\t//Get the\
    \ number of operands after doing the operation\n\t\t\tvar operand2 = operand[i].split(operator[j]);\n\
    \t\t\toperand2 = operand2[0].trim().split(operator[j]);\n\t\t\t\n\t\t\t//Convert\
    \ the operands to integers\n\t\t\toperand1 = get_integer_value(operand1[0], operand1[1]);\n\
    \t\t\toperand2 = get_integer_value(operand2[0], operand2[1]);\n\t\t\t\n\t\t\t\
    //Get the value of each operand and perform the operation\n\t\t\tvar value = operand1[j]\
    \ - operand2[j]\n\t\t\t\n\t\t\t//Keep a running sum of all the values \n\t\t\t\
    algebric_expression.push(value);\n\t\t\tcounter++;\n\t\t}\n\t\t\n\t\t//Update\
    \ the operand to be the result of the operation\n\t\toperand[i] = algebric_expression.join(operator);\n\
    \t}\n\n\t//Return the result of the operation\n\treturn operand.join(operator);\n\
    }\n", "    if(operator.length != operand.length-1){\n        console.log(\"Bad\
    \ number of operands for operation\");\n        return;\n    }\n    var result\
    \ = operand[0];\n    for(let i = 1; i < operand.length; i++){\n        let num1\
    \ = operand[i];\n        let num2 = operand[i-1];\n        if(operator[0] == '+'){\n\
    \            result += num2;\n        }else if(operator[0] == '*'){\n        \
    \    result *= num2;\n        }else if(operator[0] == '-'){\n            result\
    \ -= num2;\n        }else if(operator[0] == '/'){\n            result = num2 /\
    \ num1;\n        }else if(operator[0] == '**'){\n            result *= num1;\n\
    \            result *= num2;\n        }else if(operator[0] == '%'){\n        \
    \    result *= num1;\n            result %= num2;\n        }\n    }\n    return\
    \ result;\n}", "    //If the given operand list is of length one or zero or null\n\
    \    //Return 0 \n    if(operand.length == 0){\n        return 0;\n    }\n\n \
    \   //If the given operand list is of length two\n    //If the first operand in\
    \ operand list is less than the second operand in operand list\n    //Return null\
    \ \n    if(operand.length == 1){\n        if(operand[0] < operand[1]){\n     \
    \       return null;\n        }\n    }\n    //If the given operand list is of\
    \ length two\n    else if(operand.length == 2){\n        //If the first operand\
    \ in operand list is greater than the second operand in operand list\n       \
    \ //Return null \n        if(operand[0] > operand[1]){\n            return null;\n\
    \        }\n    }\n    //If the given operand list is of length three\n    //If\
    \ the second operand in operand list is less than the first operand in operand\
    \ list\n    //Return null \n    else if(operand.length == 3){\n        if(operand[1]\
    \ < operand[0]){\n            return null;\n        }\n    }\n    //If the given\
    \ operand list is of length three\n    else if(operand.length == 4){\n       \
    \ //If the second operand in operand list is greater than the first operand in\
    \ operand list\n        //Return null \n        if(operand[1] > operand[0]){\n\
    \            return null;\n        }\n    }\n    //If the given operand list is\
    \ of length five\n    //If the third operand in operand list is less than the\
    \ second operand in operand list\n    //Return null \n    else if(operand.length\
    \ == 5){\n        if(operand[2] < operand[1]){\n            return null;\n   \
    \     }\n    }\n    //If the given operand list is of length five\n    else if(operand.length\
    \ == 6){\n        //If the third operand in operand list is greater than the first\
    \ operand in operand list\n        //Return null \n        if(operand[2] > operand[1]){\n\
    \            return null;\n        }\n    }\n    //If the given operand list is\
    \ of length seven\n    //If the fourth operand in operand list is less than the\
    \ third operand in operand list\n    //Return null \n    else if(operand.length\
    \ == 7){\n        if(operand[3] < operand[2]){\n            return null;\n   \
    \     }\n    }\n    //If the given operand list is of length seven\n    else if(operand.length\
    \ == 8){\n        //If the fourth operand in operand list is greater than the\
    \ third operand in operand list\n        //Return null \n        if(operand[3]\
    \ > operand[2]){\n            return null;\n        }\n    }\n    //If the given\
    \ operand list is of length nine\n    //If the fifth operand in operand list is\
    \ less than the fourth operand in operand list\n    //Return null \n    else if(operand.length\
    \ == 9){\n        if(operand[4] < operand[3]){\n            return null;\n   \
    \     }\n    }\n    //If the given operand list is of length nine\n    else if(operand.length\
    \ == 10){\n        //If the fifth operand in ", "\tvar operator_index = 0\n\t\
    while(operator_index < operator.length && operand[operator_index] < operand.length){\n\
    \t\tthis[operator[operator_index]](operand[operator_index++])\n\t}\n\treturn this[0]\n\
    }", "    var result = 0;\n    var i = 0;\n    while(i < operator.length){\n  \
    \      result = result + operand[i] * operator[(i + 1) + operand.length];\n  \
    \      i++;\n    }\n    return result;\n}\n", "    let sum = 0;\n    for(let i\
    \ = 0; i < operand.length; i++){\n        switch(operator[i]){\n            case\
    \ '+':\n                sum += operand[i];\n                break;\n         \
    \   case '-':\n                sum -= operand[i];\n                break;\n  \
    \          case '*':\n                sum *= operand[i];\n                break;\n\
    \            case '/':\n                sum /= operand[i];\n                break;\n\
    \            case '//':\n                sum += operand[i] % 2 === 0 ? operand[i]\
    \ : operand[i] * operand[i];\n                break;\n            case '**':\n\
    \                sum += Math.pow(operand[i], operand.length);\n              \
    \  break;\n            default:\n                break;\n        }\n    }\n  \
    \  return sum;\n}\n", "    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your code here\n    // Your code here\n\
    \    // Your code here\n    // Your code here\n    // Your code here\n    // Your\
    \ code here\n    // Your code here\n    // Your ", "  \n  if(operator.length !==\
    \ operand.length-1){\n    throw \"Invalid Parameter!\";\n  }\n  \n  switch(operator[0]){\n\
    \    \n    case \"+\":\n      \n      let result = 0;\n      let i = 1;\n    \
    \  while(i<operand.length){\n        result = result + operand[i-1];\n       \
    \ i++;\n      }\n      return result;\n      \n    case \"-\":\n      \n     \
    \ let result = 0;\n      let i = 1;\n      while(i<operand.length){\n        result\
    \ = result - operand[i-1];\n        i++;\n      }\n      return result;\n    \
    \  \n    case \"*\":\n      \n      let result = 0;\n      let i = 1;\n      while(i<operand.length){\n\
    \        result = result + operand[i-1]*operand[i-1];\n        i++;\n      }\n\
    \      return result;\n      \n    case \"//\":\n      \n      let result = 0;\n\
    \      let i = 1;\n      while(i<operand.length){\n        result = result + operand[i-1]/operand[i-1];\n\
    \        i++;\n      }\n      return result;\n      \n    case \"**\":\n     \
    \ \n      let result = 0;\n      let i = 1;\n      while(i<operand.length){\n\
    \        result = result + operand[i-1]**operand[i-1];\n        i++;\n      }\n\
    \      return result;\n      \n    default:\n      throw \"Invalid Operator!\"\
    ;\n  }\n}\n", "  var result = 0;\n  var operators = operator.split('+');\n  for\
    \ (var i = 0; i < operators.length; i++){\n    result += operand[i] * eval(operators[i]);\n\
    \  }\n  return result;\n}\n", "\t// TODO: Implement this\n}\n", "\tif(operator\
    \ == \"+\" || operator == \"-\" || operator == \"*\" || operator == \"/\"){\n\t\
    \treturn eval(eval(operand[0]) + eval(operand[1]));\n\t}\n\tif(operator == \"\
    **\"){\n\t\treturn Math.pow(eval(operand[0]), eval(operand[1]));\n\t}\n}\n<|/\
    \ file dstars=0 filename=main.js |>", "    var result = 0;\n    // If no operands\
    \ or operators then return 0\n    if(!operand.length || !operator.length){\n \
    \       return 0;\n    }\n    \n    // If first element of operator array is not\
    \ a basic algebra operation then return 0\n    if(operator[0] !== '+' && operator[0]\
    \ !== '-' && operator[0] !== '*' && operator[0] !== '/' && operator[0] !== '^'){\n\
    \        return 0;\n    }\n    \n    // The length of the operand list minus one\
    \ is equal to the length of operator list minus one\n    // This means there are\
    \ no unary operators.\n    if(operand.length < operator.length){\n        // The\
    \ length of operand array is equal to the length of operator array minus one\n\
    \        // This means there is only one unary operator\n        if(operator.length\
    \ === 1){\n            return 0;\n        }\n        // There are unary operators.\
    \ First remove the first element from operator array and use it to \n        //\
    \ build operand array.\n        operand = operand.splice(0, 1);\n    }\n    \n\
    \    // Iterate through operator array from index 1 up to and including index\
    \ length of operand array\n    for(var i = 0; i < operator.length; i++){\n   \
    \     // Each operand value is multiplied by the corresponding operation from\
    \ the operator array \n        // and added to the result variable\n        result\
    \ += operand[i] * operator[i];\n    }\n    return result;\n}\n", "    var i, j,\
    \ k, l = 0, m = 0, n = 0;\n    var operation = operator[operand[0]];\n    var\
    \ result = null;\n    var result_op = null;\n    \n    //Go through each operand\
    \ and compare it with operator list\n    for(i=0; i<operand.length; i++){\n  \
    \      if(operand[i] != operator[j]){\n            result = null;\n        }\n\
    \        else{\n            result = (operation == \"-\") ? operand[i] - operand[i+1]\
    \ : (operation == \"+\") ? operand[i] + operand[i+1] : operand[i] * operand[i+1];\n\
    \            result_op = operation;\n        }\n        \n        //If first operand\
    \ is same with next then repeat operation\n        if(i != 0 && operand[i] ==\
    \ operator[j]){\n            operation += operator[j];\n            j++;\n   \
    \     }\n        \n        l += operand[i];\n        m++;\n    }\n    \n    \n\
    \    //If not same with last then repeat operation for last operand\n    if(i\
    \ == operand.length - 1){\n        result = null;\n        for(i=0; i<operand.length;\
    \ i++){\n            if(operand[i] != operator[j]){\n                result =\
    \ null;\n            }\n            else{\n                result = (operation\
    \ == \"-\") ? operand[i] - operand[i-1] : (operation == \"+\") ? operand[i] +\
    \ operand[i-1] : operand[i] * operand[i-1];\n                result_op = operation;\n\
    \            }\n            \n            n += operand[i];\n        }\n    }\n\
    \    \n    //Do algebra and return result\n    switch(operation){\n        case\
    \ \"+\":\n            result = l + (m * n);\n        break;\n        case \"-\"\
    :\n            result = l - (m * n);\n        break;\n        case \"*\":\n  \
    \          result = l - (m * n);\n        break;\n        case \"/\":\n      \
    \      result = l + (m * n);\n        break;\n        case \"**\":\n         \
    \   result = Math.pow(l,m);\n        break;\n    }\n    \n    if(result == null){\n\
    \        result = \"NaN\";\n    }\n    \n    return result;\n}\n\n", "    if (operator.length\
    \ !== operand.length - 1) throw \"Operator list length is incorrect\";\n    if\
    \ (operator === null || operand === null) throw \"The operator or operand list\
    \ is null\";\n    if (operator.length === 0) return operand[0];\n    if (operand.length\
    \ === 0) return null;\n    switch (operator[0]){\n        case '+':\n        \
    \    return operand[0] + do_algebra(operator, operand.slice(1));\n        case\
    \ '-':\n            return operand[0] - do_algebra(operator, operand.slice(1));\n\
    \        case '*':\n            return operand[0] * do_algebra(operator, operand.slice(1));\n\
    \        case '//':\n            return operand[0] / do_algebra(operator, operand.slice(1));\n\
    \        case '**':\n            return operand[0] ** do_algebra(operator, operand.slice(1));\n\
    \        default:\n            throw \"Operator is unknown\";\n    }\n};\n", " \
    \   //Initializations\n    let expression = \"\"; //This will contain the final\
    \ result\n    let result = 0; //This will contain the result of arithmetic expression\n\
    \    //Looping\n    for (let i = 0; i < operator.length; i++){\n        //Mathematical\
    \ operation\n        //Operand 1\n        if (operator[i] === \"+\"){\n      \
    \      //Result is addition of operand 1 and the result of operation on operand\
    \ 2\n            result = result + operand[i]\n            //Operand 2\n     \
    \   } else if (operator[i] === \"-\"){\n            //Result is subtraction of\
    \ operand 1 and the result of operation on operand 2\n            result = result\
    \ - operand[i]\n            //Operand 2\n        } else if (operator[i] === \"\
    *\"){\n            //Result is multiplication of operand 1 and the result of operation\
    \ on operand 2\n            result = result * operand[i]\n            //Operand\
    \ 2\n        } else if (operator[i] === \"//\"){\n            //Result is division\
    \ of operand 1 and the result of operation on operand 2\n            result =\
    \ result / operand[i]\n            //Operand 2\n        } else if (operator[i]\
    \ === \"**\"){\n            //Result is exponentiation of operand 1 and the result\
    \ of operation on operand 2\n            result = result ** operand[i]\n     \
    \       //Operand 2\n        }\n    }\n    //Final result\n    expression = result;\n\
    \    return expression;\n}", "  var result = 0;\n  for (var i in operator){\n\
    \    result = result + operand[i] * operator[i];\n  }\n  return result;\n}\n",
  "\tlet result = 0\n\tlet operatorIndex = -1\n\tfor (let i = 0; i < operator.length\
    \ - 1; i++){\n\t\tif (operand[i] == operator[i]){\n\t\t\toperatorIndex = i\n\t\
    \t\tbreak\n\t\t}\n\t}\n\tif (operatorIndex == -1){\n\t\tconsole.log(\"Invalid\
    \ operator\")\n\t\treturn 0\n\t}\n\tfor (let i = 0; i < operand.length; i++){\n\
    \t\tif (operand[i] >= 0){\n\t\t\tresult += (operand[i] * operator[operatorIndex])\n\
    \t\t}\n\t}\n\treturn result\n}\n", "    // console.log(operator)\n    // console.log(operand)\n\
    \n    // Find the length of operator list and the length of operand list minus\
    \ one.\n    let op_length = operator.length;\n    let op_array_length = op_length\
    \ - 1;\n    let num_operand = operand.length - op_array_length;\n\n    // Convert\
    \ each operand element to an integer. Store the result as operand.\n    operand.map(e\
    \ => parseInt(e));\n\n    // console.log(operand)\n    // console.log(op_array_length)\n\
    \n    // Initialization of expression\n    let expression = \"\";\n    // console.log(operand)\n\
    \    // console.log(num_operand)\n    // console.log(operator)\n    // console.log(op_array_length)\n\
    \    // console.log(num_operand)\n\n    // Evaluate expression\n    for (let i\
    \ = 0; i < num_operand; i++){\n        // console.log(operand)\n        // console.log(num_operand)\n\
    \        // console.log(operator)\n        // console.log(op_array_length)\n \
    \       // console.log(num_operand)\n        if (operator[0] == \"+\"){\n    \
    \        // console.log(operand)\n            // console.log(num_operand)\n  \
    \          // console.log(operator)\n            // console.log(op_array_length)\n\
    \            // console.log(num_operand)\n            expression += operand[i]\
    \ + operand[i+1];\n            // console.log(expression);\n        } else if\
    \ (operator[0] == \"-\"){\n            // console.log(operand)\n            //\
    \ console.log(num_operand)\n            // console.log(operator)\n           \
    \ // console.log(op_array_length)\n            // console.log(num_operand)\n \
    \           expression += operand[i] - operand[i+1];\n            // console.log(expression);\n\
    \        } else if (operator[0] == \"*\"){\n            // console.log(operand)\n\
    \            // console.log(num_operand)\n            // console.log(operator)\n\
    \            // console.log(op_array_length)\n            // console.log(num_operand)\n\
    \            expression += operand[i] * operand[i+1];\n            // console.log(expression);\n\
    \        } else if (operator[0] == \"//\"){\n            // console.log(operand)\n\
    \            // console.log(num_operand)\n            // console.log(operator)\n\
    \            // console.log(op_array_length)\n            // console.log(num_operand)\n\
    \            expression += operand[i] / operand[i+1];\n            // console.log(expression);\n\
    \        } else if (operator[0] == \"**\"){\n            // console.log(operand)\n\
    \            // console.log(num_operand)\n            // console.log(operator)\n\
    \            // console.log(op_array_length)\n            // console.log(num_operand)\n\
    \            expression += operand[i] ** operand[i+1];\n            // console.log(expression);\n\
    \        }\n\n        // console.log(expression)\n    }\n\n    // return expression;\n\
    }\n", "    var left = 0;\n    var right = 0;\n    var operator_index = 0;\n  \
    \  \n    //first we evaluate the operand list to see if all its elements are non-negative\n\
    \    if(operand.length < 1){\n        return 0;\n    }\n    \n    //now we do\
    \ the same with the operator list to see if all its elements are operators, \n\
    \    // and if all its elements are non-negative\n    if(operator.length < 1){\n\
    \        return 0;\n    }\n    \n    //now we do the same with the operator list\
    \ to see if all its elements are non-negative\n    for(var i = 0; i < operator.length;\
    \ i++){\n        if(operator[i] < 0){\n            return 0;\n        }\n    }\n\
    \    \n    //here we do all the checking for valid operations and operands, \n\
    \    // and if everything is valid we do the algebric calculation\n    for(var\
    \ i = 0; i < operand.length; i++){\n        var left_is_negative = false;\n  \
    \      var right_is_negative = false;\n        var temp = 0;\n        \n     \
    \   //we first check if the left operand is negative\n        if(operand[i] <\
    \ 0){\n            left_is_negative = true;\n        }\n        \n        //same\
    \ for right operand\n        if(operand.length > 1){\n            right_is_negative\
    \ = true;\n        }\n        \n        //now we check the operator list for valid\
    \ operations, if its elements are valid, \n        // and if its elements are\
    \ non-negative\n        for(var j = 0; j < operator.length; j++){\n          \
    \  \n            //we check the current operator list element against all the\
    \ operators in the \n            // given operator list, and if they all match\
    \ we set the operator index\n            if((operator[j] == operator_index) &&\
    \ (operand[i] != 0)){\n                operator_index = j;\n            }\n  \
    \          \n            //we then check if the current operand list element is\
    \ an operator, and if \n            // its a valid operator index and if the current\
    \ operand list element is non-negative\n            if((operand[i] == operator[j])\
    \ && (operator[j] >= 0) && (operand[i] != 0)){\n                \n           \
    \     //if the current list element is the same operator as the one we found earlier,\n\
    \                // then we can just use the current element to calculate the\
    \ next one\n                if((operand[i] == operator[j]) && (operand[i] != operator_index)){\n\
    \                    temp = operand[i];\n                }\n                \n\
    \                //if its not a match, then we check to see if that element is\
    \ a valid operator,\n                // and if its a valid operator index and\
    \ if the current element is not \n                // a match\n               \
    \ else if((operand[i] != operator[j]) && (operator[j] >= 0) && (operand[i] !=\
    \ operator_index)){\n                    \n                    //if its the same\
    \ operator as the one we found earlier, \n                    // then we use the\
    \ current element to calculate the next one\n                    if((operand[i]\
    \ == operator[j]) && (operand[i] != operator_index)){", "  //The result of the\
    \ algebra operation\n  var result = 0;\n\n  //Loop through all the operands of\
    \ the operand\n  for (var i = 0; i < operand.length; i++){\n    //Do the math\
    \ for each operand\n    switch(operator[i]){\n      case '+':\n        //Add two\
    \ operands\n        result += operand[i];\n        break;\n      case '-':\n \
    \       //Subtract two operands\n        result -= operand[i];\n        break;\n\
    \      case '*':\n        //Multiply two operands\n        result *= operand[i];\n\
    \        break;\n      case '//':\n        //Floor division\n        result /=\
    \ operand[i];\n        break;\n      case '**':\n        //Exponentiation\n  \
    \      result *= operand[i];\n    }\n  }\n\n  //Return the result of the algebra\n\
    \  return result;\n}\n", "  if(operator.length !== operand.length -1) return -1;\n\
    \  let result = 0;\n  for(let i = 0; i < operator.length; i++){\n    let first_value\
    \ = operand[i-1];\n    let second_value = operand[i+1];\n    switch(operator[i]){\n\
    \      case \"+\":\n        result += first_value;\n        break;\n      case\
    \ \"-\":\n        result -= first_value;\n        break;\n      case \"*\":\n\
    \        result *= first_value;\n        break;\n      case \"/\":\n        result\
    \ /= first_value;\n        break;\n      case \"//\":\n        result /= first_value;\n\
    \        break;\n      case \"**\":\n        result *= Math.pow(first_value, second_value);\n\
    \        break;\n      default:\n        console.error('Error: undefined operator\
    \ in do_algebra');\n        return -1;\n    }\n  }\n  return result;\n}\n", "\t\n\
    \t// Initialise the result and operand count\n\tvar result = 0;\n\tvar count_operand\
    \ = 0;\n\t\n\t// Loop through the operand array\n\tfor(var i = 1; i < operand.length;\
    \ i++){\n\t\t\n\t\t// If an operand in the operand array is larger than the current\
    \ result\n\t\tif((operand[i] > result)){\n\t\t\t\n\t\t\t// Set the result to the\
    \ current operand\n\t\t\tresult = operand[i];\n\t\t\t\n\t\t\t// Increment the\
    \ operand count\n\t\t\tcount_operand = 1;\n\t\t\t\n\t\t\t// If there is only one\
    \ operand, then break the loop\n\t\t\tif(operand.length == 1){\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t\t\n\t\t// Otherwise if an operand in the operand array is the\
    \ same as the current result\n\t\telse if((operand[i] == result)){\n\t\t\t\n\t\
    \t\t// Add the current operand to the result\n\t\t\tresult = result + operand[i];\n\
    \t\t\t\n\t\t\t// Increment the operand count\n\t\t\tcount_operand = count_operand\
    \ + 1;\n\t\t}\n\t}\n\t\n\t// If there is only one operand and the result is the\
    \ same as the result of the \n\t// first operand, then there are no algebraic\
    \ operations to perform\n\tif(count_operand == 1 && result == operand[0]){\n\t\
    \treturn result;\n\t}\n\t\n\t// Otherwise, loop through the operator array\n\t\
    for(var j = 0; j < operator.length; j++){\n\t\t\n\t\t// Perform the operation\
    \ on the two operands using the current operator\n\t\tresult = do_calculation(result,\
    \ operator[j], operand[j]);\n\t\t\n\t\t// If there are two operands and the first\
    \ one is the result of the operation\n\t\t// and the second operand is larger\
    \ than the result of the operation\n\t\tif((operand.length > 1) && (result > operand[0])\
    \ && result > operand[1]){\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n",
  "\t//First let's convert the operand list into an array\n\tvar operandArray = operand.split('');\n\
    \t\n\t//Now let's convert the operator list into an array\n\tvar operatorArray\
    \ = operator.split('');\n\n\t//Now let's loop through the operand list and apply\
    \ the operators to each operand.\n\tvar result = 0;\n\tvar i = 0;\n\tfor(; i <\
    \ operandArray.length-1; i++){\n\t\tvar newOperand = operandArray[i] + operandArray[i+1];\n\
    \t\tvar currentOperand = operandArray[i];\n\t\tvar newOperator = operatorArray[i];\n\
    \t\tvar newOperatorPrev = operatorArray[i+1];\n\t\t//Now let's apply the operation\n\
    \t\tswitch(newOperator){\n\t\t\tcase '+': result = newOperand + currentOperand;\
    \ break;\n\t\t\tcase '-': result = newOperand - currentOperand; break;\n\t\t\t\
    case '*': result = newOperand * currentOperand; break;\n\t\t\tcase '//': result\
    \ = newOperand / currentOperand; break;\n\t\t\tcase '**': result = Math.pow(newOperand,\
    \ currentOperand); break;\n\t\t\tdefault: break;\n\t\t}\n\t\t//Now let's apply\
    \ the previous operator\n\t\tswitch(newOperatorPrev){\n\t\t\tcase '+': result\
    \ += currentOperand; break;\n\t\t\tcase '-': result -= currentOperand; break;\n\
    \t\t\tcase '*': result *= currentOperand; break;\n\t\t\tcase '//': result = result\
    \ / currentOperand; break;\n\t\t\tcase '**': result = Math.pow(result, currentOperand);\
    \ break;\n\t\t\tdefault: break;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n", "   \
    \ let expression = '';\n    for(let i = 0; i < operator.length; i++){\n      \
    \  expression += `${operator[i]}(${operand[i]})`;\n    }\n    return eval(expression);\n\
    }\n", "\t// TODO: Write your code here\n}\n", "\tlet result = \"\"\n\toperand.forEach((element,\
    \ index, array) => {\n\t\tif(index > 0 && index < array.length - 1){\n\t\t\tif(operator[index]\
    \ == operator[index - 1]){\n\t\t\t\tresult += element\n\t\t\t}else{\n\t\t\t\t\
    result += operator[index] + operand + element\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\
    \tresult += operand + element\n\t\t}\n\t})\n\treturn eval(result)\n}\n", "\toperator\
    \ = operator.split('+');\n\toperand = operand.map(n => Number(n));\n\tvar result\
    \ = operand.reduce((acc,num,i) => ((acc[operator[i]]) ? acc[operator[i]](num,acc)\
    \ : num), operand[0]);\n\treturn result;\n}\n", "\tlet op_array = [], \n\t\top_index\
    \ = 0, \n\t\tops = [],\n\t\tindex = 0, \n\t\tresult = 0;\n\t\t\n\tfor(let i =\
    \ 0, len = operand.length - 1; i < len; i++){\n\t\top_array.push(operand[i]);\n\
    \t\tindex = operator[op_index];\n\t\tindex -= 1;\n\t\tops.push(index);\n\t\top_index\
    \ += 1;\n\t}\n\n\tfor(let i = 0, len = op_array.length; i < len; i++){\n\t\tresult\
    \ += op_array[i] * ops[i];\n\t}\n\t\n\treturn result;\n}\n", "  let ops = operator;\n\
    \  let ind = operand.length - 1;\n  let result = '';\n  while(ind-- > 0){\n  \
    \  let i = ops[ind];\n    if (i === '-'){\n      result = result - operand[ind];\n\
    \    }else if (i === '*'){\n      result = result * operand[ind];\n    }else if\
    \ (i === '/'){\n      result = result / operand[ind];\n    }else if (i === '**'){\n\
    \      result = result ** operand[ind];\n    }else if (i === '//'){\n      result\
    \ = result // operand[ind];\n    }else{\n      result = result + operand[ind];\n\
    \    }\n  }\n  return result;\n}\n", "  var res = 0; //To store your results.\n\
    \  //While there are still operators and operands to process,\n  while(operator.length\
    \ > 0 && operand.length > 0){\n    //Process the next operator\n    var temp =\
    \ operand.pop();\n    switch(operator.shift()){\n      case \"+\": res = res +\
    \ temp; break;\n      case \"-\": res = res - temp; break;\n      case \"*\":\
    \ res = res * temp; break;\n      case \"/\": res = res / temp; break;\n     \
    \ case \"**\": res = Math.pow(res, temp); break;\n    }\n  }\n  //Return the result\n\
    \  return res;\n}\n", "    //If operator and operand have different lengths, throw\
    \ an exception.\n    if(operand.length < operator.length){\n        throw \"Error:\
    \ Operand list must contain at least one operand.\";\n    }\n    \n    //Initialize\
    \ an expression stack to store the result of operations \n    //(as opposed to\
    \ operands). \n    var expressionStack = [];\n\n    //Push the first operand (the\
    \ first operand)\n    expressionStack.push(operand[0]);\n\n    //While there are\
    \ operations in the stack\n    while(expressionStack.length > 0){\n        //Get\
    \ the top of an expression stack\n        var currentExpression = expressionStack[expressionStack.length\
    \ - 1];\n\n        //Get the top operator of the expression stack\n        var\
    \ currentOperator = operator[expressionStack.length - 1];\n\n        //If an operator\
    \ is found on top of an expression in the stack \n        //then remove it from\
    \ the stack.\n        if(expressionStack.length > 0){\n            //If the top\
    \ operator of the expression stack matches the \n            // top operator of\
    \ the current operation, then pop the current\n            //expression off the\
    \ stack, and push the new value of the expression\n            //stack to the\
    \ result of the operation.\n            if(currentOperator == expressionStack[expressionStack.length\
    \ - 1]){\n                expressionStack.pop();\n            }\n\n          \
    \  //If the operator of the current expression is the same as the operator\n \
    \           // of the current operation, then push the value of the expression\n\
    \            //stack to the result of the operation.\n            else if(currentOperator\
    \ == operator[expressionStack.length -1]){\n                expressionStack.push(expressionStack[expressionStack.length\
    \ - 1]);\n            }\n        }\n        //If the operator is found at the\
    \ top of an expression stack then\n        //push the value of the expression\
    \ stack to the result of the operation.\n        else if(currentOperator == operator[expressionStack.length\
    \ -1]){\n            expressionStack.push(expressionStack[expressionStack.length\
    \ - 1]);\n        }\n        //If the operator is not found at the top of an expression\
    \ stack \n        //then push the value of the expression stack to the result\
    \ of the operation.\n        else{\n            //If the top operator of the expression\
    \ stack is not the same \n            // as the operator of the current operation,\
    \ then push the value\n            //of the expression stack to the result of\
    \ the operation.\n            if(currentOperator != operator[expressionStack.length\
    \ -1]){\n                expressionStack.push(expressionStack[expressionStack.length\
    \ - 1]);\n            }\n            //If the top operator of the expression stack\
    \ is the same as the \n            // operator of the current operation, then\
    \ push the value of the expression \n            // stack to the result of the\
    \ operation.\n            else{\n                expressionStack.push(expressionStack[expressionStack.length\
    \ - 1]);\n            }\n        }\n    }\n    //Return the result of the expression\
    \ stack.\n    return expressionStack[0];\n}\n", "\tvar sum = 0;\n\tfor(var i in\
    \ operand){\n\t\tsum += operand[i];\n\t}\n\tfor(var i in operator){\n\t\tsum +=\
    \ operator[i] * operand[i];\n\t}\n\treturn sum;\n}\n", "    var result = 0;\n\
    \    for(var i=0; i<operand.length; i++){\n        switch(operator[i]){\n    \
    \        case '+': result += operand[i]; break;\n            case '-': result\
    \ -= operand[i]; break;\n            case '*': result *= operand[i]; break;\n\
    \            case '//': result /= operand[i]; break;\n            case '**': result\
    \ = Math.pow(operand[i]); break;\n        }\n    }\n    return result;\n}\n",
  "\tlet list1 = operand.slice(0);\n\tlet list2 = operator.slice(0);\n\tlist1.pop();\n\
    \tlist2.pop();\n\tlet result = [];\n\tlist1.forEach((item) => {\n\t\tresult.push(do_evaluation(item,\
    \ list2, list1));\n\t});\n\treturn list2.pop() === undefined ? 0 : result.pop();\n\
    }\n", "\tvar result = 0;\n\tvar current;\n\tfor(var i = 0; i < operator.length;\
    \ i++){\n\t\tswitch(operator[i]){\n\t\t\tcase '+':\n\t\t\t\tresult = result +\
    \ operand[i];\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tresult = result - operand[i];\n\
    \t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tresult = result * operand[i];\n\t\t\t\
    \tbreak;\n\t\t\tcase '//':\n\t\t\t\tresult = result / operand[i];\n\t\t\t\tbreak;\n\
    \t\t\tcase '**':\n\t\t\t\tresult = result ** operand[i];\n\t\t\t\tbreak;\n\t\t\
    }\n\t}\n\treturn result;\n}\n", "\tvar arr1 = operator.split(\",\");\n\tvar arr2\
    \ = operand.split(\",\");\n\tvar result = 0;\n\tfor(var i=0;i<arr2.length;i++){\n\
    \t\tresult += arr2[i] * arr1[i]\n\t}\n\treturn result\n}\n", "    var result =\
    \ 0;\n    \n    // We check both arrays for non-zero length\n    for(var i = 0;\
    \ i < operator.length && i < operand.length; i++){\n        switch(operator[i]){\n\
    \        case '+': result = result + operand[i]; break;\n        case '-': result\
    \ = result - operand[i]; break;\n        case '*': result = result * operand[i];\
    \ break;\n        case '//': result = result / operand[i]; break;\n        case\
    \ '**': result = result ** operand[i]; break;\n        default:\n            console.log('Operator\
    \ not recognized:', operator[i]);\n            break;\n        }\n    }\n    return\
    \ result;\n}\n", "    // Your code here\n    // your code here\n    var a = operand[0]\n\
    \    var b = operand[1]\n    var c = operand[2]\n    var d = operand[3]\n    var\
    \ e = operand[4]\n    var f = operand[5]\n    var g = operand[6]\n    var h =\
    \ operand[7]\n    var i = operand[8]\n    var j = operand[9]\n    var k = operand[10]\n\
    \    var l = operand[11]\n    var m = operand[12]\n    var n = operand[13]\n \
    \   var o = operand[14]\n    var p = operand[15]\n    var q = operand[16]\n  \
    \  var r = operand[17]\n    var s = operand[18]\n    var t = operand[19]\n   \
    \ var u = operand[20]\n    var v = operand[21]\n    var w = operand[22]\n    var\
    \ x = operand[23]\n    var y = operand[24]\n    var z = operand[25]\n    var A\
    \ = operand[26]\n    var B = operand[27]\n    var C = operand[28]\n    var D =\
    \ operand[29]\n    var E = operand[30]\n    var F = operand[31]\n    var G = operand[32]\n\
    \    var H = operand[33]\n    var I = operand[34]\n    var J = operand[35]\n \
    \   var K = operand[36]\n    var L = operand[37]\n    var M = operand[38]\n  \
    \  var N = operand[39]\n    var O = operand[40]\n    var P = operand[41]\n   \
    \ var Q = operand[42]\n    var R = operand[43]\n    var S = operand[44]\n    var\
    \ T = operand[45]\n    var U = operand[46]\n    var V = operand[47]\n    var W\
    \ = operand[48]\n    var X = operand[49]\n    var Y = operand[50]\n    var Z =\
    \ operand[51]\n    var A = operand[52]\n    var B = operand[53]\n    var C = operand[54]\n\
    \    var D = operand[55]\n    var E = operand[56]\n    var F = operand[57]\n \
    \   var G = operand[58]\n    var H = operand[59]\n    var I = operand[60]\n  \
    \  var J = operand[61]\n    var K = operand[62]\n    var L = operand[63]\n   \
    \ var M = operand[64]\n    var N = operand[65]\n    var O = operand[66]\n    var\
    \ P = operand[67]\n    var Q = operand[68]\n    var R = operand[69]\n    var S\
    \ = operand[70]\n    var T = operand[71]\n    var U = operand[72]\n    var V =\
    \ operand[73]\n", "    let algebra = [];\n    // First build the basic algebra\
    \ operations.\n    for (let i = 0; i < operator.length; i++){\n        algebra.push(operator[i]);\n\
    \    }\n    // Now build the expression with the operands.\n    for (let i = 0;\
    \ i < operand.length; i++){\n        let number = 0;\n        for (let j = 0;\
    \ j < algebra.length; j++){\n            // If operands are integers, convert\
    \ them to integers before calculating the expression. \n            // Otherwise\
    \ the expression will be incorrect.\n            if (typeof operand[i] == \"number\"\
    ){\n                number = operand[i] * operand[j];\n            } else {\n\
    \                number = operand[i] + operand[j];\n            }\n        }\n\
    \        algebra.push(number);\n    }\n    // Finally, evaluate the expression.\n\
    \    return algebra.reduce((acc, curr) => acc + curr, 0);\n}\n", "\tlet operator_i\
    \ = -1;\n\tlet result_i = 0;\n\tlet operator_temp = [];\n\tlet result_temp = [];\n\
    \tlet i = 0;\n\t\n\t//Create an array for storing temporary results\n\twhile (operator_i\
    \ < operator.length && result_i < operand.length){\n\t\twhile (i < operator.length){\n\
    \t\t\t//If the operator is found\n\t\t\tif (operator_i == operator.length-1){\n\
    \t\t\t\t//Add the operand to the result array\n\t\t\t\tresult_temp[result_i] =\
    \ operand[i];\n\t\t\t\t//Increment the operand\n\t\t\t\tresult_i += 1;\n\t\t\t\
    \t//Exit the loop\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//If the operator is not found\
    \ yet\n\t\t\telse if (operator_temp.indexOf(operator_i) == -1){\n\t\t\t\t//Add\
    \ the operator to the operator array\n\t\t\t\toperator_temp[operator_i] = operator[i];\n\
    \t\t\t\t//Increment the operator\n\t\t\t\toperator_i += 1;\n\t\t\t}\n\t\t\t//If\
    \ the operator is found\n\t\t\telse if (operator_temp.indexOf(operator_i) == -1){\n\
    \t\t\t\t//Add the operand to the result array\n\t\t\t\tresult_temp[result_i] =\
    \ operand[i];\n\t\t\t\t//Increment the operand\n\t\t\t\tresult_i += 1;\n\t\t\t\
    \t//Exit the loop\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//If the operator is not found\
    \ yet\n\t\t\telse if (operator_temp.indexOf(operator_i) == -1){\n\t\t\t\t//Add\
    \ the operator to the operator array\n\t\t\t\toperator_temp[operator_i] = operator[i];\n\
    \t\t\t\t//Increment the operator\n\t\t\t\toperator_i += 1;\n\t\t\t}\n\t\t\t//If\
    \ the operator is not found yet\n\t\t\telse if (operator_temp.indexOf(operator_i)\
    \ == -1){\n\t\t\t\t//Add the operand to the result array\n\t\t\t\tresult_temp[result_i]\
    \ = operand[i];\n\t\t\t\t//Increment the operand\n\t\t\t\tresult_i += 1;\n\t\t\
    \t\t//Exit the loop\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//If the operator is not found\
    \ yet\n\t\t\telse if (operator_temp.indexOf(operator_i) == -1){\n\t\t\t\t//Add\
    \ the operator to the operator array\n\t\t\t\toperator_temp[operator_i] = operator[i];\n\
    \t\t\t\t//Increment the operator\n\t\t\t\toperator_i += 1;\n\t\t\t}\n\t\t\t//If\
    \ the operator is not found yet\n\t\t\telse if (operator_temp.indexOf(operator_i)\
    \ == -1){\n\t\t\t\t//Add the operand to the result array\n\t\t\t\tresult_temp[result_i]\
    \ = operand[i];\n\t\t\t\t//Increment the operand\n\t\t\t\tresult_i += 1;\n\t\t\
    \t\t//Exit the loop\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//If the operator is not found\
    \ yet\n\t\t\telse if (operator_temp.indexOf(operator_i) == -1){\n\t\t\t\t//Add\
    \ the operator to the operator array\n\t\t\t\toperator_temp[operator_i] = operator[i];\n\
    \t\t\t\t//Increment the operator\n\t\t\t\toperator_i += 1;\n\t\t\t}\n\t\t}\n\t\
    \tresult_i = 0;\n\t\ti = 0;\n\t}\n\t", "\t//if operator.length === operand.length\
    \ - 1 // this ensures there's enough operator in each list.\n\tvar result = 0;\n\
    \tfor (var i = 0; i < operator.length; i++) {\n\t\tresult += operand[i] * operator[i];\n\
    \t}\n\treturn result;\n}", "  let result = 1\n  for(let i = 0; i < operand.length-1;\
    \ i++){\n    switch(operator[i]){\n      case \"+\":\n        result += operand[i]\n\
    \        break\n      case \"-\":\n        result -= operand[i]\n        break\n\
    \      case \"*\":\n        result *= operand[i]\n        break\n      case \"\
    /\":\n        result /= operand[i]\n        break\n      case \"**\":\n      \
    \  result **= operand[i]\n        break\n    }\n  }\n  return result\n}\n", " \
    \   console.log(\"Start algebra...\");\n    console.log(operator);\n    console.log(operand);\n\
    \    if(operator.length > operand.length){\n        throw new Error(\"Invalid\
    \ operator\");\n    }\n    if(operand.length < 2){\n        throw new Error(\"\
    Invalid operand\");\n    }\n    \n    // Find operators and operands to do arithmetic\n\
    \    let arithmetic_operators = [\n        ['+', operator[1]],\n        ['-',\
    \ operator[2]],\n        ['*', operator[3]],\n        ['/', operator[4]],\n  \
    \      ['//', operator[5]],\n        ['**', operator[6]]\n    ];\n    let arithmetic_operands\
    \ = [operand[1], operand[2]];\n    \n    // Find operators and operands to do\
    \ exponentiation\n    let exponentiation_operators = [\n        ['**', operator[7]],\n\
    \    ];\n    let exponentiation_operands = [operand[4]];\n    \n    // Find operators\
    \ and operands to do factorial computation\n    let factorial_operators = [\n\
    \        ['/', operator[8]],\n    ];\n    let factorial_operands = [operand[5]];\n\
    \    \n    // Find operators and operands to do factorial computation\n    let\
    \ binomial_operators = [\n        ['**', operator[9]],\n    ];\n    let binomial_operands\
    \ = [operand[6]];\n    \n    // Find operators and operands to do bitwise operation\n\
    \    let bitwise_operators = [\n        ['&', operator[10]],\n        ['|', operator[11]],\n\
    \        ['^', operator[12]]\n    ];\n    let bitwise_operands = [operand[3]];\n\
    \    \n    // Find operators and operands to do bitwise operation\n    let bitwise_operators\
    \ = [\n        ['&', operator[13]],\n        ['|', operator[14]],\n        ['^',\
    \ operator[15]]\n    ];\n    let bitwise_operands = [operand[3]];\n    \n    //\
    \ Find operators and operands to do bitwise operation\n    let bitwise_operators\
    \ = [\n        ['&', operator[16]],\n        ['|', operator[17]],\n        ['^',\
    \ operator[18]]\n    ];\n    let bitwise_operands = [operand[3]];\n    \n    //\
    \ Find operators and operands to do bitwise operation\n    let bitwise_operators\
    \ = [\n        ['&', operator[19]],\n        ['|', operator[20]],\n        ['^',\
    \ operator[21]]\n    ];\n    let bitwise_operands = [operand[3]];\n    \n    //\
    \ Find operators and operands to do bitwise operation\n    let bitwise_operators\
    \ = [\n        ['&', operator[22]],\n        ['|', operator[23]],\n        ['^',\
    \ operator[24]]\n    ];\n    let bitwise_operands = [operand[3]];\n    \n    //\
    \ Find operator", "    // The base cases\n    if (operand.length == 0){\n    \
    \    return 0;\n    }\n    if (operator.length == 0){\n        return operand[0];\n\
    \    }\n    // Calculate the answer recursively.\n    return do_algebra_helper(operator,\
    \ operand, operator[0]);\n}\n", "    var result = null;\n    for (var i=0; i<\
    \ operator.length; i++){\n        if(operand.length >= i+1){\n            switch(operator[i]){\n\
    \                case '+':\n                result = result + operand[i];\n  \
    \              break;\n                case '-':\n                result = result\
    \ - operand[i];\n                break;\n                case '*':\n         \
    \       result = result * operand[i];\n                break;\n              \
    \  case '/':\n                result = result / operand[i];\n                break;\n\
    \                case '**':\n                result = result ** operand[i];\n\
    \                break;\n                default:\n                console.log(\"\
    Invalid Operator: \" + operator[i]);\n            }\n        } else {\n      \
    \      console.log(\"Invalid Operand: \" + operand);\n        }\n    }\n    return\
    \ result;\n}\n", "    var result = 0;\n    for (var i = 0; i < operand.length\
    \ - 1; i++) {\n        result += operator[operator.length - 1] * operand[i];\n\
    \    }\n    return result;\n}\n", "  var result = 0;\n  var i = operand.length;\n\
    \  while(i > 1){\n    switch(operator[0]){\n      case '+':\n      case '-':\n\
    \        result = operand[i-2] + operand[i-1];\n        break;\n      case '*':\n\
    \      case '/':\n        result = operand[i-2] * operand[i-1];\n        break;\n\
    \      case '//':\n        result = operand[i-2]; //floor division\n        break;\n\
    \      case '**':\n        result= operand[i-2] ** operand[i-1];\n        break;\n\
    \      default:\n        console.log(\"Error: operator not recognized\");\n  \
    \      return;\n    }\n    i -= 2;\n  }\n  return result;\n}\n", "  let operator_index\
    \ = 0\n  let ops = []\n  let nums = []\n  let index = operand.length\n  while(operator_index\
    \ < operator.length){\n    if(operand[index] % 2 == 0) // If the operand is even,\
    \ add the operator to the list of operations.\n      ops.push(operator[operator_index])\n\
    \    index--\n    operator_index++\n  }\n  \n  for(let i = 0; i < operand.length;\
    \ i++){\n    if(operand[i] % 2 == 0){\n      ops.push(operand[i])\n    }\n  }\n\
    \  index = ops.length - 1\n  while(index > 0){\n    nums.push(ops[index])\n  \
    \  index--\n  }\n  let num_length = nums.length\n  \n  if(num_length > 0){ //\
    \ If the number length > 0, then we evaluate the algebra expression. \n    let\
    \ eval = eval(nums.join(\"\"))\n    return eval\n  }\n}\n", "  var result = 0;\n\
    \  var index = 0;\n  var i = operand.length;\n\n  if(operand.length < 1){\n  \
    \  throw Error('Empty operator or operand');\n  }\n  if(operator.length < 1){\n\
    \    throw Error('Empty operator');\n  }\n  if(operand.length < 2){\n    throw\
    \ Error('Insufficient operand');\n  }\n  for(index = 0; index < operator.length;\
    \ index++){\n    if( operand[index] < 0){\n      throw Error('Negative operand');\n\
    \    }\n    if(isNaN(operand[index])){\n      throw Error('Non-numeric operand');\n\
    \    }\n  }\n  for(index = 0; index < operand.length; index++){\n    result =\
    \ result + operand[index] * operator[index];\n  }\n  return result;\n}\n", " \
    \ let res = 0;\n  for(let i = 0; i < operand.length - 1; i++){\n    res += operand[i]\
    \ * operator[operand.length - i - 1];\n  }\n  return res;\n}\n", "    operator.length\
    \ < 2 ? false : false;\n    var result = \"\";\n    var i = 0;\n    for(i=0; i<operator.length;\
    \ i++){\n        switch(operator[i]){\n            case '+':\n               \
    \ result = result + operand[i];\n                break;\n            case '-':\n\
    \                result = result - operand[i];\n                break;\n     \
    \       case '*':\n                result = result * operand[i];\n           \
    \     break;\n            case '//':\n                result = result / operand[i];\n\
    \                break;\n            case '**':\n                result = result\
    \ ** operand[i];\n                break;\n            default:\n             \
    \   console.log('Unexpected operator');\n        }\n    }\n    return result;\n\
    }\n", "  //Base case, no operators.\n  if(operator.length == 0){\n    if(operand.length\
    \ == 0){\n      return 0;\n    }\n    return operand[0];\n  }\n\n  //Recursive\
    \ case\n  var result = 0;\n  for(var i = 0; i < operator.length; i++){\n    //Recursive\
    \ case\n    result += do_algebra(operator, operand.slice(1));\n  }\n  return result;\n\
    }\n", "\tlet opr = operator[operand.length - 1];\n\tlet oprArray = operator;\n\
    \tlet oprLen = oprArray.length;\n\tlet op = operand[opr];\n\tlet opArray = operand;\n\
    \tlet opLen = opArray.length - 1;\n\tlet opNum = operand[opr];\n\tlet opNumArray\
    \ = operand;\n\tlet opNumLen = opNumArray.length - 1;\n\tlet opNumNum = operand[opr];\n\
    \tlet opNumNumArray = operand;\n\tlet opNumNumLen = opNumNumArray.length - 1;\n\
    \tlet opNumNumNum = operand[opr];\n\tlet opNumNumNumArray = operand;\n\tlet opNumNumNumLen\
    \ = opNumNumNumArray.length - 1;\n\tlet opNumNumNumNum = operand[opr];\n\tlet\
    \ opNumNumNumNumArray = operand;\n\tlet opNumNumNumNumLen = opNumNumNumNumArray.length\
    \ - 1;\n\tlet opNumNumNumNumNum = operand[opr];\n\tlet opNumNumNumNumNumArray\
    \ = operand;\n\tlet opNumNumNumNumNumLen = opNumNumNumNumNumArray.length - 1;\n\
    \tlet opNumNumNumNumNumNum = operand[opr];\n\tlet opNumNumNumNumNumNumArray =\
    \ operand;\n\tlet opNumNumNumNumNumNumLen = opNumNumNumNumNumNumArray.length -\
    \ 1;\n\tlet opNumNumNumNumNumNumNum = operand[opr];\n\tlet opNumNumNumNumNumNumNumArray\
    \ = operand;\n\tlet opNumNumNumNumNumNumNumLen = opNumNumNumNumNumNumNumArray.length\
    \ - 1;\n\tlet opNumNumNumNumNumNumNumNum = operand[opr];\n\tlet opNumNumNumNumNumNumNumNumArray\
    \ = operand;\n\tlet opNumNumNumNumNumNumNumNumLen = opNumNumNumNumNumNumNumNumArray.length\
    \ - 1;\n\tlet opNumNumNumNumNumNumNumNumNum = operand[opr];\n\tlet opNumNumNumNumNumNumNumNumArray\
    \ = operand;\n\tlet opNumNumNumNumNumNumNumNumLen = opNumNumNumNumNumNumNumNumNumArray.length\
    \ - 1;\n\tlet opNumNumNumNumNumNumNumNumNum = operand[opr];\n\tlet opNumNum",
  "  \n  var result = \"\"\n  \n  //Perform basic algebra operations\n  var sum =\
    \ 0\n  for(var i=0; i<operand.length; i++){\n    sum += operand[i]\n  }\n  var\
    \ product = 1\n  for(var i=0; i<operand.length; i++){\n    product *= operand[i]\n\
    \  }\n  var floor = operand.length\n  var power = 1\n  for(var i=0; i<operand.length;\
    \ i++){\n    power *= operand[i]\n  }\n  \n  //Do actual algebra operations\n\
    \  switch(operator){\n    case \"+\":\n      result = sum\n      break\n    case\
    \ \"-\":\n      result = sum\n      break\n    case \"*\":\n      result = product\n\
    \      break\n    case \"//\":\n      result = floor\n      break\n    case \"\
    **\":\n      result = power\n      break\n  }\n  return result\n}\n\n", "    \n\
    \    var result = 0;\n    for(var i = 0; i < operator.length; i++){\n        result\
    \ += operator[i] * operand[i];\n    }\n    return result;\n}\n", "  // Use a boolean\
    \ to check whether the expression is valid or not.\n  let isValid = true;\n  //\
    \ Use a counter to keep track of the current element in the operand list.\n  let\
    \ count = 0;\n  // Use a variable to keep track of the current element in the\
    \ operator list.\n  let index = 0;\n  // Define a function to evaluate the expression.\n\
    \  let evaluate = function(){\n    // Use a switch statement to check if the operator\
    \ is valid.\n    switch (operator[index]){\n      // Use case '+' to evaluate\
    \ the expression.\n      case '+':\n        // If the current element in the operand\
    \ list is empty, set the variable result to 0.\n        if (!operand[count]){\n\
    \          result = 0;\n        } else {\n          // Otherwise, set the variable\
    \ result to the value of the current element in the operand list.\n          result\
    \ = operand[count];\n        }\n        // Increase the count variable.\n    \
    \    count ++;\n        break;\n      // Use case '-' to evaluate the expression.\n\
    \      case '-':\n        // If the current element in the operand list is empty,\
    \ set the variable result to 0.\n        if (!operand[count]){\n          result\
    \ = 0;\n        } else {\n          // Otherwise, set the variable result to the\
    \ value of the current element in the operand list.\n          result = result\
    \ - operand[count];\n        }\n        // Increase the count variable.\n    \
    \    count ++;\n        break;\n      // Use case '*' to evaluate the expression.\n\
    \      case '*':\n        // If the current element in the operand list is empty,\
    \ set the variable result to 0.\n        if (!operand[count]){\n          result\
    \ = 0;\n        } else {\n          // Otherwise, set the variable result to the\
    \ value of the current element in the operand list.\n          result = result\
    \ * operand[count];\n        }\n        // Increase the count variable.\n    \
    \    count ++;\n        break;\n      // Use case '//' to evaluate the expression.\n\
    \      case '/':\n        // If the current element in the operand list is empty,\
    \ set the variable result to 0.\n        if (!operand[count]){\n          result\
    \ = 0;\n        } else {\n          // Otherwise, set the variable result to the\
    \ value of the current element in the operand list.\n          result = result\
    \ / operand[count];\n        }\n        // Increase the count variable.\n    \
    \    count ++;\n        break;\n      // Use case '**' to evaluate the expression.\n\
    \      case '**':\n        // If the current element in the operand list is empty,\
    \ set the variable result to 0.\n        if (!operand[count]){\n          result\
    \ = 0;\n        } else {\n          // Otherwise, set the variable result to the\
    \ value of the current element in the operand list.\n          result = result\
    \ ** operand[count];\n        }\n        // Increase the count variable.\n   \
    \     count ++;\n        break;\n      // Use default so that an invalid expression\
    \ cannot be evaluated.\n      default:\n        isValid = false;\n    }\n    //\
    \ Reset the count variable so that it starts at the second element in the operand\
    \ list.\n    count = 0;\n    // Return the result variable.\n    return result;\n\
    \  };\n  // ", "    if (operator.length != operand.length-1) throw 'Wrong number\
    \ of arguments.';\n    let result = 0;\n    for (let i=0; i<operator.length; i++){\n\
    \        result += operand[i] operator operand[i+1];\n    }\n    return result;\n\
    }\n</cell>\n<cell>", "\toperator = operator.split(' ');\n\toperand = operand.split('\
    \ ');\n\tif (operator.length != operand.length){\n\t\tthrow \"Invalid operation\
    \ and operand.\";\n\t}\n\tvar result = operand[0];\n\tfor (var i = 0; i < operator.length;\
    \ i++){\n\t\tresult = eval(result + ' ' + operator[i] + ' ' + operand[i]);\n\t\
    }\n\treturn result;\n}\n", "    \n    var total = 0;\n    // Go through each item\
    \ in operand list \n    for(var i = 0; i < operand.length; i++){\n        // Go\
    \ through each item in operator list \n        for(var j = 0; j < operator.length;\
    \ j++){\n            // Calculate the current operator at the current index in\
    \ operand list \n            var currentOperator = operator[j]\n            //\
    \ Check if the current index position is equal to 0, \n            // meaning\
    \ it's the first operand\n            if(j === 0){\n                // Add the\
    \ operand at the current index to total \n                total += operand[i];\n\
    \            }\n            // Calculate the current operand at the current index\
    \ position\n            var currentOperand = operand[i]\n            // Check\
    \ if the current index in the operand list is the last index,\n            //\
    \ meaning it's the last operand\n            if(i === operand.length - 1){\n \
    \               // Check if the current operator at the current index position\
    \ is a \n                // '/', then do the math, otherwise do a regular operation\n\
    \                if(currentOperator === '/'){\n                    total /= currentOperand\n\
    \                } else {\n                    total *= currentOperand\n     \
    \           }\n            }\n            // Check if the current index in the\
    \ operand list is the last index,\n            // meaning it's the last operand\n\
    \            else if(j === operator.length - 1){\n                if(currentOperator\
    \ === '/'){\n                    total /= currentOperand\n                } else\
    \ {\n                    total *= currentOperand\n                }\n        \
    \    }\n            // If the current operator at the current index position isn't\
    \ a '/',\n            // then just do an operation with this current operator\
    \ and operand\n            else{\n                if(currentOperator === '/'){\n\
    \                    total /= currentOperand\n                } else {\n     \
    \               total *= currentOperand\n                }\n            }\n  \
    \      }\n    }\n    return total;\n}", "\tvar result = 0;\n\tvar oper = Object.keys(operator)[0];\n\
    \tif(oper=='+'){\n\t\tresult = operand[0] + operand[1];\n\t} else if(oper=='-'){\n\
    \t\tresult = operand[0] - operand[1];\n\t} else if(oper=='*'){\n\t\tresult = operand[0]\
    \ * operand[1];\n\t} else if(oper=='/'){\n\t\tresult = operand[0] / operand[1];\n\
    \t} else if(oper=='**'){\n\t\tresult = operand[0] ** operand[1];\n\t} else {\n\
    \t\tresult = \"ERROR!\";\n\t}\n\treturn(result);\n}", "    var operatorList =\
    \ operator.split('+');\n    var operandList = operand;\n    var result = 0;\n\
    \    var i = 0;\n    for (i; i < operandList.length; i++){\n        if (operandList[i]\
    \ < 0){\n            throw \"operand must be non negative\"\n        }\n     \
    \   result += (operandList[i])*(operatorList.length)\n    }\n    return result\n\
    }\n", "  //First step : Build the algebraic expression with all basic algebra\
    \ operation\n  //Here I use eval but I think this could be done with eval and\
    \ without eval\n  //But eval is evil, so I will use eval\n  var expression = eval(\n\
    \    \"operator[\" + operator[0] + \"]\" +\n    \"operand[\" + operator[1] + \"\
    ]\" +\n    \"operand[\" + operator[2] + \"]\" +\n    \"operand[\" + operator[3]\
    \ + \"]\" +\n    \"operand[\" + operator[4] + \"]\" +\n    \"operand[\" + operator[5]\
    \ + \"]\"\n  );\n  //Now evaluate the expression\n  var result = eval(expression);\n\
    \  return result;\n}\n", "    //TODO: implement some kind of caching here\n  \
    \  let result = 0;\n    for(let i = 0; i < operator.length; i++){\n        switch(operator[i]){\n\
    \            case '-':\n                result = result - operand[i];\n      \
    \          break;\n            case '+':\n                result = result + operand[i];\n\
    \                break;\n            case '*':\n                result = result\
    \ * operand[i];\n                break;\n            case '/':\n             \
    \   result = result / operand[i];\n                break;\n            case '^':\n\
    \                result = result ** operand[i];\n                break;\n    \
    \        default:\n                break;\n        }\n    }\n    return result;\n\
    }\n", "    var oper = operator[Object.keys(operator)[0]];\n    var oper2 = operator[Object.keys(operator)[1]];\n\
    \    operand1 = operand[0];\n    operand2 = operand[1];\n    if (oper == \"+\"\
    ){\n        return operand1 + operand2;\n    }\n    if (oper == \"-\"){\n    \
    \    return operand1 - operand2;\n    }\n    if (oper == \"*\"){\n        return\
    \ operand1 * operand2;\n    }\n    if (oper == \"/\"){\n        if (operand2 !=\
    \ 0){\n            return operand1 / operand2;\n        }\n        else{\n   \
    \         console.log(\"No division by zero. Operand was not divided by zero.\"\
    );\n            return undefined;\n        }\n    }\n    if (oper == \"**\"){\n\
    \        if (operand2 != 0){\n            return Math.pow(operand1, operand2);\n\
    \        }\n        else{\n            console.log(\"No exponentiation by zero.\
    \ Operand was not exponentiated zero.\");\n            return undefined;\n   \
    \     }\n    }\n}\n", "  var result=[];\n  for(var i=0; i<operator.length; i++){\n\
    \    //If there is no operator, just do basic algebra\n    if(operator[i]==undefined\
    \ || operand[i]==undefined){\n      for(var j=0; j<operand.length; j++){\n   \
    \     result[j]=operand[j];\n      }\n      break;\n    }\n    if(operand.length==1){\n\
    \      result=operator[i](operand[0], result);\n    }else{\n      result=operator[i](operand[operand.length-1],\
    \ result);\n    }\n  }\n  return result;\n}\n", "    var result = 0;\n    var\
    \ oprtr = 0;\n    var operand2 = 0;\n    var operator2 = 0;\n    while(operand.length\
    \ > 0){\n        operand2 = operand.shift();\n        oprtr = operator[oprtr];\n\
    \        result += (oprtr == undefined) ? operand2 : oprtr(operand2);\n    }\n\
    \    return result;\n}\n", "  var result = 0;\n  for(var i = 0; i < operator.length;\
    \ i++){\n    result += operand[operand.length - (i+1)] * operator[i]\n  }\n  return\
    \ result;\n}", "    var sum = 0;\n    var index;\n    var counter = 0;\n    for\
    \ (index = 0; index < operand.length; index++){\n        sum = sum + operand[index]\
    \ * operator[counter];\n        counter++;\n    }\n    return sum;\n}\n", "\t\
    let algebric_expression = ''\n\n\tlet length = operator.length\n\tlet length =\
    \ operand.length - 1\n\tfor(let i = 0; i < length; i++){\n\t\tlet element = operator[i]\n\
    \t\tif(element === operand[i]){\n\t\t\t//Equal symbol\n\t\t\tif(i === length -\
    \ 1){\n\t\t\t\t//If last symbol in equation, then add equation to equation\n\t\
    \t\t\talgebric_expression += element + ' = ' + operand[i] + '\\n'\n\t\t\t}\n\t\
    \t\t//Different symbol\n\t\t\telse{\n\t\t\t\t//If previous symbol in equation,\
    \ then add previous symbol to equation\n\t\t\t\talgebric_expression += element\
    \ + ' = ' + operand[i-1] + '\\n'\n\t\t\t\t//Else add new symbol\n\t\t\t\talgebric_expression\
    \ += element + ' = ' + operand[i] + '\\n'\n\t\t\t}\n\t\t}\n\t\t//Else if current\
    \ symbol in equation, then add previous symbol to equation\n\t\telse{\n\t\t\t\
    algebric_expression += element + ' = ' + operand[i] + '\\n'\n\t\t}\n\t}\n\treturn\
    \ algebric_expression\n}", "\tconst len = operand.length;\n\tlet result = [];\n\
    \tlet temp = [];\n\tfor(let i = 0; i < len; i++){\n\t\ttemp.push(operand[i]);\n\
    \t}\n\tlet index = 0;\n\tlet counter = 0;\n\twhile(counter < len){\n\t\tindex\
    \ = 0;\n\t\twhile(index < len){\n\t\t\t\n\t\t\tif(temp[index] === operator[0]){\n\
    \t\t\t\tindex++;\n\t\t\t\tcounter++;\n\t\t\t\tif(index === len){\n\t\t\t\t\tresult.push(operator[0]);\n\
    \t\t\t\t}\n\t\t\t\tlet first = 0;\n\t\t\t\tlet second = 0;\n\t\t\t\tlet third\
    \ = 0;\n\t\t\t\tlet fourth = 0;\n\t\t\t\tif(counter === 0){\n\t\t\t\t\tfirst =\
    \ temp[index];\n\t\t\t\t\tsecond = temp[index+1];\n\t\t\t\t\tthird = temp[index+2];\n\
    \t\t\t\t\tfourth = temp[index+3];\n\t\t\t\t}else if(counter === 1){\n\t\t\t\t\t\
    second = temp[index];\n\t\t\t\t\tthird = temp[index+1];\n\t\t\t\t\tfourth = temp[index+2];\n\
    \t\t\t\t}else if(counter === 2){\n\t\t\t\t\tthird = temp[index];\n\t\t\t\t\tfourth\
    \ = temp[index+1];\n\t\t\t\t}else if(counter === 3){\n\t\t\t\t\tfourth = temp[index];\n\
    \t\t\t\t}\n\t\t\t\tswitch(operator[1]){\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tresult.push(first\
    \ + second + third + fourth);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\
    \t\tresult.push(first * second * third * fourth);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\
    \tcase 3:\n\t\t\t\t\t\tresult.push(first / second / third / fourth);\n\t\t\t\t\
    \t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tresult.push(Math.pow(first,second));\n\
    \t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tresult.push(Math.pow(first,second)\
    \ * Math.pow(third,fourth));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\
    \tresult.push(Math.pow(first,second) / Math.pow(third,fourth));\n\t\t\t\t\t\t\
    break;\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\tresult.push(Math.pow(first,second) / Math.pow(third,fourth)\
    \ / Math.pow(first,second));\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\
    \t\tif(counter === 0){\n\t\t\t\t\tif(operator === operator[2]){\n\t\t\t\t\t\t\
    result.push(temp[index] + temp[index+1]);\n\t\t\t\t\t}else if(operator === operator[3]){\n\
    \t\t\t\t\t\tresult.push(temp[index] - temp[index+1]);\n\t\t\t\t\t}else if(operator\
    \ === operator[4]){\n\t\t\t\t\t\tresult.push(temp[index] * temp[index+1]);\n\t\
    \t\t\t\t}else if(operator === operator[5]){\n\t\t\t\t\t\tresult.push(temp[index]\
    \ / temp[index+1]);\n\t\t\t\t\t}else if(operator === operator[6]){\n\t\t\t\t\t\
    \tresult.push(temp[index] % temp[index+1]);\n\t\t\t\t\t}else if(operator === operator[7]){\n\
    \t\t\t\t\t\tresult.push(temp[index] / temp[index+1] / temp[index+2]);\n", "  \
    \  var index = 0;\n    var res = 0;\n    \n    for (var i = 0; i < operand.length;\
    \ i++){\n        switch (operator[index]){\n            case '+':\n          \
    \      res = res + operand[i];\n                break;\n            case '-':\n\
    \                res = res - operand[i];\n                break;\n           \
    \ case '*':\n                res = res * operand[i];\n                break;\n\
    \            case '/':\n                if(operand[i] != 0){\n               \
    \     res = Math.floor(operand[i]/operand[i]);\n                }\n          \
    \      break;\n            case '^':\n                res = Math.pow(operand[i],\
    \ operand[i]);\n                break;\n            case '**':\n             \
    \   res = Math.pow(operand[i], operand[i]);\n                break;\n        \
    \    default:\n                console.log(\"Invalid Operator!\");\n        }\n\
    \        index++;\n    }\n    \n    console.log(res);\n    return res;\n}\n",
  "\tlet result = operand[0]\n\n\tfor (let i = 1; i < operand.length; i++){\n\t\t\
    let currentOperator = operator[i-1]\n\t\tlet currentOperand = operand[i]\n\n\t\
    \tswitch (currentOperator){\n\t\t\tcase '+': result += (currentOperand * currentOperand)\
    \ \n\t\t\t\tbreak\n\t\t\tcase '-': result -= (currentOperand * currentOperand)\
    \ \n\t\t\t\tbreak\n\t\t\tcase '*': result += (currentOperand * currentOperand)\
    \ \n\t\t\t\tbreak\n\t\t\tcase '//': result /= (currentOperand * currentOperand)\
    \ \n\t\t\t\tbreak\n\t\t\tcase '**': result *= (currentOperand * currentOperand)\
    \ \n\t\t\t\tbreak\n\t\t\tdefault: break\n\t\t}\n\t}\n\n\treturn result\n}\n",
  "\tconsole.log(\"do_algebra\", operator, operand);\n\tvar op = operator;\n\tvar\
    \ res = operand[0];\n\tfor (var i = 1; i < operand.length; i++){\n\t\tif (op ===\
    \ '+'){\n\t\t\tres = res + operand[i];\n\t\t}\n\t\telse if (op === '-'){\n\t\t\
    \tres = res - operand[i];\n\t\t}\n\t\telse if (op === '*'){\n\t\t\tres = res *\
    \ operand[i];\n\t\t}\n\t\telse if (op === '//'){\n\t\t\tres = res / operand[i];\n\
    \t\t}\n\t\telse if (op === '**'){\n\t\t\tres = Math.pow(res, operand[i]);\n\t\t\
    }\n\t\telse{\n\t\t\tconsole.log(\"do_algebra: invalid operator for list\", operator);\n\
    \t\t\treturn;\n\t\t}\n\t}\n\treturn res;\n}\n", "\ttry{\n\t\treturn do_algebra_helper(operator,\
    \ operand);\n\t}\n\tcatch(e){\n\t\treturn e;\n\t}\n}\n", "    var result;\n  \
    \  var operandCount = operand.length;\n    var operatorCount = operator.length;\n\
    \    //check if operandCount is greater than operatorCount\n    if(operandCount\
    \ < operatorCount){\n        console.log(\"Too few operands\");\n        return;\n\
    \    }\n    for(var i=0; i<operandCount; i++){\n        result = (i == 0) ? operand\
    \ : result + operator[i - 1](operand[i - 1], operand[i]);\n    }\n    return result;\n\
    }", "\t// Your code goes here!\n}\n", "    //Initializations\n    var array1 =\
    \ [];\n    var array2 = [];\n    var result = \"\"\n    var first_operation =\
    \ \"\"\n    \n    // Initialization of first array\n    // The first array has\
    \ all of the basic algebra operations as strings\n    for(var i = 0; i < operator.length;\
    \ i++){\n        var operation = operator[i];\n        array1.push(operation);\n\
    \    }\n    \n    // Initialization of second array\n    // The second array has\
    \ all of the numbers as strings\n    for(var i = 0; i < operand.length; i++){\n\
    \        var number = operand[i];\n        array2.push(number);\n    }\n\n   \
    \ // Initialization of result variable\n    // The result variable should start\
    \ as 0 and will store all of the numbers after the \n    // last number in the\
    \ operand array.\n    result = 0\n\n    // The first operation will always be\
    \ added to the result\n    first_operation = array1[0]\n    \n    // For every\
    \ value in the first array, find the value in the second array with the same \n\
    \    // index, and do that operation between the two values.\n    // For example,\
    \ the operation '-' will be done between the two\n    // array2[0] and array2[1]\n\
    \    for(var i = 0; i < array1.length; i++){\n        var operation = array1[i];\n\
    \        if(array2.length < i){\n            break;\n        }else{\n        \
    \    var number = array2[i];\n            switch(operation){\n               \
    \ // Addition\n                case \"+\":\n                    result += number;\n\
    \                    break;\n                \n                // Subtraction\n\
    \                case \"-\":\n                    result -= number;\n        \
    \            break;\n                \n                // Multiplication\n   \
    \             case \"*\":\n                    result *= number;\n           \
    \         break;\n                \n                // Floor division\n      \
    \          case \"//\":\n                    result /= number;\n             \
    \       break;\n                \n                // Exponentiation\n        \
    \        case \"**\":\n                    result **= number;\n              \
    \      break;\n            }\n        }\n    }\n    \n    // Return the final\
    \ result\n    return result;\n}\n", "    var operator_count, operand_count, result;\n\
    \    var operator_count = 0, operand_count = 0, result = 0;\n\n    //Looping through\
    \ the operator list and the operand list, building up \n    //the result of the\
    \ arithmetic expression.\n    for(var i = 0; i < operator.length; i++){\n    \
    \    //Increment the operator count by one\n        operator_count++;\n      \
    \  result += operand[operand_count];\n\n        //If the operator has been processed,\
    \ and the operand list has \n        //reached the end of the operands list, then\
    \ the result is finished \n        //and the function should return it.\n    \
    \    if(operator_count == operator.length && operand_count < operand.length){\n\
    \            return result;\n        }\n        //If the operator has been processed,\
    \ and the operand list has \n        //reached the end of the operator list, then\
    \ the result is finished \n        //and the function should return it.\n    \
    \    else if(operator_count == operator.length && operand_count == operand.length){\n\
    \            return result;\n        }\n\n        //Increment the operand count\
    \ by one\n        operand_count++;\n    }\n\n    //If the operator list has reached\
    \ the end of the operator list, \n    //and the operand list has reached the end\
    \ of the operand list, the \n    //result is finished.\n    if(operator_count\
    \ == operator.length){\n        return result;\n    }\n\n    //If the operator\
    \ list has reached the end of the operator list, \n    //and the operand list\
    \ has not reached the end of the operand list, the \n    //result is finished.\n\
    \    if(operator_count == operator.length){\n        return result;\n    }\n\n\
    \    //If the operator list has not reached the end of the operator list, \n \
    \   //and the operand list has not reached the end of the operand list, the \n\
    \    //result is finished.\n    return result;\n}\n", "  if(operator.length !==\
    \ operand.length){\n    throw \"Lengths of operator and operand lists are not\
    \ equal\";\n  }\n  var result = 0.0;\n  for(var i = 0; i < operator.length; i++){\n\
    \    var operandIndex = i+1;\n    var operatorIndex = i;\n    var operatorValue\
    \ = operator[operatorIndex];\n    var operandValue = operand[operandIndex-1];\n\
    \    var operatorFactor = 1;\n    if(operatorValue == '*'){\n      operatorFactor\
    \ = operandValue;\n    }\n    if(operatorValue == '/'){\n      operatorFactor\
    \ = 1/operandValue;\n    }\n    result = result + (operatorFactor * operandValue);\n\
    \  }\n  return result;\n}\n", "    var result = 0\n    var i = 0;\n    while(i\
    \ < operand.length && i < operator.length){\n        result = result + operator[i]\
    \ * operand[i]\n        i++;\n    }\n    return result;\n}\n", "  var result =\
    \ 0;\n  for(var i in operand){\n    result += operand[i] * operator[i];\n  }\n\
    \  return result;\n}\n", "\tlet result = 0;\n\tlet i = operand.length - 1;\n\t\
    while(i>=0){\n\t\tlet operand2 = operand[i];\n\t\tlet operator2 = operator[i];\n\
    \t\tif(operand2==undefined || operand2==null){\n\t\t\treturn 0;\n\t\t}\n\t\tif(operator2==undefined\
    \ || operator2==null){\n\t\t\treturn 0;\n\t\t}\n\t\tresult = result + operand2*\
    \ operator2;\n\t\ti-=1;\n\t}\n\treturn result;\n}\n", "    let total = 0;\n  \
    \  let i = 0;\n    for (let j = 0; j < operator.length; j++){\n        total +=\
    \ operand[j];\n        i++;\n    }\n    return total;\n}", "\t// The algebric\
    \ expression is initially an empty string.\n\tvar algebric_expression = \"\"\n\
    \t// Use this counter to know how many times to loop through operand list.\n\t\
    var counter = 0\n\t// We will loop through operand list until we reach the end\
    \ of operand\n\t// list. In the end, we will have the expression of algebric expression.\
    \ \n\t// This expression will be used to evaluate and return the value of\n\t\
    // algebric expression.\n\twhile(counter < operand.length){\n\t\t// Get the current\
    \ operand in operand list.\n\t\tvar current_operand = operand[counter]\n\t\t//\
    \ If current_operand is an integer number, then add it to the algebric expression\
    \ by \n\t\t// using the operator in operator list to perform the required operation.\n\
    \t\tif(typeof current_operand === \"number\"){\n\t\t\talgebric_expression += operator[counter]\
    \ + current_operand\n\t\t}\n\t\t// If current_operand is a string, then add it\
    \ to the algebric expression by \n\t\t// using the operator in operator list to\
    \ perform the required operation.\n\t\telse if(typeof current_operand === \"string\"\
    ){\n\t\t\talgebric_expression += operator[counter] + current_operand\n\t\t}\n\t\
    \t// If current_operand is an array of integers, then add it to the algebric expression\
    \ by \n\t\t// using the operator in operator list to perform the required operation.\n\
    \t\telse if(Array.isArray(current_operand)){\n\t\t\talgebric_expression += operator[counter]\
    \ + do_algebra(operator, current_operand)\n\t\t}\n\t\t// If current_operand is\
    \ an array of non-negative integers, then add it to the algebric expression by\
    \ \n\t\t// using the operator in operator list to perform the required operation.\n\
    \t\telse if(current_operand.length > 0 && current_operand[0] >= 0){\n\t\t\talgebric_expression\
    \ += operator[counter] + do_algebra(operator, current_operand)\n\t\t}\n\t\t//\
    \ If current_operand is true, then add it to the algebric expression by \n\t\t\
    // using the operator in operator list to perform the required operation.\n\t\t\
    else if(current_operand === true){\n\t\t\talgebric_expression += operator[counter]\
    \ + do_algebra(operator, operand[counter + 1])\n\t\t}\n\t\t// If current_operand\
    \ is false, then add it to the algebric expression by \n\t\t// using the operator\
    \ in operator list to perform the required operation.\n\t\telse if(current_operand\
    \ === false){\n\t\t\talgebric_expression += operator[counter] + do_algebra(operator,\
    \ operand[counter + 1])\n\t\t}\n\t\t// If the current_operand is neither integer\
    \ nor string or array,\n\t\t// then add it to the algebric expression by using\
    \ the operator in operator list to perform the required operation.\n\t\telse{\n\
    \t\t\talgebric_expression += operator[counter] + ", "\t// base case\n\tif (operand.length\
    \ < 2) return new Node(operator, operand);\n\n\t// recursive case\n\tswitch(operator[0]){\n\
    \t\tcase '+': \n\t\t\toperand = do_algebra(operator, operand);\n\t\t\tvar num\
    \ = parseInt(operand.pop());\n\t\t\tvar den = parseInt(operand.pop());\n\t\t\t\
    var product = num + den;\n\t\t\toperand.push(product);\n\t\t\treturn operand;\n\
    \t\t\tbreak;\n\t\tcase '-': \n\t\t\toperand = do_algebra(operator, operand);\n\
    \t\t\tvar num = parseInt(operand.pop());\n\t\t\tvar den = parseInt(operand.pop());\n\
    \t\t\tvar product = num - den;\n\t\t\toperand.push(product);\n\t\t\treturn operand;\n\
    \t\t\tbreak;\n\t\tcase '*': \n\t\t\toperand = do_algebra(operator, operand);\n\
    \t\t\tvar num = parseInt(operand.pop());\n\t\t\tvar den = parseInt(operand.pop());\n\
    \t\t\tvar product = num * den;\n\t\t\toperand.push(product);\n\t\t\treturn operand;\n\
    \t\t\tbreak;\n\t\tcase '//': \n\t\t\toperand = do_algebra(operator, operand);\n\
    \t\t\tvar num = parseInt(operand.pop());\n\t\t\tvar den = parseInt(operand.pop());\n\
    \t\t\tvar product = num // den;\n\t\t\toperand.push(product);\n\t\t\treturn operand;\n\
    \t\t\tbreak;\n\t\tcase '**': \n\t\t\toperand = do_algebra(operator, operand);\n\
    \t\t\tvar num = parseInt(operand.pop());\n\t\t\tvar den = parseInt(operand.pop());\n\
    \t\t\tvar product = num ** den;\n\t\t\toperand.push(product);\n\t\t\treturn operand;\n\
    \t\t\tbreak;\n\t\tdefault: return new Node(operator, operand);\n\t}\n}\n", " \
    \   if (operator.length == 0){\n       return 0;\n    }\n    else if (operator.length\
    \ == 1){\n       return operand[0];\n    }\n    else{\n       var result = 0;\n\
    \       for (var i = 0; i < operand.length-1; i++){\n          result += operand[i]\
    \ * operator[0] + do_algebra(operator, operand.slice(i+1));\n       }\n      \
    \ return result;\n    }\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for the\
    \ answer but this does not help me to complete my project\n<|/ c |>\n<| c |>\n\
    I did some research and found that the project is about doing a program to find\
    \ out a complex algebraic expression. I do not want to find out how complex it\
    \ is, I want to know how my algorithm works\n<|/ c |>\n<| c |>\nI see now. Sorry,\
    \ didn't have time for that.\n<|/ c |>\n<| a tags=javascript,recursion,complexity-theory,algorithm\
    \ |>\nYou can try this algorithm in JavaScript.\n<code>\nvar operator = ['+',\
    \ '-', '*', '/', '^'];\nvar array = [2, 3, 4, 5];\n", "\t//First convert the list\
    \ to an array\n\tarray = operand;\n\t//Loop through the array and build up the\
    \ expression\n\tfor(var i = 1; i < array.length; i++){\n\t\texpression = expression\
    \ + operator[0] + operand[i-1] + operator[i] + array[i-1];\n\t}\n\treturn expression;\n\
    }", "    if(operator.length != operand.length){\n        console.log('Error! The\
    \ length of operator list is ' + operator.length +\n            ', and the length\
    \ of operand list is ' + operand.length + '.');\n        return null;\n    }\n\
    \    var result = operand[0];\n    for(var i = 1; i < operand.length; i++){\n\
    \        var element = operand[i];\n        switch(operator[0]){\n           \
    \ case('+'): \n                result += element;\n            break;\n      \
    \      case('-'):\n                result -= element;\n            break;\n  \
    \          case('*'):\n                result *= element;\n            break;\n\
    \            case('//'):\n                result /= element;\n            break;\n\
    \            case('**'):\n                result = Math.pow(result, element);\n\
    \            break;\n        }\n    }\n    return result;\n}\n", "    let result\
    \ = operand[0]\n    for(let i=1;i<operand.length;i++){\n        switch(operator[i]){\n\
    \            case '+':\n                result = result + operand[i]\n       \
    \         break\n            case '-':\n                result = result - operand[i]\n\
    \                break\n            case '*':\n                result = result\
    \ * operand[i]\n                break\n            case '//':\n              \
    \  result = result // operand[i]\n                break\n            case '**':\n\
    \                result = result ** operand[i]\n                break\n      \
    \  }\n    }\n    return result\n}\n", "    var result = 0, i, num;\n    for(i\
    \ = 0; i < operand.length-1; i++){\n    \tnum = operand[i]; \n    \tresult = eval(result\
    \ + operator[i] * num);\n    }\n    num = operand[operand.length-1]; \n    result\
    \ = eval(result + operator[operator.length-1] * num);\n    return result;\n}",
  "  if(operand.length < operator.length){\n    console.log(\"Error: Not enough operands.\"\
    );\n    return -1;\n  }\n\n  let a = operand.pop();\n  let b = operand.pop();\n\
    \n  let expression = \"\";\n  for(i = 0; i < operator.length; i++){\n    expression\
    \ = expression + operator[i] + \"(\" + a + \",\" + b + \")\";\n    a = \"(\" +\
    \ a + \")\";\n    b = \"(\" + b + \")\";\n  }\n  expression = expression + operator[i]\
    \ + \"(\" + a + \",\" + b + \")\";\n\n  console.log(expression);\n  return eval(expression);\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWow, thank you so much for this. I'm going\
    \ to try this out now. Looking at it now, the only problem I am running into is\
    \ when I try to evaluate the expression. I keep getting an error. `Uncaught SyntaxError:\
    \ Unexpected token '<' ` I assume this has to do with my code not being able to\
    \ evaluate the expression. Thank you again for your help.\n<|/ c |>\n<| c |>\n\
    It looks like you're trying to run this code from the local file system. Try moving\
    \ the script to another location and test again. Also, you can probably safely\
    \ remove `return -1` from the function, as that's what `eval` will return.\n<|/\
    \ c |>\n<| c |>\nIt works! Thank you so much. Just a question: what is the purpose\
    \ of returning -1 from do_algebra? Is this the correct way to return -1 if there\
    \ are not enough operands?\n<|/ c |>\n<| c |>\nThe purpose of returning -1 from\
    \ `do_algebra` is so that the caller knows how many values were left over to evaluate.\
    \ `eval` will return a value of -1 if no values were left to evaluate, so that's\
    \ what it's returning as a response.\n<|/ c |>\n<| a tags=javascript,eval,math,algorithm,node.js\
    \ |>\nYou can use the following code\n\n<code>\nconst operatorsStack = [];\nconst\
    \ operandStack = [];\nconst expression = \"\";\n\nconst addOperator = () => operandStack.push(+operandStack[operandStack.length\
    \ - 1] + +operandStack[operandStack.length - 2]);\nconst subtractOperator = ()\
    \ => operandStack.push(+operandStack[operandStack.length - 1] - +operandStack[operandStack.length\
    \ - 2]);\nconst multiplyOperator = () => operandStack.push(+operandStack[operandStack.length\
    \ - 1] * +operandStack[operandStack.length - 2]);\nconst divideOperator = () =>\
    \ operandStack.push(+operandStack[operandStack.length - 1] / +operandStack[operandStack.length\
    \ - 2]);\nconst powOperator = ", "  let nums = [operand[0]];\n  let operators\
    \ = [operator[0]];\n  let currentVal = 0;\n\n  for (let i = 1; i < operand.length;\
    \ i++){\n    // console.log(nums, operators, currentVal);\n    nums.push(operand[i]);\n\
    \    operators.push(operator[i]);\n    currentVal += nums[i-1]*operators[i-1];\n\
    \  }\n  \n  return currentVal;\n}\n", "    //Convert operator and operand to 2D\
    \ array\n    var tempOperator = [];\n    var tempOperand = [];\n    for(var i=0;i<operator.length;i++){\n\
    \        tempOperator.push(operator[i]);\n    }\n    for(var i=0;i<operand.length;i++){\n\
    \        tempOperand.push(operand[i]);\n    }\n    //console.log(tempOperator,tempOperand);\n\
    \    //Generate expression\n    var expresion = \"\";\n    var i = 0;\n    for(var\
    \ j=tempOperand.length-1;j>=0;j--){\n        if(tempOperand[j] != 0){\n      \
    \      //console.log(tempOperand[j]);\n            var opr = tempOperator[i];\n\
    \            //console.log(opr);\n            if(opr == \"+\"){\n            \
    \    //console.log(tempOperand[j]);\n                expresion = expresion + tempOperand[j];\n\
    \                //console.log(expresion);\n            }else if(opr == \"-\"\
    ){\n                //console.log(tempOperand[j]);\n                expresion\
    \ = expresion - tempOperand[j];\n                //console.log(expresion);\n \
    \           }else if(opr == \"*\"){\n                //console.log(tempOperand[j]);\n\
    \                expresion = expresion * tempOperand[j];\n                //console.log(expresion);\n\
    \            }else if(opr == \"//\"){\n                //console.log(tempOperand[j]);\n\
    \                expresion = expresion / tempOperand[j];\n                //console.log(expresion);\n\
    \            }else if(opr == \"**\"){\n                //console.log(tempOperand[j]);\n\
    \                expresion = expresion ** tempOperand[j];\n                //console.log(expresion);\n\
    \            }\n            i++;\n        }\n    }\n    //console.log(expresion);\n\
    \    return expresion;\n}\n", "\tif(operand.length < 2 || operator.length < 1){\n\
    \t\tthrow new Error('Operand list and operator list must be at least length 2.');\n\
    \t}\n\t\n\tvar left = 0;\n\tvar right = 0;\n\tvar temp;\n\tvar exp = 0;\n\t\n\t\
    var result = 0;\n\tfor(var i = 0; i < operator.length; i++){\n\t\tswitch(operator[i]){\n\
    \t\t\tcase '+':\n\t\t\t\tleft = operand[left];\n\t\t\t\tright = operand[right];\n\
    \t\t\t\tif(left > right){\n\t\t\t\t\ttemp = right;\n\t\t\t\t\tright = left;\n\t\
    \t\t\t\tleft = temp;\n\t\t\t\t}\n\t\t\t\tresult = left + right;\n\t\t\t\tbreak;\n\
    \t\t\tcase '-':\n\t\t\t\tleft = operand[left];\n\t\t\t\tright = operand[right];\n\
    \t\t\t\tif(left > right){\n\t\t\t\t\ttemp = right;\n\t\t\t\t\tright = left;\n\t\
    \t\t\t\tleft = temp;\n\t\t\t\t}\n\t\t\t\tresult = left - right;\n\t\t\t\tbreak;\n\
    \t\t\tcase '*':\n\t\t\t\tleft = operand[left];\n\t\t\t\tright = operand[right];\n\
    \t\t\t\tresult = left * right;\n\t\t\t\tbreak;\n\t\t\tcase '//':\n\t\t\t\tleft\
    \ = operand[left];\n\t\t\t\tright = operand[right];\n\t\t\t\tresult = left / right;\n\
    \t\t\t\tbreak;\n\t\t\tcase '**':\n\t\t\t\tleft = operand[left];\n\t\t\t\tright\
    \ = operand[right];\n\t\t\t\tresult = Math.pow(left, right);\n\t\t\t\tbreak;\n\
    \t\t\tdefault:\n\t\t\t\tthrow new Error('Operator not recognized.');\n\t\t\t\t\
    break;\n\t\t}\n\t}\n\treturn result;\n}\n", "  var operator_count = operator.length;\n\
    \  var operand_count = operand.length - 1;\n  \n  var result;\n  var first_operand\
    \ = operand[0];\n  \n  if(first_operand == '+' || first_operand == '-'){\n  \n\
    \    if(operator_count == 1 && operand_count == 1){\n      var result = operand[0];\n\
    \    }\n    else if(operator_count == 1 && operand_count > 1){\n      for (var\
    \ i = 1; i < operand.length; i++){\n        result = operand[i] + result;\n  \
    \    }\n    }\n    else if(operator_count > 1 && operand_count == 1){\n      for\
    \ (var i = 1; i < operator_count; i++){\n        result = first_operand + operand[i]\
    \ + result;\n      }\n    }\n    else if(operator_count > 1 && operand_count >\
    \ 1){\n      for (var i = 1; i < operator_count; i++){\n        for (var j = 1;\
    \ j < operand_count; j++){\n          result = operand[j] + first_operand + result;\n\
    \        }\n      }\n    }\n  }\n  else if(first_operand == '*'){\n  \n    if(operator_count\
    \ == 1 && operand_count == 1){\n      result = operand[0] * operand[0];\n    }\n\
    \    else if(operator_count == 1 && operand_count > 1){\n      for (var i = 1;\
    \ i < operand.length; i++){\n        result = operand[i] * operand[i];\n     \
    \ }\n    }\n    else if(operator_count > 1 && operand_count == 1){\n      for\
    \ (var i = 1; i < operator_count; i++){\n        result = operand[0] * operand[i]\
    \ + result;\n      }\n    }\n    else if(operator_count > 1 && operand_count >\
    \ 1){\n      for (var i = 1; i < operator_count; i++){\n        for (var j = 1;\
    \ j < operand_count; j++){\n          result = operand[j] * operand[j] + result;\n\
    \        }\n      }\n    }\n  }\n  else if(first_operand == '/'){\n  \n    if(operator_count\
    \ == 1 && operand_count == 1){\n      result = Math.floor(operand[0] / operand[0]);\n\
    \    }\n    else if(operator_count == 1 && operand_count > 1){\n      for (var\
    \ i = 1; i < operand.length; i++){\n        result = operand[i] / operand[i];\n\
    \      }\n    }\n    else if(operator_count > 1 && operand_count == 1){\n    \
    \  for (var i = 1; i < operator_count; i++){\n        result = operand[0] / operand[i]\
    \ + result;\n      }\n    }\n    else if(operator_count > 1 && operand_count >\
    \ 1){\n      for (var i = 1; i < operator_count; i++){\n        for (var j = 1;\
    \ j < operand_count; j++){\n          result = Math.floor(operand[j] / operand[j])\
    \ + result;\n        }\n      }\n    }\n  }\n  else if(first_operand == '**'){\n\
    \  \n    if(operator_count == 1 && operand_count == 1){\n      result = operand[0]\
    \ ** operand[0];\n    }\n    ", "\t//The result is always 0 \n\tvar result = 0;\n\
    \n\t//The first operand is multiplied by the first operator in the operator list\
    \ \n\tvar firstOperand = operand[0] * operator[0];\n\n\t//The second operand is\
    \ multiplied by the second operator in the operator list \n\tvar secondOperand\
    \ = operand[1] * operator[1];\n\n\t//The third operand is multiplied by the third\
    \ operator in the operator list \n\tvar thirdOperand = operand[2] * operator[2];\n\
    \n\t//The fourth operand is multiplied by the fourth operator in the operator\
    \ list \n\tvar fourthOperand = operand[3] * operator[3];\n\n\t//The fifth operand\
    \ is multiplied by the fifth operator in the operator list \n\tvar fifthOperand\
    \ = operand[4] * operator[4];\n\n\t//The sixth operand is multiplied by the sixth\
    \ operator in the operator list \n\tvar sixthOperand = operand[5] * operator[5];\n\
    \n\t//The seventh operand is multiplied by the seventh operator in the operator\
    \ list \n\tvar seventhOperand = operand[6] * operator[6];\n\n\t//The eighth operand\
    \ is multiplied by the eighth operator in the operator list \n\tvar eighthOperand\
    \ = operand[7] * operator[7];\n\n\t//The ninth operand is multiplied by the ninth\
    \ operator in the operator list \n\tvar ninthOperand = operand[8] * operator[8];\n\
    \n\t//The tenth operand is multiplied by the tenth operator in the operator list\
    \ \n\tvar tenthOperand = operand[9] * operator[9];\n\n\t//The eleventh operand\
    \ is multiplied by the eleventh operator in the operator list \n\tvar eleventhOperand\
    \ = operand[10] * operator[10];\n\n\t//The twelfth operand is multiplied by the\
    \ twelfth operator in the operator list \n\tvar twelfthOperand = operand[11] *\
    \ operator[11];\n\n\t//The last operand is multiplied by the last operator in\
    \ the operator list \n\tvar lastOperand = operand[12] * operator[12];\n\n\t//The\
    \ last operator in the operator list is repeated until all of the operand \n\t\
    //lists are evaluated\n\tfor(var i=0;i<operator.length;i++){\n\t\tresult += firstOperand\
    \ + secondOperand + thirdOperand + fourthOperand + fifthOperand + sixthOperand\
    \ + seventhOperand + eighthOperand + ninthOperand + tenthOperand + eleventhOperand\
    \ + twelfthOperand + lastOperand;\n\t\tfirstOperand = secondOperand = thirdOperand\
    \ = fourthOperand = fifthOperand", "    // Add up the operands.\n    // Start\
    \ at zero, stopping when the second operand is higher than the first.\n    sum\
    \ = 0;\n    for (var i = 0; i < operand.length; i++){\n        sum += operand[i];\n\
    \    }\n\n    // If the operator is positive, multiply by the second operand.\n\
    \    // Otherwise, if it's negative, multiply by the first.\n    // Otherwise,\
    \ add the two together.\n    var opposite;\n    if (operator.includes('+')){\n\
    \        opposite = operand[1]; \n    } else {\n        opposite = operand[0];\n\
    \    }\n    \n    if (operator.includes('*')){\n        sum = sum * opposite;\n\
    \    } else if (operator.includes('-')){\n        sum = sum - opposite;\n    }\
    \ else {\n        sum = sum + opposite;\n    }\n    \n    return sum;\n}\n", "\t\
    let temp_operator = []\n\tlet temp_operand = []\n\tlet temp_result = 0\n\ttemp_operator\
    \ = operator\n\ttemp_operand = operand\n\tfor(let i=0; i<temp_operand.length;\
    \ i++){\n\t\tif(temp_operand[i]!==0){\n\t\t\ttemp_result+=temp_operand[i]\n\t\t\
    }\n\t}\n\tfor(let i=0; i<temp_operator.length-1; i++){\n\t\ttemp_result=temp_operator[i](temp_result)\n\
    \t}\n\treturn temp_result\n}\n", "    let result = 0;\n    //loop through all\
    \ operators in operator list\n    for (let i = 0; i < operator.length; i++){\n\
    \        //perform operation if operator[i] is in operand\n        if (operand.includes(operator[i]))\
    \ {\n            //get the index of operator[i] in operand and perform the operation\
    \ between the operands\n            result = operand.indexOf(operator[i]) + operand.indexOf(operator[i])*operand.indexOf(operator[i]);\n\
    \        }\n    }\n    return result;\n}", "\t// console.log('do_algebra');\n\t\
    // console.log(operator);\n\t// console.log(operand);\n\tvar result = 0;\n\tfor(var\
    \ i = 0; i <= operand.length-1; i++){\n\t\tresult += operator[operand.length-1](operand[i-1]);\n\
    \t}\n\treturn result;\n}\n", "  var stack = [];\n  for(var i=0; i<operand.length;\
    \ i++){\n    stack.push(operand[i]);\n  }\n  while((operator.length > 0) && (stack.length\
    \ > 0)){\n    if(operator.length > 1){\n      stack.push(operator.pop());\n  \
    \  }\n    switch(stack.pop()){\n      case '+':\n        stack.push(stack.pop()+stack.pop());\n\
    \        break;\n      case '-':\n        stack.push(stack.pop()-stack.pop());\n\
    \        break;\n      case '*':\n        stack.push(stack.pop()*stack.pop());\n\
    \        break;\n      case '/':\n        stack.push(stack.pop()/stack.pop());\n\
    \        break;\n      case '**':\n        stack.push(Math.pow(stack.pop(), stack.pop()));\n\
    \        break;\n      default:\n        return stack.pop();\n    }\n  }\n  return\
    \ stack.pop();\n}", "  // Declare a variable used to store the result of the expression.\n\
    \  var result;\n\n  // Declare variables used to keep track of the previous result.\n\
    \  var last_result, temp_result;\n\n  // Loop to evaluate the expression and store\
    \ the result in a temporary variable.\n  for (var i = 0; i < operand.length; i++){\n\
    \n    // Loop to determine if the previous result should be added with the current\
    \ operand.\n    if (i == 0){\n      last_result = operand[i];\n    }\n\n    //\
    \ Loop to determine if the previous result should be subtracted with the current\
    \ operand.\n    else if (i == 1){\n      temp_result = operand[i];\n    }\n\n\
    \    // Loop to determine if the previous result should be multiplied with the\
    \ current operand.\n    else if (i == 2){\n      temp_result = operand[i];\n \
    \   }\n\n    // Loop to determine if the previous result should be floored divided\
    \ with the current operand.\n    else if (i == 3){\n      temp_result = operand[i];\n\
    \    }\n\n    // Loop to determine if the previous result should be exponentiated\
    \ with the current operand.\n    else if (i == 4){\n      temp_result = operand[i];\n\
    \    }\n\n    // Loop to determine if the previous result should be added to the\
    \ temporary variable used to store the current result.\n    else if (i == 5){\n\
    \      temp_result = operand[i];\n    }\n\n    // If the current operand is equal\
    \ to the last result, then add the current operand to the temporary result variable.\n\
    \    else if (operand[i] == last_result){\n      temp_result = temp_result + operand[i];\n\
    \    }\n\n    // If the current operand is less than the last result, then subtract\
    \ the temporary variable used to store the previous result from \n    // the current\
    \ operand and add the new result to the temporary result variable.\n    else if\
    \ (operand[i] < last_result){\n      temp_result = temp_result - last_result;\n\
    \      temp_result = temp_result + operand[i];\n    }\n\n    // If the current\
    \ operand is greater than the last result, then multiply the temporary variable\
    \ used to store the previous result \n    // with the current operand and add\
    \ the new result to the temporary result variable.\n    else if (operand[i] >\
    \ last_result){\n      temp_result = temp_result * last_result;\n      temp_result\
    \ = temp_result + operand[i];\n    }\n\n    // If the current operand is equal\
    \ to the last result, then floored divide the temporary variable used to store\
    \ the previous result \n    // with the current operand and add the new result\
    \ to the temporary result variable.\n    else if (operand[i] == last_result){\n\
    \      temp_result = temp_result / operand[i];\n      temp_result = temp_result\
    \ + operand[i];\n    }\n\n    // If the current operand is less than the last\
    \ result, then exponentiate the temporary variable used to store the previous\
    \ result \n    // with the current operand and add the new result to the temporary\
    \ result variable.\n    else if (operand[i] < last_result){\n      temp_result\
    \ = temp_result ** operand[i];\n      temp_result = temp_result + operand[i];\n\
    \    }\n\n    // If the current operand is greater than the last result, then\
    \ add the temporary variable used to store the previous result ", "  if(operator.length\
    \ != operand.length-1){\n    return null\n  }\n  \n  let res = 0\n  for (let i=0;\
    \ i < operand.length; i++){\n    if (operator[i] == '+'){\n      res = res + operand[i]\n\
    \    } else if (operator[i] == '-'){\n      res = res - operand[i]\n    } else\
    \ if (operator[i] == '*'){\n      res = res * operand[i]\n    } else if (operator[i]\
    \ == '//'){\n      res = res / operand[i]\n    } else if (operator[i] == '**'){\n\
    \      res = Math.pow(res, operand[i])\n    } else {\n      return null\n    }\n\
    \  }\n  return res\n}\n", "    let result = 0;\n    let operatorList = operator.split('+');\n\
    \    let operandList = operand.split('+');\n    let operatorIndex = operandList.length-1;\
    \ //Index of last element of operand list.\n    for (let i = 0; i < operandList.length;\
    \ i++){\n        result += operandList[i];\n        operatorIndex--;\n    }\n\
    \    for (let i = 0; i < operatorList.length; i++){\n        result += eval(operatorList[i]\
    \ + operandList[i]);\n    }\n    return result\n}\n", "\t// Your code here\n\t\
    var sum = 0;\n\tfor (var i = 0; i < operand.length; i++){\n\t\tsum += operand[i]\
    \ * operator[0]\n\t\tsum += operand[i] * operator[1]\n\t\tsum += operand[i] *\
    \ operator[2]\n\t\tsum += operand[i] * operator[3]\n\t}\n\treturn sum;\n}\n",
  "    if (operand.length > operator.length){\n        alert(\"The length of operands\
    \ list is less than the length of operators list\");\n    }else{\n        var\
    \ sum = 0;\n        for (var i = 0; i < operand.length; i++){\n            var\
    \ value = operand[i];\n            sum += value;\n        }\n        return eval(operator.join(\"\
    \ + \")+\"(\"+operand.join(\" + \")+\")\");\n    }\n}", "   var result = 0;\n\
    \   var index = 0;\n   var sum = 0;\n   var operands_length = operand.length -1;\n\
    \   while(index <= operands_length){\n      var sum = 0;\n      var operands_value\
    \ = operand[index];\n      if(operands_value){\n         operands_value = operands_value.toString();\n\
    \         for(var i = index+1; i<operands_length; i++){\n            sum += parseInt(operand[i]);\n\
    \         }\n         result = eval(\"(\" + sum + operator[0] + operand [index]\
    \ + operator[1]+ \")\");\n      }\n      index++;\n   };\n   if(index === operands_length){\n\
    \      return result;\n   }\n}\n", "  if(operand.length < operator.length-1){\n\
    \      throw(\"Error 1\");\n  }\n  if(operator.length < 2){\n      throw(\"Error\
    \ 2\");\n  }\n  var expr = operand[0]\n  for(var i = 1; i < operator.length; i++){\n\
    \      expr += operator[i]*operand[i]\n  }\n  return expr;\n}\n", "\t\n\tlet operation\
    \ = operator[0]\n\tlet operator1 = operator[1]\n\tlet operator2 = operator[2]\n\
    \n\tlet operand1 = operand[0]\n\tlet operand2 = operand[1]\n\n\tlet newOperand1\
    \ = 0\n\tlet newOperand2 = 0\n\n\tif (operation === '+'){\n\t\tnewOperand1 = operand1\
    \ + operand2\n\t}\n\tif (operation === '-'){\n\t\tnewOperand1 = operand1 - operand2\n\
    \t}\n\tif (operation === '*'){\n\t\tnewOperand1 = operand1 * operand2\n\t}\n\t\
    if (operation === '//'){\n\t\tnewOperand1 = operand1 // operand2\n\t}\n\tif (operation\
    \ === '**'){\n\t\tnewOperand1 = operand1 ** operand2\n\t}\n\t\n\treturn newOperand1\n\
    }\n", "  var result = 0;\n  operand.forEach(function(element){\n    result +=\
    \ (element); \n  });\n  return result; \n}\n", "    var result = 0;\n    var temp\
    \ = 0;\n    var i = 0;\n    var j = 0;\n\n    //Iterate through each element in\
    \ the operand list\n    for(; i < operand.length; i++){\n\n        //Iterate through\
    \ each element in the operator list\n        for(; j < operator.length; j++){\n\
    \n            //Create a temporary variable\n            temp = operand[i];\n\n\
    \            //Perform the operation\n            temp = (temp + operator[j])\
    \ * (j + 1);\n\n            //Add the result to the accumulator and move onto\
    \ the next element in the operand list\n            result += temp;\n        }\n\
    \    }\n\n    return result;\n}\n", "  //First check if the operand list has enough\
    \ operands for an algebraic expression\n  if(operand.length < 2){\n    throw 'Operands\
    \ list is too small, needs at least two operands.';\n  }\n  \n  //Create a list\
    \ with 0's equal to the length of operand list\n  var list = [];\n  for(var i\
    \ = 0; i < operand.length; i++){\n    list.push(0);\n  }\n\n  //Set list[1] to\
    \ the first operand\n  list[1] = operand[0];\n\n  //Set list[2] to the second\
    \ operand\n  list[2] = operand[1];\n  \n  //Set list[3] to the first operand and\
    \ use the second operand as the operation\n  list[3] = operand[0];\n  \n  //Start\
    \ iterating the list and build the algebraic expression from left to right.\n\
    \  for(var i = 0; i < list.length; i++){\n    switch(list[i]){\n      //Addition\n\
    \      case operator[0]: list[3] += list[2]; break;\n      //Subtraction\n   \
    \   case operator[1]: list[3] -= list[2]; break;\n      //Multiplication\n   \
    \   case operator[2]: list[3] *= list[2]; break;\n      //Floor Division\n   \
    \   case operator[3]: list[3] /= list[2]; break;\n      //Exponentiation\n   \
    \   case operator[4]: list[3] **= list[2]; break;\n      //If there isn't a case\
    \ for this operator throw an error\n      default:\n        throw \"Operator not\
    \ found, check the operator list.\";\n    }\n  }\n  return list[3];\n}\n", "\t\
    // Write your code here.\n}\n</cell>\n<text>\nQuestion 3\nWrite a function that\
    \ takes a list and returns its arithmetic mean. \nThe arithmetic mean is calculated\
    \ as the sum of the list divided by the number of elements in the list.\n\nWrite\
    \ a program that reads a list from keyboard and prints its arithmetic mean.\n\
    Example:\nInput:\n[3, 5, -2, 6, -1]\nOutput:\n3.5\nNote:\nThe list contains at\
    \ least one element, and the list is not empty.\nAll elements in the list are\
    \ non-negative integers.\nThe size of the list is unknown.\n\n</text>\n<cell>",
  "    var result = 0;\n    var temp = [];\n\n    // loop through each operator in\
    \ operator list\n    for (var i = 0; i < operator.length; i++){\n        // loop\
    \ through each operand in operand list\n        for (var j = 0; j < operand.length;\
    \ j++){\n            // if the current operator and operand combination match\
    \ \n            // the operator and operand in the current list \n           \
    \ if (operator[i] == operand[j]){\n                // add the current operand\
    \ to the temp list\n                temp.push(operand[j]);\n                //\
    \ loop through each operator in the temp list\n                for (var k = 0;\
    \ k < operator.length; k++){\n                    // if the current operator matches\
    \ an operator in the operator list\n                    if (operator[k] == temp[k]){\n\
    \                        // subtract current operand from previous result and\
    \ \n                        // add the result to the result list\n           \
    \             result = result - operand[j] + result;\n                       \
    \ // break out of the inner loop\n                        break;\n           \
    \         }\n                }\n                break;\n            }\n      \
    \  }\n    }\n\n    // return the evaluated algebraic expression\n    return result;\n\
    }\n</code>\n<|/ a tags=arrays,javascript |>\n<| c |>\nThanks, I appreciate the\
    \ effort you've put into this. I'm going to do some research into this, as I am\
    \ fairly new to javascript, and this seems very complex.\n<|/ c |>\n<| a |>\n\
    Your code doesn't work because there are some logical problems in your code.\n\
    If you will look at your code:\n\nfor loop will execute only once.\nit will go\
    \ into the second loop to check operator list.\nIt will never go into the third\
    \ loop because operator list is empty.\n\nFor further details you can go through\
    \ this question answer\n<|/ a dscore=1 tags=arrays,javascript |>\n<| a dscore=1\
    \ tags=arrays,javascript |>\nHere is another way of doing it, it uses the following\
    \ techniques:\n\nFunctional programming principles of javascript\nArray.prototype.map()\n\
    Array.prototype.filter()\nArray.prototype.indexOf()\nString.replace()\n\n<code>",
  "    console.log(\"operator: \" + operator);\n    console.log(\"operand: \" + operand);\n\
    \    var num_operator = operator.length;\n    var num_operand = operand.length;\n\
    \    var result = 0;\n    console.log(\"num_operator: \" + num_operator);\n  \
    \  console.log(\"num_operand: \" + num_operand);\n    console.log(\"\\n\");\n\
    \    console.log(\"do algebra with num_operator: \" + num_operator + \", num_operand:\
    \ \" + num_operand);\n    for (var i = 0; i < num_operator; i++){\n        var\
    \ op_symbol = operator[i];\n        console.log(\"doing op: \" + op_symbol);\n\
    \        if (op_symbol == \"*\"){\n            console.log(\"do multiply with\
    \ num1: \" + operand[i] + \", num2: \" + operand[i - 1]);\n            result\
    \ = result + (operand[i] * operand[i - 1]);\n            console.log(\"result:\
    \ \" + result);\n        } else if (op_symbol == \"/\"){\n            console.log(\"\
    do divide with num1: \" + operand[i] + \", num2: \" + operand[i - 1]);\n     \
    \       result = result + (operand[i] / operand[i - 1]);\n            console.log(\"\
    result: \" + result);\n        } else if (op_symbol == \"-\"){\n            console.log(\"\
    do subtract with num1: \" + operand[i] + \", num2: \" + operand[i - 1]);\n   \
    \         result = result + (operand[i] - operand[i - 1]);\n            console.log(\"\
    result: \" + result);\n        } else if (op_symbol == \"+\"){\n            console.log(\"\
    do addition with num1: \" + operand[i] + \", num2: \" + operand[i - 1]);\n   \
    \         result = result + (operand[i] + operand[i - 1]);\n            console.log(\"\
    result: \" + result);\n        } else if (op_symbol == \"**\"){\n            console.log(\"\
    do exponentiation with num1: \" + operand[i] + \", num2: \" + operand[i - 1]);\n\
    \            result = result + (operand[i] ** operand[i - 1]);\n            console.log(\"\
    result: \" + result);\n        }\n    }\n    return result;\n}\n", "\tlet expression\
    \ = '';\n\tlet operator_index = 0; \n\tfor(let i = 0; i < operator.length; i++){\n\
    \t\texpression += operand[operator_index] * operator[operator_index]; \n\t\toperator_index++;\n\
    \t}\n\treturn expression;\n}\n\n", "\t\n\t//Initialize the answer\n\tvar answer;\n\
    \t\n\t//Get the lengths of the two lists\n\tvar len_operator = operator.length;\n\
    \tvar len_operand = operand.length;\n\t\n\t//Start the recursive part\n\tif(len_operand>0\
    \ && len_operator>0){\n\t\t\n\t\t//Base Case\n\t\tif(len_operand==1 && len_operator==1){\n\
    \t\t\t\n\t\t\t//Add the two operands\n\t\t\tanswer = operand[0] + operand[0];\n\
    \t\t\t\n\t\t}\n\t\t\n\t\t//Recursive Case\n\t\telse{\n\t\t\t\n\t\t\t//Take the\
    \ first element in the operand list \n\t\t\tvar temp1 = operand[0];\n\t\t\t\n\t\
    \t\t//Remove the element from the operand list\n\t\t\toperand.shift();\n\t\t\t\
    \n\t\t\t//Take the first element in the operator list \n\t\t\tvar temp2 = operator[0];\n\
    \t\t\t\n\t\t\t//Remove the element from the operator list\n\t\t\toperator.shift();\n\
    \t\t\t\n\t\t\t//Call the recursive part\n\t\t\tanswer = temp1 + do_algebra(operator,\
    \ operand);\n\t\t\t\n\t\t\t//Add the second element\n\t\t\tanswer += temp2;\n\t\
    \t}\n\t\t\n\t}\n\t\n\t//Return the answer\n\treturn answer;\n}\n", "    let result\
    \ = 0;\n    for (let i = 0; i < operator.length; i++)\n        if (operator[i]\
    \ == \"*\")\n            result = result * operand[i];\n        else if (operator[i]\
    \ == \"/\")\n            result = result / operand[i];\n        else if (operator[i]\
    \ == \"**\")\n            result = result ** operand[i];\n        else if (operator[i]\
    \ == \"+\")\n            result = result + operand[i];\n        else if (operator[i]\
    \ == \"-\")\n            result = result - operand[i];\n    return result\n}",
  "    // Your code goes here\n    let operators = [\"+\", \"-\", \"*\", \"/\", \"\
    **\"];\n    let op1 = operators.indexOf(operator[0]);\n    let op2 = operators.indexOf(operator[1]);\n\
    \    let op3 = operators.indexOf(operator[2]);\n    let op4 = operators.indexOf(operator[3]);\n\
    \    let op5 = operators.indexOf(operator[4]);\n    let operand1 = operand.slice(op1);\n\
    \    let operand2 = operand.slice(op2);\n    let operand3 = operand.slice(op3);\n\
    \    let operand4 = operand.slice(op4);\n    let operand5 = operand.slice(op5);\n\
    \    let result = 0;\n    switch(operator){\n        case \"+\": result += operand1.reduce((a,\
    \ b) => a + b);\n            break;\n        case \"-\": result += operand1.reduce((a,\
    \ b) => a - b);\n            break;\n        case \"*\": result += operand1.reduce((a,\
    \ b) => a * b);\n            break;\n        case \"/\": result += operand1.reduce((a,\
    \ b) => a / b);\n            break;\n        case \"**\": result += operand1.reduce((a,\
    \ b) => a ** b);\n            break;\n        default:\n    }\n    switch(operator){\n\
    \        case \"+\": result += operand2.reduce((a, b) => a + b);\n           \
    \ break;\n        case \"-\": result += operand2.reduce((a, b) => a - b);\n  \
    \          break;\n        case \"*\": result += operand2.reduce((a, b) => a *\
    \ b);\n            break;\n        case \"/\": result += operand2.reduce((a, b)\
    \ => a / b);\n            break;\n        case \"**\": result += operand2.reduce((a,\
    \ b) => a ** b);\n            break;\n        default:\n    }\n    switch(operator){\n\
    \        case \"+\": result += operand3.reduce((a, b) => a + b);\n           \
    \ break;\n        case \"-\": result += operand3.reduce((a, b) => a - b);\n  \
    \          break;\n        case \"*\": result += operand3.reduce((a, b) => a *\
    \ b);\n            break;\n        case \"/\": result += operand3.reduce((a, b)\
    \ => a / b);\n            break;\n        case \"**\": result += operand3.reduce((a,\
    \ b) => a ** b);\n            break;\n        default:\n    }\n    switch(operator){\n\
    \        case \"+\": result += operand4.reduce((a, b) => a + b);\n           \
    \ break;\n        case \"-\": result += operand4.reduce((a, b) => a - b);\n  \
    \          break;\n        case \"*\": result += operand4.reduce((a, b) => a *\
    \ b);\n            break;\n        case \"/\": result += operand4.reduce((a, b)\
    \ => a / b);\n            break;\n        case \"**\": result += operand4.reduce((a,\
    \ b) => a ** b);\n            break;\n        default:\n    }\n    switch(operator){\n\
    \        case \"+\": result += operand5.reduce((", "\tvar result_list = [];\n\t\
    for(var i = 0; i<operand.length-1; i++){\n\t\tresult_list[i] = operator[operand[i]](result_list[i],\
    \ operand[i+1])\n\t}\n\treturn result_list[0]\n}", "    let result = 1\n    for(let\
    \ i = 0, l = operator.length; i < l; i++){\n        result = operator[i](result,\
    \ operand[i])\n    }\n    return result\n}\n", "  // Add your code here\n  if(operand.length<1){\n\
    \    console.log(\"Error: operand list is empty.\");\n    return undefined;\n\
    \  }\n\n  if(operator.length<1){\n    console.log(\"Error: operator list is empty.\"\
    );\n    return undefined;\n  }\n\n  let new_array = [];\n  let array_length =\
    \ operand.length - 1;\n\n  if(operator.length>operand.length-1){\n    console.log(\"\
    Error: operator list length is greater than operand list length.\");\n    return\
    \ undefined;\n  }\n  \n  for(let i = 0; i < array_length; i++){\n    if(new_array.length>0){\n\
    \      new_array = new_array.concat(operand);\n    }\n    if(operator[i]==\"+\"\
    \ || operator[i]==\"-\" || operator[i]==\"*\"){\n      new_array = new_array.concat(operand);\n\
    \    }\n    if(operator[i]==\"/\"){\n      new_array = new_array.concat(operand);\n\
    \    }\n    if(operator[i]==\"^\"){\n      new_array = new_array.concat(operand);\n\
    \    }\n  }\n  return new_array.reduce((total, num) => {\n    return total + num;\n\
    \  }, 0);\n}\n", "  var result = 0;\n  if(operator.length < operand.length){\n\
    \    throw \"ERROR:operator list length is less than operand list length\";\n\
    \  }\n  for (var i = 0; i < operand.length; i++){\n    // console.log(\"i\");\n\
    \    // console.log(operator);\n    // console.log(operand);\n    result = result\
    \ + eval(operator[i] + operand[i]);\n    // console.log(result);\n  }\n  return\
    \ result;\n}\n", "\tif (operator.length !== operand.length-1){\n\t\tconsole.log(\"\
    Error: operator list length should be equal to the operand list length-1 minus\
    \ one.\")\n\t\treturn \"Error\"\n\t} else{\n\t\tvar op = operator[0],\n\t\t\t\
    operands = operand.slice(1, operand.length-1),\n\t\t\tresult = 0;\n\t\t\n\t\t\
    // console.log(operator, operands)\n\t\t// For every operation, find its value\
    \ in the operand list.\n\t\tfor (var i = 0; i < operands.length; i++){\n\t\t\t\
    result += operands[i] * operands[i];\n\t\t}\n\t\t\n\t\t// Do the operation with\
    \ the found value in the operand list.\n\t\tswitch (op){\n\t\t\tcase \"+\":\n\t\
    \t\t\tresult = operands.reduce((a, b) => a + b);\n\t\t\t\tbreak;\n\t\t\tcase \"\
    -\":\n\t\t\t\tresult = operands.reduce((a, b) => a - b);\n\t\t\t\tbreak;\n\t\t\
    \tcase \"*\":\n\t\t\t\tresult = operands.reduce((a, b) => a * b);\n\t\t\t\tbreak;\n\
    \t\t\tcase \"/\":\n\t\t\t\tresult = operands.reduce((a, b) => a / b);\n\t\t\t\t\
    break;\n\t\t\tcase \"**\":\n\t\t\t\tresult = operands.reduce((a, b) => a ** b);\n\
    \t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.log(\"Error: operator is not an\
    \ algebraic operation.\")\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n}\n", "\t// console.log(operator,\
    \ operand);\n\t// var result = operand[0] + operand[1]; \n\t// var result = operand[0]\
    \ * operand[1]; \n\t// var result = operand[0] ** operand[1]; \n\t// var result\
    \ = operand[0] / operand[1];\n\tvar result = 0;\n\tfor(let i=0; i<operator.length;\
    \ i++){\n\t\tresult = operator[i] * result;\n\t\t// console.log(result)\n\t}\n\
    \treturn result;\n}\n", "\tlet temp = [];\n\tlet stack = [];\n\tlet temp_stack\
    \ = [];\n\tlet stack_index = 0;\n\tlet stack_position = 0;\n\n\t//Push elements\
    \ to stack\n\twhile(stack_index < operator.length){\n\t\tstack.push(operator[stack_index]);\n\
    \t\tstack_index++;\n\t}\n\n\t//Push elements to temp_stack\n\twhile(stack_position\
    \ < operand.length){\n\t\ttemp_stack.push(operand[stack_position]);\n\t\tstack_position++;\n\
    \t}\n\n\t//Process stack\n\twhile(stack.length){\n\t\t//Push operand to stack\n\
    \t\twhile(temp_stack.length){\n\t\t\ttemp.push(temp_stack.pop());\n\t\t}\n\n\t\
    \tswitch(stack[stack.length - 1]){\n\t\t\tcase '+':\n\t\t\t\twhile(temp.length){\n\
    \t\t\t\t\tstack.push(temp.pop() + stack.pop());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\
    \t\tcase '-':\n\t\t\t\twhile(temp.length){\n\t\t\t\t\tstack.push(temp.pop() -\
    \ stack.pop());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\twhile(temp.length){\n\
    \t\t\t\t\tstack.push(temp.pop()*stack.pop());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\
    \tcase '//':\n\t\t\t\twhile(temp.length){\n\t\t\t\t\tstack.push(temp.pop()/stack.pop());\n\
    \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '**':\n\t\t\t\twhile(temp.length){\n\t\t\
    \t\t\tstack.push(temp.pop()**stack.pop());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\
    \t}\n\n\t//Pop elements from stack and temp_stack\n\twhile(stack.length){\n\t\t\
    stack.shift();\n\t\ttemp_stack.shift();\n\t}\n\n\treturn stack.pop();\n}\n", "\t\
    /*\n\t\t1. Reverse the operands to make it easier to work with.\n\t\t2. Convert\
    \ the operators to their binary equivalents \n\t\t3. The two operands to binary\
    \ equivalents are joined by the operator.\n\t\t4. For each binary equivalent of\
    \ the first operand and the operator, convert it to the equivalent of \n\t\tthe\
    \ second operand.\n\t\t5. The two binary equivalents of the two operands are joined\
    \ by the operator. \n\t\t6. At this point we have our answer, in its binary equivalent\
    \ form. \n\t\t7. Convert the binary equivalent form to an integer.\n\t*/\n\tvar\
    \ result_array = [];\n\tfor(var i = 0; i < operand.length - 1; i++){\n\t\tresult_array.push(operand[operand.length\
    \ - i - 1] + operator[operator.length - i - 1] * operand[operand.length - i]);\n\
    \t}\n\treturn parseInt(result_array.join(\"\"));\n}\n", "    console.log(\"do_algebra\"\
    );\n    var result = 0;\n    var opIndex = 0;\n    while(opIndex < operator.length\
    \ && opIndex < operand.length){\n        switch(operator[opIndex]){\n        \
    \    case '+':\n                result = result + operand[opIndex];\n        \
    \        break;\n            case '-':\n                result = result - operand[opIndex];\n\
    \                break;\n            case '*':\n                result = result\
    \ * operand[opIndex];\n                break;\n            case '//':\n      \
    \          result = Math.floor(result / operand[opIndex]);\n                break;\n\
    \            case '**':\n                result = result ** operand[opIndex];\n\
    \                break;\n            default:\n                break;\n      \
    \  }\n        opIndex++;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks for your answer but this doesn't work.\n<|/ c |>\n<| c |>\n\
    I have tried it.  It works.  Are you giving it the correct inputs?\n<|/ c |>\n\
    <| c |>\nYes, I do, exactly like the example I gave in the question. But the result\
    \ is always 0.\n<|/ c |>\n<| c |>\nTry adding a line `console.log(operator, operand)`\
    \ before the `while` loop. Does the values match up?\n<|/ c |>\n<| c |>\nI do\
    \ get `[\"+\", 2]` for `operator` and `[2, 3, 4, 5]` for `operand`. But still\
    \ the result is 0.\n<|/ c |>\n<| a |>\n<code>\nvar operators = ['+', '*', '*',\
    \ '//'];\nvar operands = [2,3,4,5];\nvar operandsString = \"\";\noperands.forEach(function(x){\n\
    \  operandsString = operandsString + x + ' ';\n});\nvar operatorIndex = operandsString.indexOf('\
    \ ');\nvar operator = operandsString.substring(0, operatorIndex);\nvar operand\
    \ = operandsString.substring(operatorIndex+1);\nvar result = do_algebra(operator,\
    \ operand);", "  //We create a stack to store temporary values.\n  var stack =\
    \ [];\n  //We create a variable to store the final result.\n  var result;\n  //We\
    \ iterate through the list of operands and operands.\n  for(var i=1; i<operand.length;\
    \ i++){\n    //If the current operator is the operator at the top of the stack,\n\
    \    //we push it on the stack.\n    if(operator[stack.length] == operand[i]){\n\
    \      stack.push(operand[i]);\n    }else{\n      //Otherwise, we pop out the\
    \ top element of the stack and \n      //multiply it by the top element of operand\
    \ list minus one, \n      //then push the result back on the stack.\n      result\
    \ = operand[i-1] * stack.pop();\n      stack.push(result);\n    }\n  }\n  //The\
    \ last item on the stack is the final answer.\n  return stack.pop();\n}\n</code>\n\
    Here's a visualization of the stack-based algorithm.\n<|/ a tags=javascript,algorithm,arrays\
    \ |>\n<| c |>\nThank you for answering my question and teaching me this stack-based\
    \ algorithm. Just a question before I test your code: What would the stack look\
    \ like in this case (array [2,3,4,5] and operator['+','*','-'])?\n<|/ c |>\n<|\
    \ c |>\nIt would look like this: [2,3,4,5] -> [2,3,4,5] -> [6,8,9,10] -> [6,8,9,10,6]\
    \ -> [20,30,40,50,60] -> [20,30,40,50,60,20] -> [40,60,80,90,100,60] -> [40,60,80,90,100,60,40]\
    \ -> [80,100,120,140,160,80,100,120,140,160,80] -> [80,100,120,140,160,80,100,120,140,160,80]\n\
    <|/ c |>\n<| c |>\nI tested your code, and it works great! Thank you so much for\
    \ the help :) I really appreciate it. I'm also trying to understand your visualization\
    \ of the stack-based algorithm. Could you possibly give me a quick explanation\
    \ of the stack-based algorithm?\n<|/ c |>\n<| c |>\nThanks for following up! I\
    \ added a link to a visualization of the stack-based algorithm. Also, I added\
    \ an explanation of the stack-based algorithm.\n<|/ c |>\n<| a |>\nHere is a more\
    \ dynamic solution without hardcoding the number of operators and operands:\n\n\
    <code>", "    if(operator.length != operand.length){\n        throw 'Operator\
    \ and Operand lists should have same length'\n    }\n    let result = 0\n    for(let\
    \ i = 0; i < operator.length; i++){\n        result += operator[i](operand[i -\
    \ 1], operand[i])\n    }\n    return result\n}", "    //TODO: Add more operations\
    \ (-,/,%,^,+,-,*,/,%,**) to the list to allow easy addition \n    // of more complex\
    \ operations. \n    //TODO: Modify the do_algebra() function to return the result\
    \ of the algebra \n    // operation instead of printing it out.\n    //TODO: Add\
    \ more tests to verify that do_algebra() works properly. \n    try{\n        if(operator.length\
    \ != operand.length){\n            throw \"The number of operators and operands\
    \ do not match!\";\n        }\n        let result = \"\";\n        for(let i =\
    \ 0; i < operator.length; i++){\n            //TODO: Modify the do_algebra() function\
    \ so that the correct operation \n            // is performed depending on whether\
    \ the operator at the current position \n            // is a basic algebra operation\
    \ or a number that is being operated on. \n            // For example, if the\
    \ current operator is an addition operator, then \n            // the result should\
    \ be added to the next operand. \n            result += operand[i];\n        }\n\
    \        console.log(result);\n        return result;\n    }catch(e){\n      \
    \  console.log(e);\n    }\n}\n", "\tif (operand.length !== operator.length-1)\
    \ throw \"Operands and operator list have different length.\";\n\t\n\tvar result\
    \ = 0, i = 0, j = 0;\n\tfor (; i < operand.length-1; i++){\n\t\tfor (; j < operator.length;\
    \ j++){\n\t\t\tif (operator[j] === '+') result += operand[i] - operand[i+1];\n\
    \t\t\telse if (operator[j] === '-') result -= operand[i] - operand[i+1];\n\t\t\
    \telse if (operator[j] === '*') result *= operand[i] - operand[i+1];\n\t\t\telse\
    \ if (operator[j] === '/') result /= operand[i] - operand[i+1];\n\t\t\telse if\
    \ (operator[j] === '^') result ^= operand[i] - operand[i+1];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n", "  var operators_list = operator.split(\"\");\n  var operands_list\
    \ = operand.split(\"\");\n  var result = \"\";\n  for(var i=0; i< operands_list.length;\
    \ i++){\n    //If the operator isn't in the list then just append the integer\n\
    \    if(operators_list.indexOf(operators_list[i]) == -1)\n      result += operands_list[i];\n\
    \    else{\n      //if the operator is at the end then just append the operand\n\
    \      if(i == operators_list.length -1 )\n        result += operators_list[i]\
    \ + operands_list[i];\n      else{\n        //if the operator is in the middle\
    \ then do multiplication\n        if(operators_list[i] == \"*\"){\n          if(operands_list[i+1]\
    \ == \"+\"){\n            result += operators_list[i] * operands_list[i+1];\n\
    \          }\n          else if(operands_list[i+1] == \"-\"){\n            result\
    \ += operators_list[i] * operands_list[i+1];\n          }\n          else if(operands_list[i+1]\
    \ == \"*\"){\n            result += operators_list[i] * operands_list[i+1];\n\
    \          }\n          else if(operands_list[i+1] == \"/\"){\n            result\
    \ += operators_list[i] * operands_list[i+1];\n          }\n          else if(operands_list[i+1]\
    \ == \"//\"){\n            result += operators_list[i] * operands_list[i+1];\n\
    \          }\n        }\n        //if the operator is at the end then just append\
    \ the operand\n        else if(operators_list[i] == \"+\"){\n          result\
    \ += operators_list[i] + operands_list[i];\n        }\n        //if the operator\
    \ is at the end then just append the operand\n        else if(operators_list[i]\
    \ == \"-\"){\n          result += operators_list[i] - operands_list[i];\n    \
    \    }\n        //if the operator is at the end then just append the operand\n\
    \        else if(operators_list[i] == \"/\"){\n          result += operators_list[i]\
    \ / operands_list[i];\n        }\n        //if the operator is at the end then\
    \ just append the operand\n        else if(operators_list[i] == \"//\"){\n   \
    \       result += operators_list[i] // operands_list[i];\n        }\n        //if\
    \ the operator is at the end then just append the operand\n        else if(operators_list[i]\
    \ == \"**\"){\n          result += operators_list[i] ** operands_list[i];\n  \
    \      }\n      }\n    }\n  }\n  return result;\n}\n", "    let ops = operator\n\
    \    let res = operand[0]\n    let op1 = ops[0]\n    let op2 = ops[1]\n    \n\
    \    for(let i=0; i<operand.length; i++){\n        if(op1===\"+\" || op1===\"\
    *\" || op1===\"-\" || op1===\"x\" || op1===\"/\" || op1===\"^\"){\n          \
    \  res +=  operand[i]\n        }\n        else if(op1===\"//\"){\n           \
    \ res =  Math.floor( operand[i]/operand[i] )\n        }\n        else if(op1===\"\
    **\"){\n            res =  Math.pow( operand[i], operand[i] )\n        }\n   \
    \     else if(op1===\"+\"){\n            res =  operand[i] +  operand[i+1]\n \
    \       }\n        else if(op1===\"-\"){\n            res =  operand[i] -  operand[i+1]\n\
    \        }\n        else if(op1===\"*\"){\n            res =  operand[i] *  operand[i+1]\n\
    \        }\n        else if(op1===\"^\"){\n            res =  Math.pow( operand[i],\
    \ operand[i+1] )\n        }\n    }\n    return res\n}\n", "\t// TODO: Implement\
    \ the algorithm to evaluate the given expression.\n\t// Hint: you can use the\
    \ eval() function to evaluate an expression.\n\t// Hint 2: you can use map and\
    \ filter to iterate over the operand.\n\t// Hint 3: you can use reduce to iterate\
    \ over the operator.\n\t// Hint 4: you can use the operators to find the operator\
    \ from the operator.\n\t// Hint 5: you can use the operators to find the operator\
    \ from the operator.\n\t// Hint 6: you can use the operators to find the operator\
    \ from the operator.\n\t// Hint 7: you can use the operators to find the operator\
    \ from the operator.\n\t// Hint 8: you can use the operators to find the operator\
    \ from the operator.\n\t// Hint 9: you can use the operators to find the operator\
    \ from the operator.\n\t// Hint 10: you can use the operators to find the operator\
    \ from the operator.\n\n}\n</code>\n<|/ a tags=javascript,recursion,algorithm\
    \ |>\n<| c |>\nThanks that's a great way to start, but what about when the array\
    \ contains negative numbers?\n<|/ c |>\n<| c |>\nI edited the answer to include\
    \ a solution using negative numbers.  Thanks for pointing it out.\n<|/ c |>\n\
    <| c |>\nI fixed the code for the negative number issue.\n<|/ c |>\n<| c |>\n\
    Thank you again. I'm very grateful for your help.\n<|/ c |>\n<| a dscore=0 |>\n\
    Try this:\n<code>\nvar array1 = [1, 2, 3, 4];\nvar array2 = [1, 2, 5, 6];\nvar\
    \ operators = ['+', '-', '*', '/'];\nvar result = [];\nfor (var i = 0; i < array1.length;\
    \ i++) {\n    for (var j = 0; j < array2.length; j++) {\n        var found = false;\n\
    \        for (var k = 0; k < operators.length; k++) {\n            if (operators[k]\
    \ == array1[i]) {\n                found = true;\n                break;\n   \
    \         }\n        }\n        if (found) {\n            result.push(array2[j]);\n\
    \        } else {\n            result.push(0);\n        }\n    }\n}\n</code>\n\
    <|/ a tags=javascript,recursion,algorithm |>\n<| c |>\nI appreciate your help\
    \ but my question is not about finding all the possible combinations. I'm just\
    \ looking for an algorithm to evaluate an algebraic expression.\n<|/ c |>\n<|\
    \ c |>\nWhat do you want to do with the expression? Evaluate it? Get it's value?\
    \ What do you mean by \"evaluate\"?\n<|/ c |>\n<| c |>\nI'm just trying to understand\
    \ how to solve this with recursion, without actually implementing the algorithm.\
    \ I can do everything you described with my code. The point of this exercise is\
    \ to figure out how to solve it with recursion.\n<|/ c |>\n<| a dscore=0 |>\n\
    You can try this:\n\n<code>", "   var result = 0;\n   //console.log(operand);\n\
    \   for(var i = 0; i < operand.length; i++){\n       var temp = 0;\n       switch(operator[i]){\n\
    \           case '+': \n               temp = temp + operand[i]; \n          \
    \ break;\n           case '-': \n               temp = temp - operand[i]; \n \
    \          break;\n           case '*': \n               temp = temp * operand[i];\
    \ \n           break;\n           case '//': \n               temp = temp // operand[i];\
    \ \n           break;\n           case '**': \n               temp = temp ** operand[i];\
    \ \n           break;\n       }\n       result = result + temp;\n   }\n   return\
    \ result; \n}\n", "\t\n\toperator = operator.split('+')[0];\n\toperand = operand.split('+');\n\
    \t\n\tvar sum = 0;\n\t\n\tfor(var i = 1; i < operand.length; i++){\n\t\tswitch(operator){\n\
    \t\t\tcase '+':\n\t\t\t\tsum += parseFloat(operand[i]);\n\t\t\t\tbreak;\n\t\t\t\
    case '-':\n\t\t\t\tsum -= parseFloat(operand[i]);\n\t\t\t\tbreak;\n\t\t\tcase\
    \ '*':\n\t\t\t\tsum *= parseFloat(operand[i]);\n\t\t\t\tbreak;\n\t\t\tcase '//':\n\
    \t\t\t\tsum /= parseFloat(operand[i]);\n\t\t\t\tbreak;\n\t\t\tcase '**':\n\t\t\
    \t\tsum %= parseFloat(operand[i]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn sum;\n}\n", "  try{\n    var exp = \"\";\n    \n    for (var\
    \ i = 0; i < operator.length; i++){\n      exp += operator[i] + operand[i];\n\
    \    }\n    \n    exp = exp.replace(\"*\", \"\");\n    exp = exp.replace(\"/\"\
    , \"\");\n    exp = exp.replace(\"+\", \"\");\n    exp = exp.replace(\"//\", \"\
    \");\n    exp = exp.replace(\"**\", \"\");\n    \n    return eval(exp);\n  }\n\
    \  catch(e){\n    throw e;\n  }\n}\n", "\t// Your code goes here\n\tvar result\
    \ = 0;\n\tfor(var i=0; i < operator.length; i++){\n\t\tresult += operand[i]*operator[i];\n\
    \t}\n\treturn result;\n}", "    var operands = operand.map((n) => { return Number(n)\
    \ })\n    var operators = operator.map((o) => { return o })\n    var result =\
    \ operands[0]\n    for(var i=0;i<operators.length;i++){\n        switch (operators[i]){\n\
    \            case '+':\n                result += operands[i+1]\n            \
    \    break\n            case '-':\n                result -= operands[i+1]\n \
    \               break\n            case '*':\n                result *= operands[i+1]\n\
    \                break\n            case '/':\n                result /= operands[i+1]\n\
    \                break\n            case '**':\n                result **= operands[i+1]\n\
    \                break\n        }\n    }\n    return result\n}\n", "\tvar result\
    \ = operand[0]; //initialize result to first operand \n\tfor(var i = 0; i < operator.length;\
    \ i++){\n\t\tvar current = operator[i]; //get the current operator from operator\
    \ list \n\t\tresult += current * operand[i + 1]; //apply the operator to the result\
    \ and the next operand \n\t}\n\treturn result;\n}\n", "    var expression = \"\
    \";\n    \n    if(operand.length < 2) return 'Operand list must have at least\
    \ two elements.';\n    \n    for(var i = 0; i < operand.length; i++){\n      \
    \  expression = expression + eval(operand[i] + operator[0] + operand[i + 1]);\n\
    \    }\n    \n    return expression;\n}\n", "    let result = 1;\n    for(let\
    \ i = 0; i < operator.length; i++){\n        if(operator[i] == '+'){\n       \
    \     result += operand[i];\n        }else if(operator[i] == '-'){\n         \
    \   result -= operand[i];\n        }else if(operator[i] == '*'){\n           \
    \ result *= operand[i];\n        }else if(operator[i] == '/'){\n            result\
    \ /= operand[i];\n        }else if(operator[i] == '^'){\n            result **=\
    \ operand[i];\n        }\n    }\n    return result;\n}\n    ", "  var result =\
    \ 0;\n  for (var i = 0; i < operator.length; i++){\n    result += operand[i] *\
    \ operator[i];\n  }\n  return result;\n}\n", "    let result = 0;\n    for (let\
    \ i = 0; i < operand.length; i++){\n        if(!operator[i]) throw \"ERROR! Invalid\
    \ operation \"+operator;\n        result += operand[i];\n    }\n    return result;\n\
    }", "    //We will store the result here\n    let result = 0;\n    //We will iterate\
    \ through the operator list to see if we have found any operator\n    for (let\
    \ i = 0; i < operator.length; i++){\n        //We will iterate through our operand\
    \ list to see if we have found an operand\n        for (let j = 0; j < operand.length;\
    \ j++){\n            //If we have found an operator, we will use the basic arithmetic\
    \ operation\n            if (operator[i] === '+' || operator[i] === '-' || operator[i]\
    \ === '*' || operator[i] === '/' || operator[i] === '**'){\n                //The\
    \ value of the operands is added together\n                result += operand[j];\n\
    \                //We break out of this loop since we have found the operator\n\
    \                break;\n            }\n        }\n    }\n    //Return the result\n\
    \    return result;\n}", "   var re = /(\\d+)/g;\n   var ops = operator.split(',');\n\
    \   var arr = operand.split(re);\n   var sum = 0;\n   var flag = true;\n   var\
    \ i;\n   var len = ops.length;\n   for(i=0;i<len;i++){\n      var op = ops[i];\n\
    \      var arr = arr.slice();\n      var flag = true;\n      while(arr.length\
    \ > 1){\n         var num = parseInt(arr.shift());\n         var op2 = arr.shift();\n\
    \         if(op != '-' && op != '*'){\n            if(op == '/'){\n          \
    \     sum += num / op2;\n               flag = false;\n            }else if(op\
    \ == '**'){\n               sum += num **op2;\n               flag = false;\n\
    \            }else{\n               sum += num + op2;\n               flag = false;\n\
    \            }\n         }else if(op == '-' && op2 == '-' && flag){\n        \
    \    arr.shift();\n            flag = false;\n         }else if(op == '-' && op2\
    \ == '*'){\n            arr.shift();\n            flag = false;\n         }else\
    \ if(op == '-' && op2 == '/'){\n            sum += num - op2;\n            flag\
    \ = false;\n         }else if(op == '*' && op2 == '*'){\n            sum += num\
    \ * op2;\n            flag = false;\n         }else if(op == '*' && op2 == '/'){\n\
    \            sum += num / op2;\n            flag = false;\n         }else if(op\
    \ == '*' && op2 == '-'){\n            arr.shift();\n            flag = false;\n\
    \         }else if(op == '-' && op2 == '-' && flag){\n            arr.shift();\n\
    \            flag = false;\n         }else if(op == '*' && op2 == '-'){\n    \
    \        arr.shift();\n            flag = false;\n         }else if(op == '-'\
    \ && op2 == '*'){\n            arr.shift();\n            flag = false;\n     \
    \    }else if(op == '-' && op2 == '/'){\n            sum += num - op2;\n     \
    \       flag = false;\n         }else if(op == '-' && op2 == '-'){\n         \
    \   arr.shift();\n            flag = false;\n         }else{\n            arr.unshift(num);\n\
    \            break;\n         }\n      }\n   }\n   if(arr.length > 1){\n     \
    \ arr.shift();\n      flag = false;\n   }\n   return sum;\n}\n</code>\n<|/ a tags=arrays,javascript,algorithm\
    \ |>\n<| a |>\nThe problem is with your algorithm. Here is one way of doing it\
    \ without using eval.\n<code>", "    var expression = \"\";\n    var i;\n\n  \
    \  if(operator.length == 0){\n        return (\"No operator in list!\");\n   \
    \ }\n    if(operand.length < 2){\n        return ((\"The two lists are inconsistent!\"\
    ));\n    }\n\n    for(i = 0; i < operand.length; i++){\n        var left_operand\
    \ = operand[i-1];\n        var right_operand = operand[i];\n\n        //Basic\
    \ algebra operations\n        switch(operator[i]){\n            case '+':\n  \
    \              expression = expression + left_operand + right_operand;\n     \
    \           break;\n            case '-':\n                expression = expression\
    \ + left_operand - right_operand;\n                break;\n            case '*':\n\
    \                expression = expression + left_operand * right_operand;\n   \
    \             break;\n            case '/':\n                expression = expression\
    \ + left_operand / right_operand;\n                break;\n            case '**':\n\
    \                expression = expression + left_operand ** right_operand;\n  \
    \              break;\n            default:\n                return(\"Operator\
    \ not recognized!\");\n        }\n    }\n    return(expression);\n}\n", "    var\
    \ result = parseInt(operand[0]) + parseInt(operand[1]) + parseInt(operand[2])\
    \ - parseInt(operand[3]);\n    console.log(result);\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThe question is asked for javascript, not python.\
    \ Your answer is pure javascript.\n<|/ c |>\n<| c |>\nOops, sorry I didn't realize\
    \ that I had posted in python first time. I'll leave this up for a while in case\
    \ anyone else finds my answer is helpful.\n<|/ c |>\n<| a |>\nI wrote a solution\
    \ based upon Akhilesh Ramani's answer, that has three parameters for easier modification.\
    \ The function returns a string representation of the arithmetic expression, just\
    \ like in your example code.\n<code>\nconst getArithmeticExpression = function(operator,\
    \ firstOperand, secondOperand){\n  switch(operator){\n    case '+': \n      return\
    \ firstOperand + secondOperand;\n    case '-':\n      return firstOperand - secondOperand;\n\
    \    case '*':\n      return firstOperand * secondOperand;\n    case '/':\n  \
    \    return firstOperand / secondOperand;\n    case '**':\n      return firstOperand\
    \ ** secondOperand;\n    case '%':\n      return firstOperand % secondOperand;\n\
    \  }\n}\n\nconst firstOperand = 2;\nconst secondOperand = 3;\nconst operator =\
    \ '+';\n\nconst result = getArithmeticExpression(operator, firstOperand, secondOperand);\n\
    </code>\n<|/ a dscore=0 tags=javascript,python,algebra |>\n<| a tags=javascript,python,algebra\
    \ dscore=0 |>\n<code>", "    //Get the operator\n    var operators = operator.operator.split(\"\
    \ \");\n    var firstIndex = operators.indexOf(\"^\");\n    var secondIndex =\
    \ operators.indexOf(\"*\");\n\n    if(firstIndex !== -1){\n        if(secondIndex\
    \ === -1){\n            return operand[firstIndex].pow();\n        }else{\n  \
    \          return operand[firstIndex].multiply(operand[secondIndex].pow());\n\
    \        }\n    }else{\n        if(secondIndex === -1){\n            return operand[firstIndex].pow();\n\
    \        }else{\n            return operand[firstIndex].multiply(operand[secondIndex].pow());\n\
    \        }\n    }\n}\n", "  \n  // Convert operator list to array\n  operator\
    \ = operator.split(' ');\n\n  // Convert operand list to array\n  operand = operand.split('\
    \ ');\n\n  // Create an empty list for storing intermediate result\n  result =\
    \ [];\n  \n  // Evaluate the expression\n  for(i = 0; i < operator.length; i++){\n\
    \    \n    // For the first operand, just evaluate and push it\n    if(i === 0){\n\
    \      result.push(Number(operand[i]));\n    }\n    \n    // For the second operand,\
    \ evaluate and push it\n    else{\n      result.push(do_algebra(operator[i], operand[i]));\n\
    \    }\n  }\n  \n  // Return the result of the expression\n  return result;\n\
    \  \n}\n", "\tlet ops = []\n\tlet op = ''\n\tlet expr = ''\n\tlet result = 0\n\
    \t\n\t// Basic algebra operations\n\tfor(let i = 0; i < operator.length; i++){\n\
    \t\top = operator[i]\n\t\texpr = ''\n\t\tfor(let j = 0; j < operand.length; j++){\n\
    \t\t\texpr += ops[op] + '*' + operand[j] \n\t\t}\n\t\tresult = eval(expr)\n\t\t\
    ops.push(op)\n\t\toperand.push(result)\n\t}\n\t\n\t// Evaluate expression\n\t\
    for(let i = 0; i < ops.length; i++){\n\t\top = ops[i]\n\t\texpr = ''\n\t\tfor(let\
    \ j = 0; j < operand.length; j++){\n\t\t\texpr += op + '*' + operand[j]\n\t\t\
    }\n\t\tresult = eval(expr)\n\t\toperand.push(result)\n\t}\n\t\n\tconsole.log(operand)\n\
    }\n", "\t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes\
    \ here!\n\t// Your code goes here!\n\t// Your code goes here!\n\t// Your code\
    \ goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\t// Your\
    \ code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\t//\
    \ Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// Your code goes here!\n\
    \t// Your code goes here!\n\t// Your code goes here!\n\t// ", "  if(operand.length\
    \ < 1){\n    throw \"ERROR: Need at least two operands\";\n  }\n  var result_expression\
    \ = \"\";\n  for(var i = 0; i <= operand.length -1 ; i++){\n    var a = operand[i];\n\
    \    if(operator.length > 0 && i === operand.length -1){\n      result_expression\
    \ += operator[operator.length-1](a);\n    }\n    else{\n      result_expression\
    \ += a;\n    }\n  }\n  return result_expression;\n}\n", "  //TODO: Implement this\n\
    \  let operandStack = [];\n  let operationStack = [];\n  let operatorStack = [];\n\
    \  let expression;\n\n  for(let i=0; i < operand.length; i++){\n    operandStack.push(operand[i]);\n\
    \  }\n  while(operatorStack.length != operand.length){\n    operationStack.push(operatorStack.pop());\n\
    \  }\n\n  expression = operandStack.pop();\n\n  while(operationStack.length !=\
    \ 0){\n    expression = operationStack.pop() * expression + operandStack.pop();\n\
    \  }\n  return expression;\n}\n", "\tlet result = operand;\n\tfor(let i = 0; i\
    \ < operator.length; i++){\n\t\tswitch(operator[i]){\n\t\t\tcase '+':\n\t\t\t\t\
    result = result + operand[i];\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tresult\
    \ = result - operand[i];\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tresult = result\
    \ * operand[i];\n\t\t\t\tbreak;\n\t\t\tcase '//':\n\t\t\t\tresult = Math.floor(result\
    \ / operand[i]);\n\t\t\t\tbreak;\n\t\t\tcase '**':\n\t\t\t\tresult = result **\
    \ operand[i];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\n", "\tif(operator.length\
    \ < 1 || operand.length < 2) return false;\n\t//console.log('operator: ', operator);\n\
    \t//console.log('operand: ', operand);\n\tlet expression = '';\n\toperand.map((item,\
    \ index) => {\n\t\tlet operator = operator[index - 1];\n\t\tlet operand1 = operand[index];\n\
    \t\tlet operand2 = operand[index + 1];\n\t\texpression += operator;\n\t\tif(operator=='+')\
    \ expression += '+' + operand1;\n\t\tif(operator=='-') expression += '-' + operand1;\n\
    \t\tif(operator=='*') expression += '*' + operand1;\n\t\tif(operator=='/') expression\
    \ += '//' + operand1;\n\t\tif(operator=='**') expression += '**' + operand1;\n\
    \t});\n\treturn eval(expression);\n}", "    // console.log(\"do_algebra called\"\
    );\n    // console.log(\"operator\", operator);\n    // console.log(\"operand\"\
    , operand);\n    // var operators = [\"+\", \"-\", \"*\", \"/\", \"//\", \"**\"\
    ];\n    // var result = 0;\n    // for (var i = 0; i < operand.length; i++){\n\
    \    //     result += operand[i] * operand[i];\n    // }\n    // return result;\n\
    \    // var operators = [\"+\", \"-\", \"*\", \"/\", \"//\", \"**\"];\n    //\
    \ var result = 0;\n    // for (var i = 0; i < operator.length; i++){\n    // \
    \    result += operand[i] * operators[i];\n    // }\n    // return result;\n \
    \   \n    var operators = [\"+\", \"-\", \"*\", \"/\", \"//\", \"**\"];\n    var\
    \ result = 0;\n    for (var i = 0; i < operator.length; i++){\n        result\
    \ += operand[i] * operators[i];\n    }\n    return result;\n}\n", "  console.log(\"\
    do_algebra\")\n  //console.log(operator)\n  //console.log(operand)\n  //console.log(\"\
    \\n\")\n  \n  if(!operator){\n    //console.log(\"no operator\")\n    //console.log(operand)\n\
    \    return\n  }\n  if(operator.length == 0){\n    //console.log(\"no operator\"\
    )\n    //console.log(operand)\n    return\n  }\n  if(operand.length == 0){\n \
    \   //console.log(\"no operand\")\n    //console.log(operator)\n    return\n \
    \ }\n  if(operand.length < operator.length){\n    //console.log(\"too many operands\"\
    )\n    //console.log(operator)\n    //console.log(operand)\n    return\n  }\n\
    \  \n  if(operand.length == 1){\n    //console.log(\"one operand\")\n    //console.log(operator)\n\
    \    //console.log(operand)\n    return eval(operator[0] + operand[0])\n  }\n\
    \  \n  //console.log(\"multi\")\n  //console.log(operator)\n  //console.log(operand)\n\
    \  var left_operand = operand.slice(0, operand.length-1)\n  var right_operand\
    \ = operand.slice(operand.length-1, operand.length)\n  \n  //console.log(left_operand)\n\
    \  //console.log(right_operand)\n  //console.log(\"\\n\")\n  \n  if(operator.length\
    \ == 2){\n    //console.log(\"two\")\n    //console.log(operator)\n    //console.log(operand)\n\
    \    var result = eval(operator[0] + operator[1] + left_operand[0] + right_operand[0])\n\
    \    return do_algebra(operator[0], result) + do_algebra(operator[1], result)\n\
    \  }\n  \n  //console.log(\"tri\")\n  //console.log(operator)\n  //console.log(operand)\n\
    \  var result = [do_algebra(operator[0], left_operand[0]), do_algebra(operator[1],\
    \ left_operand[1])] \n  result = result.concat(do_algebra(operator[0], right_operand))\n\
    \  result = result.concat(do_algebra(operator[1], right_operand))\n  \n  return\
    \ result\n}\n<|/ file filename=algebra.js dstars=0 |>", "  let operatorStack =\
    \ [];\n  let operandStack = [];\n  let stackPointer = 0;\n\n  // push operand\n\
    \  operandStack.push(operand[0]);\n\n  // push operator\n  operatorStack.push(operator[0]);\n\
    \n  while (stackPointer < operatorStack.length){\n    // pop operator and operand\n\
    \    let operator = operatorStack[stackPointer];\n    let operand = operandStack[stackPointer];\n\
    \    \n    if (operator === '+'){\n      operandStack.push(operand + operandStack.pop());\n\
    \    }else if (operator === '-'){\n      operandStack.push(operand - operandStack.pop());\n\
    \    }else if (operator === '*'){\n      operandStack.push(operand * operandStack.pop());\n\
    \    }else if (operator === '/'){\n      operandStack.push(operand / operandStack.pop());\n\
    \    }else if (operator === '//'){\n      operandStack.push(operand / operandStack.pop());\n\
    \    }else if (operator === '**'){\n      operandStack.push(operand ** operandStack.pop());\n\
    \    }\n    stackPointer += 1;\n  }\n\n  return operandStack[0];\n}\n", "  //\
    \ Initialize a result variable.\n  var result = 0;\n  // Initialize a variable\
    \ for the number of operands.\n  var operandCount = operand.length;\n  // Check\
    \ if operator list has at least one operator.\n  if(operandCount == 0){\n    console.log('Error:\
    \ Invalid operand list');\n    return 0;\n  }\n  // Initialize the variable for\
    \ the number of operators.\n  var operatorCount = operator.length;\n  // Check\
    \ if operator list has at least one operator.\n  if(operatorCount == 0){\n   \
    \ console.log('Error: Invalid operator list');\n    return 0;\n  }\n  // Initialize\
    \ the variable for the number of operators.\n  var stackCount = 0;\n  // Initialize\
    \ the variable for the number of operators.\n  var stack = [];\n  // For each\
    \ operand, check each operator and if the operation is valid, \n  // then push\
    \ the operation onto the stack.\n  for(var operandIndex = 0; operandIndex < operandCount;\
    \ operandIndex++){\n    // Check if operator list has at least one operator.\n\
    \    if(operatorCount == 0){\n      console.log('Error: Invalid operator list');\n\
    \      return 0;\n    }\n    // Initialize the variable for the number of operators.\n\
    \    var operatorCountLeft = operatorCount;\n    // While there are still operators\
    \ on the stack...\n    while(stackCount != operatorCountLeft){\n      // Pop the\
    \ last operation off the stack.\n      stack.pop();\n      // Increment the variable\
    \ for the number of operators.\n      operatorCountLeft--;\n      // Push the\
    \ operation onto the stack.\n      stack.push(operator[stackCount]);\n      //\
    \ Increment the stackCount by the operation on the stack.\n      stackCount++;\n\
    \    }\n    // If the current operation is valid, then push it to the result stack.\n\
    \    stack.push(operand[operandIndex]);\n    stackCount++;\n    // Increment the\
    \ stackCount by the operation on the stack.\n    stackCount++;\n  }\n  // Return\
    \ result.\n  return result;\n}\n", "\t// Write code here.\n\tvar array = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \tvar result\n\t\n\tfor(var i=0; i< operand.length; i++){\n\t\tresult = eval(\
    \ array[operator[0]] + '*' + array[operator[1]] + operand[i] + '*' + array[operator[2]]\
    \ )\n\t}\n\treturn result\n}\n", "    // TODO: \n    // add validation to ensure\
    \ that the length of operator is equal to the length of operand\n    // This code\
    \ assumes that the number of operands in operand list is equal to the number of\
    \ \n    // operators in operator list minus 1\n    console.log(operator);\n  \
    \  console.log(operand);\n    let result = eval(`(${operator}) (${operand})`);\n\
    \    return result;\n}\n", "    var op = new Array();\n    for (var i = 0; i <\
    \ operator.length; i++){\n        op[i] = operator[i].toUpperCase();\n    }\n\
    \    var res = 0;\n    for (var i = 0; i < operand.length; i++){\n        res\
    \ += operand[i] * Math.pow(10, operand.length - i - 1);\n    }\n    return res;\n\
    }\n", "    let res = \"0\";\n    for(let i=0;i<operand.length;i++){\n        res\
    \ += operand[i] * operator[i]; \n    }\n    return res;\n}\n", "  let operatorIndex\
    \ = 0\n  let result = operand[operand.length - 1]\n  //loop through every operator\
    \ in operator array\n  for(let i = 0; i < operator.length; i++){\n    //if the\
    \ current operator is the one at the index in operand array\n    if(operatorIndex\
    \ === operand.length - 1){\n      //do binary operations\n      switch(operator[i]){\n\
    \        case '+':\n          result = result + operand[operand.length - 2]\n\
    \          break\n        case '-':\n          result = result - operand[operand.length\
    \ - 2]\n          break\n        case '*':\n          result = result * operand[operand.length\
    \ - 2]\n          break\n        case '//':\n          result = Math.floor(result\
    \ / operand[operand.length - 2])\n          break\n        case '**':\n      \
    \    result = Math.pow(result, operand[operand.length - 2])\n          break\n\
    \        default:\n          console.log('ERROR: Invalid operator in do_algebra\
    \ function.')\n          break\n      }\n    }\n    else{\n      //do unary operations\n\
    \      switch(operator[i]){\n        case '+':\n          result = result + operand[operand.length]\n\
    \          break\n        case '-':\n          result = result - operand[operand.length]\n\
    \          break\n        case '*':\n          result = result * operand[operand.length]\n\
    \          break\n        case '//':\n          result = Math.floor(result / operand[operand.length])\n\
    \          break\n        case '**':\n          result = Math.pow(result, operand[operand.length])\n\
    \          break\n        default:\n          console.log('ERROR: Invalid operator\
    \ in do_algebra function.')\n          break\n      }\n    }\n    //increment\
    \ the operator index to move to the next operator\n    operatorIndex++\n  }\n\
    \  //return the result\n  return result\n}\n", "    let result = 0;\n    \n  \
    \  operator.forEach((op) =>{\n        if(op === '+'){\n            result += operand.pop();\n\
    \        } else if(op === '-'){\n            result -= operand.pop();\n      \
    \  } else if(op === '*'){\n            result *= operand.pop();\n        } else\
    \ if(op === '/'){\n            result = Math.floor(operand.pop()/operand.pop());\
    \ //Get floor division result\n        } else if(op === '**'){\n            result\
    \ = Math.pow(operand.pop(), operand.pop()); //Get exponential result\n       \
    \ }\n    });\n\n    return result;\n}\n</code>\n<|/ a |>\n<| a |>\nHere is a recursive\
    \ solution that works by storing the operations in a stack and calculating them\
    \ recursively. Each time you pop an operation and perform it on the operands,\
    \ you add the result back onto the stack. At each recursive step you can take\
    \ the last operation from the stack and perform it on the operands and add it\
    \ back onto the stack:\n\n<code>\nconst operators = {\n  '+': (a, b) => a + b,\n\
    \  '-': (a, b) => a - b,\n  '*': (a, b) => a * b,\n  '/': (a, b) => a / b,\n \
    \ '**': (a, b) => a ** b\n};\n\nconst calc = (operator, num1, num2) => operators[operator](num1,\
    \ num2);\n\nconst calcWithStack = (operator, num1, num2, stack = []) => {\n  if\
    \ (operators[operator](num1, num2)) {\n    stack.push(operator);\n    return calc(operator,\
    \ num1, num2);\n  }\n\n  if (stack.length) {\n    const op = stack.pop();\n  \
    \  return calc(op, num2, num1 + num2);\n  }\n\n  return undefined;\n};\n\nconst\
    \ calcWithArray = (operator, num1, num2) => {\n  const stack = [];\n  \n  do {\n\
    \    stack.push(operators.pop());\n  } while (stack.length && stack[stack.length\
    \ - 1] < operator);\n\n  return calc(stack.pop(), num1, num2);\n};\n", "\tvar\
    \ operandList = operand.slice();\n\tvar operatorList = operators.slice();\n\t\
    var result = operandList[0]; //Initialize the result to first element of operand\
    \ list.\n\tvar i = 0, j = 0, k = 0;\n\t\n\tfor (; i < operatorList.length; i++){\n\
    \t\tswitch (operatorList[i]){\n\t\t\tcase '+': //Addition\n\t\t\t\tfor (; j <\
    \ operandList.length; j++){\n\t\t\t\t\tresult += operandList[j];\n\t\t\t\t}\n\t\
    \t\t\tbreak;\n\t\t\tcase '-': //Subtraction\n\t\t\t\tfor (; j < operandList.length;\
    \ j++){\n\t\t\t\t\tresult -= operandList[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\
    case '*': //Multiplication\n\t\t\t\tfor (; j < operandList.length; j++){\n\t\t\
    \t\t\tresult *= operandList[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '//': //Floor\
    \ division\n\t\t\t\tfor (; j < operandList.length; j++){\n\t\t\t\t\tresult /=\
    \ operandList[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '**': //Exponentiation\n\
    \t\t\t\tfor (; j < operandList.length; j++){\n\t\t\t\t\tresult **= operandList[j];\n\
    \t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\toperandList.splice(0,1); //Remove first\
    \ element of operand list so operandList size will not change. \n\t\toperatorList.splice(0,1);\
    \ //Remove first element of operator list so operatorList size will not change.\
    \ \n\t}\n\treturn result;\n}\n", "    let exp=\"\";\n    for(let op of operator){\n\
    \        exp+=op;\n    }\n    for(let num of operand){\n        exp+=num;\n  \
    \  }\n    console.log(exp);\n    return eval(exp);\n}", "    if(operand.length\
    \ < operator.lenght || operand.length > operator.lenght){\n        throw 'Error:\
    \ The length of operand list is ' + operand.length + ' but the length of operator\
    \ list is ' + operator.lenght;\n    }\n    if(operand.length > 1){\n        var\
    \ result = 0;\n        for(var i=0; i < operand.length; i++){\n            result\
    \ += operand[i]*operator[i];\n        }\n        return result;\n    } else {\n\
    \        return operand[0] * operator[0];\n    }\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a |>\nThe code above is very helpful,but i found another way for it.\n<code>",
  "  let new_array = []\n  let temp = new Array(operand.length).fill(0)\n  for (let\
    \ i = 0; i < operand.length; i++){\n    for (let j = 0; j < operator.length; j++){\n\
    \      if (operator[j] === '+'){\n        temp[i] += operand[j]\n      }\n   \
    \   else if (operator[j] === '-'){\n        temp[i] -= operand[j]\n      }\n \
    \     else if (operator[j] === '*'){\n        temp[i] *= operand[j]\n      }\n\
    \      else if (operator[j] === '//'){\n        temp[i] /= operand[j]\n      }\n\
    \      else if (operator[j] === '**'){\n        temp[i] **= operand[j]\n     \
    \ }\n    }\n  }\n  for (let i = 0; i < temp.length; i++){\n    new_array.push(temp[i])\n\
    \  }\n  return new_array\n}\n", "    let opArr = operator.split(''),\n       \
    \ opNum = opArr.length,\n        operandArr = operand.split(\"\"),\n        operandNum\
    \ = operandArr.length,\n        expArr = new Array(),\n        firstOp = opArr[0],\n\
    \        lastOp = opArr[opNum - 1],\n        firstOperand = operandArr[0],\n \
    \       lastOperand = operandArr[operandNum - 1],\n        firstExp = expArr[0],\n\
    \        lastExp = expArr[expArr.length - 1],\n        firstOperandNum = 0,\n\
    \        lastOperandNum = 0,\n        expression = '',\n        expNum = 0,\n\
    \        multiplier = 1;\n\n    for (let i = 0; i < opNum; i++){\n        if (firstOp\
    \ === opArr[i]){\n            firstOperandNum = i;\n        }\n        if (lastOp\
    \ === opArr[i]){\n            lastOperandNum = i;\n        }\n    }\n\n    for\
    \ (let i = 0; i <= operandNum - 1; i++){\n        if (firstOperand === operandArr[i]){\n\
    \            firstOperandNum = i;\n        }\n        if (lastOperand === operandArr[i]){\n\
    \            lastOperandNum = i;\n        }\n    }\n\n    for (let i = 0; i <\
    \ firstOperandNum; i++){\n        if (i === firstOperandNum){\n            firstExp\
    \ = firstExp + (firstOperand) * firstOperandNum;\n        }\n        expArr.push(firstExp);\n\
    \    }\n\n    for (let i = firstOperandNum + 1; i < lastOperandNum; i++){\n  \
    \      if (i === firstOperandNum + 1){\n            firstExp = firstExp + (firstOperand)\
    \ * firstOperandNum;\n        }\n        expArr.push(firstExp);\n    }\n\n   \
    \ for (let i = firstOperandNum + 1; i < lastOperandNum; i++){\n        expNum\
    \ = expArr[expArr.length - 1];\n        expArr.push(expNum);\n        multiplier\
    \ = multiplier * i;\n    }\n\n    for (let i = firstOperandNum + 1; i < lastOperandNum;\
    \ i++){\n        expression = expression + expArr[i] + '*';\n    }\n\n    for\
    \ (let i = firstOperandNum + 1; i < lastOperandNum; i++){\n        expression\
    \ = expression + expArr[i];\n    }\n\n    if (lastOperandNum === operandNum -\
    \ 1){\n        for (let i = firstOperandNum; i < lastOperandNum; i++){\n     \
    \       expression = expression + expArr[i];\n        }\n    }\n\n    let finalExp\
    \ = expression.replace(/[^0-9.]/g, \"\");\n\n    let finalMultiplier = multiplier\n\
    \    let finalExpNum = parseInt(finalExp);\n\n    if (finalExpNum < 0){\n", " \
    \ var result = \"\"\n  for(var i = 0; i < operator.length; i++){\n    var operatorCode\
    \ = operator[i]\n    var operand1 = operand[i] - 1\n    var operand2 = operand[i]\n\
    \    var currentNumber = operand1 * operand2\n    var operation = operatorCode\n\
    \n    switch(operation){\n      case '+':\n        result += currentNumber\n \
    \       break\n      case '-':\n        result -= currentNumber\n        break\n\
    \      case '*':\n        result *= currentNumber\n        break\n      case '/':\n\
    \        result /= currentNumber\n        break\n      case '^':\n        result\
    \ **= currentNumber\n        break\n    }\n  }\n\n  return result\n}\n", "\tvar\
    \ result = 0;\n\tvar operator_index = 0;\n\tvar operators = operator.split('');\n\
    \twhile(operator_index < operators.length){\n\t\tresult = result + eval_expression(operators[operator_index],\
    \ operand, operator_index);\n\t\toperator_index++;\n\t}\n\treturn result;\n}\n",
  "\t// Step 1: Check arguments\n\t// If null or undefined is passed into operator,\
    \ throw exception.\n\tif(typeof operator === 'undefined' || operator === null){\n\
    \t\tthrow new Error('Invalid operator passed!');\n\t}\n\t// If null or undefined\
    \ is passed into operand, throw exception.\n\tif(typeof operand === 'undefined'\
    \ || operand === null){\n\t\tthrow new Error('Invalid operand passed!');\n\t}\n\
    \t\n\t// Step 2: Convert operand and operator to basic algebra expressions\n\t\
    var expression = [];\n\tfor(var i = 0; i<operand.length; i++){\n\t\texpression.push(operator[i]);\n\
    \t\texpression.push(operand[i]);\n\t}\n\t\n\t// Step 3: Perform the calculation\
    \ and return the result\n\t// Iterate through the list and perform the calculation.\
    \ \n\tvar result = 1;\n\tfor(var i = 0; i<expression.length; i++){\n\t\tswitch(expression[i]){\n\
    \t\t\tcase '+':\n\t\t\t\tresult = result + operand[i];\n\t\t\t\tbreak;\n\t\t\t\
    case '-':\n\t\t\t\tresult = result - operand[i];\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\
    \t\t\t\tresult = result * operand[i];\n\t\t\t\tbreak;\n\t\t\tcase '//':\n\t\t\t\
    \tresult = result / operand[i];\n\t\t\t\tbreak;\n\t\t\tcase '**':\n\t\t\t\tresult\
    \ = result ** operand[i];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n",
  "\tlet op = operator[Math.floor(Math.random()*operator.length)];\n\tlet operand_1\
    \ = operand[Math.floor(Math.random()*operand.length)];\n\tlet operand_2 = operand[Math.floor(Math.random()*operand.length)];\n\
    \tlet result = operand_1 + operand_2;\n\tif(op == '-') result = result - operand_2;\n\
    \tif(op == '*') result = result * operand_2;\n\tif(op == '/') result = result\
    \ / operand_2;\n\tif(op == '**') result = result ** operand_2;\n\tif(op == '*')\
    \ result = Math.floor(result);\n\treturn result;\n}\n", "    let result = 0;\n\
    \    for(var i = 0; i < operator.length; i++){\n        result += operand[i] *\
    \ operator[i];\n    }\n    return result;\n}\n", "    for(let i=0;i<operand.length;i++){\n\
    \        //add number\n        if(operator[i]==\"+\"){\n            //add them\
    \ up\n            return operand[i]+operand[i+1];\n        }\n        //subtract\
    \ numbers\n        else if(operator[i]==\"-\"){\n            //subtract them down\n\
    \            return operand[i]-operand[i+1];\n        }\n        //multiply numbers\
    \ by numbers\n        else if(operator[i]==\"*\"){\n            //multiply them\
    \ times\n            return operand[i]*operand[i+1];\n        }\n        //divide\
    \ numbers by numbers\n        else if(operator[i]==\"//\"){\n            //divide\
    \ them by numbers\n            return operand[i]/operand[i+1];\n        }\n  \
    \      //raise numbers to power\n        else if(operator[i]==\"**\"){\n     \
    \       //raise them to the power of numbers\n            return operand[i]**operand[i+1];\n\
    \        }\n    }\n}\n", "    let total = 0;\n    let op1 = operator[0];\n   \
    \ let op2 = operator[1];\n    let op3 = operator[2];\n    let op4 = operator[3];\n\
    \    let operand1 = operand[0];\n    let operand2 = operand[1];\n    let operand3\
    \ = operand[2];\n    let operand4 = operand[3];\n    switch(op1){\n        case\
    \ '+':\n            total+=operand1;\n            total+=operand2;\n         \
    \   total-=operand3;\n            total-=operand4;\n            break;\n     \
    \   case '-':\n            total+=operand1;\n            total-=operand2;\n  \
    \          total+=operand3;\n            total+=operand4;\n            break;\n\
    \        case '*':\n            total+=operand1;\n            total*=operand2;\n\
    \            total/=operand3;\n            total/=operand4;\n            break;\n\
    \        case '/':\n            total+=operand1;\n            total/=operand2;\n\
    \            total+=operand3;\n            total*=operand4;\n            break;\n\
    \        case '//':\n            total+=operand1;\n            total+=operand2;\n\
    \            total+=operand3;\n            total+=operand4;\n            total=total%10;\n\
    \            break;\n        case '**':\n            total+=operand1;\n      \
    \      total*=operand2;\n            total/=operand3;\n            total*=operand4;\n\
    \            total=total%10;\n            break;\n    }\n    return total;\n}",
  "    var result = 0;\n    for (var i = 0; i < operator.length - 1; i++)\n    {\n\
    \        var operator1 = operator[i];\n        var operator2 = operator[i + 1];\n\
    \        result += operand[i] * operator1(operand[i+1], operand[i+2]);\n    }\n\
    \    return result;\n}", "    let result = 0\n    for(let i = 0; i < operator.length;\
    \ i++){\n        result += operand[i] * operator[i]\n    }\n    return result\
    \ \n}"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
