name: HumanEval_16_count_distinct_characters
language: js
prompt: "//Given a string, find out how many distinct characters (regardless of case)\
  \ does it consist of\n// >>> count_distinct_characters('xyzXYZ')\n// 3\n// >>> count_distinct_characters('Jerry')\n\
  // 4\nfunction count_distinct_characters(string){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = count_distinct_characters;\n  assert.deepEqual(candidate(\"\"),0);\n  assert.deepEqual(candidate(\"\
  abcde\"),5);\n  assert.deepEqual(candidate(\"abcdecadeCADE\"),5);\n  assert.deepEqual(candidate(\"\
  aaaaAAAAaaaa\"),1);\n  assert.deepEqual(candidate(\"Jerry jERRY JeRRRY\"),5);\n\
  }\n\ntest();"
completions: ["    var chars={}\n    \n    for(let i = 0; i < string.length; i++){\n\
    \        chars[string[i]] ? chars[string[i]]++ : chars[string[i]]=1\n    }\n \
    \   \n    return Object.keys(chars).length\n}\n</cell>\n<text>\nThe solution is\
    \ trivial:\n\n</text>\n<cell>", "  var unique = {}, uniqueChars = \"\", countChars\
    \ = \"\";\n  \n  if(string === undefined){\n    return 0;\n  }\n  \n  for(var\
    \ i = 0, len = string.length; i < len; i++){\n    var char = string.charAt(i);\n\
    \    \n    if(unique[char] === undefined){\n      uniqueChars += char;\n     \
    \ unique[char] = true;\n      countChars += 1;\n    }\n  }\n  \n  return countChars;\n\
    }\n", "  //remove spaces\n  var string = string.split(' ');\n  var counts = {}\n\
    \  for(var i = 0; i < string.length; i++){\n    var character = string[i];\n \
    \   if(counts[character]){\n      counts[character]++;\n    } else {\n      counts[character]\
    \ = 1;\n    }\n  }\n  return counts;\n}\n", "\tvar char_counts = { };\n\tvar char_list\
    \ = [];\n\t\n\tfor(var i = 0; i < string.length; i++){\n\t\tif(!char_counts[string[i]]){\n\
    \t\t\tchar_counts[string[i]] = 1;\n\t\t\tchar_list.push(string[i]);\n\t\t} else\
    \ {\n\t\t\tchar_counts[string[i]] += 1;\n\t\t}\n\t}\n\t\n\treturn char_list.length;\n\
    }\n", "\treturn string\n\t\t.split(\"\")\n\t\t.reduce(\n\t\t\t(count, character)=>\
    \ count+=1,\n\t\t\t0\n\t\t)\n}", "    var result = 0;\n    for(var i = 0; i <\
    \ string.length; i++){\n        var character = string[i];\n        var lowerCaseCharacter\
    \ = character.toLowerCase();\n        if(lowerCaseCharacter !== character){\n\
    \            result++;\n        }\n    }\n    return result;\n}", "    var chars\
    \ = string.split(\"\");\n    var result = 0;\n    for(var i=0;i<chars.length;i++){\n\
    \        for(var j=0;j<chars.length;j++){\n            if(chars[i]!=chars[j])\
    \ break;\n        }\n        result+=i;\n    }\n    return result;\n}\n", "  \
    \  var char_str = \"\";\n    var count = 0;\n    \n    for (var i=0; i<string.length;\
    \ i++) {\n        if(char_str.indexOf(string[i].toLowerCase()) == -1){\n     \
    \       char_str += string[i].toString();\n            count++;\n        }\n \
    \   }\n    return count;\n}\n", "  // Use an object to hold the counts\n  var\
    \ counts = {};\n  // Loop over the string and add counts for each character\n\
    \  for (var i = 0; i < string.length; i++){\n    // If the char does not yet exist\
    \ in the object then add it\n    if(counts[string[i]] === undefined) counts[string[i]]\
    \ = 1;\n    // Otherwise increase the count for that character\n    else counts[string[i]]++;\n\
    \  }\n  // Return the number of distinct characters\n  return Object.keys(counts).length;\n\
    }", "  var character = {};\n\n  for (var i = 0; i < string.length; i++){\n   \
    \ var current_char = string.charAt(i);\n\n    if (character.hasOwnProperty(current_char)){\n\
    \      character[current_char]++;\n    } else {\n      character[current_char]\
    \ = 1;\n    }\n  }\n\n  return Object.keys(character).length;\n}\n", "\treturn\
    \ string.replace(/[\\u4E00-\\u9FFF]/g, '')\n\t\t.match(/([a-zA-Z])\\1*/gi)\n\t\
    \t.length;\n}\n", "\tlet count = 0;\n\tfor(let i = 0; i < string.length; i++){\n\
    \t\tif(string.charAt(i) != string.charAt(i).toLowerCase() \n\t\t\t&& string.charAt(i)\
    \ != string.charAt(i).toUpperCase() \n\t\t\t&& string.charAt(i) != string.charAt(i).replace(/[^\\\
    w]/, '')){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n", "  var count =\
    \ {};\n  for(var i=0; i<string.length; i++){\n    var character = string[i];\n\
    \    if (count[character] == null)\n      count[character] = 0;\n    count[character]++;\n\
    \  }\n  return Object.keys(count).length;\n}\n\n", "    if(string.length == 0)\
    \ return 0;\n    var result = 0;\n    for(var i = 0; i < string.length; i++){\n\
    \        if(string.charCodeAt(i) > 96 && string.charCodeAt(i) < 123){\n      \
    \      result += string.charCodeAt(i) - 96;\n        }\n        else{\n      \
    \      result += string.charCodeAt(i);\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=2 tags=javascript,string,regex |>\n<| a |>\nHere is another\
    \ solution, which uses a counter to count the characters and a regular expression\
    \ to capture the groups of characters that appear more than once:\n\n<code>",
  "    var i, char, count = 1;\n    for(i = 0; i < string.length; i++){\n        char\
    \ = string.charAt(i);\n        if(i){\n            char = string.charAt(i).toLowerCase();\n\
    \        }\n        if(char_table[char]){\n            count++;\n        }else{\n\
    \            count = 1;\n        }\n    }\n    return count;\n}", "    var characters\
    \ = [];\n    var distinct = 0;\n    var stringLowerCase = string.toLowerCase();\n\
    \    \n    for (var i = 0; i < stringLowerCase.length; i++){\n        var character\
    \ = stringLowerCase[i];\n        \n        if(characters.indexOf(character) ===\
    \ -1){\n            characters.push(character);\n            distinct++;\n   \
    \     }\n    }\n    \n    return distinct;\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThis works, but I do think your solution is way better, because it doesn't\
    \ involve the use of regular expressions.\n<|/ c |>\n<| a tags=javascript,string,algorithm\
    \ |>\nAs others have noted, regular expressions might be the way to go. Here's\
    \ a solution using them.\n<code>", "  var counts = {};\n  var i;\n\n  for (i =\
    \ string.length-1; i >= 0; i--){\n    counts[string.charAt(i)] = 0;\n  }\n\n \
    \ for (i = 0; i < string.length; i++){\n    var letter = string.charAt(i);\n \
    \   counts[letter] +=1;\n  }\n\n  return counts;\n}\n", "  var hash = {};\n  var\
    \ length = 0;\n  \n  for (var i = 0; i < string.length; i++){\n    var char =\
    \ string.charAt(i);\n    var lowerCaseChar = char.toLowerCase();\n    if (!hash[lowerCaseChar])\
    \ hash[lowerCaseChar] = [];\n    hash[lowerCaseChar].push(char);\n  }\n  \n  for\
    \ (var chars in hash){\n    length += hash[chars].length;\n  }\n  \n  return length;\n\
    }\n", "    let arrOfLettersCount = new Array(26);\n    for (let i = 0; i < string.length;\
    \ i++) {\n        let char = string.charAt(i);\n        arrOfLettersCount[string.charCodeAt(i)\
    \ - 97]++;\n    }\n    let distinctCharsCount = 0;\n    for (let i = 0; i < 26;\
    \ i++) {\n        distinctCharsCount += arrOfLettersCount[i];\n    }\n    return\
    \ distinctCharsCount;\n}\n", "  var characters = string.split('');\n  return characters.length;\n\
    }\n", "  let char_map = {}\n  for (let char of string){\n    char_map[char] =\
    \ (char_map[char] || 0) + 1 //This line will increment the count for the character\
    \ if it already exists\n  }\n  return Object.keys(char_map).length\n}\n", "  return\
    \ (string+'').split('').filter(function(x, i) { return i && x }).length\n}\n\n",
  "\tvar characters = string.split('');\n\tvar counts = {};\n\tfor (var i = 0; i <\
    \ characters.length; i++){\n\t\tif (counts[characters[i]] == undefined)\n\t\t\t\
    counts[characters[i]] = 0;\n\t\tcounts[characters[i]]++;\n\t}\n\treturn counts;\n\
    }\n<|/ file dstars=1 filename=main.js source=github |>", "  // https://stackoverflow.com/questions/10382571/how-to-count-distinct-characters-in-javascript-string\n\
    \  if(!string){\n    return 0;\n  }\n  \n  var counts = Object.create(null), //\
    \ keep track of the counts for any given character\n      length    = string.length;\n\
    \n  // Step through each character in the string, one by one\n  for (var i = 0;\
    \ i < length; i++) {\n    var char = string.charAt(i); // Get the character at\
    \ position i\n    // If we haven't encountered this character before, increment\
    \ its count\n    // and mark it as encountered in the character counts object\n\
    \    if(counts.hasOwnProperty(char)){\n      counts[char]++;\n    } else {\n \
    \     // If we have encountered this character before, decrement its count\n \
    \     // and mark it as encountered in the character counts object\n      counts[char]--;\n\
    \    }\n  }\n\n  // Then return the total number of distinct characters\n  return\
    \ counts;\n}\n", "    string += ''\n    string = string.toLowerCase()\n    string\
    \ = string.replace(/[^\\w\\s]/gi, '')\n    return string.length\n}\n</code>\n\
    <|/ a tags=javascript,string,algorithm dscore=1 |>\n<| c |>\nI think this is overkill\
    \ to solve this problem. You're simply looping over the string and incrementing\
    \ `count` by 1 every time you see a character that isn't in the string (e.g. `count`\
    \ equals 0 on `abc`) which you can easily do with a single pass over the string.\n\
    <|/ c |>\n<| c |>\nHi Jack, that's a good point; I wasn't too sure of the best\
    \ way to get the count in a single pass. I made it a bit more explicit with a\
    \ comment in the code.\n<|/ c |>\n<| a tags=javascript,string,algorithm |>\nThe\
    \ most straightforward solution is to build a map of characters, counting the\
    \ number of occurrences of each one as you go, and keeping track of the highest\
    \ count seen so far:\n<code>", "  return string.toLowerCase()\n              .split('\
    \ ')\n              .filter( s => s.trim().length )\n              .length;\n\
    }\n", "    var freq = {},\n        character;\n    for(var i = 0, len = string.length;\
    \ i < len; i++){\n        character = string[i].toLowerCase();\n        if(freq[character]\
    \ == undefined)\n            freq[character] = 0;\n        freq[character]++;\n\
    \    }\n    return freq;\n}\n", "    \n    if(!string || !string.length){\n  \
    \      return 0\n    }\n\n    string = string.toLowerCase()\n    string = string.replace(/[^\\\
    w\\s]/gi, '')\n\n    let count = {}\n    for(const char of string){\n        \n\
    \        if(!count[char]) count[char] = 1\n        else count[char]++\n    }\n\
    \n    return Object.keys(count).length\n}\n", "\tvar counter = 0;\n\t\n\tfor(var\
    \ i=0; i<string.length; i++){\n\t\tvar character = string.charAt(i);\n\t\t\n\t\
    \tif(character.toUpperCase() === character){\n\t\t\tcounter++;\n\t\t}\n\t\t\n\t\
    \tif(character.toLowerCase() === character){\n\t\t\tcounter++;\n\t\t}\n\t}\n\t\
    \n\treturn counter;\n}\n", "    return string.split('').reduce(function(count,\
    \ char){\n        return count+char.match(/[a-z]/).length+char.match(/[A-Z]/).length+char.match(/\\\
    d/).length+char.match(/[^a-zA-Z\\d]/g).length;\n    }, 0);\n}\n", "    let characters\
    \ = []\n    for(let i = 0; i < string.length; i++){\n        if(characters.indexOf(string[i])\
    \ === -1){\n            characters.push(string[i])\n        }\n    }\n    return\
    \ characters.length\n}\n</code>\n<|/ a tags=javascript,python,algorithm |>\n<|\
    \ c |>\nWhy do you think that it's O(N) when it's O(N*N)?\n<|/ c |>\n<| c |>\n\
    My bad, fixed it.\n<|/ c |>\n<| c |>\nIt's O(n log n) because of the sort, so\
    \ you might as well just sort it first. O(n\xB2) doesn't seem very useful, especially\
    \ when there's an O(n log n) solution which can be done in O(n).\n<|/ c |>\n<|\
    \ c |>\nOh yeah, that's true, I just thought of it in terms of what OP asked for,\
    \ and forgot about the complexity.\n<|/ c |>\n<| a |>\nI think you need a hash\
    \ that counts how many of each letter are in the string, and return that value.\
    \ So if there are 3 a's and 4 b's in the string, you only have one 'a' in the\
    \ hash, and three 'b's. Then you can easily determine how many unique letters\
    \ there are in the string.\n<code>", "  return string.toLowerCase().split('').filter(function(item){\n\
    \    return (item === string.trim().toLowerCase());\n  }).length;\n}\n", "  var\
    \ counts = {};\n  string.split(\"\").forEach(function(char){\n    if (counts[char]){\n\
    \      counts[char]++;\n    } else {\n      counts[char] = 1;\n    }\n  });\n\
    \  return Object.keys(counts).length;\n}", "    var ret = {};\n    for(var i =\
    \ 0; i < string.length; i++){\n        ret[string[i].toLowerCase()] = true;\n\
    \    }\n    return Object.keys(ret).length;\n}\n", "    let chars = [];\n    for(let\
    \ c of string){\n        if(c in chars) chars[c]+=1; else chars[c]=1;\n    }\n\
    \    let res = 0;\n    for(const c in chars){\n        if(chars[c] > 1) res+=chars[c];\n\
    \    }\n    return res;\n}\n", "    // loop through the string\n    for(var i=0;i<string.length;i++){\n\
    \        // check if this character is unique\n        if(!in_array(string.charAt(i),\
    \ unique_characters)){\n            // add this character to the array of unique\
    \ characters\n            unique_characters.push(string.charAt(i));\n        }\n\
    \    }\n    // return the length of the unique characters (regardless of case)\n\
    \    return unique_characters.length;\n}\n</code>\n<|/ a tags=javascript,string,arrays,sorting,unique\
    \ |>\n<| a tags=javascript,string,arrays,sorting,unique |>\n<code>\nlet result\
    \ = arr.reduce((acc, curr, i, arr) => {\n    let [firstChar, secondChar] = curr.split('');\n\
    \    firstChar = firstChar.toLowerCase();\n    secondChar = secondChar.toLowerCase();\n\
    \n    if (firstChar.charCodeAt(0) === secondChar.charCodeAt(0)) \n        acc[firstChar]\
    \ = acc[firstChar] + 1 || 1;\n    return acc;\n}, {});\n</code>\nThe above snippet\
    \ should do exactly what you asked for. Here is a link to play around with.\n\
    <|/ a dscore=1 |>\n<| c |>\nThis code may do what you want, but it is more complex\
    \ than it needs to be. No need to call `toLowerCase` when doing `firstChar.charCodeAt(0)`,\
    \ etc.\n<|/ c |>\n<| a |>\n<code>\nvar string = \"Jerry\"\n\nvar unique = (string\
    \ => {\n  var u = {}\n  var t = string.split('')\n  for(var i=0; i<t.length; i++){\n\
    \    if(u.hasOwnProperty(t[i])){\n      u[t[i]]++\n    }else{\n      u[t[i]] =\
    \ 1\n    }\n  }\n  console.log(Object.keys(u).length)\n  return Object.keys(u).length\n\
    })(string)\n</code>\n<|/ a dscore=1 tags=javascript,string,arrays,sorting,unique\
    \ |>\n<| a tags=javascript,string,arrays,sorting,unique |>\nUsing a Map (which\
    \ has O(1) lookup time) should suffice.\n\n<code>\nlet myString = \"Jerry\"\n\n\
    let map = new Map()\nmyString.split('').forEach(char => map.set(char, true))\n\
    \nlet unique = Array.from(map.keys())", "  return count_distinct_characters_1(string.toLowerCase());\n\
    }\n", "    var result = {};\n    var character;\n    var i;\n    var c;\n\n  \
    \  for (i = 0; i < string.length; i++){\n        c = string[i];\n        if (character\
    \ !== c){\n            result[character] = result[character] || 0;\n         \
    \   result[character]++;\n        }\n        character = c;\n    }\n\n    return\
    \ result;\n}\n\n", "  return string.split('').filter((v,i)=>{\n    return string.indexOf(v)===i;\n\
    \  }).length;\n}\n</cell>\n<text>\nB) Challenge yourself\nWrite a function that\
    \ will accept 2 arguments: a list of characters and a list of strings (any length)\
    \ and return a list of booleans indicating whether each string contains the distinct\
    \ characters from the list of characters.\n\n\n</text>\n<cell>", "    let count\
    \ = 0;\n    for(let i = 0; i < string.length; i++){\n        if(string.charAt(i)\
    \ !== string.charAt(i).toUpperCase()){\n            count += 1;\n        }\n \
    \   }\n    return count;\n}\n", "    let uniqueCharArr = []\n    let charCount\
    \ = 0\n    for(let char of string){\n        if(uniqueCharArr.indexOf(char) ==\
    \ -1){\n            uniqueCharArr.push(char)\n            charCount++\n      \
    \  }\n    }\n    return charCount\n}", "  let hash={};\n  let count=0;\n  let\
    \ current_char;\n  for (let char of string){\n    if(hash[char]){\n      hash[char]++;\n\
    \    }else{\n      hash[char]=1;\n    }\n  }\n  for (let char in hash){\n    count+=hash[char];\n\
    \  }\n  return count;\n}\n", "    var arr = [];\n    for(var i=0; i<string.length;\
    \ i++){\n        var char = string.charAt(i).toLowerCase();\n        if(arr.indexOf(char)\
    \ < 0){\n            arr.push(char);\n        }\n    }\n    return arr.length;\n\
    }\n</code>\nThe only thing to do now is to implement the function above as a map\
    \ operation to convert your strings into numbers. The following code snippet would\
    \ do this:\n<code>", "    var strings = string.split('');\n    var counts = {};\n\
    \n    strings.forEach(function(value){\n        counts[value] = counts[value]\
    \ ? counts[value]+1 : 1;\n    });\n\n    return counts;\n}\n", "\treturn string.split('').sort().filter(function(elem,\
    \ index, self){\n\t\treturn index == self.indexOf(elem);\n\t}).length;\n}\n",
  "    //If the string starts with a lowercase letter, make it uppercase and remove\
    \ it from the string\n    //If the string starts with a capital letter, make it\
    \ lowercase and remove it from the string\n    //If it contains only lowercase\
    \ letters, just return it\n    //If it contains only capital letters, make it\
    \ uppercase and remove it from the string\n    var firstChar = string.charAt(0).toLowerCase();\n\
    \    var lastChar = string.charAt(string.length - 1);\n    if(firstChar == lastChar){\n\
    \        return string.length\n    }\n    else if(firstChar == string[0]){\n \
    \       return string.charAt(0).toLowerCase().charCodeAt(0) - 96\n    }\n    else\
    \ if(firstChar == string[string.length - 1]){\n        return string.charAt(string.length\
    \ - 1).charCodeAt(0) - 64\n    }\n    return string.length\n}\n", "\tlet characters\
    \ = string.split('').sort();\n\treturn characters.length - 1;\n}\n", "  let counter\
    \ = 0;\n  let upperCase = true;\n  let i = 0;\n  while(i < string.length){\n \
    \   if(string[i] === string[i].toUpperCase() && upperCase === true){\n      counter++;\n\
    \    }\n    else if(string[i] === string[i].toLowerCase() && upperCase === false){\n\
    \      counter++;\n    }\n    i++;\n  }\n  return counter;\n}\n", "    var arr\
    \ = [];\n    var count = -1;\n    string.split('').map(function(each){\n     \
    \   if(each == each){\n            count++;\n        }else{\n            if(arr[0]\
    \ > count){\n                arr = arr.slice(0,-1);\n            }\n         \
    \   arr.push(each);\n            count = 1;\n        }\n    });\n    if(arr[0]\
    \ > count){\n        arr = arr.slice(0,-1);\n    }\n    return arr.length;\n}\n\
    </code>\n<|/ a tags=javascript,algorithm,string |>\n<| a dscore=2 |>\nIn Python\
    \ we can do this as follows:\n<code>\ndef number_of_unique_chars(string):\n  chars\
    \ = [x for x in string]\n  return len([x for x in chars if chars.count(x) == 1])\n\
    </code>\n<|/ a tags=javascript,algorithm,string |>\n<| a tags=javascript,algorithm,string\
    \ |>\nI created a function that counts the number of distinct characters in a\
    \ string.\nThe algorithm is:\n\nIterate through the string.\nCreate a map of characters\
    \ to number of occurrences.\nIf current character in map has count greater than\
    \ 1, remove it.\nIf current character in map has count 1, add 1 to the count of\
    \ that character in the map.\n\nThe code is as follows:\n<code>", "  return string.replace(/[^A-Z]+/g,\"\
    \").length;\n}\n", "    var uniques = new HashSet();\n    var stringAsArray =\
    \ string.split(\"\");\n    for (var i=0;i<stringAsArray.length;i++){\n       \
    \ if (uniques.contains(stringAsArray[i])){\n            uniques.delete(stringAsArray[i]);\n\
    \        } else {\n            uniques.add(stringAsArray[i]);\n        }\n   \
    \ }\n    return uniques.size;\n}\n", "  var unique = {}, counter = 0;\n  string\
    \ = string.split('');\n  for(var i = 0, len = string.length; i < len;  i++){\n\
    \    unique[string[i]] = string[i];\n  }\n  for(var key in unique){\n    counter++;\n\
    \  }\n  return counter;\n}\n</code>\n<|/ a tags=javascript,string,arrays |>\n\
    <| a dscore=0 |>\nYou could use an associative array.\n<code>\nvar a = {};\nvar\
    \ len = str.length,\n    i=0;\n\nfor(i=0;i<len;i++){\n  if(!(a[str[i]])){\n  \
    \  a[str[i]] = 1;\n  }else{\n    a[str[i]] = a[str[i]] + 1;\n  }\n}\n</code>\n\
    The associative array will contain a list of all unique characters and the count\
    \ of how often they occur in the string.\n<|/ a tags=javascript,string,arrays\
    \ |>\n<| a dscore=0 |>\nA good way to do it if you are not interested in ordering,\
    \ would be to use the following:\n<code>", "  let charCounts = {};\n  for(const\
    \ char of string){\n    if(charCounts[char]){\n      charCounts[char] += 1;\n\
    \    }else{\n      charCounts[char] = 1;\n    }\n  }\n  return Object.keys(charCounts).length\n\
    }\n", "  return [...string].reduce((a, b) => {\n    return a + (b ? b.length :\
    \ 0);\n  }, 0);\n}\n", "  var distinct_characters_count = {};\n  distinct_characters_count\
    \ = distinct_characters_count || {};\n  distinct_characters_count[''] = 1;\n \
    \ for(var i=0;i<string.length;i++){\n    distinct_characters_count[string.charAt(i)]\
    \ = (distinct_characters_count[string.charAt(i)] || 0) + 1;\n  }\n  return distinct_characters_count;\n\
    }", "    let result = 0;\n    string.split('').forEach((char) => {\n        if(char.match(/[a-z]/i)\
    \ || char.match(/[A-Z]/i)){\n            result += 1\n        }\n    })\n    return\
    \ result\n}\n", "\tvar chars = {};\n\tvar i, len = string.length;\n\tfor(i = 0;\
    \ i < len; i++){\n\t\tif(chars[string[i]]){\n\t\t\tchars[string[i]] += 1;\n\t\t\
    } else {\n\t\t\tchars[string[i]] = 1;\n\t\t}\n\t}\n\treturn chars;\n}\n", "  \
    \  let charsCounter = new Map();\n    string.split('').forEach((char, index) =>\
    \ {\n        charsCounter.has(char) ? (charsCounter.get(char) + 1) : charsCounter.set(char,\
    \ 1);\n    });\n\n    return charsCounter.size;\n}", "    \n}\n", "    return\
    \ string.replace(/[^A-Z]+/gi,\"\").length;\n}\n</code>\n<|/ a |>\n<| c |>\nThat\
    \ was what I was looking for, Thanks!\n<|/ c |>\n<| c |>\nYou beat me to it. :)\
    \ I'd like to add that `countDistinctCharacters` is much slower than `count_distinct_characters`.\
    \ It's not a big deal though, but it's still pretty slow.\n<|/ c |>\n<| a tags=javascript,algorithm\
    \ dscore=1 |>\nThe solution is to use javascript string split function.\n<code>",
  "    return arrayToString(string).length\n}\n", "  var hash = {}\n  for (var i =\
    \ 0; i < string.length; i++){\n    var char = string[i]\n    hash[char] = hash[char]\
    \ + 1 || 1\n  }\n  return hash\n}\n", "\tvar count = 0;\n\tvar current_char =\
    \ string.charAt(0);\n\tfor(var i = 0; i < string.length; i++){\n\t\tcurrent_char\
    \ = string.charAt(i);\n\t\tif(current_char == string.charAt(i + 1)){\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\treturn count;\n}\n", "  return string\n    .toLowerCase()\n    .split(\"\
    \")\n    .reduce((acc, cur) => acc + cur.length, 0);\n}\n", "\treturn (string\
    \ + '').replace(/[^a-z]/g,'').length;\n}\n", "  let result = 0\n  let currentChar\
    \ = ''\n  for(let i = 0; i < string.length; i++){\n    if(string[i] !== currentChar){\n\
    \      result++\n      currentChar = string[i]\n    }\n  }\n  return result\n\
    }\n\n", "  var unique_array = [];\n  for(var i = 0;i < string.length;i++){\n \
    \   if(unique_array.indexOf(string[i]) == -1){\n      unique_array.push(string[i]);\n\
    \    }\n  }\n  return unique_array.length;\n}\n", "  var result = 0;\n  for (var\
    \ i = 0; i < string.length; i++)\n    result += (string.charCodeAt(i) === string.charCodeAt(i));\n\
    \  return result;\n}\n", "\tconst dict = {};\n\t\n\tstring.split('').forEach(letter=>{\n\
    \t\tif(dict[letter]) dict[letter]++;\n\t\telse dict[letter] = 1;\n\t});\n\t\n\t\
    return Object.keys(dict).length;\n}\n", "  //count the number of occurrences of\
    \ any character in a given string\n  let count = 0;\n  //convert the string into\
    \ an array and then count each character in that array\n  //note: if the string\
    \ has more than 26 characters, this will get an error\n  for (let i = 0; i < string.length;\
    \ i++){\n    count += string.split(string.charAt(i)).length;\n  }\n  return count;\n\
    }\n", "\tvar characters = {};\n\tfor(var i = 0; i< string.length; i++){\n\t\t\
    var character = string[i];\n\t\tif(character in characters){\n\t\t\tcharacters[character]\
    \ += 1;\n\t\t}else{\n\t\t\tcharacters[character] = 1;\n\t\t}\n\t}\n\treturn Object.keys(characters).length;\n\
    }", "  // We need to keep track of how many different chars there are until we\
    \ find an alphanumeric one.\n  let uniqueCharacters = 0;\n\n  for (let i = 0;\
    \ i < string.length; i++){\n    // If the current character isn't alphanumeric,\
    \ increment the counter\n    if (uniqueCharacters !== 0 && uniqueCharacters !==\
    \ string[i]) uniqueCharacters++;\n  }\n\n  return uniqueCharacters;\n}\n</code></pre>\n\
    \        </article>\n    </section>\n\n\n\n\n\n\n        \n\n        <footer class=\"\
    content-size\">\n            <div class=\"footer\">\n                Documentation\
    \ generated by <a href=\"https://github.com/jsdoc3/jsdoc\">JSDoc 3.5.5</a> on\
    \ Thu Jan 21 2019 18:42:43 GMT+0800 (CST)\n            </div>\n        </footer>\n\
    \    </div>\n</div>\n<script>prettyPrint();</script>\n<script src=\"scripts/main.js\"\
    ></script>\n</body>\n</html>\n\n<|/ file source=github |><|endofmask|>dstars=2\
    \ ext=.html |><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>//Given\
    \ a string, find out how many distinct characters (regardless of case) does it\
    \ consist of", "  var result = 1;\n  for(var i = 1; i < string.length; i++){\n\
    \    if(string.charCodeAt(i) !== string.charCodeAt(i - 1)){\n      result++;\n\
    \    }\n  }\n  return result;\n}\n", "  return string.toLowerCase()\n    .replace(/[^a-z\
    \ ]/g, '')\n    .length;\n}", "\treturn count_distinct_characters_in_string(string.toLowerCase(),\
    \ string.toUpperCase());\n}\n", "\treturn string.split('').map(function(letter){\n\
    \t\treturn [letter.toUpperCase(), letter.toLowerCase()].sort().join('').length;\n\
    \t}).reduce(function(pv, cv){\n\t\treturn pv + cv;\n\t});\n}\n\n", "  var unique_characters\
    \ = \"\";\n  \n  for(var i = 0; i < string.length; i++){\n    var letter = string.charAt(i)\n\
    \    if(unique_characters.indexOf(letter) == -1){\n      unique_characters +=\
    \ letter\n    }\n  }\n  \n  return unique_characters.length\n}\n</cell>\n<text>\n\
    Given a string, find out how many times the letter X appears in the string.\n\
    If the letter appears more than once, ignore all but the first occurrence.\n\n\
    \n</text>\n<cell>", "    var count = 0;\n    for(var i = 0; i < string.length;\
    \ i++){\n        for(var j = i; j < string.length; j++){\n            if(string.charCodeAt(i)\
    \ === string.charCodeAt(j)){\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    // Go through\
    \ each character in the string and add it to an array (called array)\n    let\
    \ array = string.split(\"\");\n    // Go through each character in the array and\
    \ count the ones that are different\n    // We use an object here to hold the\
    \ number of times each character appears within array\n    let count_characters\
    \ = {};\n    array.forEach(element => {\n        if (count_characters[element])\
    \ {\n            count_characters[element]++;\n        }else{\n            count_characters[element]\
    \ = 1;\n        }\n    });\n    // The length of the object is the number of different\
    \ characters\n    return count_characters.length;\n}\n</code>\n<|/ a tags=character,javascript,string\
    \ |>\n<| c |>\nThis is actually the best solution\n<|/ c |>\n<| a dscore=5 tags=character,javascript,string\
    \ |>\nUse a Set to store your characters in and count how many characters are\
    \ in the Set by using the size property of Set :\n<code>", "    return string.split('').filter(\
    \ function(character){\n            return character.trim().toLowerCase() !==\
    \ character;\n        }).length;\n}\nmodule.exports = count_distinct_characters;\n\
    },{}],\"Sic/common/Errors\":[function(require,module,exports){\n'use strict';\n\
    var Errors = function (errors) {\n    this.errors = errors || [];\n}\n\nErrors.prototype.add\
    \ = function (err) {\n    this.errors.push(err);\n};\n\nErrors.prototype.clear\
    \ = function () {\n    this.errors = [];\n};\n\nErrors.prototype.toString = function\
    \ () {\n    return this.errors.map(function (err) {\n        return err.message;\n\
    \    }).join('\\n');\n};\n\nmodule.exports = Errors;\n},{}],\"Sic/common/Message\"\
    :[function(require,module,exports){\n'use strict';", "  return string.split('').reduce(function(result,\
    \ char){\n    return result.hasOwnProperty(char) ? result[+char] : ++result[+char];\n\
    \  }, {});\n}\n", "\tvar characterCountMap = {};\n\tfor (var i = 0; i < string.length;\
    \ i++){\n\t\tvar character = string.charAt(i);\n\t\tif (!characterCountMap[character]){\n\
    \t\t\tcharacterCountMap[character] = 1;\n\t\t}\n\t\telse {\n\t\t\tcharacterCountMap[character]\
    \ ++;\n\t\t}\n\t}\n\treturn Object.keys(characterCountMap).length;\n}\n", "  \
    \  var hash = {}; // hash of characters (not case sensitive)\n    var count =\
    \ 0; // how many different characters were in the string\n\n    //For every character\
    \ in the string...\n    for(var i = 0; i < string.length; i++){\n        var character\
    \ = string[i];\n\n        //If the character is already in the hash, add one to\
    \ its count value\n        if(hash[character]){\n            hash[character] +=\
    \ 1;\n        }\n        else{\n            //Otherwise add the character to the\
    \ hash object and give it a count of 1\n            hash[character] = 1;\n   \
    \     }\n    }\n\n    //Return the length of the hash object\n    return Object.keys(hash).length;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i)\
    \ !== string.charAt(i).toUpperCase()) {\n      count++;\n    }\n  }\n  return\
    \ count;\n}", "  var result = 0;\n  for(var i = 0; i < string.length; i++){\n\
    \    var letter = string[i];\n    for( var j = i + 1; j < string.length; j++){\n\
    \      var other = string[j];\n      if(letter === other){\n        result++;\n\
    \      }\n    }\n  }\n  return result;\n}\n", "\treturn string\n\t\t.toLowerCase()\n\
    \t\t.match(/[a-z]+/g).length\n}", "  let counter=0\n  \n  for (let i = 0; i <\
    \ string.length; i++) {\n    let char = string.charAt(i)\n    if (string.indexOf(char.toLowerCase())\
    \ >= 0 || string.indexOf(char.toUpperCase()) >= 0) {\n      counter ++\n    }\n\
    \  }\n\n  return counter\n}\n", "    let map = {};\n    for(let i=0; i<string.length;\
    \ i++){\n        let key = string.charAt(i);\n        if(map[key] == null)\n \
    \           map[key] = 1;\n        else\n            map[key]+=1;\n    }\n   \
    \ return Object.keys(map).length;\n}\n", "    let num_characters = 0;\n    for\
    \ (let i = 0; i < string.length; i++)\n    {\n        if (string.includes(string.charAt(i).toUpperCase()))\n\
    \        {\n            num_characters++;\n        }\n    }\n    return num_characters;\n\
    }\n", "  return string.split('').filter((character)=> character === character\
    \ || character.toLowerCase() === character.toLowerCase()).length\n}\n", "    return\
    \ string.split('').filter( function(i) { return this.indexOf(i) !== 0 }).length;\n\
    }\n", "    for(var i = 0, char_count = 0; i < string.length; i++){\n        if(string.charAt(i)\
    \ !== string.charAt(i)){\n            char_count++;\n        }\n    }\n    return\
    \ char_count;\n}\n", "  var unique = {}, hash = {}, result = 0;\n  for(var i =\
    \ 0; i < string.length; i++){\n    var char = string.charAt(i);\n    if (!(char\
    \ in unique)) unique[char] = 1;\n    else unique[char]++;\n  }\n  for(var char\
    \ in unique){\n    if(!(char in hash)){\n      hash[char] = 0;\n      result++;\n\
    \    }\n    hash[char]++;\n  }\n  return result;\n}\n\n", "    return string.split('').filter(function(char){\n\
    \      return !char.match(/[a-z]$/) && !char.match(/[A-Z]$/) && !char.match(/[_]$/);\n\
    \    }).length;\n  }\n  \n  //Given a string, find out how many different characters\
    \ (regardless of case) does it consist of", "  let distinct_characters_count =\
    \ 0;\n  const char_array = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\
    \n  for (let i = 0; i < string.length; i++) {\n    if (char_array.includes(string.charAt(i)))\
    \ {\n      distinct_characters_count++;\n    }\n  }\n  return distinct_characters_count;\n\
    }\n", "    var counter = {}\n    for(var i = 0; i < string.length; i++){\n   \
    \     var char = string.charAt(i)\n        if(counter[char] !== undefined){\n\
    \            counter[char] += 1\n        } else {\n            counter[char] =\
    \ 1\n        }\n    }\n    return Object.keys(counter).length\n}", "    return\
    \ string.split('').reduce(function(acc, val) {\n        if(val === string){\n\
    \            acc++;\n        }\n        return acc;\n    }, 0);\n}\n", "  let\
    \ count = 0;\n  for(let i = 0; i < string.length; i++){\n    if(string.charCodeAt(i)\
    \ > 90){\n      count += 1;\n    }\n  }\n  return count;\n}", "\t// Count distinct\
    \ characters (regardless of case)\n\tlet counts = {};\n\tfor(let i = 0; i < string.length;\
    \ i++){\n\t\tlet char = string.charAt(i);\n\t\tcounts[char] = (counts[char] ||\
    \ 0) + 1;\n\t}\n\treturn counts;\n}\n", "  return string.toLowerCase().split('').filter(function(character){\n\
    \    return character === character.toUpperCase();\n  }).length;\n}\n", "    //Make\
    \ sure we only deal with letters\n    string = string.split(\"\").sort().join(\"\
    \");\n    //Initialize a dictionary to store how many times each character appears\n\
    \    var characters = {};\n    for(let i = 0; i < string.length; i++){\n     \
    \   //Check if the character is in the dictionary\n        if(characters[string[i]]){\n\
    \            //If it is, increment the count by 1\n            characters[string[i]]\
    \ ++;\n        } else {\n            //Otherwise, set the count to 1, and add\
    \ it to the dictionary\n            characters[string[i]] = 1;\n        }\n  \
    \  }\n    //Return the number of distinct characters\n    return Object.keys(characters).length;\n\
    }\n", "    return string.split(\"\").reduce((acc, char) => acc + 1, 0)\n}\n",
  "  return countChars(string, '', {});\n}\nmodule.exports = count_distinct_characters;\n\
    \n},{\"./lib/countChars\":32}],34:[function(require,module,exports){", "    return\
    \ string.split('').reduce(function(memo, letter){\n        if(memo[letter]){\n\
    \            memo[letter]++\n        }else{\n            memo[letter] = 1\n  \
    \      }\n        return memo\n    }, {})\n}\n", "  var unique = {};\n  var length\
    \ = 0;\n  \n  for(var i = 0; i < string.length; i++){\n    var character = string[i].toLowerCase();\n\
    \    if(unique[character] === undefined) unique[character] = true;\n    else unique[character]++;\n\
    \  }\n  \n  for(var i = 0; i < Object.keys(unique).length; i++){\n    length++;\n\
    \  }\n  \n  return length;\n}", "    return string.split('')\n        .filter(function(character){\n\
    \            return character.toUpperCase() === character && character.toLowerCase()\
    \ !== character;\n        })\n        .length;\n}\n</code>\nA different implementation\
    \ using reduce method could be\n<code>", "    let characters = string.split('')\n\
    \    return characters.length\n}\n", "    return string.toLowerCase().split('').filter(function(value,\
    \ index, self){\n        return self.indexOf(value) === index;\n    }).length;\n\
    }\n", "  const map = new Map();\n  for (let i = 0; i < string.length; i++){\n\
    \    const letter = string[i].toLowerCase()\n    if (map.has(letter)){\n     \
    \ map.set(letter, map.get(letter) + 1)\n    } else {\n      map.set(letter, 1)\n\
    \    }\n  }\n  return map.size\n}\n", "  var letters = {}, letters_count = 0,\
    \ string_to_test = string;\n  for(var i = 0, length = string_to_test.length; i\
    \ < length; i++) {\n    letters[string_to_test[i]] = string_to_test[i];\n  }\n\
    \  for(var i in letters){\n    if(letters.hasOwnProperty(i)) {\n      letters_count\
    \ += 1;\n    }\n  }\n  return letters_count;\n}\n", "  // Create an empty object\
    \ to store all the characters\n  var uniqueChars = {};\n  // Count all the characters\
    \ in the string\n  for(var i=0;i<string.length;i++){\n    if(!uniqueChars[string[i]]){\n\
    \      uniqueChars[string[i]]=1;\n    } else {\n      uniqueChars[string[i]]+=1;\n\
    \    }\n  }\n  // Count the distinct characters\n  var distinctCount = 0;\n  for(var\
    \ key in uniqueChars){\n    distinctCount++;\n  }\n  return distinctCount;\n}\n\
    </code>\nAnd that's all there is to it!\n<|/ a dscore=0 |>\n<| a tags=javascript,node.js\
    \ |>\nI made this function, it counts how many times the word appears in an array,\
    \ by splitting the word and counting how many times each letter appears.\n<code>",
  "    var count = 0;\n    var character;\n    \n    for(var i = 0; i < string.length;\
    \ i++){\n        character = string.charAt(i);\n        if(character === character.toUpperCase()){\n\
    \            count++;\n        }\n        else if(character === character.toLowerCase()){\n\
    \            count++;\n        }\n    }\n    \n    return count;\n}\n\n", "  \
    \  let map = new Map();\n    for(let letter of string){\n        map.set(letter,\
    \ map.has(letter) ? map.get(letter) + 1 : 1);\n    }\n    return map.size;\n}\n",
  "  if (string == '')\n    return 0;\n  var characters = string.split('');\n  var\
    \ count = 0;\n  for (var i = 0; i < characters.length; i++)\n    count += characters[i].length;\n\
    \  return count;\n}\n", "  return string.split('').reduce((acc, val) => {\n  \
    \  if(val === string[acc.length - 1]) return acc;\n    return acc + val.toLowerCase().split('').reduce((acc,\
    \ val) => {\n      if(val === string[acc.length - 1]) return acc;\n      return\
    \ acc + val;\n    }, 0);\n  }, 0);\n}\n", "\tvar unique = [];\n\tfor (var i =\
    \ 0; i < string.length; i++){\n\t\tvar char = string.charCodeAt(i);\n\t\tif (!~unique.indexOf(char))\
    \ {\n\t\t\tunique.push(char);\n\t\t}\n\t}\n\treturn unique.length\n}\n", "\tvar\
    \ result = {}\n\tfor (character in string){\n\t\tif (string.hasOwnProperty(character)){\n\
    \t\t\tresult[character] = result[character] ? result[character]+1 : 1;\n\t\t}\n\
    \t}\n\treturn Object.values(result).length;\n}\n", '  return unique(string.replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]/g,
    "").replace(/[^A-Za-z]/g, "").replace(/[^A-Za-z]', "  // TODO: Optimize\n  var\
    \ letters = 'abcdefghijklmnopqrstuvwxyz';\n  var count = {};\n  for (var i = 0;\
    \ i < string.length; i++) {\n    var letter = string[i];\n    count[letter] ?\
    \ count[letter]++ : count[letter] = 1;\n  }\n  var total_letters = letters.length;\n\
    \  var distinct_letters = 0;\n  for (var letter in count) {\n    distinct_letters\
    \ += count[letter];\n  }\n  return distinct_letters;\n}\n", "  var map = {}, count\
    \ = 1;\n  for (var i = 0; i < string.length; i++){\n    map[string[i].toLowerCase()]\
    \ = map[string[i].toLowerCase()] || {};\n    map = map[string[i].toLowerCase()];\n\
    \    map[string[i]] = map[string[i]] || count;\n    count = count + 1;\n  }\n\
    \  return count;\n}", "  string = string.toLowerCase()\n  string = string.replace(/[^a-z\
    \ ]/g, \"\")\n  var char_count = {}\n  for (var i=0; i<string.length; i++){\n\
    \    if (char_count[string.charAt(i)] == undefined){\n      char_count[string.charAt(i)]\
    \ = 0\n    }\n    char_count[string.charAt(i)] ++\n  }\n  return Object.keys(char_count).length\n\
    }\n", "  var result = 1;\n  for (var i = 0; i < string.length; i++) {\n    result\
    \ += string.charCodeAt(i) - 64;\n  }\n  return result;\n}\n", "    // Create a\
    \ list with all possible characters except all lowercase, all uppercase and all\
    \ numbers\n    let possibleCharacters = [...string.toLowerCase(),...string.toUpperCase(),...string.match(\
    \ /[0-9]/g )];\n    // Create an empty array to store counts of every unique character\n\
    \    let characterCounts = [];\n    // Loop through all possible characters\n\
    \    for(let possibleCharacter of possibleCharacters){\n        // If that character\
    \ is not present in characterCounts array, add it\n        if(!characterCounts.includes(possibleCharacter)){\n\
    \            characterCounts.push(possibleCharacter);\n        }\n    }\n    //\
    \ Return the number of unique characters in characterCounts array\n    return\
    \ characterCounts.length;\n}\n", "  return string.replace(/[\\u4E00-\\u9FA5]|[\\\
    uFF10-\\uFF19]/g, function(letter){\n    return letter.charCodeAt(0);\n  }).length;\n\
    }\n", "    var unique = {}\n    for(var i=0;i<string.length;i++){\n        var\
    \ character = string[i];\n        if(unique[character] === undefined){\n     \
    \       unique[character] = 1;\n        } else {\n            unique[character]+=1;\n\
    \        }\n    }\n    return Object.keys(unique).length;\n}\n", "\treturn string.split('').filter(function(v){\n\
    \t\treturn v.trim().length !== 0 \n\t}).length;\n}\n", "  var result = 0;\n  for(var\
    \ i = 0, len = string.length; i < len; i++){\n    if(string.charCodeAt(i) > 128){\n\
    \      result++;\n    }\n  }\n  return result;\n}", "  let characters = string.split('')\n\
    \  let count_characters = Object.values(characters).length\n  return count_characters;\n\
    }\n", "  return string.replace(/([A-Z]+)(\\1)*/g, function($0, $1, $2){return\
    \ $2.length;});\n}\n", "  // create a string array from the given string\n  var\
    \ strArray = string.split(\"\");\n  var strLength;\n\n  // loop through the string\n\
    \  for(strLength = 1; strLength <= strArray.length ; strLength++){\n    // push\
    \ only unique elements to the array\n    strArray.push(strArray[strLength]);\n\
    \  }\n\n  // return the new length of the array\n  return strArray.length;\n}\n",
  "    var ret = 0;\n    for(var i = 0; i < string.length; i++){\n        if(string.charAt(i)\
    \ !== string.charAt(string.length - 1 - i)){\n            ret++;\n        }\n\
    \    }\n    return ret;\n}", "  var chars = \"\";\n  for(var i=0;i<string.length;i++){\n\
    \    if(chars.indexOf(string[i])==-1){\n      chars+=string[i];\n    }\n  }\n\
    \  return chars.length;\n}\n", "  return arrayCount(distinct_characters(string));\n\
    }\n", "  var distinct = 0;\n  for(var i = 0; i < string.length; i++){\n    if(distinct_characters[string.charAt(i)]\
    \ == undefined){\n      distinct = distinct + 1;\n      distinct_characters[string.charAt(i)]\
    \ = 1;\n    }else{\n      distinct_characters[string.charAt(i)]++;\n    }\n  }\n\
    \  return distinct;\n}\n", "\tvar characters = string.toUpperCase().split('');\n\
    \tvar count = 1;\n\tfor(var i = 0; i < characters.length; i++){\n\t\tif(characters.indexOf(characters[i])\
    \ == -1) count++;\n\t}\n\treturn count;\n}\n", "    var totalCount = 0;\n    var\
    \ characters = {};\n    for (var i = 0; i < string.length; i++) {\n        var\
    \ character = string[i].toLowerCase();\n        characters[character] = characters[character]\
    \ ? characters[character] + 1 : 1;\n        totalCount = totalCount + 1;\n   \
    \ }\n    return totalCount;\n}", "  return string.split('').filter(function(elem,\
    \ index){\n    return string.split('').indexOf(elem) == index;\n  }).length;\n\
    }\n", "  var chars = string.split(\"\");\n  var distinct_characters = 0;\n  chars.forEach(function(char){\n\
    \    if(chars.indexOf(char) == -1){\n      distinct_characters++;\n    }\n  });\n\
    \  return distinct_characters;\n}\n", "  return string.replace(/[^A-Z ]/g, \"\"\
    ).length;\n}\n", "    if(!string || string.length === 0) return 0;\n    let result\
    \ = 1;\n    for(let char of string){\n        if(!result[char]) return 0;\n  \
    \      result++;\n    }\n    return result;\n}\n", "    string = string.split('').sort().join('');\n\
    \    var chars = {};\n    \n    for(var i = 0; i < string.length; i++){\n    \
    \    if(!chars[string[i]]){\n            chars[string[i]] = 1;\n        } else\
    \ {\n            chars[string[i]]++;\n        }\n    }\n    \n    return Object.keys(chars).length;\n\
    }\n", "  var chars = new Set();\n  string.replace(/[^0-9A-Za-z]/g, function(char){\n\
    \    chars.add(char.toLowerCase());\n  });\n  return chars.size;\n}\n", "\tvar\
    \ count = 0;\n\tfor (var j = 0; j < string.length; j++){\n\t\tvar char = string.charAt(j);\n\
    \t\tif (j == string.length-1){\n\t\t\tbreak;\n\t\t}\n\t\tif (isLowerCase(char)\
    \ || isUpperCase(char)){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n", " \
    \   let letters = new Set();\n    for(let letter of string){\n        letters.add(letter);\n\
    \    }\n    return letters.size;\n}\n", "    string += ''; //Convert to a string\n\
    \    var chars = []; //Create an array of all the characters\n    string.split('').forEach((char)\
    \ => chars.push(char)); //Add each char to the array\n    return chars.filter((char,\
    \ i) => i === 0).length; //Return a count of how many chars are in the array\n\
    }\n", "  return string.split(\"\").filter(function(char){\n    return unique_characters.indexOf(char.charCodeAt(0))\
    \ > -1;\n  }).length;\n}\n", "    var char_count = 0\n    for(var i = 0; i < string.length;\
    \ i++){\n        if(string.charCodeAt(i) >= 65 && string.charCodeAt(i) <= 90){\n\
    \            char_count ++\n        }\n    }\n    return char_count\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work on all languages. For example, in Portuguese\
    \ `A` and `a` count as distinct characters.\n<|/ c |>\n<| c |>\nYou're right -\
    \ I didn't think about that before. I've updated my answer with a different function\
    \ that accounts for that case. :)\n<|/ c |>\n<| c |>\nI assume this isn't the\
    \ fastest solution, since we're looping over every character in the string and\
    \ using .charCodeAt() to determine each character type for each character. Also,\
    \ isn't the String.length method slower than String.charCodeAt(i)?\n<|/ c |>\n\
    <| c |>\nThe length method is faster, but since we are using charCodeAt(i) we\
    \ can't rely on that in all cases. For example, some languages treat \"\xF1\"\
    \ as a single character. I'm not sure if those two are considered distinct characters\
    \ or not, so I can't help you there, sorry.\n<|/ c |>\n<| c |>\nThank you all\
    \ for the comments and answers, they were helpful and I learned a lot!\n<|/ c\
    \ |>\n<| a dscore=3 tags=javascript,algorithm |>\nThis is a great question, and\
    \ it's difficult to answer definitively without giving you a precise answer.\n\
    If we can assume that every single character is unique, we have a problem of the\
    \ sort where every character is distinct, except for one that appears more than\
    \ once.\nIf we can assume that every character is unique, and we only have uppercase\
    \ and lowercase letters available, then the problem is that there aren't enough\
    \ distinct characters to have all letters occur at least twice. \nIf we can assume\
    \ that every character is unique, and we have all the letters available (uppercase\
    \ and lowercase), then we have a problem of the sort where every character is\
    \ distinct, except for one that appears exactly twice.\nIf we can assume that\
    \ every character is unique, and we have an even number of unique characters,\
    \ then we have an even number of distinct characters.\nLet's see how we get to\
    \ these answers. I'll use numbers as characters to simplify things and make them\
    \ easier to read - but these answers are the same regardless of which characters\
    \ we're talking about.\nWe start with \"AB\". One possibility is \"AB\", which\
    \ has a distinct count of 2. This could be either \"AB\" or the empty string.\
    \ The empty string has a distinct count of 0. The next character has two possibilities\
    \ - \"A\" or \"", "    var char_count = {},\n        i=0,\n        chars = string.split('');\n\
    \    while(chars.length > i){\n        var char = chars[i],\n            lowerchar\
    \ = char.toLowerCase(),\n            count = char_count[lowerchar];\n        if(!count){\n\
    \            count = 1;\n        }else{\n            count += 1;\n        }\n\
    \        char_count[lowerchar] = count;\n        i++;\n    }\n    return Object.keys(char_count).length;\n\
    }\n", "    var counter= {};\n    string.split(\"\").map(function(char){ counter[char]\
    \ = counter[char] ? counter[char] + 1 : 1 })\n    return Object.keys(counter).length;\n\
    }", "\tvar count = 0;\n\tfor(var i=0;i<string.length;i++){\n\t\tvar letter = string.charAt(i);\n\
    \t\tcount = count + (letter.charCodeAt(0) - 97);\n\t}\n\treturn count;\n}\n",
  "  return string.toLowerCase().split('').filter(function(item, pos) {\n    return\
    \ string.indexOf(item) == pos;\n  }).length;\n}\n</code>\n<|/ a dscore=2 tags=javascript\
    \ |>\n<| a tags=javascript dscore=2 |>\nHere's an alternative to using regex for\
    \ this, which might make it easier to understand.\n\n<code>\nvar letters = ['a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n\nvar count_distinct_characters\
    \ = function(string) {\n  let count = 0;\n  string.split('').forEach((letter)\
    \ => {\n    if(letters.includes(letter)) {\n      count++;\n    }\n  });\n  return\
    \ count;\n};\n", "  let chars = {};\n  string.split(\"\").forEach((c) => (chars[c.toLowerCase()]\
    \ = chars[c.toLowerCase()] + 1 || 1));\n  return Object.keys(chars).reduce((acc,\
    \ el) => acc+chars[el], 0);\n}\n", "  var hash = {}\n  for (var i = 0; i < string.length;\
    \ i++) {\n    if (!hash[string[i]]) {\n      hash[string[i]] = 1;\n    } else\
    \ {\n      hash[string[i]]++;\n    }\n  }\n  return Object.keys(hash).length;\n\
    }\n", "\tvar letters = string.split('');\n\tvar characters = letters.reduce(function(set,\
    \ letter){\n\t\tvar c = letter.toLowerCase();\n\t\tif(c in set){ //If the letter\
    \ has already been added, don't add it again\n\t\t\treturn set;\n\t\t}\n\t\tset[c]\
    \ = true;\n\t\treturn set;\n\t},{});\n\treturn Object.keys(characters).length;\n\
    }\n", "    return string.replace(/[^A-Z ]+/g,\"\").length;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a |>\nThe easiest way to do this (as long as your input is not\
    \ too large) is to use some sort of hash map. For this example, I'll use a JavaScript\
    \ object:\n<code>", "\tvar characters = [];\n\tfor(var i = 0; i < string.length;\
    \ i++){\n\t\tvar char = string.charAt(i);\n\t\tcharacters.push(char);\n\t}\n\t\
    var count = {};\n\tfor(var i = 0; i < characters.length; i++){\n\t\tif(!count[characters[i]]){\n\
    \t\t\tcount[characters[i]] = 0;\n\t\t}\n\t\tcount[characters[i]] += 1;\n\t}\n\t\
    return count[''];\n}\n", "\tvar charArray = [], i, c = {};\n\tfor(i = 0; i < string.length;\
    \ i++){\n\t\tif(!c[string[i]]){\n\t\t\tcharArray.push(string[i]);\n\t\t\tc[string[i]]\
    \ = 1;\n\t\t}\n\t\telse{\n\t\t\tc[string[i]]++;\n\t\t}\n\t}\n\treturn charArray.length;\n\
    }\n", "\treturn string.split('').reduce(function(prev,current){\n\t\tif(prev >\
    \ 0 && prev === current.length) return prev;\n\t\telse return prev + current.length;\n\
    \t},0);\n}\n", "  let unique_letters = {}\n  \n  for(const letter of string.toLowerCase()){\n\
    \    if(!unique_letters[letter])\n      unique_letters[letter] = 1\n    else\n\
    \      unique_letters[letter]++\n  }\n  \n  return unique_letters.length\n}\n",
  "\tvar count = 0;\n\tfor (var i in string){\n\t\tfor (var j in string){\n\t\t\t\
    if (i !== j){\n\t\t\t\tif (string[i] === string[j]){\n\t\t\t\t\tcount += 1;\n\t\
    \t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n", "  var counter={},\n    \
    \  count=0;\n  string.split('').forEach(function(char){\n    counter[char] = (counter[char]\
    \ || 0)+1;\n    if (counter[char] > 1){\n      counter[char] = 1;\n      count++;\n\
    \    }\n  });\n  return count;\n}", "  return string.split('').length\n}\n", "\t\
    let count = 0;\n\tfor(let i = 0; i < string.length; i++){\n\t\tif(string.charCodeAt(i)\
    \ === string.charCodeAt(i) + 1){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n", "    let characters = [];\n    let counter = 0;\n    for(let i of string){\n\
    \        characters.push(i);\n    }\n    for(let j of characters){\n        for(let\
    \ k of characters){\n            if(j===k){\n                counter++;\n    \
    \        }\n        }\n    }\n    return counter;\n}\n", "\t// This should ideally\
    \ be using a regexp-tree for O(log n) performance\n\t// This would be too slow\
    \ for my use-case\n\t// But it shouldn't matter for reasonable input sizes (<\
    \ 100 chars)\n\tlet chars = string.split('');\n\tlet distinctCharCounts = {};\n\
    \n\tfor(let i = 0; i < chars.length; i++){\n\t\tlet char = chars[i];\n\t\tlet\
    \ lowerChar = char.toLowerCase();\n\t\tdistinctCharCounts[lowerChar] = distinctCharCounts[lowerChar]\
    \ + 1 || 1;\n\t}\n\n\treturn Object.keys(distinctCharCounts).length;\n}\n", " \
    \ return string.split('').reduce(function(map, char){\n    if(map[char]){\n  \
    \    map[char]++;\n    }else{\n      map[char] = 1;\n    }\n    return map;\n\
    \  }, {});\n}\n", "  // Use an object for O(1) lookup\n  var hash = {};\n\n  //\
    \ Use a map for O(n) iteration\n  var chars = new Map();\n\n  for(var i = 0; i\
    \ < string.length; i++){\n    var char = string[i];\n    if(hash[char]){\n   \
    \   hash[char] += 1;\n    } else {\n      hash[char] = 1;\n    }\n  }\n\n  return\
    \ chars.size;\n}\n", "   let count = 1\n   for(const char of string.toLowerCase()){\n\
    \      if(string.includes(char)){\n         count++\n      }\n   }\n   return\
    \ count\n}\n", "  return count_distinct_characters_arr(string, [], [], false);\n\
    }", "    var counts = {};\n    for(var i = 0; i < string.length; i++){\n     \
    \   var letter = string[i];\n        if(counts[letter] == null) counts[letter]\
    \ = 1;\n        else counts[letter]++;\n    }\n    var num = 0;\n    for(var i\
    \ = 0; i < counts; i++){\n        if(counts[i] == 1) num++;\n    }\n    return\
    \ num;\n}\n", "    str = string.split('');\n    count = str.length;\n    for(i=0;i<str.length;i++){\n\
    \        count--;\n        if(str[i] !== str[count])\n            count++;\n \
    \   }\n    return count;\n}", "  string = string.toLowerCase();\n  var count =\
    \ 1;\n  for(var i = 0; i <= string.length; i++){\n    char = string.charAt(i);\n\
    \    if(char !== string.charAt(i - 1)){\n      count++;\n    }\n  }\n  return\
    \ count;\n}\n", "    \n    var charCount = 0;\n    \n    for(let i = 0; i < string.length;\
    \ i++){\n        \n        if(string.charAt(i) !== string.charAt(i).toUpperCase()){\n\
    \            charCount++;\n        }\n    }\n    \n    return charCount;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=javascript dscore=1 |>\nHere's a solution\
    \ similar to Kenny's, but using string methods.  It doesn't need to know how many\
    \ duplicates there are as it will stop once it has found a character that's not\
    \ duplicated:\n\n<code>\nvar chars = str => str\n  .split('')\n  .reduce((m, v)\
    \ => (m[m.indexOf(v)] = v, m), [])\n  .join('');\n\nvar charCount = str => chars(str).length;\n",
  "\tvar count = 1;\n\t\n\tfor(var i = 0; i < string.length; i++){\n\t\tif(string.charCodeAt(i)\
    \ != string.charCodeAt(i + 1)){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n\t", "    var uniqueCharacters = [];\n    uniqueCharacters = uniqueCharacters.concat(\
    \ string.split('') );\n    return uniqueCharacters.length;\n}\n", "  let letters\
    \ = [];\n  for(i = 0; i < string.length; i++){\n    if(letters.indexOf(string[i])\
    \ === -1) letters.push(string[i]);\n  }\n  return letters.length;\n}\n", "  var\
    \ re = new RegExp('(.)\\\\1{2,}', 'g');\n  return string.replace(re,'$1').length;\n\
    }\n", "    return string.split('').reduce(function(prev, current){\n        var\
    \ current = current.toLowerCase();\n        var prev = prev || 0;\n\n        //\
    \ If there are duplicates, then keep on adding\n        if(current!=prev){\n \
    \           prev++;\n        }\n\n        return prev;\n    }, 0);\n}\n", "  let\
    \ distinct_count = 0\n  let string = string.toLowerCase()\n  for(let i = 0; i\
    \ < string.length; i++){\n    if(distinct_count < string[i]) distinct_count +=\
    \ 1\n    else distinct_count = null\n  }\n  return distinct_count\n}\n", "  let\
    \ letters = {};\n  for(let i = 0; i < string.length; i++){\n    letters[string[i]]\
    \ = letters[string[i]] ? letters[string[i]]+1 : 1;\n  }\n  return Object.keys(letters).map(k\
    \ => k.toLowerCase()).sort().length;\n}\n", "  var counter = {}\n  string.split('').forEach(function(character){\n\
    \    counter[character] = (counter[character] || 0) + 1\n  })\n  return Object.keys(counter).length\n\
    }\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThe question does not specify whether\
    \ it has to be in javascript, so here are two solutions in C/C++\nIn C, we can\
    \ use the standard library function strtol and strtoul for this, which are available\
    \ in the <limits.h> header file.\n<code>", "  let char_count = {}\n  for (const\
    \ char of string.toLowerCase().split('')){\n    if (char_count[char] == undefined){\n\
    \      char_count[char] = 1\n    } else {\n      char_count[char] += 1\n    }\n\
    \  }\n  return Object.entries(char_count).length\n}\n", "  let chars = [];\n \
    \ let distinct_characters = 0;\n  for (let i=0; i<string.length; i++){\n    let\
    \ character = string.charAt(i);\n    if (chars.indexOf(character)==-1){\n    \
    \  chars.push(character);\n    }\n  }\n  for (let i=0; i<chars.length; i++){\n\
    \    if (chars.indexOf(chars[i].toUpperCase())==-1 && chars.indexOf(chars[i].toLowerCase())==-1){\n\
    \      distinct_characters++;\n    }\n  }\n  return distinct_characters;\n}",
  "    //return string == null ? 0 : string.trim().split(' ').length;\n    return\
    \ string.replace(/[^\\s]/g, '').length;\n}\n", "\tlet count=0\n\tstring.split(\"\
    \").forEach(function(char){\n\t\tif(is_valid_alphanumeric(char)){\n\t\t\tcount++\n\
    \t\t}\n\t})\n\treturn count\n}\n", "  var hash = {},\n      char_count = 0,\n\
    \      curr_char;\n\n  for (var i = 0; i < string.length; i++) {\n    curr_char\
    \ = string[i];\n    if (!hash[curr_char]) {\n      hash[curr_char] = 1;\n    \
    \  char_count++;\n    }else{\n      hash[curr_char]++;\n    }\n  }\n  return char_count;\n\
    }\n</code>\n<|/ a |>\n<| a |>\nHere is a simple answer which uses a map to store\
    \ the unique characters, it also takes care of capitalization, case difference,\
    \ numbers and anything else which is not considered as a character.\n<code>",
  "\treturn count_distinct_characters_with_case(string, false);\n}", "\tlet characterCount\
    \ = 0\n\tfor (let i = 0; i < string.length; i++) {\n\t\tcharacterCount += string.charCodeAt(i)\
    \ - 97\n\t}\n\treturn characterCount\n}\n", "    counts = {};\n    for(let i =\
    \ 0; i < string.length; i++){\n        let char = string[i];\n        if(counts[char]\
    \ == null){\n            counts[char] = 0;\n        }\n        counts[char]++;\n\
    \    }\n    return Object.keys(counts).length\n}\n", "\tvar count = 0;\n\tfor(var\
    \ i=0; i< string.length; i++){\n\t\tif(string.charCodeAt(i) === string.charCodeAt(i)){\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n", "  var unique_chars = \"\"\
    ;\n  for(var i=0; i<string.length; i++){\n    unique_chars += string.charCodeAt(i);\n\
    \  }\n  return unique_chars.length;\n}\n", "  return string.split('').filter(Boolean).length;\n\
    }\n", "  string = string.toLowerCase();\n  string = string.split('');\n  var unique\
    \ = [];\n  var char_count = 0;\n  for(var i = 0; i < string.length; i++){\n  \
    \  if(unique.indexOf(string[i]) == -1){\n      unique.push(string[i]);\n     \
    \ char_count++;\n    }\n  }\n  return char_count;\n}\n</cell>\n<cell>", "  return\
    \ string.split('').sort().join('').length;\n}\n", "\tvar num_distinct_characters\
    \ = 0;\n\t//First loop: count how many distinct characters are there\n\tfor(var\
    \ i = 0; i < string.length; i++){\n\t\tnum_distinct_characters += string.charCodeAt(i);\n\
    \t}\n\t//Second loop: Count how many distinct characters are there, but ignore\
    \ capital letters\n\tfor(var i = 0; i < string.length; i++){\n\t\tnum_distinct_characters\
    \ += string.charCodeAt(i);\n\t\tif(string.charCodeAt(i) > 64){\n\t\t\tnum_distinct_characters--;\n\
    \t\t}\n\t}\n\treturn num_distinct_characters;\n}\n", "    var obj = {}, // character\
    \ -> count\n        chars = string.split('');\n    for(var i = 0; i < chars.length;\
    \ i++){\n        if(obj[chars[i]] == null)\n            obj[chars[i]] = 0;\n \
    \       obj[chars[i]]++;\n    }\n    var len = Object.keys(obj).length;\n    return\
    \ len;\n}\n", "  let char_count = string.split('').length;\n  let distinct_chars\
    \ = 0;\n  for(let i = 0; i<string.length;i++){\n    let char = string[i];\n  \
    \  distinct_chars += String.fromCharCode(char.charCodeAt(0)-65);\n  }\n  return\
    \ distinct_chars;\n}\n", "    var count = {};\n    \n    for(var i = 0; i < string.length;\
    \ i++){\n        count[string[i]] = count[string[i]] ? count[string[i]] + 1 :\
    \ 1;\n    }\n    \n    return Object.keys(count).length;\n}\n", "    var counts\
    \ = {};\n    for(var i=0; i< string.length; i++){\n        var letter = string[i];\n\
    \        if(letter in counts) counts[letter] ++;\n        else counts[letter]\
    \ = 1;\n    }\n    return counts;\n}\n", "    var hash = {};\n    \n    for(var\
    \ i = 0; i < string.length; i++){\n        char = string.charAt(i)\n        if\
    \ (hash[char] === undefined) {\n            hash[char] = 1\n        } else {\n\
    \            hash[char] += 1\n        }\n    }\n    return Object.keys(hash).length;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you for posting your answer! Please\
    \ be sure to read the [FAQ on Self-Promotion](http://stackoverflow.com/faq#promotion)\
    \ carefully. Also note that it is *required* that you post a disclaimer every\
    \ time you link to your own site/product.\n<|/ c |>\n<| c |>\nWhat do you mean\
    \ by \"disclaimer\"? It will give a message that I can read more about but I'm\
    \ not trying to promote my own website.\n<|/ c |>\n<| c |>\nYes, but you shouldn't\
    \ post such messages. You *are* trying to promote your own website. :-) The reason\
    \ is that we try to keep those links to a minimum. You should strive for as few\
    \ links as possible (ie, if you link someone's website, post the *link*, but don't\
    \ include their name or other identifying information).\n<|/ c |>\n<| c |>\nOh,\
    \ okay. I was actually looking at the FAQ you linked to and it says that if your\
    \ affiliate link is too long, it will be penalized.\n<|/ c |>\n<| c |>\nFair enough,\
    \ I'll keep that in mind. Thanks for the warning!\n<|/ c |>\n<| a tags=javascript,node.js\
    \ |>\nI guess this may help you:\n<code>"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
