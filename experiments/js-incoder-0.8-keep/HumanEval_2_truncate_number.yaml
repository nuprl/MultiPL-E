name: HumanEval_2_truncate_number
language: js
prompt: "//Given a positive floating point number, it can be decomposed into\n// and\
  \ integer part (largest integer smaller than given number) and decimals\n// (leftover\
  \ part always smaller than 1).\n// Return the decimal part of the number.\n// >>>\
  \ truncate_number(3.5)\n// 0.5\nfunction truncate_number(number){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = truncate_number;\n  assert.deepEqual(candidate(3.5),0.5);\n  assert.deepEqual(candidate(1.25),0.25);\n\
  \  assert.deepEqual(candidate(123.0),0.0);\n}\n\ntest();"
completions: ["\treturn number.toFixed(Math.ceil(number.toFixed(0).split('.')[1].length))\n\
    }", "    var parts = (number + '').split('.');\n    if(parts.length == 1){\n \
    \       return parseInt(number, 10);\n    }\n    var decimals = parts[1].length;\n\
    \    if(decimals > 1){\n        return parseInt(parts[0], 10);\n    }\n    return\
    \ parts[0];\n}\n", "\t// if number <= 0 or number >= 1 return number\n\tif(!isFinite(number)\
    \ || number < 1 || number > 1){\n\t\treturn number;\n\t}\n\n\t// if number >=\
    \ 10 return number\n\tif(number >= 10){\n\t\treturn number;\n\t}\n\n\t// number\
    \ % 10 equals 0 so we need to add 0 to number\n\tvar decPart = Math.round(number\
    \ % 10);\n\tnumber -= decPart;\n\n\t// if number > 10 we add one to number\n\t\
    if(number > 10){\n\t\tdecPart++;\n\t}\n\n\treturn number + decPart;\n}\n", "\t\
    return Math.round(number);\n}\n", "    var decimals = Math.abs(number);\n    if\
    \ (decimals < 1) {\n        return 0;\n    }\n    var whole = Math.floor(number);\n\
    \    var part1 = (whole % 1 == 0) ? whole - whole : whole - whole;\n    var part2\
    \ = Math.floor((whole - part1) / 1);\n    return part2 == 0 ? (part1 + decimals)\
    \ : number;\n}\n", "  if(number<0) return 0;\n  if(number>1) return 1;\n  if((Math.round(number*1000)%1)==0)\
    \ return 0;\n  var factor=Math.pow(10,Math.round(number));\n  return Math.floor(number*factor)/factor;\n\
    }", "    var integer_part = 0;\n    var decimals_part = 0;\n    if(number > 0){\n\
    \        var whole_number_part = parseInt(number, 10);\n        if(whole_number_part\
    \ >= 1){\n            integer_part = whole_number_part;\n        }\n        decimals_part\
    \ = number - whole_number_part;\n    }\n    return {integer: integer_part, decimals:\
    \ decimals_part};\n}\n", "  if(isNaN(number)){\n    return 0\n  }\n  var int_part\
    \ = Math.floor(number),\n      dec_part = number-int_part,\n      decimals = Math.trunc(Math.log10(Math.pow(10,dec_part))),\n\
    \      output = int_part+(dec_part>0?decimals-dec_part:0),\n      is_negative\
    \ = int_part < 0\n\n  if(is_negative){\n    output = -output\n  }\n\n  return\
    \ output\n}\n", "    var decimal_part = Math.floor(number);\n    return decimal_part\
    \ < 0.5 ? decimal_part\n        : decimal_part - 1;\n}\n", "  return Math.round(number);\n\
    }\nexports.truncate_number = truncate_number;\n", "\t// number > 1 && number <\
    \ 1000 //If number is higher than 1, and not lower than 1000 (integer part), this\
    \ is not a decimal number and it doesn't require decimal truncation.\n\t// number\
    \ < 1 && number >= 1000 //If number is lower than 1, and not higher than 1000\
    \ (integer part), this is not a decimal number and it doesn't require decimal\
    \ truncation.\n\tif (number > 1 && number < 1000){\n\t\treturn Math.round(number);\n\
    \t} else {\n\t\treturn number;\n\t}\n}\n", "  var digits = String(number).split('.');\n\
    \  return digits[1] ? parseInt(digits[1]) : 1;\n}\n", "    var i = Math.round(number);\n\
    \    \n    if(Math.abs(number-i)<1e-6){\n        i = Math.round(1/Math.pow(10,Math.floor(Math.log10(number)))*Math.pow(10,Math.floor(Math.log10(i)));\n\
    \    }\n    \n    return i;\n}\n", "\tvar fraction = number - Math.floor(number);\n\
    \treturn Math.round(fraction * 100) / 100;\n}", "\t\n\t// Truncate to the integer\
    \ part\n\tvar integer_part = Math.floor(number);\n\t\n\t// Decompose the integer\
    \ part into decimal and integer parts\n\tvar decimals = number - integer_part;\n\
    \tvar integer = integer_part;\n\t\n\t// Return decimal part\n\treturn decimals;\n\
    }\n", "  var parts = /^(-?)([0-9]+|Infinity)\\.([0-9]+)$/.exec(number);\n  if(parts.length\
    \ == 3){\n    var integralPart = parseInt(parts[1]);\n    var decimalPart = parseFloat(parts[2]);\n\
    \    if(decimalPart > 1) decimalPart = 1;\n    if(decimalPart < 0) decimalPart\
    \ = 0;\n    if(integralPart != 0){\n      number = integralPart + ((decimalPart\
    \ - 1) * Math.pow(10, -Math.floor(decimalPart / 10)));\n    }\n  }\n  return number;\n\
    }\n", "  if(number < 1.0){\n    return 0.0;\n  }\n  var decomposed = Math.trunc(number\
    \ * 10000000000000.0);\n  return Math.floor(decomposed / 10000000000000.0);\n\
    }\n", "    if(number <= 1){\n        return Math.trunc(number);\n    }\n    const\
    \ split = Math.trunc(number);\n    return (number - split) / (1 - split);\n}\n",
  "    var dec = number.toString().split('.')[1];\n    return dec.length < 2 ? 0 :\
    \ parseInt(dec.length < 1 ? 0 : dec);\n}\n", "  var n = number.toFixed(1);\n \
    \ if(n == n.toFixed(1) && n < 1) return 0.0;\n  if(n%1) return parseFloat(n.toFixed(1));\n\
    \  if(n == 0) return 0.0;\n  if(n%1 == 0) return parseFloat(n.toFixed(1));\n \
    \ if(n == 1) return 1.0;\n  var res = truncate_number(n.toFixed(1));\n  for(var\
    \ i = 2; i<=5; i *= 2) res = res * 10 + (n.toFixed(i)-1);\n  return res;\n}\n",
  "    var num_parts = Math.pow(10, Math.floor(Math.log10(Math.abs(number))));\n \
    \   var decimals = number % 1;\n    return Math.trunc(number / num_parts) * num_parts\
    \ + decimals;\n}\n", "    var decimals = Math.floor(Math.abs(number));\n    if(decimals\
    \ <= 0){\n        return 0;\n    }\n    var result = number.toFixed(decimals -\
    \ 1);\n    return parseFloat(result);\n}\n", "\treturn Math.floor(number * 1000)\
    \ / 1000;\n}\n\n", "    if(number < 1){\n        number = 1;\n    }\n\n    if(number\
    \ > 10000000000000){\n        throw new Error(\"This number can't be represented\
    \ by a 32 bit float.\");\n    }\n\n    var decimal_number = Math.floor(number\
    \ % 1);\n    var fractional_part = number - decimal_number;\n\n    if(fractional_part\
    \ > 0){\n        return \"0.\" + truncate_number(fractional_part);\n    }else{\n\
    \        return truncate_number(decimal_number);\n    }\n}\n\n", "  var decimals\
    \ = Math.ceil(Math.abs(number));\n  return number < 0 ? -decimals : decimals;\n\
    }\n\n", "  var integer_part = Math.round(number),\n      decimal_part = number\
    \ - integer_part;\n  return Math.trunc(number) + decimal_part;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=0 |>\nThis can be easily done with the help of toFixed.\
    \ \n<code>\nvar number = \"1.234\";", "  var decimal = Math.pow(10, Math.ceil(Math.log(number)/Math.LN10));\n\
    \  return Math.trunc(number * decimal) / decimal;\n}", "\tvar parts = math.trunc(number).toNumber().toString().split(\"\
    .\");\n\tparts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n\tparts[1]\
    \ = parts[1].replace(/0+$/, '');\n\treturn parts.join(\".\");\n}\n", "    var\
    \ m = Math.pow(10, Math.floor(Math.log(number)/Math.LN10));\n    return Math.floor((number*m)/1)/m;\n\
    }\n</code>\n<|/ a |>\n<| a tags=javascript,number-formatting dscore=1 |>\n<code>\n\
    const myNum = 45,\n  myFraction = 0.001;\n\nlet decimalPart = myNum;\nlet decimalCount\
    \ = 0;\n\nconst myFrac = myFraction;\n\nwhile (myFrac > 1) {\n  myFrac = myFrac\
    \ / 10;\n  decimalCount++;\n}\n\ndecimalPart = myNum - myFrac * decimalCount;\n\
    decimalPart = (decimalPart / 10) % 10;\n", "  if(number < 1){\n    return 1;\n\
    \  }\n  else if(number < 10){\n    return number;\n  }\n  else if(number < 100){\n\
    \    return Math.ceil(number);\n  }\n  else if(number < 1000) {\n    return Math.floor(number);\n\
    \  }\n  else {\n    return number;\n  }\n}\n", "    var whole_number = Math.floor(number);\n\
    \    var decimal = number - whole_number;\n    if (number > 1) {\n        decimal\
    \ = 1;\n    }\n    return decimal;\n}\n", "  if (number <= 1) return 0;\n\n  var\
    \ decimal_places = Math.pow(10, get_precision(number));\n  var whole_part = (number\
    \ - truncate_number_helper(number)) / decimal_places;\n\n  // if fraction is smaller\
    \ than 1, we will round up with 1 decimal\n  // if the fraction is larger than\
    \ 1, we will round up\n  if (whole_part >= 1) return Math.ceil(whole_part);\n\
    \  return Math.floor(whole_part);\n}\n", "  var integer_part=Math.trunc(number);\n\
    \  var decimals_part=number-integer_part;\n  if (decimals_part==0.0) return integer_part;\n\
    \  else if (decimals_part<0.0) throw \"Error: the number is negative. Can't truncate\
    \ it.\"\n  else return integer_part+Math.trunc(Math.pow(10,(1+decimals_part))-1);\n\
    }\n", "\tvar decimals = Math.ceil(Math.abs(number));\n\treturn Math.round(decimals\
    \ * (1/Math.pow(10,decimals)));\n}\n", "\tlet [integer_part, decimal] = Math.round(number).toString().split('.')\n\
    \tif (decimal && decimal.length > 0){\n\t\tdecimal = decimal.substring(0, decimal.length\
    \ - 1)\n\t}else{\n\t\tdecimal = ''\n\t}\n\treturn [integer_part, decimal]\n}\n",
  "  var negative = number < 0;\n  var whole = number/1e8;\n  var decimal = (number%1e8)/1e8;\n\
    \  var intPart = whole*Math.pow(10,-decimal);\n  var intPart2 = Math.floor(intPart);\n\
    \  var decimalPart = Math.floor((decimal*Math.pow(10,decimal))-intPart2);\n  var\
    \ result = intPart2;\n  if(decimalPart >= 0.5){\n    result = decimalPart;\n \
    \ }\n  return negative ? -result : result;\n}\n", "    return Math.floor(number);\n\
    }\n", "\tlet x = parseInt(number);\n\tlet y = number - x;\n\treturn y;\n}\n",
  "    // If number is negative, return number.\n    if(number < 0){\n        return\
    \ number;\n    }\n\n    // If the number is exactly halfway between two whole\
    \ numbers,\n    // return the number itself (the number that was passed in).\n\
    \    if(number == Math.floor(number)){\n        return number;\n    }\n\n    //\
    \ If the number is whole, return it, since it isn't susceptible to round-off error.\n\
    \    if(number % 1 == 0){\n        return number;\n    }\n\n    // If the number\
    \ is negative, take the reciprocal.\n    var result = Math.pow(10,Math.floor(Math.log(number)/Math.LN10));\n\
    \    if(number < result){\n        return Math.floor(number) / result;\n    }\n\
    \n    // If the number is positive, return the reciprocal, dropping the decimal.\n\
    \    result = Math.pow(10,Math.floor(Math.log(number)/Math.LN10));\n    if(number\
    \ < result){\n        return Math.floor(number) / result; //drop decimal\n   \
    \ }\n\n    // Otherwise, return the number itself (number was an integer, and\
    \ was just truncated).\n    return number;\n}\n", "\tif(!number_is(number)) return\
    \ number;\n\n\tvar remainder = number_modulo(number, 1);\n\tvar integer = number_modulo(number,\
    \ number);\n\n\treturn remainder ? integer + remainder : integer;\n}\n", "  if\
    \ (number < 1){\n    return 0\n  }\n  let result = number\n  if (number % 1 >\
    \ 0){\n    result = Math.floor(number * 1000) / 1000\n  }\n  else {\n    result\
    \ = Math.round(number * 1000) / 1000\n  }\n  return result\n}\n", "\tif(number<0)\
    \ return 0;\n\tif(number<1) return 1;\n\tvar exp = Math.floor(Math.log(number)/Math.LN10);\n\
    \tif(exp < -4 || exp >= number) return number;\n\tvar num_str = number.toExponential(exp);\n\
    \tfor(var i=1;exp>i;++exp) num_str = num_str.replace('e'+i,'e-'+i);\n\tvar num\
    \ = eval(num_str);\n\treturn num;\n}\n", "  if(number <= 0) return 0;\n  if(number\
    \ >= 1) return 1;\n  if(number >= 10) return number;\n  return Math.floor(number);\n\
    }\n", "\tvar number_int = parseInt(number);\n\tvar decimals = (number - number_int).toFixed(0).length;\n\
    \treturn number_int.toFixed(0);\n}\n", "    if(!number) return 0;\n    var decimals\
    \ = Math.pow(10, Math.floor(Math.log(number)/Math.LN10));\n    return Math.floor(number\
    \ * decimals) / decimals;\n}\n", "  return Math.round(number);\n}\n", "\tvar parts\
    \ = parseFloat(number.toPrecision(15));\n\tvar decimalPart = parts % 1;\n\tif(!decimalPart)\
    \ decimalPart = parts;\n\tvar integerPart = Math.floor(parts);\n\tif(integerPart\
    \ && decimalPart && integerPart - decimalPart > 1){\n\t\tnumber *= Math.pow(10,\
    \ integerPart - decimalPart);\n\t}\n\treturn number;\n}\n", "  var decimal_part\
    \ = Math.abs(number - Math.floor(number));\n  return decimal_part > 0.999999999999\
    \ ? decimal_part : Math.round(number);\n}\n", "    // Return the decimal part\
    \ of the number.\n    // >>> truncate_number(3.5)\n    // 0.5\n    return Math.ceil(number\
    \ % 1 * 100) / 100;\n}\n", "    let int_part = Math.trunc(number);\n    let dec\
    \ = number - int_part;\n    return dec;\n}", "  var decimals = Math.pow(10, Math.abs(Math.floor(Math.log(number)/Math.LN10)\
    \ - 1));\n  if (number < 1) {\n    return Math.ceil(number * decimals) / decimals;\n\
    \  } else {\n    return Math.floor(number * decimals) / decimals;\n  }\n}\n",
  "\t\n\tif (number<1)\n\t{\n\t\treturn 1;\n\t}\n\t\n\tnumber -= Math.floor(number);\n\
    \t\n\treturn number;\n}\n", "    number = Math.abs(number);\n    var precision\
    \ = 1000000;\n    while(number > precision){\n        number /= 10;\n        precision\
    \ *= 10;\n    }\n    return number;\n}\n", "\tconst decimals = Math.floor(Math.log10(Math.abs(number)))\
    \ + 1;\n\treturn Math.trunc(number / Math.pow(10, decimals)) * Math.pow(10, -decimals);\n\
    }\n", "\tvar decimals = Math.abs(number - Math.floor(number))\n\treturn {\n\t\t\
    integer : Math.floor(number),\n\t\tdecimals : decimals\n\t}\n}\n", "    var parts\
    \ = (number + \"\").split(\".\");\n    parts[0] = parts[0].replace(/\\B(?=(\\\
    d{3})+(?!\\d))/g, \",\"); // for thousands\n    return parseInt(parts.join(\"\
    .\"));\n}\n", "  if(number < 1)\n    return number;\n  var exp = Math.floor(log10(number));\n\
    \  var decimals = exp/Math.pow(10, exp-1);\n  var int_part = (number/Math.pow(10,\
    \ exp-1)).toFixed(exp-1);\n  var factor = Math.pow(10, exp);\n  return int_part\
    \ * factor;\n}\n\n", "  return Math.floor(number).toString().split(\".\")[1] ||\
    \ 0;\n}\n", "\tvar integer_part = Math.floor(number);\n\tvar decimals_part = number\
    \ - integer_part;\n\tif(decimals_part >= 1){\n\t\treturn integer_part + '.' +\
    \ decimals_part + ' ';\n\t}else{\n\t\treturn integer_part;\n\t}\n}", "  if (number\
    \ < 1) {\n    return number\n  }\n  var remainder = number%1;\n  var integer =\
    \ Math.floor(number);\n  var decimals = Math.round(remainder * Math.pow(10, Math.floor(Math.log(number)/Math.LN10)))\
    \ - remainder;\n  if (decimals < 1) {\n    return integer\n  }\n  return integer\
    \ + decimals;\n}", "\tif(number > 1){\n\t\treturn number - Math.round(number %\
    \ 1);\n\t}\n\treturn 0;\n}\n", "  if (number < 1.0){\n    return Math.floor(number);\n\
    \  }\n  else {\n    return Math.ceil(number);\n  }\n}", "\tvar integerPart,\n\t\
    \tdecimalPart,\n\t\tdecomposedPart;\n\t\n\tif(number > 0){\n\t\tintegerPart =\
    \ Math.floor(number);\n\t\tdecimalPart = number - integerPart;\n\t} else {\n\t\
    \tintegerPart = Math.ceil(number);\n\t\tdecimalPart = number - integerPart;\n\t\
    }\n\t\n\tdecomposedPart = integerPart + decimalPart;\n\t\n\treturn decomposedPart;\n\
    }\n\t", "  return Math.floor(number);\n}\n", "    var decimal_part = number %\
    \ 1;\n    var integer_part = (number-decimal_part)/1;\n    return Math.ceil(decimal_part)\
    \ === 0.9999999 ? integer_part : 0.9999999 + integer_part;\n}", "\tvar result\
    \ = math.sign(number) * Math.floor(Math.abs(number));\n\tif(result === math.floor(result)){\n\
    \t\tresult--;\n\t}\n\treturn result;\n}\n", "    var s = number.toString();\n\
    \    s = s.split('.');\n    return s[0].length > 3 ? s[0].length : 0;\n}\n", " \
    \ var m = truncate_number.m;\n  if(m === undefined){\n    m = 10000;\n    truncate_number.m\
    \ = m;\n  }\n  if(number < 0){\n    number *= -1;\n  }\n  number -= Math.floor(number);\n\
    \  return Math.floor(number * m) / m;\n}\ntruncate_number.m = undefined;\n", " \
    \ var m = Math.pow(10,Math.floor(Math.log(number)/Math.LN10));\n  return Math.floor(number*m)+(m==100?0:(m==10&&number>3.49999?0.5:0));\n\
    }\n", "    var fractional_portion = number - Math.floor(number);\n    var integer_portion\
    \ = Math.trunc(number);\n    var decimal = integer_portion - fractional_portion;\n\
    \    return decimal;\n}\n", "  var numberString=number.toString();\n  if(numberString.indexOf(\"\
    .\") > -1){\n    var integerPart = numberString.split(\".\")[0];\n    if(integerPart.length\
    \ < numberString.length){\n      integerPart = \"0\".repeat(integerPart.length)\
    \ + integerPart;\n    }\n    return parseFloat(integerPart);\n  }\n  return number;\n\
    }\n", "  return Math.trunc(number * 100) / 100;\n}\nexports.truncate_number =\
    \ truncate_number;\n\n", "\tvar n = number.toFixed(20).split('.')[1];\n\treturn\
    \ n;\n}\n\n", "\tnumber = (number == Math.floor( number)) ? number : parseFloat(number);\n\
    \treturn (number < 0 || number > 1) ? 0 : (number * Math.pow(10, -1 * (number.toString().split('.')[1].length)))\n\
    }\n", "  if(number < 1){\n    return 0\n  }\n  return Math.floor(number)\n}\n",
  "    let float_num = number.toFixed(10);\n    // const integer_part = parseInt(float_num);\n\
    \    // const decimals_part = float_num - integer_part;\n    return parseInt(float_num);\n\
    }\n", "  if (number<1) {return 0;}\n  var integerPart=Math.floor(number);\n  var\
    \ decimalPart=number-integerPart;\n  return(integerPart+decimalPart);\n}\n\n",
  "    number = number.toFixed(4);\n    var parts = number.split(\".\");\n    return\
    \ parts[parts.length-1];\n}\n", "\tnumber = number.toFixed(2);\n\tif (number.indexOf(\"\
    0.\") === 0){\n\t\tnumber = number.slice(1)\n\t}\n\tvar splitted = number.split(\"\
    .\");\n\tvar decimals = splitted[1];\n\tvar integer = splitted[0];\n\t\n\treturn\
    \ Math.trunc(parseFloat(integer) + parseFloat(decimals)) \n}\n", "\tvar parts\
    \ = number.toString().split(\".\");\n\treturn parts[1] || 0;\n}\n", "  var decimal_part\
    \ = Math.abs(number) - Math.floor(Math.abs(number));\n  var whole_part = 0;\n\n\
    \  // Return an error if number is null\n  if(number == null){\n    throw new\
    \ Error(\"Argument can't be null or undefined.\");\n  }\n\n  // Return null if\
    \ number is a decimal or 0 decimal part\n  if(number == number_to_string(0.1)){\n\
    \    return null;\n  }\n\n  if(number > 0){\n    whole_part = Math.floor(Math.abs(number));\n\
    \  }else{\n    whole_part = Math.ceil(Math.abs(number));\n  }\n\n  // If whole\
    \ part is greater than 1, then return whole part\n  if(whole_part > 1){\n    return\
    \ whole_part;\n  }\n\n  // Return null if number is a decimal or 0 decimal part\n\
    \  if(number == number_to_string(0.1)){\n    return null;\n  }\n\n  // Return\
    \ whole part minus decimal part if decimal part is greater than 1\n  if(Math.abs(decimal_part)\
    \ > 1){\n    return whole_part;\n  }\n\n  // Return decimal part minus whole part\n\
    \  return decimal_part;\n}\n", "\tvar decimal_part = number % 1;\n\tnumber = Math.floor(\
    \ number );\n\tif (number > 0)\n\t\tnumber = number - decimal_part;\n\treturn\
    \ number + decimal_part;\n}\n", "    var decimals = Math.pow(10, get_precision(number));\n\
    \    var int_part = Math.floor(number * decimals) / decimals;\n    var float_value\
    \ = number * decimals - int_part * decimals;\n    int_part += 0.5;\n    return\
    \ int_part + float_value;\n}\n", "\tnumber  = parseFloat(number);\n\tvar\tdecimal_part\
    \ = Math.floor(number);\n\treturn decimal_part;\n}\n", "    if(number<0) return\
    \ number; //don't do negative numbers\n    var negative = number<0;\n    number\
    \ = Math.abs(number);\n    var decimal = Math.floor(number);\n    var whole =\
    \ Math.floor(decimal+1);\n    \n    if(decimal>number.length) decimal = number.length;\n\
    \    \n    return negative ? -whole : whole;\n}\n", "  if(number < 1){\n    return\
    \ 0;\n  }\n\n  var whole = Math.floor(number);\n  var decimal = Math.ceil(number\
    \ - whole);\n\n  return whole + decimal;\n}\n", "    var n = number.toFixed(15),\
    \ // toFixed returns a string and we know it is convertable to int\n        i\
    \ = parseInt(n.split('.')[1]), // convert n from string to float\n        decimalPart\
    \ = (n.split('.')[1] - i) || 1;\n    return Math.round(i * Math.pow(10,15)) /\
    \ Math.pow(10,15) + decimalPart;\n}\n", "\tvar num_arr = new Array();\n\tvar float_arr\
    \ = new Array();\n\tvar decimal = 0;\n\t\n\tnumber_arr = number.split('.');\n\t\
    \n\tfor(let i = 0; i < number_arr.length; i++){\n\t\tif(number_arr[i].length ==\
    \ 2){\n\t\t\tfloat_arr.push(number_arr[i]);\n\t\t}\n\t\telse{\n\t\t\tdecimal =\
    \ number_arr[i].length - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tdecimal_part = number_arr[number_arr.length-1];\n\
    \t\n\tnumber_arr.pop();\n\tnumber_arr.push('0');\n\tnumber_arr.push(decimal);\n\
    \t\n\tnum_arr = number_arr.join('');\n\t\n\treturn num_arr;\n}\n\n", "    var\
    \ part1 = Math.ceil(number);\n    var part2 = Math.floor(number);\n    return\
    \ (part2 - part1).toFixed(2);\n}\n", "    var parts = (number + '').split('.');\n\
    \    if (parts[1]){\n        parts[1] = parts[1].substr(0,1);\n    }\n    return\
    \ parseFloat(parts.join('.'))/1000000000000000000;\n}\n", "\tvar parts = Number(number).toFixed(1).split(\"\
    .\");\n\treturn parts[0].replace(/^0+/, \"\");\n}\n", "\tnumber = number - 0;\n\
    \tvar int_part=Math.floor(number);\n\tvar decs_part=Math.round((number-int_part)*Math.pow(10,(number<int_part)?0:0));\n\
    \t\n\tif (decs_part>=0){\n\t\treturn int_part+\"e\"+decs_part;\n\t}\n\treturn\
    \ int_part+\"e-\"+(decs_part+1);\n}\n", "\tvar whole = Math.trunc(number);\n\t\
    var decimal = number - whole;\n\treturn whole + decimal;\n}\n", "  number = number.toFixed(0);\n\
    \  if(number.length <= 3){\n    return number;\n  }\n  var p = number.toString().split(\"\
    .\");\n  return Math.ceil(p[0].length + p[1].length);\n}\n", "\tvar fraction =\
    \ number % 1;\n\treturn number - (number*fraction);\n}\n", "  let decimalPart\
    \ = number % 1;\n  while (decimalPart < 1) {\n    decimalPart = decimalPart *\
    \ 10;\n  }\n\n  return number;\n}\n", "    // Only accept positive numbers\n \
    \   if(number <= 0){\n        return 0;\n    }\n    if(number > -1){\n       \
    \ var x = Math.pow(10, Math.floor(Math.log(number)/Math.LN10));\n        // Make\
    \ sure that the rounding doesn't cause weird rounding\n        var round = x ===\
    \ Math.pow(10,0) ? 0 : x / Math.pow(10,1);\n        return Math.ceil(number /\
    \ round) * round;\n    }\n    return -1;\n}\n", "  if (number > 1){\n    number\
    \ = Math.round(number);\n  }\n  number = number.toFixed(number_decimals);\n  return\
    \ number.split('.');\n}\n", "    let decimal_part = number % 1;\n    if(decimal_part\
    \ < 0.5){\n        return number - (decimal_part * 10);\n    } else {\n      \
    \  return number;\n    }\n}\n</code>\n<|/ a tags=javascript,arrays |>\n<| c |>\n\
    This answer is awesome, thanks for sharing.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n\
    const data = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25];\n\
    const length = data.length;\n\nlet result = [];\nfor (let i = length; i >= 0;\
    \ i--) {\n  const num = data[i]; \n  result.unshift(num);\n}", "  let decimals\
    \ = parseInt(Math.log10(Math.abs(number)).toString().split('.').shift());\n  return\
    \ decimals > 0 ? Math.trunc(number * Math.pow(10, -decimals)) / Math.pow(10, -decimals)\
    \ : Math.trunc(number);\n}\n", "    var number_as_string = number.toString();\n\
    \    var result = number_as_string.split('.')[0] || 0;\n    if(number_as_string.split('.')[1]){\n\
    \        result = Math.floor(result + result*number_as_string.split('.')[1])/number_as_string.split('.')[1]\
    \ || 0;\n    }\n    return result;\n}\n", "  let integer;\n  let decimals;\n \
    \ if (number >= 1){\n    integer = Math.floor(number);\n    decimals = Math.ceil((number-integer)\
    \ * 100) / 100;\n  }\n  return integer + '' + decimals;\n}\nmodule.exports = truncate_number;\n\
    \n},{}],13:[function(require,module,exports){\n'use strict';\n\nconst util = require('./util');\n\
    \nconst isNode = (typeof process === 'undefined' ? (typeof require === 'function'\
    \ ? require : false) : process) ? false : true;\n\nconst isWindows = process.platform\
    \ === 'win32';\n", "    number = Math.round(number);\n    var remainder = number\
    \ % 1;\n    if(number <= 0){\n        return 0;\n    }\n    else if(number < 10){\n\
    \        return number;\n    }\n    else if(number >= 10 && number % 10 !== 0){\n\
    \        return number - remainder;\n    }\n    else if(number < 100){\n     \
    \   return Math.trunc(number);\n    }\n    else if(number >= 100 && number % 100\
    \ === 0){\n        return Math.trunc(number) - remainder;\n    }\n    else if(number\
    \ < 1000){\n        return Math.floor(number);\n    }\n    else if(number >= 1000\
    \ && number % 1000 === 0){\n        return Math.floor(number) - remainder;\n \
    \   }\n    else if(number < 10000){\n        return Math.ceil(number);\n    }\n\
    \    else if(number >= 10000 && number % 10000 === 0){\n        return Math.ceil(number)\
    \ - remainder;\n    }\n    else if(number < 1000000){\n        return Math.floor(number);\n\
    \    }\n    else if(number >= 1000000 && number % 1000000 === 0){\n        return\
    \ Math.floor(number) - remainder;\n    }\n    return number;\n}\n", "  return\
    \ Math.round(number * Math.pow(10, Number.MAX_SAFE_INTEGER) ) / Math.pow(10, Number.MAX_SAFE_INTEGER);\n\
    }\n", "    // Handle extremely small numbers\n    if(Math.abs(number) < 1.01)\
    \ return number;\n    // Truncate to the correct decimal precision.\n    var precision\
    \ = Math.pow(10,Math.max(0,Math.ceil(Math.log10(Math.abs(number)))-1)),\n    \
    \    factor = Math.pow(10,precision);\n    return (number*factor)/factor;\n}\n",
  "\tvar digits = String(number).split('.');\n\tdigits = digits[1] ? digits.splice(0,\
    \ 1) : [];\n\treturn Number(digits.join(''));\n}\n", "    var i = parseInt(number);\n\
    \    return i < 0 ? Math.round(-1 * i) : i;\n}\n<|/ file ext=.js filename=utils.js\
    \ dstars=1 |>", "    if (number < 1.0){\n        return number;\n    }\n    if\
    \ (number > 1000000000.0) {\n        return number/1000000000.0;\n    }\n    return\
    \ number/10.0;\n}\n", "    var exponent = Math.floor(Math.log(number)/Math.LN10);\n\
    \    if (exponent > -10 && exponent < 0){\n        return Math.floor(number*Math.pow(10,\
    \ exponent))/Math.pow(10, exponent);\n    }\n    return number;\n}", "  var integer_part\
    \ = Math.floor(number);\n  var decimals_part = number - integer_part;\n  return\
    \ integer_part + \".\" + decimals_part;\n}\n  \n  \n  \n  //From the given number\
    \ build the object {\n  //  \"text\": The text that shows the number. Can be empty\
    \ if no text was set.\n  //  \"value\": The number value of the object. Can be\
    \ empty if no value was set.\n  //  \"unit\": The units of the number. Can be\
    \ empty if no unit was set.\n  //  \"step\": The step (precision) used in the\
    \ number. Can be empty if no step was set.\n  //  \"unit_scale\": The scale of\
    \ unit. Can be empty if no unit was set.\n  //  \"is_decimal\": If true, the number\
    \ was a decimal number. Can be empty if \n  //  no value was set.\n  //  \"is_negative\"\
    : If true, the number was negative. Can be empty if \n  //  no value was set.\n\
    \  //  \"is_decimals\": If true, the number is decimal. Can be empty if \n  //\
    \  no value was set.\n  //  \"is_integer\": If true, the number was an integer.\n\
    \  //  \"is_negative\": If true, the number was negative. Can be empty if \n \
    \ //  no value was set.\n  //  \"is_percent\": If true, the number was percent.\
    \ Can be empty if \n  //  no value was set.\n  //  \"is_percent\": If true, the\
    \ number was percent. Can be empty if \n  //  no value was set.\n  //  \"is_negative\"\
    : If true, the number was negative. Can be empty if \n  //  no value was set.\n\
    \  //  \"is_decimals\": If true, the number is decimal. Can be empty if \n  //\
    \  no value was set.\n  //  \"is_integer\": If true, the number was an integer.\n\
    \  //  \"is_negative\": If true, the number was negative. Can be empty if \n \
    \ //  no value was set.\n  //  \"is_percent\": If true, the number was percent.\
    \ Can be empty if \n  //  no value was set.\n  //  \"is_percent\": If true, the\
    \ number was percent. Can be empty if \n  //  no value was set.\n  //  \"is_negative\"\
    : If true, the number was negative. Can be empty if \n  //  no value was set.\n\
    \  //  \"is_decimals\": If true, the number is decimal. Can be empty if \n  //\
    \  no value was set.\n  //  \"is_integer\": If true, the number was an integer.\n\
    \  //  \"is_negative\": If true, the number was negative. Can be empty if \n \
    \ //  no value was set.\n  //  \"is_percent\": If true, the number was percent.\
    \ Can be empty if \n  //  no value was set.\n", "\treturn Math.floor(number*100)/100;\n\
    }\n<|/ file ext=.js source=github dstars=1 |>\n\"use strict\";\n\nvar BigNumber\
    \ = require(\"bignumber.js\");\nvar assert = require(\"assert\");\n", "  var digits\
    \ = String(number).match(/\\d+|\\.\\d+/g);\n  return digits ? digits.pop() : 0\n\
    }\n", "  if(number < 1){\n    return number;\n  }\n  const decimals = Math.trunc(number)\
    \ - number\n  if(decimals <= 0){\n    return 1;\n  }\n  return Math.trunc(number/10)\
    \ + decimals;\n}\n", "  var decPart = number.toString().split(\".\")[1];\n  var\
    \ integerPart = number.toString().split(\".\")[0];\n  var integer = parseInt(integerPart);\n\
    \  return Math.ceil(integer);\n}\n", "  if(!number) return 0;\n  number = number.toFixed(5);\n\
    \  return parseFloat(number.split('.')[0]);\n}\n", "    var n = number,\n    \
    \    precision = Math.pow(10,Math.floor(Math.log(n) / Math.LN10)),\n        factor\
    \ = Math.pow(10, precision);\n    if(n >= factor){\n       n = Math.floor(n /\
    \ factor) * factor;\n    }\n    return Math.round(n) / precision;\n}", "\tvar\
    \ dec_part = parseFloat(number);\n\tvar num_str = String(dec_part);\n\tvar index\
    \ = num_str.indexOf('.');\n\tvar dec = index == -1 ? 0 : num_str.substring(index\
    \ + 1);\n\treturn Number(dec_part).toFixed(dec);\n}\n", "  return Math.trunc(number);\n\
    }\n", "  return number<1?Math.floor(number):Math.floor(number)-Math.ceil(number)\n\
    }\n", "    var decimalPlaces = Math.pow(10,Math.floor(Math.log10(number))),\n\
    \        wholeNumber = Math.floor(number/decimalPlaces);\n    return wholeNumber*decimalPlaces;\n\
    }\n", "    number = number.toFixed(15).replace(/\\.?0+$/, '');\n    var parts\
    \ = number.split('.');\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\\
    d))/g, ',');\n    return parts.join('.');\n}\n", "\tif (number < 1){\n\t\tnumber\
    \ = 0;\n\t}\n\treturn Math.round(number);\n}", "\tnumber = Math.round(number);\n\
    \t\n\t// return Math.floor(number);\n\treturn number;\n}\n", "\tvar decimals =\
    \ Math.pow(10, Math.floor(Math.log(number) / Math.LN10)),\n\t\twhole = Math.round(number\
    \ * decimals),\n\t\tmod = whole%1,\n\t\tfract = whole - mod;\n\treturn (mod >\
    \ .5) ? (whole+fract) : whole;\n}\n", "    var p = number.toString().split(/E/)[0],\
    \ //To get the integer part\n        decimals = p.substring(p.length - 2, p.length);\
    \ //To get the leftover part\n    decimals = decimals ? decimals.length : 0; //If\
    \ there is no leftover part, return 0\n\n    return parseFloat(number.toPrecision(decimals));\n\
    }\n", "    var decimals = Math.trunc(number).toString().split(\".\")[1];\n   \
    \ var dec_val = Math.trunc(number);\n    var dec_val_decimals = dec_val.toString().split(\"\
    .\")[1];\n    var integer = Math.trunc(number);\n\n    var dec = dec_val_decimals.split('.')[0];\n\
    \n    var integer_val = integer + '' + dec;\n    if (integer_val.length > 3){\n\
    \        integer_val = integer_val.slice(0, -3);\n    }\n    \n    return parseFloat(integer_val\
    \ + decimals);\n}\n", "    var _number = number,\n        decimals = _number.toString().split('.')[1],\n\
    \        integerPart = _number.toString().split('.')[0],\n        precision =\
    \ parseInt(decimals),\n        intPart;\n\n    // if there aren't any decimals,\
    \ we'll just truncate the integer part\n    if(!decimals)\n        intPart = integerPart;\n\
    \    else\n    {\n        // remove all decimals except for the last one\n   \
    \     while(decimals.length)\n        {\n            decimals = decimals.substr(0,\
    \ decimals.length-1);\n        }\n        // get the integer part and pad with\
    \ zeros on the left to the\n        // specified number of decimals\n        intPart\
    \ = integerPart.split('.')[0].\n            split('').\n            map(function(n){\
    \ return n+decimals; }).\n            join('').\n            split('').\n    \
    \        slice(0, precision+1).\n            join('');\n        // add the decimal\
    \ part back with the new number of decimals\n        intPart += '.'+decimals.substr(precision);\n\
    \    }\n    return {integer: parseInt(intPart), decimal: decimals};\n}\n", " \
    \   var r = number.toString().split('.');\n    return r[0] ? r[0] + '.' + r[1]\
    \ : '0.' + r[1];\n}\n", "  var integerPart = (Math.floor(number) == number) ?\
    \ Math.floor(number) : number;\n  var decimalPart = (number-Math.floor(number))\
    \ * Math.pow(10, getDecimalPrecision(integerPart));\n  if (decimalPart < 1) {\n\
    \    decimalPart = 0.0;\n  }\n  return {\n    integerPart: integerPart,\n    decimalPart:\
    \ decimalPart\n  };\n}\n", "\tvar fraction = number % 1;\n\t\n\t// if number is\
    \ negative, add it to the fraction\n\tif(fraction < 0){\n\t\tfraction += 1;\n\t\
    }\n\t\n\treturn fraction;\n}\n", "\tnumber = number.toString();\n\t\n\t//If there\
    \ are no digits after the decimal point\n\tif(number.slice(-1)=='.'){\n\t\treturn\
    \ number.slice(0, -1);\n\t}\n\t\n\tnumber = number.slice(0, -1);\n\t\n\t\n\t\n\
    \tvar decimals = number.split('.');\n\t\n\t//If the length of the decimal part\
    \ is greater than zero\n\tif(decimals.length>1){\n\t\t\n\t\t//Remove all decimals\n\
    \t\tfor(i=0; i<decimals.length; i++){\n\t\t\tdecimals[i] = decimals[i].slice(0,\
    \ -1);\n\t\t}\n\t\t\n\t\t//Return the decimal part of the number\n\t\treturn decimals.join('.');\n\
    \t}\n\t\n\treturn number;\n}\n\n", "  if(number === null || number === undefined\
    \ || number === NaN){\n    return null;\n  }\n  var decimal_precision = Math.min(Math.abs(Math.log(Math.abs(number))),14);\n\
    \  var number = Math.round(number);\n  var decimals = number % 1;\n  if(decimals\
    \ < 0){\n    if(Math.abs(decimals) !== 1){\n      number = number + decimals;\n\
    \    }\n    else number = number * 2;\n  }\n  if(number > 0){\n    number = number\
    \ - decimals;\n  }\n  if(decimals < 0){\n    number = -number;\n  }\n  if(number\
    \ < -1e-6){\n    number = -number;\n  }\n  if(number < 1e-30){\n    number = -number;\n\
    \  }\n  number = number * Math.pow(10, decimal_precision);\n  return number;\n\
    }\n", "  var decimals = Math.pow(10,Math.ceil(Math.log(number)/Math.LN10));\n\
    \  return Math.round(number * decimals) / decimals;\n}\n", "\tvar integer_part\
    \ = 0;\n\tvar decimals = 1;\n\twhile(number >= 1){\n\t\tnumber = Math.floor(number);\n\
    \t\tinteger_part++;\n\t}\n\twhile(number < 0){\n\t\tnumber = Math.ceil(number);\n\
    \t\tdecimals++;\n\t}\n\treturn Math.trunc(number*Math.pow(10, decimals)) / Math.pow(10,\
    \ decimals);\n}\n", "    var result = Math.floor(number);\n    var decimals =\
    \ result - Math.floor(result);\n    while (decimals < 0) {\n        result +=\
    \ 1;\n        decimals++;\n    }\n    return result + decimals;\n}\n\nmodule.exports\
    \ = truncate_number;\n},{}],151:[function(require,module,exports){\n'use strict';\n\
    \nvar utils = require('./utils');\n\nvar decimal_to_precision = utils.decimal_to_precision;\n",
  "    if(number<1) return 0;\n    var p = bigInt(number).toString(2)\n    if(p.match(/^-?\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\\
    d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*\\d*", "\treturn Math.floor(number);\n}\n",
  "\tvar m = truncate_number(number, 0);\n\treturn Math.abs(m) > 1e-15 ? m : Math.round(number\
    \ * 10) / 10;\n}\n", "    var decimal_places = Math.ceil(Math.log10(number));\n\
    \    return Math.trunc(number/Math.pow(10,decimal_places))*Math.pow(10,decimal_places);\n\
    }\n", "\treturn Math.abs(number) < 1e-16 ? 0 : number < 1 ? Math.trunc(number)\
    \ : Math.floor(number);\n}\n", "\tvar re = /^\\-?\\d+/;\n\tif(!number.match(re)){\n\
    \t\tthrow new Error(\"Input argument is not a number: \" + number);\n\t}\n\tvar\
    \ digits = number.match(re);\n\tvar decimals = digits[1] - 0;\n\tvar whole = digits[2];\n\
    \tif(whole == 0 || decimals == 0){\n\t\treturn 0;\n\t}\n\tvar factor = Math.pow(10,decimals);\n\
    \tnumber = Math.round(number * factor) / factor;\n\treturn number;\n}\n", "\t\
    return number.toFixed(20);\n}\n", "\tvar dec_par = number.toString().split('.')[1];\n\
    \tdec_par = dec_par.length > 1 ? dec_par.slice(0,-1) : dec_par;\n\treturn parseInt(dec_par);\n\
    }\n", "\tnumber = number - 0;\n\tnumber = Math.round(number * 100) / 100;\n\t\n\
    \tvar parts = String(number).split(\".\");\n\t\n\treturn parts[0] || 0;\n}\n\n",
  "  if(number >= 1)\n    return Math.floor(number);\n  var first_digit = Math.trunc(number);\n\
    \  number = (number - first_digit) / Math.pow(10, 10);\n  return Math.trunc(number);\n\
    }\n", "\t// TODO: support negative numbers\n\t// TODO: support negative exponents\n\
    \tif(number < 0){\n\t\tnumber *= -1;\n\t}\n\tvar decimal_part = parseInt(number\
    \ % 1);\n\t\n\tvar integer = parseInt(number / 1);\n\t\n\treturn {\n\t\tinteger:\
    \ integer,\n\t\tdecimal: decimal_part\n\t};\n}\n", "    if (number < 0)\n    \
    \    number *= -1;\n    if (number.toString().length < number.toFixed(10).length)\n\
    \        number += 1;\n    return number;\n}\n", "\t// if number > 1 return number\n\
    \tif(number <= 1) return 0;\n\t// if number < 1 return 0\n\tif(number >= -1) return\
    \ 0;\n\t// else return the last digit\n\treturn Math.floor(number);\n}\n", "\t\
    var remainder = number % 1;\n\tnumber = number - remainder;\n\t\n\tif (number\
    \ < 0){\n\t\tnumber = number * (-1);\n\t}\n\t\n\treturn number;\n}\n\t", "\t//\
    \ Return number if number is a positive floating point number.\n\tif(number <\
    \ 1){\n\t\treturn number;\n\t}\n\t// Return 1 if number is a decimal.\n\tif(number\
    \ % 1 != 0){\n\t\treturn 1;\n\t}\n\t// Return number-floor(number), which means\
    \ that all the decimals\n\t// will be truncated.\n\tnumber = Math.floor(number);\n\
    \treturn number - number;\n}", "\tif (number > 0){\n\t\tvar exponent = number.toExponential().split('e')[1];\n\
    \t\tvar decimals = Math.abs(exponent) > 7 ? exponent.toFixed(exponent < 0 ? -exponent\
    \ : 0) : '';\n\t\treturn Math.round(number*Math.pow(10, exponent-decimals)) /\
    \ (Math.pow(10, decimals) || 1);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n", "  \
    \  if (number < 0)\n        return 0;\n    else\n        return number;\n}\n",
  "  var integer = Math.floor(number),\n      decimals = Math.round((number - integer)\
    \ * 100),\n      decimal_places = Math.max(0, decimals - 1);\n  if (decimal_places\
    \ <= 0) {\n    return integer;\n  }\n  return Math.ceil(number / Math.pow(10,\
    \ decimal_places)) * Math.pow(10, decimal_places);\n}\n", "\tlet splitNum = number.toFixed(100).split(\"\
    .\");\n\treturn splitNum.length > 1 ? splitNum[1] : \"0\";\n}\n", "  if(number\
    \ < 1)\n    return number;\n  var digits = Math.log10(Math.abs(number));\n  if(digits\
    \ < 10)\n    return number;\n  if(number > 0){\n    if(number % 1 > 0)\n     \
    \ return number;\n    var decimal = Math.pow(10, digits);\n    return Math.round(number\
    \ * decimal) / decimal;\n  }\n  return number;\n}\n", "    const decimals = Math.trunc(number).toString().length\
    \ - 1;\n    const parts = [Math.floor(number), Math.trunc(number) - Math.floor(number)];\n\
    \    return parts[1] + decimals;\n}", "    if (number < 1){\n        return 0;\n\
    \    }\n\n    var decimal_part = Math.trunc(number);\n    var integer_part = Math.floor(number);\n\
    \    var left_over = Math.trunc(number-integer_part);\n\n    return decimal_part\
    \ + Math.trunc(left_over/decimal_part);\n}\n", "  if(number < 1){\n    number\
    \ = 0;\n  }\n  const x = number\n  const a = 1;\n  const b = 1;\n  const c = 1;\n\
    \  if(number > 0){\n    const x = 1;\n  }\n  while(number !== 0){\n    const a\
    \ = b\n    const b = c\n    const c = number\n    const x = number\n    number\
    \ = (b*c)\n  }\n  const dec = Math.trunc(a*b*c)\n  if(dec == 1){\n    return 0\n\
    \  }\n  if(dec == 0){\n    return 1\n  }\n  return dec\n}\n", "    var fraction\
    \ = Math.pow(10,Math.floor(Math.log10(number)+1))-1;\n    return (Math.round(number/fraction)*fraction).toFixed(1);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer, but it didn't work for the\
    \ number 5.5\n<|/ c |>\n<| c |>\n, 5.5 is returning 5.5, instead of 5.5.\n<|/\
    \ c |>\n<| c |>\nNo, the number 5.5 should return 5.5, and 5.6 to return 5.6\n\
    <|/ c |>\n<| c |>\nYes, it will, it truncates it to 5. Try it and see.\n<|/ c\
    \ |>\n<| c |>\nYeah, but 5.6 to return 5.6\n<|/ c |>\n<| a tags=javascript |>\n\
    <code>\nvar a = 5.5;\nif (isNaN(a) || !Number.isFinite(a)) {\n    //not a number\
    \ or NaN\n} else {\n    var b = Math.pow(10, Math.floor((Math.log10(a)+1))-1);\n\
    \    var result = a * b;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for the\
    \ answer, but it didn't work for the number 5.5\n<|/ c |>\n<| a tags=javascript\
    \ dscore=0 |>\n<code>\nvar number= 5.5;\nvar decimal=number.toFixed(1).toString();",
  "\tlet n = number.toFixed(6);\n\tlet decimal = n.split(\".\")[1];\n\tif(decimal\
    \ === undefined){\n\t\treturn \"0\";\n\t}\n\treturn decimal;\n}\n", "    number\
    \ = parseFloat(number);\n    var digits = Math.pow(10, Math.floor(Math.log(number)/Math.LN10));\n\
    \    return Math.ceil(number*digits/digits);\n}\n", "\tnumber = Math.round(number);\n\
    \tnumber = number/Math.pow(10,Math.floor(Math.log(number)/Math.LN10));\n\treturn\
    \ number*Math.pow(10,Math.floor(Math.log(number)/Math.LN10));\n}\n", "    return\
    \ Math.floor(number);\n}\n", "\tvar parts=new Array(2);\n\tvar decimals=0;\n\t\
    var integer=Math.round(number);\n\tvar decimal=number-integer;\n\tvar leftover_number=number;\n\
    \twhile(decimal!==0){\n\t\tdecimal*=10;\n\t\tleftover_number*=10;\n\t\tdecimals++;\n\
    \t}\n\tparts[0]=integer;\n\tparts[1]=leftover_number;\n\tif(decimals<parts.length){\n\
    \t\tparts.length=decimals;\n\t}\n\treturn parts;\n}", "  return Math.floor(number\
    \ * 100) / 100;\n}\n", "\tvar decimals = Math.pow(10,Math.floor(Math.log(number)/Math.LN10));\n\
    \tif(decimals>=1){\n\t\tvar whole = Math.floor(number);\n\t\treturn whole + decimals;\n\
    \t}\n\telse{\n\t\treturn Math.floor(number);\n\t}\n}", "\tlet decimal_part = Math.trunc(number);\n\
    \tlet integer_part = number-decimal_part;\n\treturn (integer_part*10+decimal_part)/100;\n\
    }\n", "\treturn Math.floor(number);\n}\n", "    if(number < 0){\n        number\
    \ *= -1;\n    }\n\n    var number_str = number.toString();\n    var i = number_str.indexOf('.');\n\
    \    if(i != -1){\n        var dec = number_str.substr(i+1);\n        return number_str.substr(0,\
    \ i);\n    }\n    return number_str;\n}\n", "    number = number < 0 ? -number\
    \ : number\n    var decimals = String(number).split('.')[1]\n    var integer =\
    \ Number(decimals.split('')[0])\n    return Math.ceil(integer - 0.5) + 0.5\n}\n",
  "\tvar m = number.toString().match(/\\.(\\d+)?$/)[1]||0;\n\tif(m === 0) return number;\n\
    \treturn Math.round(number * Math.pow(10, m)) / Math.pow(10, m);\n}\n", "    if\
    \ (number < 1.0){\n        return Math.round(number);\n    }\n    var dec = number.toString().split('.')[1];\n\
    \    var dec_int = Math.trunc(dec);\n    return dec_int / Math.pow(10, dec_int);\n\
    }\n", "    var parts=number.toFixed(0).split(\".\");\n    return parseFloat(parts[0]);\n\
    }\n\nvar canvas = document.getElementById(\"myCanvas\");\nvar ctx = canvas.getContext(\"\
    2d\");\nvar width = ctx.canvas.width;\nvar height = ctx.canvas.height;\n\nvar\
    \ circle_radius = 20;\nvar circles = [];\nvar circles_number = 3;\n\nvar PI =\
    \ Math.PI;\nvar DEGREES = PI / 180;\n", "  if(number < 0)\n    return 0;\n  else\
    \ if(number >= 1)\n    return 1;\n  else\n    return parseInt(number * 10) % 10;\n\
    }\n", "\treturn Math.trunc(number);\n}\n", "    var dec = (Math.round(number*100))/100;\n\
    \    return dec < 1 ? 1 : dec;\n}\n", "    var n = number.toFixed(20);\n    n\
    \ = parseFloat(n);\n    return Math.floor(n);\n}\n", "\treturn Math.floor(number);\n\
    }\n", "    var int_part = Math.trunc(number);\n    var fraction = number - int_part;\n\
    \    if(fraction < 1){\n        int_part += 1;\n    }\n    return int_part;\n}",
  "\tvar decimals = Number(String(number).split(\".\"))[1];\n\treturn (Math.round(number\
    \ + decimals) != number) ? ((Math.round(number % 1) / 1) * 1) + decimals : decimals;\n\
    }", "    const fraction = number.toString().split('.')[1];\n    const decimal\
    \ = number.toString().split('.')[0];\n    const integer_part = parseInt(decimal,\
    \ 10);\n    return fraction.length > 1 ? integer_part : integer_part * Math.pow(10,\
    \ (fraction.length - 1));\n}\n", "  if(!number) return NaN;\n  return Math.floor(number)\
    \ + number%1;\n}", "  var parts = number.toString().split('.')\n  return parts[0]\
    \ + '.' + parts[1]\n}\n", "  return Math.round(number);\n}\n", "  if (number <\
    \ 1) return 0;\n  var exp = Math.floor(log10(number));\n  var decimals = number\
    \ % 1;\n  return number/Math.pow(10,exp).slice(0,exp) + decimals;\n}\n", "  var\
    \ fraction = parseFloat(number.toFixed(3));\n  var whole = number - (fraction\
    \ * number);\n  var decimals = Math.ceil(Math.abs(whole));\n  return fraction.toFixed(decimals);\n\
    }\n\n", "\tlet float_number = parseFloat(number);\n\tlet decimal_part = number_utils.truncate_decimal(float_number);\n\
    \tlet integer_part = number_utils.truncate_int(float_number);\n\treturn decimal_part\
    \ + '/' + integer_part;\n}\n", "\tlet [integer, decimal] = parse_decimal(number)\n\
    \tdecimal = Math.trunc(decimal)\n\tnumber = decimal + integer\n\treturn number\
    \ < 0.000001 ? 0 : number\n}\n", "\tvar n = number.toFixed();\n\tvar parts = n.split(\"\
    .\");\n\tparts[1] = parts[1].split(\".\")[0]\n\tif(isNaN(parts[1])){\n\t\tparts[1]\
    \ = 1\n\t}\n\treturn parts[1];\n}\n", "\tif (number > 0)\n\t\treturn Math.trunc(number);\n\
    \telse\n\t\treturn Math.floor(number);\n}\n", "  var decimals = Math.floor(Math.log(Math.abs(number))\
    \ / Math.LN10);\n  if(decimals === 0) return number;\n  \n  return Math.floor(number\
    \ * Math.pow(10, decimals)) / Math.pow(10, decimals);\n}\n", "\tif (number < 1){\n\
    \t\treturn 0;\n\t}\n\tif (number < 10){\n\t\treturn number;\n\t}\n\tnumber = Math.round(number);\n\
    \twhile (number % 10 == 0){\n\t\tnumber = Math.round(number / 10);\n\t}\n\treturn\
    \ number;\n}\n", "\tconst sign = number < 0 ? -1 : 1\n\treturn Math.floor(Math.abs(number))/Math.pow(10,Math.floor(Math.log(Math.abs(number))\
    \ * Math.LOG10E))\n}\n", "\tvar decimals = Math.pow(10,Math.floor(Math.log(number)/Math.LN10));\n\
    \tnumber = Math.round(number * decimals)/decimals;\n\treturn number;\n}\n", "\t\
    var number_int = parseInt(number);\n\tvar number_float = parseFloat(number);\n\
    \tvar number_string = \"\" + number_float;\n\tvar decimal_places = number_string.split(\"\
    .\")[1].length;\n\tvar result_float = number_float;\n\tvar result_int = (result_float\
    \ * Math.pow(10, decimal_places)) + 0.5;\n\tvar result_string = number_int.toFixed(decimal_places);\n\
    \treturn result_string;\n}\n\n", "    var decimal_places = Math.floor(Math.log(number)\
    \ / Math.LN10);\n    return Math.trunc(number * Math.pow(10,decimal_places)) /\
    \ Math.pow(10,decimal_places);\n}\n", "\tif(number<=1) {\n\t\treturn number;\n\
    \t}\n\tvar parts=number.toString().split(\".\");\n\tif(parts[1]==\"\") {\n\t\t\
    return number<0?-number:number\n\t}\n\treturn parts[0]+\".\"+parts[1];\n}\n",
  "\tvar integer_part;\n\tvar dec = number % 1;\n\tif (dec<0.5){\n\t\tinteger_part\
    \ = number;\n\t} else {\n\t\tinteger_part = Math.ceil(number);\n\t}\n\treturn\
    \ Math.floor(integer_part) + dec;\n}\n", "  var parts = Math.round(number).toString().split(\"\
    .\");\n  return parts[0].replace(/\\d$/, '');\n}\n", "    var numStr = number.toPrecision(20);\n\
    \    var decimal = numStr.substring(numStr.length - 1);\n    return parseFloat(decimal);\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
