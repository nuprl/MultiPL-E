name: HumanEval_99_closest_integer
language: js
prompt: "//Create a function that takes a value (string) representing a number\n//\
  \ and returns the closest integer to it. If the number is equidistant\n// from two\
  \ integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\"\
  )\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from\
  \ zero means that if the given number is equidistant\n// from two integers, the\
  \ one you should return is the one that is the\n// farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\nfunction closest_integer(value){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = closest_integer;\n  assert.deepEqual(candidate(\"10\"),10);\n  assert.deepEqual(candidate(\"\
  14.5\"),15);\n  assert.deepEqual(candidate(\"-15.5\"),-16);\n  assert.deepEqual(candidate(\"\
  15.3\"),15);\n  assert.deepEqual(candidate(\"0\"),0);\n}\n\ntest();"
completions: ["  var rounded_value = round(value);\n  var difference = Math.abs(value\
    \ - rounded_value);\n  var closest_integer = parseInt(rounded_value);\n  \n  //\
    \ Check if difference is more than half the number\n  if(difference > value /\
    \ 2){\n    // If difference is more than half the number, set closest_integer\
    \ to rounded number\n    closest_integer = parseInt(rounded_value);\n  }\n  \n\
    \  return closest_integer;\n}\n", "  return closest_number(value, 10, 0);\n}\n",
  "    var diff = (value - closest_integer(Math.abs(value))).toFixed(0);\n    if (diff\
    \ > 0){\n        return closest_integer(Math.abs(value));\n    } else {\n    \
    \    return value - diff;\n    }\n}\n", "  value = Number(value);\n  var closest_integer\
    \ = null;\n  var closest_distance = null;\n  var delta = null;\n  var delta_index\
    \ = null;\n  var closest_index_value = null;\n  var closest_number = null;\n \
    \ \n  //Calculate the distance between a given number and each of the integers\n\
    \  //between 0 and \"value\". Choose the integer with the smallest distance\n\
    \  for(var i = 0; i < MAX_INTEGERS; i++){\n    delta = Math.abs(value - i);\n\
    \    delta_index = i;\n    if(delta < closest_distance){\n      closest_integer\
    \ = i;\n      closest_distance = delta;\n      closest_index_value = delta_index;\n\
    \    }\n  }\n\n  //Round the closest integer towards zero\n  if(closest_index_value\
    \ !== 0){\n    closest_integer = Math.round(closest_integer);\n  }\n  \n  //Return\
    \ the rounded number\n  return closest_integer;\n}", "\tvar a = parseInt(value);\n\
    \tvar b = parseInt(value);\n\tvar mid = Math.floor( (a+b)/2 );\n\n\t// if the\
    \ number is equidistant, return one of them\n\tif( Math.abs( b-a ) < Math.abs(\
    \ mid-a ) )\n\t\treturn mid;\n\telse\n\t\treturn b;\n}\n", "  var closest_integer\
    \ = Number(value);\n  var diff = Number(value) - closest_integer;\n  while(diff\
    \ >= 0) {\n    closest_integer = Math.round(closest_integer);\n    diff = Number(value)\
    \ - closest_integer;\n  }\n  return closest_integer;\n}\n", "  \n  //Check if\
    \ the value is a number\n  if(typeof value !== 'string'){\n    throw new Error('Value\
    \ is not a string');\n  }\n  \n  //Check if the value is a float\n  if(value.search(/^-?\\\
    d+\\.\\d+$/) !== -1){\n    \n    //Split the value by comma\n    var split = value.split(',');\n\
    \    \n    //Get the first value after the comma.\n    var firstVal = split[0];\n\
    \    \n    //Check if the number is a float and greater than 0\n    if(firstVal.search(/^-?\\\
    d+\\.\\d+$/) !== -1){\n      \n      //Get the first number\n      var firstValNumber\
    \ = parseFloat(firstVal);\n      \n      //If it is equidistant, round it up\n\
    \      if(Math.abs(firstValNumber - value) === 1){\n        return Math.ceil(firstValNumber);\n\
    \      }\n      \n      //Otherwise, round it down\n      else{\n        return\
    \ Math.floor(firstValNumber);\n      }\n    }\n    \n    //Otherwise, it's a string\n\
    \    else{\n      //Remove all commas\n      value = value.replace(/,/g, '');\n\
    \      \n      //Convert the string to float\n      var firstValNumber = parseFloat(value);\n\
    \      \n      //If it is equidistant, round it up\n      if(Math.abs(firstValNumber\
    \ - value) === 1){\n        return Math.ceil(firstValNumber);\n      }\n     \
    \ \n      //Otherwise, round it down\n      else{\n        return Math.floor(firstValNumber);\n\
    \      }\n    }\n  }\n  \n  //Otherwise, it's a string\n  else{\n    //Remove\
    \ all commas\n    value = value.replace(/,/g, '');\n    \n    //Convert the string\
    \ to float\n    var firstValNumber = parseFloat(value);\n    \n    //If it is\
    \ equidistant, round it up\n    if(Math.abs(firstValNumber - value) === 1){\n\
    \      return Math.ceil(firstValNumber);\n    }\n    \n    //Otherwise, round\
    \ it down\n    else{\n      return Math.floor(firstValNumber);\n    }\n  }\n}\n\
    \n", "  if(value === undefined){\n    return NaN;\n  }\n  if(isFinite(value)){\n\
    \    return Math.round(value / 100) * 100;\n  }\n  if(typeof value === \"string\"\
    ){\n    // TODO: Add support for negative values.\n    if(value[0] === \"-\"){\n\
    \      // Convert \"-15.4\" to 15\n      value = value.substring(1);\n    }\n\
    \    // TODO: Make sure the string is valid before returning\n    return parseInt(value);\n\
    \  }\n  return NaN;\n}\n", "    return Math.round(Math.abs(value - parseFloat(value)));\n\
    }\n", "  var closest;\n\n  if(Math.abs(value) <= 1){\n    return value;\n  } else\
    \ {\n    closest = Math.abs(value - Math.round(value));\n\n    if(Math.abs(closest\
    \ - Math.round(value)) > Math.abs(value - Math.round(value))){\n      return Math.round(value);\n\
    \    } else {\n      return Math.floor(value + 0.5);\n    }\n  }\n}\n\nmodule.exports\
    \ = closest_integer;\n\n},{}],8:[function(_dereq_,module,exports){\n\"use strict\"\
    ;\n\nvar closest_number = _dereq_('./closest_number');\n", "\treturn round_away_from_zero(\
    \ Math.round(Math.abs( parseFloat(value) )) );\n}\n", "  var rounded = Math.floor(value);\n\
    \  var difference = Math.abs(value - rounded);\n  var increment = Math.round(difference\
    \ / 2);\n  if(Math.abs(difference - increment) < difference){\n    return rounded;\n\
    \  } else {\n    return rounded + increment;\n  }\n}\n", "    var nearest = Math.round(value/1)\n\
    \    if(nearest - value < (value % 1))\n        nearest = nearest-1\n    return\
    \ nearest\n}\n", "    var closest = Math.round(value);\n    if(closest===value){\n\
    \        return closest;\n    }\n    if(closest<0){\n        closest = 0;\n  \
    \  }\n    return closest;\n}\n", "  var ratio = Math.abs(value - closest_integer(Math.floor(value)))\
    \ / Math.PI;\n  return Math.round(ratio * 10) / 10;\n}\n", "  var difference =\
    \ Math.abs(parseFloat(value)-parseInt(value));\n  if(Math.abs(difference)<0.00001){\n\
    \    return parseInt(value);\n  }else{\n    return Math.ceil(difference/2);\n\
    \  }\n}\n", "\tvar closest;\n\tvar closestRound;\n\t\n\t// If the value is an\
    \ integer, then simply return it\n\tif( parseInt( value ) == value ){\n\t\treturn\
    \ value;\n\t}\n\t\n\t// If the value is an equidistant integer, round it away\n\
    \tif( Math.abs( value % 1 ) == 0.5 ){\n\t\tclosestRound = Math.round( value );\n\
    \t\tif( closestRound == value ){\n\t\t\treturn closestRound;\n\t\t}\n\t\t\n\t\t\
    return closestRound;\n\t}\n\t\n\t// If the value is not a number, then return\
    \ \"?\"\n\tclosest = \"?\";\n\tif( isNaN( value ) ){\n\t\treturn closest;\n\t\
    }\n\t\n\t// If the value is negative, then find the closest integer in the \n\t\
    // range [-closestRound, -closestRound]\n\tif( value < 0 ){\n\t\tclosestRound\
    \ = Math.ceil( value );\n\t\tif( closestRound == value ){\n\t\t\treturn closestRound;\n\
    \t\t}\n\t\t\n\t\treturn closestRound;\n\t}\n\t\n\t// If the value is positive,\
    \ then find the closest integer in the \n\t// range [closestRound, closestRound]\n\
    \tclosestRound = Math.floor( value );\n\tif( closestRound == value ){\n\t\treturn\
    \ closestRound;\n\t}\n\t\n\treturn closestRound;\n}", "  if (Math.abs(value) <\
    \ 0.000001) return Math.round(value)\n  var n = Math.abs(value)\n  var a = []\n\
    \  for(var i=0; i<10; i++) a.push(Math.floor(n/10) + (n % 10 > 4) ? 10*i : i)\n\
    \  var closest = a.sort(function(a, b){\n    return Math.abs(b-a)\n  })\n  return\
    \ a[closest[0]]\n}\n", "    var difference = Math.abs(value - closest_integer(\"\
    0\"));\n    if (difference < 1){\n        return value;\n    } else {\n      \
    \  return value - difference;\n    }\n}\n", "  var ratio = parseFloat(value) /\
    \ parseInt(value)\n  return Math.round(ratio)\n}\n\n", "    var closest = null;\n\
    \    var diff = Math.abs(value - closest_integer(value));\n    var abs = Math.abs(value);\n\
    \    if(diff <= abs){\n        closest = value;\n    }\n    else {\n        var\
    \ remain = value - closest_integer(value);\n        var round = Math.round(remain\
    \ / diff) * diff;\n        closest = closest_integer(round);\n    }\n    return\
    \ closest;\n}\n", "  var int_num = (parseInt(value,10)+\"\").split('.')[0] ||\
    \ value;\n  var diff = 10000000000000;\n\n  var closest_int;\n  if(int_num.length\
    \ <= 4){\n    closest_int = int_num;\n  }else{\n    for(var i=0;i<int_num.length-1;i++){\n\
    \      diff += int_num.charCodeAt(i)-int_num.charCodeAt(i+1);\n      if(diff>closest_int){\
    \ // if the difference is greater than the number we are currently looking at,\
    \ save the current and make the new closest\n        closest_int = diff;\n   \
    \   }\n    }\n  }\n  return closest_int;\n}\n\n", "  \n  var closest_int = Math.abs(value);\n\
    \  \n  if(closest_int === 0){\n    closest_int = 1e-9;\n  }\n  \n  if(closest_int\
    \ < 1e-9){\n    closest_int = 1;\n  }\n  \n  return Math.floor(value+closest_int);\n\
    \  \n}\n", "    return Math.ceil(Math.abs(value - Math.floor(number)) / 10);\n\
    }\n", "  // 1. Convert all values to floats\n  var val = parseFloat(value);\n\
    \  \n  // 2. Return if the value is not an integer\n  if(Number.isNaN(val)){\n\
    \    // a. return null if value is a float\n    return null;\n    // b. return\
    \ value if value is not an integer\n  }\n  \n  // 3. Compute closest integer\n\
    \  var closest = Math.round(val);\n  \n  // 4. Check if the difference is smaller\
    \ than the biggest difference\n  // so far. If it is, return the biggest difference\n\
    \  var biggest = Math.max.apply(null, \n  \t[Math.abs(val), Math.abs(closest)]);\n\
    \  \n  if(Math.abs(closest - biggest) < 1e-5){\n    return biggest;\n  }\n  \n\
    \  return closest;\n}\n", "\tvar closest = Number.MAX_SAFE_INTEGER;\n\tfor(var\
    \ i = -Number.MAX_SAFE_INTEGER; i <= Number.MAX_SAFE_INTEGER; i++){\n\t\tvar testValue\
    \ = value;\n\t\tif( Math.abs(testValue) >= Math.abs(i)){\n\t\t\ttestValue = Math.floor(\
    \ testValue / Math.abs(i) );\n\t\t}\n\t\tif( Math.abs(testValue) < Math.abs(closest)){\n\
    \t\t\tclosest = Math.abs(testValue);\n\t\t}\n\t}\n\treturn closest;\n}\n", " \
    \ value = String(value).valueOf();\n  if(value.length == 0){\n    return value;\n\
    \  }\n  if(value.length <= 2){\n    return parseInt(value);\n  }\n  if(value <\
    \ 0){\n    return -closest_integer(-value);\n  }\n  if(value.length <= 4){\n \
    \   var digits = value.split(\".\");\n    var diff = Math.abs(parseFloat(digits[1])\
    \ - parseFloat(digits[2]));\n    return parseInt(digits[0]) + diff;\n  }\n  var\
    \ digits = value.split(\".\");\n  var diff = Math.abs(parseFloat(digits[1]) -\
    \ parseFloat(digits[2]));\n  var diff = diff * 10;\n  diff = diff > 10 ? diff\
    \ - 10 : diff;\n  return parseInt(digits[0]) + diff;\n}\n", "    // Make sure\
    \ the value is a number\n    let x = parseFloat(value);\n    // If x is NaN, return\
    \ undefined\n    if(isNaN(x)) return;\n\n    // Make sure the value is a number\n\
    \    x = Number(x);\n\n    // Make sure the value is an integer\n    if(typeof\
    \ x !== 'number') return;\n\n    // If x is equidistant from 2 integers, return\
    \ one of them\n    if(x % 2 === 0) return x;\n\n    // If x is equidistant from\
    \ 3 integers, return one of them\n    if(x % 3 === 0) return x;\n\n    // If x\
    \ is equidistant from 4 integers, return one of them\n    if(x % 4 === 0) return\
    \ x;\n\n    // If x is equidistant from 5 integers, return one of them\n    if(x\
    \ % 5 === 0) return x;\n\n    // If x is equidistant from 6 integers, return one\
    \ of them\n    if(x % 6 === 0) return x;\n\n    // If x is equidistant from 7\
    \ integers, return one of them\n    if(x % 7 === 0) return x;\n\n    // If x is\
    \ equidistant from 8 integers, return one of them\n    if(x % 8 === 0) return\
    \ x;\n\n    // If x is equidistant from 9 integers, return one of them\n    if(x\
    \ % 9 === 0) return x;\n\n    // If x is equidistant from 10 integers, return\
    \ one of them\n    if(x % 10 === 0) return x;\n\n    // If x is equidistant from\
    \ 11 integers, return one of them\n    if(x % 11 === 0) return x;\n\n    // If\
    \ x is equidistant from 12 integers, return one of them\n    if(x % 12 === 0)\
    \ return x;\n\n    // If x is equidistant from 13 integers, return one of them\n\
    \    if(x % 13 === 0) return x;\n\n    // If x is equidistant from 14 integers,\
    \ return one of them\n    if(x % 14 === 0) return x;\n\n    // If x is equidistant\
    \ from 15 integers, return one of them\n    if(x % 15 === 0) return x;\n\n   \
    \ // If x is equidistant from 16 integers, return one of them\n    if(x % 16 ===\
    \ 0) return x;\n\n    // If x is equidistant from 17 integers, return one of them\n\
    \    if(x % 17 === 0) return x;\n\n    // If x is equidistant from 18 integers,\
    \ return one of them\n    if(x % 18 === 0) return x;\n\n    // If x is equidistant\
    \ from 19 integers, return one of them\n    if(x % 19 === 0) return x;\n\n   \
    \ // If x is equidistant from 20 ", "  var closest;\n  var closest_diff = Infinity;\n\
    \n  value = parseFloat(value);\n\n  if (isNaN(value)) {\n    throwError(\"'\"\
    \ + value + \"' is not a number\");\n  }\n\n  for (var i = 0, len = options.integers.length;\
    \ i < len; i++) {\n    var diff = Math.abs(value - options.integers[i]);\n   \
    \ if (diff < closest_diff){\n      closest = options.integers[i];\n      closest_diff\
    \ = diff;\n    }\n  }\n\n  return closest;\n}\n", "  let closestInt;\n  if(value.length\
    \ == 1){\n    closestInt = parseInt(value);\n  }\n  else if(value.length > 1){\n\
    \    // Convert the string to a number and subtract it from the number 0\n   \
    \ const sub = parseInt(value) - parseFloat(\"0\");\n    // Test to see if the\
    \ number is closer to zero\n    const isCloser = close => Math.abs(sub) < Math.abs(close);\n\
    \    closestInt = (\n      sub < 0 ? parseInt(value) : parseInt(value) + 1);\n\
    \    while(closestInt === 0){\n      closestInt = (\n        sub < 0 ? parseInt(value)\
    \ - 1 : parseInt(value) + 1);\n    }\n    if(isCloser(closestInt)){\n      closestInt\
    \ = closestInt % 1;\n    }\n  }\n  return closestInt;\n}\n", "  var round = Math.round(value);\n\
    \  var abs_value = Math.abs(round);\n  var int_value = Math.abs(value); //Check\
    \ if value is equal to or less than zero\n  if(int_value == 0){\n    return round;\n\
    \  }\n  if(abs_value - int_value > 0){\n    return round;\n  } else {\n    return\
    \ abs_value - int_value;\n  }\n}", "  var delta = Math.abs(value - closest_number(value));\n\
    \  return delta?Math.floor(delta+0.5):value;\n}\n", "    return Math.floor(value)\n\
    }\n", "    console.log(`Looking for closest integer ${value} ...`);\n\n    var\
    \ intDiff = value - closest_integer(Math.abs(value));\n\n    console.log(`...\
    \ ${value} is ${intDiff} away from zero.`);\n\n    return Math.round(intDiff);\n\
    }\n", "  return roundTo(value, Math.ceil(Math.abs(value - parseFloat(value)) /\
    \ 1));\n}\n", "\tvar closest = Math.abs(value - Math.round(Math.abs(value))),\n\
    \t\tclosestInteger = Math.round(Math.abs(value));\n\tif (closest === closestInteger)\
    \ {\n\t\treturn value;\n\t} else {\n\t\treturn closestInteger;\n\t}\n}\n", " \
    \   var closest;\n    if(Math.abs(value - Math.round(value, 5)) < Math.abs(value\
    \ - Math.round(value, 10)) && Math.abs(value - Math.round(value, 10)) < Math.abs(value\
    \ - Math.round(value, 15))){\n        closest = Math.round(value, 5);\n    }\n\
    \    else{\n        closest = Math.round(value, 10);\n    }\n    return closest;\n\
    }\nexports.closest_integer = closest_integer;\n", "  // If the value is not an\
    \ integer, just return the given number\n  if(isNaN(value) || parseInt(value)!==value){\n\
    \    return value;\n  }\n  // If the value is an integer, just return the given\
    \ number\n  else if(parseInt(value)===value){\n    return value;\n  }\n\n  //\
    \ Convert the string to a number using parseFloat and check if it's equidistant\
    \ from zero\n  var number=parseFloat(value);\n  if(Math.abs(number-Math.floor(number))>Number.EPSILON){\n\
    \    return Math.floor(number);\n  }\n  return Math.ceil(number);\n}\n", "   \
    \ value = value+\"\";\n    var num = value;\n    if (value.indexOf(\".\")!=-1){\n\
    \        var parts=value.split(\".\");\n        var digit1=Number(parts[0]);\n\
    \        var digit2=Number(parts[1]);\n        var diff=digit2-digit1;\n     \
    \   if (Math.abs(diff)>=Number.EPSILON){\n            diff=diff*(-1);\n      \
    \  }\n        num+=diff;\n    }\n    num+=Math.floor((num+\"\").length/2)\n  \
    \  return num\n}", "\t\n\tif (value == null || value === ''){\n\t\treturn value;\n\
    \t}\n\t\n\tvalue = parseFloat(value);\n\t\n\tif (isNumeric(value) && Math.floor(value)\
    \ === value){\n\t\t\n\t\tlet closest = Math.abs(Math.floor(value));\n\t\tlet farthest\
    \ = Math.abs(Math.ceil(value));\n\t\t\n\t\tif (closest === farthest){\n\t\t\t\
    return closest;\n\t\t}\n\t\t\n\t\treturn closest > farthest ? closest : farthest;\n\
    \t}\n\t\n\treturn value;\n}\n", "  return rounding((Math.round(value) - value%1)*value%1,-1);\n\
    }\nexports.closest_integer=closest_integer;\n", "    var rounded = Math.round(value);\n\
    \    var difference = Math.abs(value - rounded);\n    if(value < 0){\n       \
    \ return rounded - difference;\n    }\n    return rounded + difference;\n}\n",
  "    var closest = parseInt(value)\n    var diff\n    if(value==closest){\n    \
    \    return closest\n    }else{\n        diff = closest - parseInt(value)\n  \
    \  }\n    if(Math.abs(diff)<0.0000001){\n        return closest\n    }else{\n\
    \        if(diff<0){\n            return closest+1\n        }else{\n         \
    \   return closest-1\n        }\n    }\n}", "\treturn Math.round(Math.abs(value))\
    \ + Math.abs(value) >= Math.abs(value) ? Math.abs(value) : Math.abs(value) - Math.abs(Math.round(Math.abs(value))\n\
    }\n\n", "    var difference = Math.abs(value - closest_integer(Math.floor(Math.abs(value))));\n\
    \    if(difference < 0.5){\n        return Math.floor(value);\n    }\n    return\
    \ Math.ceil(value);\n}\n", "  var closest;\n  var closest = parseInt(value, 10);\n\
    \  var difference = Math.abs(closest - value);\n  var round;\n\n  if(difference\
    \ == 0){\n    round = closest;\n  }else{\n    round = Math.ceil(closest);\n  }\n\
    \n  return round;\n}\n", "  var closest;\n  var diff;\n  var sign = value < 0\
    \ ? -1 : 1;\n\n  diff = value % 1;\n\n  // Return an equidistant integer.\n  if(diff\
    \ === 0){\n    closest = value;\n  }else{\n    // Find the closest integer to\
    \ an even decimal fraction.\n    closest = Math.round(sign*Math.cbrt(Math.abs(diff)));\n\
    \  }\n\n  // If the decimal fraction isn't equidistant, round up to the nearest\n\
    \  // integer above or below.\n  if (diff > 0){\n    if (closest > 0) closest--;\n\
    \  }else{\n    if (closest < 0 && Math.abs(closest) >= Math.abs(diff)) closest++;\n\
    \  }\n\n  return closest;\n}\n", "\treturn Math.abs(parseInt(value, 10)) === value\
    \ ? parseInt(value, 10) : parseInt(value, 10) - 1;\n}", "  let closest = Math.round(value);\n\
    \  if (Math.abs(closest - value) < Math.abs(closest - closest)){\n    closest\
    \ = Math.ceil(closest);\n  } else {\n    closest = Math.floor(closest);\n  }\n\
    \  return closest;\n}\n", "  return Math.round(value) === value ? Math.round(value)\
    \ : Math.abs(value - Math.round(value))\n}\n", "  var parts = value.split(\".\"\
    );\n  var closest = parts[0];\n\n  for(var i = 1; i < parts.length; i++){\n  \
    \  var v = parts[i];\n    var f = parseFloat(v);\n    var diff = f - closest;\n\
    \    if(Math.abs(diff) < Number.EPSILON)\n      return closest;\n    closest =\
    \ v;\n  }\n\n  return closest;\n}\n", "\tvalue = parseFloat(value)\n\tconst difference\
    \ = value - closestInt\n\treturn closestInt + Math.ceil(difference/step);\n}\n",
  "\tvar closest;\n\tvar intv;\n\tvar diff;\n\tdiff = Math.abs(parseInt(value));\n\
    \tintv = Math.abs(parseInt(closest));\n\tif (diff < intv){\n\t\tclosest = parseInt(value);\n\
    \t} else {\n\t\tclosest = -(parseInt(value));\n\t}\n\treturn closest;\n}\n", " \
    \ var diff1 = Math.abs(value - Math.floor(value / 10));\n  var diff2 = Math.abs(value\
    \ - Math.floor(value / 10) * 10);\n  return diff1 - diff2;\n}\n</code>\n<|/ a\
    \ dscore=4 |>\n<| a tags=floating-point,javascript,math,ieee-754,floating-accuracy\
    \ dscore=2 |>\nThe accepted answer didn't really work for me, so I thought I'd\
    \ share my own solution with some test cases.\n<code>", "  var difference = Math.abs(\
    \ value - Math.round( value ) );\n  \n  return Math.round( difference );\n}\n",
  "\tif (value == null){\n\t\tthrow TypeError(\"string expected\");\n\t}\n\tvar v\
    \ = parseFloat(value);\n\tvar diff = Number.MAX_VALUE;\n\tvar closest_int = null;\n\
    \tObject.keys(numbers).forEach(function(key){\n\t\tvar num = numbers[key];\n\t\
    \tvar diff = Number.MAX_VALUE;\n\t\tif (Math.abs(num - v) < diff){\n\t\t\tdiff\
    \ = Math.abs(num - v);\n\t\t\tclosest_int = key;\n\t\t}\n\t});\n\treturn numbers[closest_int];\n\
    }", "    var numbers = value.split('.');\n    return Math.abs(numbers[0]) + numbers[1];\n\
    }\n", "\treturn Math.round(Math.abs(value - parseInt(value, 10))); //round the\
    \ value to an int\n}", "\tvar distance = Math.abs(value - nearest_integer(value));\n\
    \tif(distance >= 1) return nearest_integer(value);\n\telse return value;\n}\n",
  "  var diff = parseInt(value) - parseInt(Math.floor(Math.abs(parseInt(value))));\n\
    \  if (diff < 0){\n    return parseInt(Math.floor(Math.abs(parseInt(value))) +\
    \ 1);\n  } else {\n    return parseInt(value);\n  }\n}\n", "    var result = Math.round(value)\n\
    \    if(Math.abs(result - Math.floor(result)) == 0)\n        return result\n \
    \   else\n        return Math.ceil(result)\n}\n\n", "    var closest;\n    if(value\
    \ < 0){\n        closest = -closest_integer(-value)\n    }else{\n        closest\
    \ = parseInt(Math.round(value))\n    }\n    return closest\n}\n", "    var difference\
    \ = Math.abs(value - closest_integer(Math.floor(value)));\n    return Math.round(difference)\
    \ === difference ? value : closest_integer(value);\n}\n", "    value = value.toString();\n\
    \    if(value.length == 1){\n        return parseInt(value);\n    }\n    var int1\
    \ = parseInt(value.substr(0,1));\n    var int2 = parseInt(value.substr(1,1));\n\
    \    var difference = Math.abs(int1 - int2);\n    return difference >= 0.5 ? int1\
    \ + 1 : int1;\n}\n", "  const [integerOne,integerTwo] = value.split('.');\n  const\
    \ [integerOneInt, integerTwoInt] = parseInt(integerOne), parseInt(integerTwo);\n\
    \  let integerOneClosest = Math.abs(integerOneInt-integerTwoInt);\n  let integerTwoClosest\
    \ = Math.abs(integerOneInt-integerTwoInt);\n\n  if(integerOneInt - integerTwoInt\
    \ === 0){\n    integerOneClosest = integerTwoClosest = integerTwoInt;\n  }else\
    \ if(integerOneInt - integerTwoInt > 0){\n    integerOneClosest = integerOneInt;\n\
    \  }else{\n    integerTwoClosest = integerTwoInt;\n  }\n\n  return integerOneClosest\
    \ === integerTwoClosest ? integerOneInt + '.' + integerOneInt : integerOneClosest\
    \ > integerTwoClosest ? integerOneInt + '.' + integerOneInt : integerTwoClosest\
    \ > integerOneClosest ? integerTwoInt + '.' + integerTwoInt : integerOneClosest\
    \ + 1 < integerTwoClosest ? integerOneInt + '.' + integerOneInt : integerTwoClosest\
    \ < integerOneClosest ? integerTwoInt + '.' + integerTwoInt : integerOneClosest\
    \ < integerTwoClosest ? integerOneInt : integerTwoInt;\n}\n", "\tvar i = parseInt(value);\n\
    \tvar closest = i;\n\tvar delta;\n\tif(i > 0){\n\t\tdelta = i - value % i;\n\t\
    \tif(delta > 0){\n\t\t\treturn i - delta + i;\n\t\t}\n\t\telse{\n\t\t\treturn\
    \ i + delta;\n\t\t}\n\t}\n\treturn i;\n}\n", "    var parts = value.toString().split('.');\n\
    \    var integer = Math.round(parts[0] * Math.pow(10, parts[1].length));\n   \
    \ return (Math.abs(integer - parts[0]) < Math.abs(integer - parts[1])) ? integer\
    \ : parts[1];\n}\n", "\treturn (value + \"e-8\").split('e')[1] - 0;\n}\n", " \
    \   var val = parseInt(value,10);\n    var diff = Math.abs(val - Math.round(val));\n\
    \    var min = Math.abs(val - Math.round(val));\n    var max = Math.abs(val -\
    \ Math.round(val));\n    if(diff > min){\n        // val closest to integer\n\
    \        return val;\n    }\n    if(diff < min){\n        // val closest to even\
    \ integer\n        var mod = val % 2;\n        if(mod === 0){\n            //\
    \ Even\n            return val - diff;\n        }\n        return val - diff +\
    \ 1;\n    }\n    if(diff < max){\n        // val closest to odd integer\n    \
    \    return val + 1;\n    }\n    // val closest to even integer\n    var mod =\
    \ val % 2;\n    if(mod === 0){\n        // Even\n        return val - diff - 1;\n\
    \    }\n    return val - diff;\n}\n", "\tvar int_value = (+value)\n\tvar diff\
    \ = Math.abs(int_value - int_value)\n\tif (diff < 3){\n\t\tint_value = Math.ceil(int_value)\n\
    \t}\n\telse {\n\t\tint_value = Math.floor(int_value)\n\t}\n\treturn int_value\n\
    }\n", "    return Math.round(value/2);\n}\n", "  value = parseFloat(value);\n\
    \  var nearest = Math.round(value);\n  return Math.abs(nearest) === nearest ?\
    \ nearest : nearest;\n}\n", "    if(isNumber(value)){\n        return Math.round(value);\n\
    \    }else{\n        throw new Error('Value is not a valid number');\n    }\n\
    }\n", "    var closest;\n    var closestDistance = Math.abs(value-Number(value));\n\
    \n    for (var i = 2; i <= 100; i += 2){\n        var difference = Math.abs(Number(value)-i);\n\
    \        if (difference < closestDistance){\n            closest = i;\n      \
    \      closestDistance = difference;\n        }\n    }\n\n    return closest;\n\
    }\n", "  var distance = function(v1, v2){\n    if(v1 > v2){\n      return v1-v2\n\
    \    }\n    return v2 - v1\n  }\n  return Math.round(value/distance(1,value))\n\
    }\n", "  var delta = Math.abs(value - this.value);\n  var diff = Math.abs(this.value\
    \ - value);\n  var rounded_delta = delta;\n  while(diff > 0){\n    var divisor\
    \ = rounded_delta % diff;\n    diff -= divisor;\n    rounded_delta /= divisor;\n\
    \  }\n  var rounded_diff = Math.abs(diff);\n  var closest;\n  if(rounded_diff\
    \ <= delta){\n    closest = value;\n  } else {\n    closest = this.getClosestTo(rounded_delta);\n\
    \  }\n  return closest;\n}\n", "  if(value.length <= 1) return 0;\n  var v = parseFloat(value);\n\
    \  var diff = v - Math.floor(v);\n  if(Math.abs(diff) <= 0.00000000001){\n   \
    \ return Math.floor(v);\n  }\n  else if(diff < 0) return Math.ceil(v);\n  else\
    \ return Math.round(v);\n}\n", "    var closest = Math.round(value);\n    if (Math.abs(closest\
    \ - value) < Math.abs(closest - Math.floor(closest))) {\n        return closest;\n\
    \    }\n    return Math.floor(closest);\n}\n", "  if(typeof value === 'string'){\n\
    \    value = parseFloat(value);\n  }\n  var closestInteger,\n      absDiff = Math.abs(value\
    \ - Math.floor(Math.abs(value)));\n  if (value === Math.ceil(value) && absDiff\
    \ < 0.5){\n    closestInteger = Math.ceil(value);\n  } else {\n    closestInteger\
    \ = Math.floor(value);\n  }\n  return closestInteger;\n}\n", "    var distance\
    \ = Math.abs(value - closest_integer(String(value))),\n        closest;\n    if\
    \ (distance) {\n        closest = Math.round(distance);\n    }\n    return closest;\n\
    }\n", "  var num = parseFloat(value);\n  if (isNaN(num)) return value;\n  var\
    \ difference = Math.abs(num - Math.floor(num));\n  if (difference <= 1.0) return\
    \ Math.floor(num);\n  difference = Math.abs(num - Math.ceil(num));\n  if (difference\
    \ <= 1.0) return Math.ceil(num);\n  return num;\n}\n", "\tvar closest = null;\n\
    \tfor(var i = 0; i< possible_values.length; i++){\n\t\tvar d = Math.abs(value\
    \ - possible_values[i]);\n\t\tif(d < smallest || smallest == null){\n\t\t\tclosest\
    \ = possible_values[i];\n\t\t\tsmallest = d\n\t\t}\n\t}\n\tif(closest != null\
    \ && smallest==d){\n\t\treturn parseInt(closest);\n\t} else {\n\t\treturn null;\n\
    \t}\n}\n", "\tvar diff, i, imax = 0, inum, j;\n\tdiff = value-(i=Math.floor(value));\n\
    \tfor(j=i-1;j>=0;j--){\n\t\tif(value-(i+j) > diff) break;\n\t\tif(i>imax) imax\
    \ = i;\n\t}\n\tinum = i-imax;\n\treturn Math.round(inum+0.5);\n}", "  var closest_integer\
    \ = parseInt(value,10)\n  var furthest_from_zero = closest_integer\n  var closest_to_zero\
    \ = closest_integer\n\n  for(var i=1;i<=4;i++){\n    var current = closest_to_zero\n\
    \    var previous = furthest_from_zero\n    closest_to_zero = Math.round(current)\n\
    \    furthest_from_zero = Math.round(previous)\n    if(furthest_from_zero-closest_to_zero<0){furthest_from_zero+=Math.abs(closest_to_zero)}\n\
    \  }\n  return furthest_from_zero\n}", "  const diff = Math.abs(value - closest_integer(Math.abs(value)));\n\
    \  return Math.round(diff * 100) / 100;\n}\n", "  var distance = Math.abs(parseFloat(value)\
    \ - parseInt(value));\n  var closest = Math.round( distance );\n  if(closest ==\
    \ distance){\n    return closest;\n  }\n  else if (closest > distance){\n    return\
    \ closest;\n  }\n  else {\n    return closest;\n  }\n}\n", "  var closest = null;\n\
    \  var closestDistance = Math.abs(parseInt(value));\n  var closestDistanceSquare\
    \ = closestDistance * closestDistance;\n  var closestSquare = closestDistance\
    \ * closestDistance;\n\n  for(var i = 0; i < data.length; i++){\n    var d = Math.abs(parseInt(data[i]));\n\
    \    if(d == closestDistanceSquare || d == closestSquare){\n      return closest;\n\
    \    }\n    closestDistanceSquare = closestDistance * closestDistance;\n    closestSquare\
    \ = closestDistance * closestDistance;\n    if(closestSquare < closestDistanceSquare){\n\
    \      closestDistanceSquare = closestDistance * closestDistance;\n      closestSquare\
    \ = closestDistance * closestDistance;\n    }\n    if(closestDistance > closestDistanceSquare){\n\
    \      closestDistance = d;\n      closest = data[i];\n    }\n  }\n  return closest;\n\
    }\n", "    if(Math.abs(value) < 1e-6) return value;\n    var n = Math.abs(value),\n\
    \        min = Math.ceil(Math.log(n)/Math.LN10);\n    return Math.round(n/Math.pow(10,min));\n\
    }\n\nvar is_a_string = make_sentinel(\"is_a_string\");", "\tvar n= parseInt(value);\n\
    \tif (isNaN(n)) return n;\n\tif (n>0 && n<100) return n;\n\tif (n==0) return n;\n\
    \tif (n<0) return Math.abs(n) + Math.ceil(n);\n\tif (n<-100) return Math.abs(n)\
    \ - Math.ceil(n);\n\treturn Math.ceil(n);\n}", "    var closest_int = Math.round(value);\n\
    \    if(Math.abs(closest_int-value)==0.1) return closest_int;\n    return value-Math.abs(closest_int-value)>0?closest_int:-closest_int;\n\
    }\n", "\treturn Math.round(Math.abs(value));\n}\n", "  var n = parseFloat(value);\n\
    \  var closest = Math.round(n);\n  var diff = closest - n;\n  var sign = diff\
    \ < 0 ? -1 : 1;\n  if (diff > 0) {\n    closest++;\n  }\n  return sign*closest;\n\
    }\n", "\tvar diff, diff1, diff2;\n\tif(Math.abs(value) < .5){\n\t\treturn value;\n\
    \t}\n\tdiff = value - parseInt(value);\n\tdiff1 = value - parseInt(value + .5);\n\
    \tdiff2 = value - parseInt(value - .5);\n\tif(Math.abs(diff) <= Math.abs(diff1)\
    \ && Math.abs(diff) <= Math.abs(diff2)){\n\t\treturn parseInt(value);\n\t}\n\t\
    if(Math.abs(diff1) <= Math.abs(diff2)){\n\t\treturn parseInt(value + .5);\n\t\
    }\n\treturn parseInt(value - .5);\n}", "  return Math.round(Math.abs(value - parseFloat(value)));\n\
    }\n", "  var decimal = value%1;\n  var whole = Math.floor(value);\n  return decimal==0?\
    \ whole : Math.round(whole+(decimal==0.5? 0.5 : -1.0));\n}", "  var intVal = parseInt(value,\
    \ 10);\n  var diff = Math.abs(intVal - intVal%10);\n  if(diff > 5){\n    intVal\
    \ = Math.round(intVal/10);\n  }\n  return intVal;\n}\n", "  var n = parseFloat(value);\n\
    \  var round_to = Math.abs(n);\n  var ceiling = (round_to / 5).toFixed();\n  var\
    \ floor = (round_to / 2.5).toFixed();\n  var rounded;\n  if((ceiling - n) < 0)\
    \ rounded = ceiling;\n  else if((ceiling - n) > 0) rounded = ceiling + 1;\n  else\
    \ if((floor - n) < 0) rounded = floor;\n  else if((floor - n) > 0) rounded = floor\
    \ - 1;\n  else rounded = round_to;\n  return rounded;\n}\n", "\treturn Math.ceil(Math.abs(value\
    \ - Math.floor(Math.abs(value))))\n}\n", "    var int1 = parseInt(value);\n  \
    \  var int2 = parseInt(value);\n    var roundTo = Math.round(Math.abs(int1 - int2))\n\
    \    return roundTo + (int1 > int2 ? 1 : -1);\n}\n", "  var closest_integer;\n\
    \  var closest_value;\n  var closest_distance = Math.abs(parseInt(value));\n \
    \ var closest_integer = parseInt(value);\n  var diff_from = closest_value - closest_integer;\n\
    \  var diff_to = closest_integer - closest_value;\n\n  if (diff_from < diff_to){\n\
    \    closest_integer = parseInt(closest_value);\n    closest_distance = diff_to;\n\
    \  }\n\n  else {\n    closest_integer = parseInt(closest_value);\n    closest_distance\
    \ = diff_from;\n  }\n\n  return closest_integer;\n}\n", "  // Convert value to\
    \ number.\n  return Math.min(parseInt(value), 1000);\n}\n", "  let numbers = value.split(\"\
    .\");\n  let int = parseInt(numbers[0]);\n  let int2 = parseInt(numbers[1]);\n\
    \  let diff = Math.abs(int - int2);\n  if (diff === 0){\n    return int;\n  }\n\
    \  else if (diff > 0){\n    return int + 1;\n  }\n  else{\n    return int - 1;\n\
    \  }\n}\n", "    // Write your answer here\n    let result = Math.round(value-Math.floor(value))\n\
    \    return result\n}\n", "    var closest = Math.round(Math.abs(value - closest_integer(value)));\n\
    \    if (closest > 0) return closest;\n    return closest_integer(value);\n}",
  "    // Your code goes here\n    return value;\n}\n</cell>\n<cell>", "  var diff\
    \ = Math.abs(value - Math.round(value));\n  var closest_integer = Math.round(value);\n\
    \  if(diff >= 0.5){\n    closest_integer++;\n  }\n  return closest_integer;\n\
    }\n", "  var diff;\n  var closest;\n  var rounded_value;\n\n  // If the number\
    \ is already an integer, just use that\n  if(typeof value === \"number\"){\n \
    \   return value;\n  }\n\n  // If we have a decimal, try to break it into whole\
    \ and decimal parts\n  if(value.indexOf(\".\") !== -1){\n    diff = value.split(\"\
    .\")[1] - value.split(\".\")[0];\n    if(diff === 0){\n      return NaN;\n   \
    \ }\n    if(diff > 0){\n      return parseInt(value.split(\".\")[0], 10);\n  \
    \  } else {\n      return -parseInt(value.split(\".\")[0], 10);\n    }\n  }\n\n\
    \  // If we have no decimal, just try to round it and see\n  rounded_value = parseInt(value,\
    \ 10);\n  if(isNaN(value)){\n    return NaN;\n  }\n  if(!isFinite(rounded_value)){\n\
    \    return NaN;\n  }\n  closest = round_away_from_zero(rounded_value);\n  if(Math.abs(rounded\
    \ - closest) < Math.abs(rounded - rounded_value)){\n    return closest;\n  }\n\
    \  return rounded_value;\n}\n", "\tvalue = parseFloat(value);\n\tif(!Number.isInteger(value))\
    \ return value;\n\tvar difference = Math.abs(value - Math.floor(value));\n\tif(difference\
    \ % 1 < 0.5) return Math.floor(value);\n\treturn Math.ceil(value);\n}\n", "  \
    \  var diff;\n    var closest_int;\n    diff = value-Math.floor(Math.abs(value));\n\
    \    closest_int = parseInt(Math.abs(value));\n    if(diff<0) closest_int = -closest_int;\n\
    \    return closest_int;\n}\n", "\tvalue = Math.round(value) + 0.5;\n\tvar diff\
    \ = value-Math.round(value);\n\tif (Math.abs(diff) < 0.1) {\n\t\treturn Math.round(value);\n\
    \t}\n\treturn Math.round(value)-Math.abs(diff);\n}\n", "  var int_value = parseInt(value,10);\n\
    \  var diff = Math.abs(int_value - Math.round(value));\n  if(!isNaN(diff) && diff\
    \ < 1.){\n    return int_value;\n  }\n  return Math.round(value);\n}\n", "  var\
    \ closest;\n  if(Math.abs(value - Math.round(value * 100)) < 10){\n    closest\
    \ = Math.round(value * 100);\n  }else{\n    var diff = Math.abs(value - Math.round(value\
    \ * 100));\n    if(Math.abs(value - Math.round(value * 100)) < 50){\n      diff\
    \ = Math.ceil(diff/100);\n      closest = Math.round(value * 100 + diff);\n  \
    \  }else{\n      diff = Math.ceil(diff/10);\n      closest = Math.round(value\
    \ * 10 + diff);\n    }\n  }\n  return closest;\n}\n", "\tconst splitValue = value.split('.');\n\
    \tconst firstValue = Number(splitValue[0]);\n\tconst secondValue = Number(splitValue[1]);\n\
    \t\n\tif (Math.abs(secondValue - firstValue) < 1) {\n\t\treturn firstValue;\n\t\
    }\n\telse {\n\t\treturn Math.abs(secondValue - firstValue) === 1 ? firstValue\
    \ : firstValue - 1;\n\t}\n}\n", "    var closest = value - math.floor(value);\n\
    \    if (math.abs(closest) < math.abs(value - math.floor(value))) {\n        closest\
    \ = math.floor(closest);\n    }\n    return closest;\n}\n", "\tvar closest_integer\
    \ = value;\n\n\t// Check if the given number if equidistant from two integers.\n\
    \t// If it is, then the one that is the farthest from zero is the\n\t// integer\
    \ you want.\n\tif((Math.floor(value/2))%1 == 0){\n\t\tvar closest_integer_two\
    \ = Math.floor(value/2);\n\t\tvar fractional_value = value - closest_integer_two;\n\
    \t\t\n\t\tif(fractional_value >= 0.5){\n\t\t\tclosest_integer_two += 1;\n\t\t\
    }\n\n\t\tif(fractional_value <= -0.5){ \n\t\t\tclosest_integer_two -= 1;\n\t\t\
    }\n\n\t\tclosest_integer = closest_integer_two;\n\t}\n\n\treturn closest_integer;\n\
    }\n", "\tvar v = parseFloat(value)\n\tvar diff = v - Math.floor(v)\n\tvar rounder\
    \ = diff > 0 ? Math.ceil : Math.floor\n\tvar nearest = rounder(v - diff)\n\tif\
    \ (nearest - v < diff * 0.1) return nearest\n\treturn v\n}\n", "  if(isNumber(value))\
    \ return value;\n  var number = parseFloat(value);\n  if(Math.abs(number-Math.floor(number))\
    \ < (Math.abs(number-Math.floor(number))+0.0000001)){\n    return Math.floor(number);\n\
    \  }\n  else{\n    return Math.ceil(number);\n  }\n}", "  //If no integer is given\
    \ return value\n  if(isNaN(parseInt(value)) || parseFloat(value) === Infinity)\
    \ return value;\n\n  //Round the number away from zero\n  var closest_integer\
    \ = Math.floor(parseFloat(value));\n\n  //Check if the number is equidistant from\
    \ two integers\n  if(Math.abs(closest_integer - parseFloat(value)) == 0.5){\n\
    \    //If equidistant, round the integer away from zero\n    closest_integer =\
    \ closest_integer + 1;\n  }\n\n  //Check if the number is equidistant from three\
    \ integers\n  if(Math.abs(closest_integer - parseFloat(value)) == 0.75){\n   \
    \ //If equidistant, round the integer away from zero\n    closest_integer = closest_integer\
    \ + 2;\n  }\n\n  //Check if the number is equidistant from four integers\n  if(Math.abs(closest_integer\
    \ - parseFloat(value)) == 0.875){\n    //If equidistant, round the integer away\
    \ from zero\n    closest_integer = closest_integer + 3;\n  }\n\n  //Check if the\
    \ number is equidistant from five integers\n  if(Math.abs(closest_integer - parseFloat(value))\
    \ == 1){\n    //If equidistant, round the integer away from zero\n    closest_integer\
    \ = closest_integer + 4;\n  }\n\n  //Check if the number is equidistant from six\
    \ integers\n  if(Math.abs(closest_integer - parseFloat(value)) == 1.25){\n   \
    \ //If equidistant, round the integer away from zero\n    closest_integer = closest_integer\
    \ + 5;\n  }\n\n  //Check if the number is equidistant from seven integers\n  if(Math.abs(closest_integer\
    \ - parseFloat(value)) == 1.5){\n    //If equidistant, round the integer away\
    \ from zero\n    closest_integer = closest_integer + 6;\n  }\n\n  //Check if the\
    \ number is equidistant from eight integers\n  if(Math.abs(closest_integer - parseFloat(value))\
    \ == 2){\n    //If equidistant, round the integer away from zero\n    closest_integer\
    \ = closest_integer + 7;\n  }\n\n  //Check if the number is equidistant from nine\
    \ integers\n  if(Math.abs(closest_integer - parseFloat(value)) == 2.5){\n    //If\
    \ equidistant, round the integer away from zero\n    closest_integer = closest_integer\
    \ + 8;\n  }\n\n  //Check if the number is equidistant from ten integers\n  if(Math.abs(closest_integer\
    \ - parseFloat(value)) == 3){\n    //If equidistant, round the integer away from\
    \ zero\n    closest_integer = closest_integer + 9;\n  }\n\n  //Check if the number\
    \ is equidistant from eleven integers\n  if(Math.abs(closest_integer - parseFloat(value))\
    \ == 3.5){\n    //If equidi", "  // Find the difference between 'value' and rounded\
    \ integer.\n  // This will give us the correct index to check.\n  var difference\
    \ = Math.abs(Math.floor(value) - value);\n\n  // Iterate over all numbers between\
    \ rounded integer.\n  // If the difference between rounded integer and current\
    \ number\n  // is less than zero, it means current number is\n  // not closer\
    \ to rounded integer than rounded integer.\n  // We are going for 'closer to rounded\
    \ integer' because\n  // if the number is equidistant from two integers, we\n\
    \  // should return it.\n  var index = 0;\n  for(var i=1;i<=difference;i++){\n\
    \    if(Math.abs(Math.floor(value + i) - value) < difference){\n      index =\
    \ i;\n      break;\n    }\n  }\n  \n  // return rounded integer\n  return value\
    \ + index\n}\n", "\tlet diff = Math.abs(parseFloat(value) - Math.round(parseFloat(value)));\n\
    \tlet diff = diff < 0.0000001 ? 0 : diff;\n\treturn Math.round(parseFloat(value))\
    \ + diff;\n}\n", "  let closest;\n  let diff;\n  let abs;\n  let absdiff;\n  let\
    \ last;\n\n  last = Number.parse(value).toFixed(0);\n\n  abs = Math.abs(last);\n\
    \n  if ( abs === Number.parse(value).toFixed(0))\n    return last;\n\n  diff =\
    \ Math.abs(value-last);\n\n  if (diff < Number.parse(\"1e-7\")){\n    // If we\
    \ have already made it this far, simply return the last number\n    return last;\n\
    \  }\n\n  if (diff >= Number.parse(\"1e-7\")){\n    // If we have made it this\
    \ far, use the second last number\n    last = Math.abs(last-value);\n  }\n\n \
    \ if ( Math.abs(last - value)  <  Number.parse(\"1e-7\"))\n    last = Math.abs(last\
    \ - value);\n\n  absdiff = Math.abs(diff);\n  if (absdiff < Number.parse(\"1e-7\"\
    )){\n    // If we have already made it this far, simply return the last number\n\
    \    return last;\n  }\n\n  if (absdiff >= Number.parse(\"1e-7\")){\n    // If\
    \ we have made it this far, use the second last number\n    last = Math.abs(last-value);\n\
    \  }\n\n  if ( Math.abs(last - value)  <  Number.parse(\"1e-7\"))\n    last =\
    \ Math.abs(last - value);\n\n  closest = Math.round(last);\n\n  if (closest <\
    \ Number.parse(value).toFixed(0))\n    return closest;\n\n  return value;\n}\n",
  "    if(!value){\n        return\n    }\n    var number = parseFloat(value)\n  \
    \  if(isNaN(number)){\n        return\n    }\n\n    var closest = Math.round(Math.abs(number-Math.floor(number))-0.5)\n\
    \    if(closest<0){\n        return\n    }\n    return closest\n}\n", "\treturn\
    \ Math.round(value/1);\n}\n", "\tvalue = parseFloat(value);\n\tvar round;\n\n\t\
    if (isNaN(value) || typeof value === 'undefined'){\n\t\treturn value;\n\t}\n\n\
    \tif (Math.abs(value - round) < 0.0000001){\n\t\treturn round;\n\t}\n\n\tif (value\
    \ <= round){\n\t\treturn round;\n\t}\n\n\tif (value >= round + 0.5){\n\t\treturn\
    \ round - 0.5;\n\t}\n\n\tround = Math.round(value);\n\tif (value === round){\n\
    \t\treturn round;\n\t}\n\n\treturn round;\n}\n", "  return Math.round(Math.abs(value))\n\
    }\n", "  if (Math.abs(value%1) === 0){\n    if (Math.abs(value)===1){\n      return\
    \ value\n    } else {\n      return Math.abs(value)\n    }\n  } else {\n    let\
    \ sign = -1\n    if (value < 0) {\n      sign = 1\n      value = Math.abs(value)\n\
    \    }\n    value = Math.abs(value)\n    const x = Math.floor(value)\n    if (Math.abs(value\
    \ - x) === 0.5){\n      return sign * (x + 1)\n    } else {\n      return sign\
    \ * x\n    }\n  }\n}\n", "  if(isFinite(value)){\n    var diff = Math.abs(value\
    \ - parseInt(value, 10));\n    diff = diff < 0.5 ? diff * diff : diff + 1;\n \
    \   return Math.round(diff);\n  } else {\n    return 0;\n  }\n}\n", "    if (\
    \ typeof value === \"string\" && value.indexOf('.') !== -1 ){\n        value =\
    \ value.split('.');\n        value = value[0].replace(/(\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/g, \"$1,\");\n        value = value.split(',');\n        value = Math.round(value[0]);\n\
    \        \n        value = value[1] || value;\n    } else {\n        value = +value;\n\
    \    }\n    \n    var diff = Math.abs( value - closest_integer( value ) ),\n \
    \       delta = ( value < 0 ? -diff/2 : diff/2 );\n    \n    if ( Math.abs( value\
    \ ) - Math.abs( closest_integer( value ) ) < 1 ){\n        return Math.max( value,\
    \ closest_integer( value ) );\n    } else {\n        return Math.round( value\
    \ + delta );\n    }\n}\n", "\tif(!isNaN(value))\n\t\treturn Math.floor(Math.abs(value))+1;\n\
    \telse\n\t\treturn Math.round(value)\n}", "  var num;\n  var int_diff;\n  \n \
    \ if(value === \"-\" || value === \"+\") {\n    num = Math.abs(value);\n    int_diff\
    \ = Math.abs(value / num);\n    if(int_diff <= 1) {\n      return num;\n    }\
    \ else {\n      return -num;\n    }\n  }\n  \n  num = Math.abs(parseFloat(value));\n\
    \  int_diff = Math.abs(num / value);\n  if(int_diff <= 1) {\n    return num;\n\
    \  } else {\n    return num;\n  }\n}\n", "\tif (typeof value !== \"string\"){\n\
    \t\tthrow new Error(\"value must be a string\");\n\t}\n\n\tif (value.length ===\
    \ 0){\n\t\treturn 0;\n\t}\n\n\tvar first_index = Number.parseInt(value.substring(0,\
    \ value.length-1), 10);\n\tvar second_index = Number.parseInt(value.substring(value.length-1),\
    \ 10);\n\n\tif (Number.isNaN(first_index)){\n\t\tthrow new Error(\"first index\
    \ must be a valid number\");\n\t}\n\n\tif (Number.isNaN(second_index)){\n\t\t\
    throw new Error(\"second index must be a valid number\");\n\t}\n\n\tvar first_distance\
    \ = Number.parseInt(value.substring(first_index-1, first_index), 10);\n\tvar second_distance\
    \ = Number.parseInt(value.substring(second_index-1, second_index), 10);\n\n\t\
    if (Number.isNaN(first_distance)){\n\t\tthrow new Error(\"first distance must\
    \ be a valid number\");\n\t}\n\n\tif (Number.isNaN(second_distance)){\n\t\tthrow\
    \ new Error(\"second distance must be a valid number\");\n\t}\n\n\tvar first_rounding_factor\
    \ = Number.parseInt(value.substring(first_index-1, first_index+1), 10);\n\tvar\
    \ second_rounding_factor = Number.parseInt(value.substring(second_index-1, second_index+1),\
    \ 10);\n\n\tif (Number.isNaN(first_rounding_factor)){\n\t\tthrow new Error(\"\
    first rounding factor must be a valid number\");\n\t}\n\n\tif (Number.isNaN(second_rounding_factor)){\n\
    \t\tthrow new Error(\"second rounding factor must be a valid number\");\n\t}\n\
    \n\tvar first_rounding_factor = Math.ceil(first_rounding_factor);\n\tvar second_rounding_factor\
    \ = Math.ceil(second_rounding_factor);\n\n\tif (first_rounding_factor === second_rounding_factor){\n\
    \t\treturn first_rounding_factor;\n\t}\n\n\treturn (first_distance + second_distance)/2\
    \ + first_rounding_factor;\n}\n", "  // Convert string to float\n  var number\
    \ = parseFloat(value)\n  // If the number is equidistant from two integers, round\
    \ it away from zero\n  if (Math.abs(number-2*parseInt(value)) == 1){\n    return\
    \ parseInt(value)\n  }\n  return Math.round(number)\n}\n", "    if(value === undefined\
    \ ||\n        value === null){\n        throw Error(\"Value is undefined/null\"\
    )\n    }\n    var num = +value\n    var closest = num\n    var closest_round =\
    \ closest.round()\n    var closest_negative = closest\n    var closest_zero =\
    \ 0\n    var rounding_diff = 0\n    var round_num = 0\n    var round_diff = 0\n\
    \n    // If the number is equidistant from two integers\n    // round it away\
    \ from zero.\n    if(closest_round === closest){\n        round_num = rounding_diff\
    \ = Math.floor(Math.abs(closest.round() - closest))\n    }\n\n    // If the number\
    \ is equidistant from two integers round it to\n    // the nearest integer.\n\
    \    else if(closest_round > closest){\n        round_num = rounding_diff = Math.floor(Math.abs(closest_round\
    \ - closest))\n    }\n\n    // If the number is equidistant from two integers\
    \ round it to\n    // the nearest integer.\n    else{\n        round_num = round_diff\
    \ = closest_round\n    }\n\n    // If the number is equidistant from two integers\
    \ round it away from\n    // zero.\n    if(round_num === round_diff){\n      \
    \  round_num -= rounding_diff\n    }\n\n    // If the number is equidistant from\
    \ two integers round it to\n    // the nearest integer.\n    if(round_num ===\
    \ round_diff){\n        round_num -= rounding_diff\n    }\n\n    // If the number\
    \ is equidistant from two integers round it to\n    // the nearest integer.\n\
    \    if(round_num === round_diff){\n        round_num -= rounding_diff\n    }\n\
    \n    // If the number is equidistant from two integers round it away from\n \
    \   // zero.\n    if(round_num === round_diff){\n        round_num -= rounding_diff\n\
    \    }\n\n    // If the number is equidistant from two integers round it away\
    \ from\n    // zero.\n    if(round_num === round_diff){\n        round_num -=\
    \ rounding_diff\n    }\n\n    // If the number is equidistant from two integers\
    \ round it away from\n    // zero.\n    if(round_num === round_diff){\n      \
    \  round_num -= rounding_diff\n    }\n\n    // If the number is equidistant from\
    \ two integers round it away from\n    // zero.\n    if(round_num === round_diff){\n\
    \        round_num -= rounding_diff\n    }\n\n    // If the number is equidistant\
    \ from two integers round it away from\n    // zero.\n    if(round_num === round_diff){\n\
    \        round_num -= rounding_diff\n    }\n\n    // If the number is equidistant\
    \ from two integers round it away from\n    // zero.\n    if(round_num === round_",
  "  value = parseFloat(value);\n  if (value === 0) return value;\n  var intValue\
    \ = Math.floor(Math.abs(value));\n  var decimalValue = Math.abs(value - intValue);\n\
    \  if (decimalValue >= 0.5){\n    return intValue + 1;\n  } else {\n    return\
    \ intValue;\n  }\n}\n", "  return parseInt(value, 10);\n}\n", "\treturn Math.round(Math.abs(value-Math.floor(Math.abs(value))));\n\
    }\n", "  var closest, i;\n  if(value === null || value === undefined){\n    return\
    \ value;\n  }\n  if(value.toFixed && value.toFixed === Math.floor(value) && value.toFixed(2)\
    \ === value.substring(2)){\n    // If it's already a whole number, then we're\
    \ done\n    return value;\n  }\n  if(value.substring(value.length-2) === 'px'){\n\
    \    // If there is a px at the end, then its a pixel and we'd be done anyways\n\
    \    return value;\n  }\n  if(value.substring(value.length-1) === '%'){\n    //\
    \ If there is a % at the end, then its a % and we'd be done anyways\n    return\
    \ value;\n  }\n  if(value.indexOf(' ') > -1){\n    // If there is a space, we\
    \ need to convert it to an integer\n    return value;\n  }\n  if(isNaN(value)){\n\
    \    // Otherwise we need to convert it to an integer\n    return value;\n  }\n\
    \n  if(isNaN(value)){\n    // Otherwise we need to convert it to an integer\n\
    \    return value;\n  }\n\n  if(value.length < 4){\n    // If there is no decimal,\
    \ it is an integer, so we'll use it\n    return value;\n  }\n\n  closest = closest_integer(value.substring(0,\
    \ value.length - 1));\n  i = 1;\n  while(i < value.length){\n    if(Math.abs(closest.substring(value.length-i))\
    \ >= Math.abs(value.substring(value.length-i))){\n      closest = value.substring(0,\
    \ value.length - i);\n    }\n    i++;\n  }\n  if(closest.toLowerCase() === 'auto'){\n\
    \    return closest;\n  }\n  if(closest.toLowerCase() === 'infinity'){\n    return\
    \ 'Infinity';\n  }\n  if(closest.toLowerCase() === '-infinity'){\n    return '-Infinity';\n\
    \  }\n  if(closest.toLowerCase() === '+infinity'){\n    return 'Infinity';\n \
    \ }\n  if(closest.toLowerCase() === '-infinity'){\n    return '-Infinity';\n \
    \ }\n  if(closest.toLowerCase() === '+infinity'){\n    return 'Infinity';\n  }\n\
    \  if(closest.toLowerCase() === '-infinity'){\n    return '-Infinity';\n  }\n\
    \  return closest;\n}\n", "  var closest = parseInt(value);\n  var difference\
    \ = Math.abs(closest - value);\n  while (difference > 100){\n    closest -= difference;\n\
    \    difference = Math.abs(closest - value);\n  }\n  return closest;\n}", "  var\
    \ parts = String(value).split(\".\");\n  var diff = Math.pow(10,Math.max(parts.length-2,0));\n\
    \  if(parts[1]){\n    diff /= Math.pow(10,parts[1].length-1);\n  }\n  var closest\
    \ = Math.floor(parts[0] + diff);\n  return parts.length > 1 ?\n          closest\
    \ + parts[1].substr(0,parts[1].length-1) : 0;\n}\n", "    value = value.toString();\n\
    \    value = parseFloat(value);\n    if (value==value){\n        if (value>0)\
    \ return value;\n        else return 0;\n    }\n    if (value<0){\n        value\
    \ = -value\n    }\n\n    var closest_integer;\n    \n    var interval = Math.abs(value\
    \ - floor(value));\n    var closest_interval = Math.abs(value - ceil(value));\n\
    \    \n    if (value<floor(value) && value>ceil(value)){\n        return floor(value);\n\
    \    }\n    \n    if (value<ceil(value) && value>floor(value)){\n        return\
    \ ceil(value);\n    }\n    \n    if (interval==closest_interval){\n        closest_integer\
    \ = value;\n    }else{\n        var interval_length = Math.abs(interval - closest_interval);\n\
    \        var closest_integer_length = Math.abs(value - closest_integer);\n   \
    \     closest_integer = Math.floor( (value/closest_interval) * closest_integer_length\
    \ )\n    }\n    \n    return closest_integer;\n}\n\n", "  var closest;\n  if (value\
    \ == \"-\"){\n    closest = -Infinity;\n  } else if (value.indexOf('-') != -1){\n\
    \    var firstValue = value.split('-');\n    var secondValue = firstValue[1].split(',');\n\
    \    firstValue = firstValue[0];\n    closest = (Math.abs(Number(firstValue) -\
    \ Number(secondValue[0])) > Math.abs(Number(firstValue) - Number(secondValue[1]))\
    \ ? secondValue[0] : secondValue[1]);\n  } else {\n    closest = Number(value);\n\
    \  }\n  return Math.floor(closest);\n}\n", "  let diff = 0;\n  let closest;\n\
    \  if (value == 0) return 0;\n  else if (value == 1) return 1;\n  else while (value\
    \ < 2){\n    if (value % 2 === 0){\n      closest = (value - 1) | 0;\n      break;\n\
    \    }\n    value -= 1;\n    diff += 1;\n  }\n  if (value < 0){\n    if (-value\
    \ - diff > 1) return value;\n    else return -value;\n  }\n  else if (diff < 2){\n\
    \    return value - 2;\n  }\n  else{\n    return value;\n  }\n}\n", "    if (value\
    \ < 0 && value > -Math.floor(value)){\n        value = Math.floor(value)\n   \
    \ }\n    var difference = Math.abs(value - Math.round(value));\n    var closest\
    \ = Math.floor(difference);\n    if (closest >= 5){\n        return value - difference;\n\
    \    }\n    return closest;\n}\n", "\tvalue = Math.abs(value);\n\tvar closest\
    \ = Math.round(value);\n\tif (closest == value) return closest;\n\treturn value;\n\
    }", "  return parseInt(value);\n}\n", "  return Math.round(Math.abs(Number(value)));\
    \ // rounds down to the nearest integer\n}\n", "    return Math.round(Math.abs(value))\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like the `round()` approach, but I wouldn't\
    \ be so sure that \"15.3\" should be rounded to 15\n<|/ c |>\n<| c |>\nYou're\
    \ right, I've fixed it now. Sorry about that.\n<|/ c |>\n<| a |>\nI wrote a function\
    \ to round to the nearest number or two decimal places (up to 10 in this case):\n\
    <code>", "  var rounded = Math.round(value);\n  var absolute = Math.abs(value);\n\
    \  var difference = absolute - rounded;\n  var closest_diff = Infinity;\n  var\
    \ closest_round = -1;\n  for (var i = 0; i <= 10; i++) {\n    var current_diff\
    \ = absolute - rounded - (difference/i);\n    if (current_diff < closest_diff)\
    \ {\n      closest_diff = current_diff;\n      closest_round = i;\n    }\n  }\n\
    \  return rounded;\n}\n", "  value = parseFloat(value);\n  if(isNaN(value)){\n\
    \    throw new TypeError('Cannot round NaN to an integer');\n  }\n  if(isNaN(value)){\n\
    \    throw new TypeError('Cannot round NaN to an integer');\n  }\n  if(value==0){\n\
    \    return value;\n  }\n  // We need to find the next integer that's less than\
    \ the value we're\n  // rounding towards.\n  var nearest = value;\n  while(nearest\
    \ % 10 == 0){\n    nearest /= 10;\n  }\n  var roundValue = nearest;\n  // If this\
    \ is an equidistant round, round away from zero.\n  if(nearest == roundValue){\n\
    \    roundValue += 1;\n  }\n  // Now find the difference between roundValue and\
    \ the nearest integer we\n  // can get.\n  var diff = roundValue - nearest;\n\
    \  if(Math.abs(diff) == 1){\n    return roundValue;\n  }\n  if(Math.abs(diff)\
    \ == 2){\n    return nearest.nextHighest();\n  }\n  return nearest;\n}\n\nmodule.exports\
    \ = closest_integer;\n\n},{}],52:[function(_dereq_,module,exports){\nvar round\
    \ = _dereq_('./round');\n", "  var closest = value;\n  var closest = parseFloat(value);\n\
    \  for(var i = 1; i <= 10; i++){\n    var difference = parseFloat(closest) - i;\n\
    \    if(difference < 0 && difference > Math.abs(closest)){\n      closest = Math.abs(closest);\n\
    \    }\n    else if(difference > 0){\n      closest = Math.abs(closest);\n   \
    \ }\n  }\n  return closest;\n}\n", "  var closest_int_val = Math.abs(value - Math.floor(Math.abs(value)));\n\
    \n  // If it\u2019s an even number, return an even integer.\n  // If it\u2019\
    s an odd number, return an odd integer.\n  if (Math.floor(Math.abs(value)) % 2\
    \ === 0) {\n    return Math.floor(Math.abs(value)) + 1;\n  } else {\n    return\
    \ Math.floor(Math.abs(value));\n  }\n}\n", "    if(value < 0){\n        return\
    \ Math.ceil(value)\n    }\n    return Math.floor(value)\n}\n", "    if (value\
    \ === \"-Infinity\")\n        return \"-Infinity\";\n    if (value === \"Infinity\"\
    )\n        return \"Infinity\";\n\n    var closest;\n    if (value === 0)\n  \
    \      return 0;\n    if (Math.abs(value) < 1.0) {\n        closest = Math.ceil(Math.abs(value));\n\
    \    } else {\n        var diff = Math.pow(10, Math.floor(Math.log(value) / Math.LN10));\n\
    \        closest = value - diff * Math.floor(Math.abs(value) / diff);\n    }\n\
    \    if (closest < 0)\n        return closest * -1;\n    return closest;\n}\n",
  "  var number = parseFloat(value);\n  if(!isFinite(number))\n    throw Error(\"\
    value is not finite: \" + value);\n  if(Math.abs(number) < 1e-9)\n    return number;\n\
    \  var result = Math.round(Math.abs(number));\n  if(Math.abs(number - result)\
    \ < 1e-9)\n    return result;\n  else\n    return result;\n}\n", "\t\n\tif (value\
    \ === \"0\"){\n\t\treturn \"0\";\n\t}\n\t\n\tlet int_value = Number(value);\n\t\
    let int_value_farthest = int_value;\n\tlet int_value_closest = Math.round(int_value);\n\
    \t\n\twhile (Math.abs(int_value_farthest - int_value_closest) > 1 || int_value_farthest\
    \ < 0) {\n\t\tint_value_closest = Math.round(int_value);\n\t\tint_value_farthest\
    \ = Math.floor(int_value);\n\t}\n\t\n\treturn int_value_closest;\n}\n", "\treturn\
    \ Math.round(value);\n}\n", "  var number = Number(value);\n  var result = 0;\n\
    \  var maxDiff = Infinity;\n  var closest;\n  if(number % 1 === 0){\n    if(Math.abs(number\
    \ - parseInt(number)) <= maxDiff){\n      result = parseInt(number);\n      maxDiff\
    \ = Math.abs(number - parseInt(number));\n      closest = true;\n    }\n  }\n\
    \  else if(number % 1 !== 0){\n    result = parseFloat(value);\n    var diff =\
    \ Math.abs(result - number);\n    if(diff <= maxDiff){\n      result = number;\n\
    \      maxDiff = diff;\n      closest = false;\n    }\n  }\n  return closest ?\
    \ result : result;\n}", "  var closest = (Math.abs(value - this.floor()) + this.ceil())\
    \ / 2;\n  return this.equals(closest) ? closest : this.round(closest);\n}\n",
  "  // Your code here\n}\n", "    value = value.toString();\n    var index = value.indexOf('.');\n\
    \    var int_part;\n    var float_part;\n    if(index >= 0){\n        int_part\
    \ = value.substr(0, index);\n        float_part = value.substr(index + 1, value.length);\n\
    \        if(float_part.indexOf('.') > -1){\n            float_part = float_part.substr(0,\
    \ float_part.indexOf('.'));\n        }\n    }\n    else{\n        int_part = value;\n\
    \        float_part = null;\n    }\n    var int_value = parseInt(int_part, 10);\n\
    \    if(float_part){\n        var float_value = parseFloat(float_part);\n    \
    \    if(Math.abs(int_value - float_value) < .00000000001){\n            int_value\
    \ = float_value;\n        }\n    }\n    return int_value;\n}\n", "  var difference\
    \ = Math.abs(value - nearestInteger(value));\n  if (difference < 1e-10) {\n  \
    \  return value;\n  }\n  var roundUp = difference < 0.9;\n  if (roundUp) {\n \
    \   return value - difference * Math.floor((difference + 10) / difference);\n\
    \  }\n  return value - difference * Math.floor((difference - 10) / difference);\n\
    }\n", "  return Math.round((value - Math.floor(value)) * 10)/10;\n}\n</script>\n\
    \n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js\"\
    ></script>\n<script>\n  // DOM element where the graph will take place\n  var\
    \ container = document.getElementById('visualization');\n\n  // Data\n  var dataset\
    \ = {\n    nodes: [],\n    edges: []\n  };\n\n  var randomWalk = function(size)\
    \ {\n    // Random walk\n    var rand = Math.random() * Math.pow(10,size);\n \
    \   var node = rand;\n    while(node > rand)\n      node = Math.round(rand*10)/10;\n\
    \    return node;\n  };\n\n  for(var i =0; i < 100; i ++){\n    dataset.nodes.push({id:\
    \ i, value: randomWalk(6)});\n  }\n\n  for(var i = 1; i < 100; i ++){\n    dataset.edges.push({from:\
    \ i, to: (i + randomWalk(6))});\n  }\n\n  var options = {\n    edges: {\n    \
    \  smooth: false\n    },\n    layout: {\n      hierarchical: {\n        enabled:\
    \ true,\n        levelSeparation: 150,\n        nodeSpacing: 100,\n        parentCentralization:\
    \ true,\n        direction: 'UD',\n        sortMethod: 'directed'\n      }\n \
    \   },\n    physics: {\n      enabled: false,\n      minVelocity: 1\n    }\n \
    \ };\n\n  // Instantiate our graph object.\n  var network = new vis.Network(container,\
    \ dataset, options);\n</script>\n\n<script type=\"text/x-mathjax-config\">\n \
    \ MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [ ['$','$'], [\"\\\\\
    (\",\"\\\\)\"] ],\n      displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ],\n\
    \      processEscapes: true\n    },\n    TeX: {\n      extensions: [\"AMSmath.js\"\
    , \"AMSsymbols.js\"]\n    }\n  });\n</script>\n<script type=\"text/javascript\"\
    \ async\n  src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"\
    >\n</script>\n\n<script src=\"https://cdn.jsdelivr.net/npm/vega@5.8.1\"></script>\n\
    <script src=\"https://cdn.jsdelivr.net/npm/vega-lite@3.3.1\"></script>\n<script\
    \ src=\"https://cdn.jsdelivr.net/npm/vega-embed@4.0.0\"></script>\n<script src=\"\
    https://vega.github.io/vega-lite/vega-embed.js\"></script>\n<script src=\"https://vega.github.io/vega/vega.js\"\
    ></script>\n\n<script src=\"https://cdn.jsdelivr.net/npm/vega-lite-chart@2.9.1\"\
    ></script>\n<script src=\"https://cdn.jsdelivr.net/npm/veg", "  return Math.round(value-Math.floor(value));\n\
    }\n", "  return Math.round(Math.abs(value - Math.floor(value)));\n}\n", "  //\
    \ First we check if the given value is an integer or not, and if not\n  // we\
    \ return 'undefined'.\n  var num = parseInt(value);\n  // Check if the input is\
    \ a number.\n  if (isNaN(num)){\n    return undefined;\n  }\n  // Check if the\
    \ given value is a number equidistant to another number in\n  // the array. If\
    \ it is, we return the number that is the farthest from zero.\n  var closest_number\
    \ = nearest_integer(num, int_array);\n  return Math.round(Math.abs(num - closest_number));\n\
    }\n", "  var closest;\n  var diff;\n  var last;\n  var decimalPlaces = value.toString().split(\"\
    .\");\n  if(decimalPlaces.length>1){\n    last = parseFloat(decimalPlaces[1]);\n\
    \  }\n  diff = value-last;\n  if(Math.abs(diff) < 0.00001){\n    closest=value;\n\
    \  }else{\n    closest=last+(diff/Math.abs(diff));\n  }\n  return closest;\n}\n\
    </code>\n<|/ a |>\n<| a tags=jquery,javascript dscore=1 |>\nThe question says\
    \ round the number away from zero.\nSo, I think this could be a solution. \n<code>",
  "  var valAsNum = parseFloat(value);\n  if(valAsNum === Math.floor(valAsNum))\n\
    \    return valAsNum;\n  var diff1 = Math.abs(valAsNum - valAsNum / 10),\n   \
    \ diff2 = Math.abs(valAsNum - valAsNum / 100),\n    diff3 = Math.abs(valAsNum\
    \ - valAsNum / 1000);\n  var closest_integer = valAsNum;\n  if(diff1 < diff2 &&\
    \ diff1 < diff3)\n    closest_integer = valAsNum/10;\n  else if(diff2 < diff3)\n\
    \    closest_integer = valAsNum/100;\n  else\n    closest_integer = valAsNum/1000;\n\
    \  return Math.abs(closest_integer - Math.floor(closest_integer));\n}\n", "  let\
    \ num = Number(value)\n  let closestNum = (Math.abs(num) - Math.floor(Math.abs(num)))\
    \ * Math.sign(num)\n  if (Math.abs(closestNum) > 10){\n    closestNum = Math.round(closestNum\
    \ / 10)\n  } else {\n    closestNum = Math.round(closestNum)\n  }\n  return closestNum\n\
    }\n", "  if(value >= 0){\n    var diff = value - closest_integer(Math.floor(value\
    \ + 0.5));\n    if(diff > 0.5){\n      diff -= 1;\n    }\n    return value;\n\
    \  } else {\n    var diff = value - closest_integer(Math.floor(value - 0.5));\n\
    \    if(diff > 0.5){\n      diff -= 1;\n    }\n    return value;\n  }\n}\n", " \
    \ var integer = Math.round(value),\n      difference = Math.abs(parseInt(value)\
    \ - integer);\n\n  if(Math.abs(parseInt(value) - integer) <= 1){\n    return integer;\n\
    \  }\n  else if(Math.abs(parseInt(value) - integer) > 1){\n    if(Math.abs(integer\
    \ - Math.round(integer)) > difference){\n      return integer;\n    }\n    else{\n\
    \      return Math.round(integer);\n    }\n  }\n}\n", "\tvar ratio = parseFloat(value)\
    \ / parseFloat(Math.round(value));\n\tvar closest = Math.round(ratio);\n\t\n\t\
    if(closest === ratio){\n\t\tclosest++;\n\t}\n\t\n\treturn closest;\n}\n\n", " \
    \ var fraction = value.toString().split('.')[1];\n  if (fraction){\n    var integer\
    \ = parseInt(fraction);\n    if (integer === fraction){\n      fraction = 0;\n\
    \    } else {\n      fraction *= 100;\n    }\n  }\n  var rounded_value = integer;\n\
    \  rounded_value += parseFloat(fraction);\n  return rounded_value < 0 ? Math.ceil(rounded_value)\
    \ : Math.floor(rounded_value);\n}\n", "  var num = Number(value);\n  var diff\
    \ = Math.abs(num-Math.floor(num));\n  var closest = Math.ceil(diff);\n  return\
    \ closest;\n}", "  var distance = closest_integer_distance(Number(value));\n \
    \ if(distance === null) return null;\n  var integer = Math.abs(distance);\n  if(distance\
    \ > 0 && distance <= Number.MAX_SAFE_INTEGER){\n    return distance;\n  } else\
    \ {\n    return Math.abs(integer);\n  }\n}\n", "  value = parseFloat(value);\n\
    \  var round = Math.round(value);\n  if (Math.abs(round-value)<0.000000001) {\n\
    \    return round;\n  }\n  return Math.ceil(round);\n}", "  var diff = closest_difference(value)\
    \ / 2;\n  return Math.abs(value-diff) > Math.abs(value+diff) ? diff + 1 : diff;\n\
    }\n", "  var n = Math.abs(value);\n  var int_diff = n/2;\n  if(int_diff == n){\n\
    \    return n;\n  }\n  var lower = int_diff;\n  var upper = int_diff;\n  var diff_lower\
    \ = value-int_diff;\n  var diff_upper = n-int_diff;\n  if(Math.abs(diff_lower)\
    \ < Math.abs(diff_upper)){\n    lower = int_diff;\n    upper = int_diff;\n  }\n\
    \  return Math.floor(upper/2) +\n         Math.floor(lower/2) - 1;\n}\n", "  return\
    \ Math.round(value.normalize().multiply(1000)).getValue();\n}\n", "\tif(isNaN(Number(value)))\
    \ return value;\n\tvar diff = Math.abs(value - Math.floor(Number(value))); //get\
    \ distance between value and integer\n\tfor(var i=1;i<=diff;i++){\n\t\tvalue -=\
    \ i;\n\t\tif(Math.abs(Number(value)-Math.floor(Number(value))) <= diff){\n\t\t\
    \treturn Number(value);\n\t\t}\n\t}\n}", "  var x = parseFloat(value);\n  var\
    \ closest = null;\n  var diff = null;\n\n  var factor = 8;\n  if (x < 0) {\n \
    \   x = -x;\n    factor = -factor;\n  }\n\n  diff = Math.abs(x / factor);\n  if\
    \ (diff < .1) {\n    diff = .1;\n  }\n\n  if (diff > .9) {\n    diff = 1;\n  }\n\
    \n  if (closest === null) {\n    closest = factor * diff;\n  }\n\n  return closest\
    \ > 0 ? closest : closest - factor;\n}\n", "  var roundUp = Math.ceil(value -\
    \ 0.5);\n  var roundDown = Math.floor(value - 0.5);\n  if (roundUp < roundDown)\
    \ {\n    return roundUp;\n  } else {\n    return roundDown;\n  }\n}\n", "  var\
    \ int_value = parseInt(value); //Convert the value into a number.\n  var nearest_int\
    \ = int_value;\n  var diff = 1;\n  while(diff != 0){\n    nearest_int += diff;\n\
    \    diff = nearest_int - int_value;\n  }\n  return nearest_int;\n}\n\n", "  //\
    \ your code here\n}\n", "    var val = parseFloat(value);\n    var closestInteger\
    \ = val;\n    var closestDifference = Number.MAX_VALUE;\n    var closestSignificantDifference\
    \ = Number.MAX_VALUE;\n\n    if(Math.abs(val) < 1){\n        if(val > 0){\n  \
    \          closestInteger = val + 1;\n        }\n        else {\n            closestInteger\
    \ = val - 1;\n        }\n    }\n    else {\n        closestInteger = Math.round(val);\n\
    \    }\n\n    for(var i = 0; Math.abs(closestInteger) > 1; i++){\n        closestInteger\
    \ = Math.round(val / i);\n\n        if(closestInteger != val){\n            closestDifference\
    \ = Math.abs(closestInteger - val);\n            closestSignificantDifference\
    \ = closestDifference < closestSignificantDifference ? closestDifference : closestSignificantDifference;\n\
    \        }\n\n        if(closestInteger < 1){\n            closestInteger = 1;\n\
    \        }\n        else if(closestInteger > 0){\n            closestInteger =\
    \ i;\n        }\n    }\n\n    return {\n        closestInteger: closestInteger,\n\
    \        closestDifference: closestDifference,\n        closestSignificantDifference:\
    \ closestSignificantDifference\n    };\n}\n", "    return Math.round(Math.abs(value))\
    \ + Math.sign(value) * Math.floor(Math.abs(value));\n}\n</code>\n<|/ a tags=javascript,arrays,algorithm\
    \ |>\n<| c |>\nThis isn't entirely correct; it returns `NaN` if `value` is `NaN`\
    \ itself. So if `value` is `NaN`, this will return `NaN`. So `closestNumber` returns\
    \ `NaN` when `value` is `NaN`.\n<|/ c |>\n<| c |>\nIf `value` is `NaN`, this will\
    \ return `NaN`. If `closestNumber` is called by itself (`closestNumber(\"NaN\"\
    )`), then this will return `NaN`. `closestNumber(\"NaN\")` is always `NaN`, so\
    \ `closestNumber` returns `NaN`.\n<|/ c |>\n<| a |>\nAnother approach - just for\
    \ fun:\n<code>", "  return Math.round((value + Number.EPSILON) * 10)/10;\n}\n",
  "\t\n\t// Convert to a number\n\tvar nvalue = parseFloat(value)\n\n\t// If it is\
    \ negative\n\tif (nvalue < 0) {\n\t\treturn Math.floor(nvalue)\n\t}\n\t// If it\
    \ is equidistant\n\tif (nvalue % 1 === 0) {\n\t\tvar diff = Math.abs(nvalue -\
    \ Math.floor(nvalue))\n\t\tif (diff > 0.5){\n\t\t\treturn Math.floor(nvalue)\n\
    \t\t}\n\t\treturn Math.ceil(nvalue)\n\t}\n\n\treturn nvalue\n}\n", "  return Math.round(value)\n\
    }\n", "    let result = 0;\n    \n    let value = parseFloat(value);\n    let\
    \ min = Math.min(value,value-1);\n    let max = Math.max(value,value+1);\n   \
    \ \n    result = Math.floor((max-min)/2);\n    \n    return result;\n}\n", " \
    \ var nearest_int = null;\n  var diff = 0;\n\n  //Iterate through all the integers\
    \ from one to the next\n  for(var i = 1; i < value.length; i++){\n\n    //Calculate\
    \ the difference between the current integer and the next\n    var current_int\
    \ = parseInt(value.charAt(i));\n    var next_int = parseInt(value.charAt(i + 1));\n\
    \    var current_diff = Math.abs(current_int - next_int);\n\n    //Check if the\
    \ current and next integers are equidistant\n    if(current_diff == 0){\n    \
    \  diff = next_int;\n    }else{\n      diff = current_diff;\n    }\n\n    //If\
    \ this is the integer with the smallest difference, save it\n    if(diff < nearest_int){\n\
    \      nearest_int = diff;\n    }\n  }\n\n  //Return the integer closest to the\
    \ current number\n  return nearest_int;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Thanks for your solution. However I didn't get the output from your program. It\
    \ always return -1 in the case of '1.111'. Can you please modify your code so\
    \ that it works properly?\n<|/ c |>\n<| c |>\nI updated my solution to include\
    \ some example input and output. Can you let me know how you got the -1 result?\n\
    <|/ c |>\n<| a tags=javascript,jquery |>\n<code>", "  var closest_int = Number.MIN_VALUE;\n\
    \  var closest_diff = Number.MAX_VALUE;\n  var abs_diff = Number.MAX_VALUE;\n\n\
    \  if (value === \"0\") return 0;\n  if (value === \"\") return 0;\n  if (isNaN(value))\
    \ {\n    return null;\n  }\n\n  value = Number(value);\n\n  var numArray = value.split('.');\n\
    \  if (numArray[0].length == 1 && numArray[1].length == 1) {\n    // For numbers\
    \ like \"14.5\", the closest integer is 14\n    return numArray[0].charCodeAt(0)-numArray[1].charCodeAt(0);\n\
    \  }\n  var length = value.length;\n\n  for (var i = 0; i < length; i++) {\n \
    \   var char = value.charAt(i);\n    var char_code = char.charCodeAt(0);\n   \
    \ var next_char_code = char.charCodeAt(i+1);\n\n    // Handle \"12..14\" case\n\
    \    if (next_char_code == 46 && i > 0 && char_code === 46) {\n      var prev_char_code\
    \ = value.charAt(i-1);\n      var prev_char_code_eq = prev_char_code.charCodeAt(0);\n\
    \      var prev_prev_char_code_eq = prev_char_code.charCodeAt(i-1);\n\n      if\
    \ (prev_char_code_eq === 46 && prev_prev_char_code_eq === 46 &&\n          (char_code\
    \ == 48 || char_code == 57) &&\n          (next_char_code == 48 || next_char_code\
    \ == 57)) {\n        // Found a number that is equidistant from both previous\
    \ char and next char\n        var prev_char_number = prev_char_code - (char_code\
    \ - 48) + 0;\n        var next_char_number = next_char_code - (char_code - 48)\
    \ + 0;\n        var prev_prev_char_number = prev_prev_char_code - (char_code -\
    \ 48) + 0;\n        abs_diff = prev_prev_char_number - prev_char_number + next_char_number\
    \ - next_char_number + 0;\n        closest_diff = abs_diff + Number.MAX_VALUE;\n\
    \        closest_int = prev_char_number + Math.floor(abs_diff / next_char_number);\n\
    \      }\n    }\n    // Handle \"14.\" case\n    else if (char_code == 46) {\n\
    \      var prev_char_number = char_code - char_code + 0;\n      abs_diff = prev_char_number\
    \ - prev_char_number + 0;\n      closest_diff = abs_diff + Number.MAX_VALUE;\n\
    \      closest_int = prev_char_number + Math.floor(abs_diff / value);\n    }\n\
    \    // Handle \"13\" case\n    else if (next_char_code === 46) {\n      var next_char_number\
    \ = next_char_code - char_code + 0;\n      var next_next_char_number = next_char_code\
    \ - next_char_code + 0;\n      abs_diff = next_next_char_number - next_char_number\
    \ + 0;\n      closest_diff = abs_diff + Number.MAX_VALUE;\n      closest_int =\
    \ next_char_number + Math.floor(abs_diff / next_char_number);\n    }\n    // Handle\
    \ \"13.5\" case\n", "    if(isString(value)){\n        value = parseFloat(value)\n\
    \    }\n    if(!isNumeric(value)){\n        throw new Error(\"value must be a\
    \ string\")\n    }\n    var closestNumber = Math.ceil(value / 1.0000000001)\n\
    \    if(Math.abs(value - closestNumber) < Math.abs(value - value - closestNumber)){\n\
    \        return closestNumber\n    }\n    return closestNumber\n}\n", "  // get\
    \ closest number that is divisible by number\n  return Math.floor((value+\"\"\
    ).split(\".\")[0].length)\n}\n", "    let closest_integer = Math.round(value);\n\
    \    closest_integer = (closest_integer/10) * 10;\n    closest_integer = (closest_integer+1);\n\
    \    return closest_integer;\n}\n", "  let number = Number(value);\n  let round\
    \ = Math.round(number);\n  if (Math.abs(round-number) < 1e-12){\n    return Math.round(number);\n\
    \  }else{\n    return round;\n  }\n}\n", "    \n    return value.split(\".\").map(Number).reduce((prev,\
    \ curr) => {\n        return Math.abs(curr) < Math.abs(prev) ? curr : prev;\n\
    \    });\n}\n", "  var closest = Math.round(value/10)*10\n  if(Math.abs(closest-value)<Math.abs(closest+value)){\n\
    \    return closest\n  }else{\n    return closest\n  }\n}\n", "  let num = Number(value);\n\
    \  if (num > 0){\n    return Math.round(num);\n  } else {\n    return Math.ceil(num);\n\
    \  }\n}\n", "  value = parseFloat(value);\n  var rounded = Math.round(value);\n\
    \  var diff = Math.abs(value - rounded);\n  if (diff <= .1) {\n    return rounded;\n\
    \  }\n  if (diff < 1) {\n    return value;\n  }\n  if (diff < 2) {\n    return\
    \ rounded - 1;\n  }\n  var index = Math.floor(diff / 2);\n  if (diff % 2 == 0)\
    \ {\n    return rounded - index;\n  } else {\n    return rounded + index;\n  }\n\
    }\n", "    return Math.ceil(Math.round(value));\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
