name: HumanEval_136_largest_smallest_integers
language: js
prompt: "//Create a function that returns a tuple (a, b), where 'a' is\n// the largest\
  \ of negative integers, and 'b' is the smallest\n// of positive integers in a list.\n\
  // If there is no negative or positive integers, return them as None.\n// Examples:\n\
  // largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n// largest_smallest_integers([])\
  \ == (None, None)\n// largest_smallest_integers([0]) == (None, None)\nfunction largest_smallest_integers(lst){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = largest_smallest_integers;\n  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7]),[undefined,\
  \ 1]);\n  assert.deepEqual(candidate([2, 4, 1, 3, 5, 7, 0]),[undefined, 1]);\n \
  \ assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2, 1]);\n  assert.deepEqual(candidate([4,\
  \ 5, 3, 6, 2, 7, -7]),[-7, 2]);\n  assert.deepEqual(candidate([7, 3, 8, 4, 9, 2,\
  \ 5, -9]),[-9, 2]);\n  assert.deepEqual(candidate([]),[undefined, undefined]);\n\
  \  assert.deepEqual(candidate([0]),[undefined, undefined]);\n  assert.deepEqual(candidate([-1,\
  \ -3, -5, -6]),[-1, undefined]);\n  assert.deepEqual(candidate([-1, -3, -5, -6,\
  \ 0]),[-1, undefined]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3,\
  \ 1]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);\n}\n\n\
  test();"
completions: ["    if(lst.sort){\n        lst = lst.sort();\n        if(lst[0] < 0){\n\
    \            return [lst[0], lst[lst.length-1]];\n        }\n        if(lst[0]\
    \ > 0){\n            return [lst[lst.length-1], lst[0]];\n        }\n    }\n \
    \   let largest = -1;\n    let smallest = 100;\n    for(let i = 0; i < lst.length;\
    \ i++){\n        const curr = lst[i];\n        if(curr < smallest){\n        \
    \    smallest = curr;\n        }\n        if(curr > largest){\n            largest\
    \ = curr;\n        }\n    }\n    return [largest, smallest];\n}\n", "  //Find\
    \ min and max of list\n  let min1 = Number.MAX_SAFE_INTEGER;\n  let max1 = Number.MIN_SAFE_INTEGER;\n\
    \  for (let i = 0; i < lst.length; i++){\n    if(lst[i] < min1) min1 = lst[i];\n\
    \    if(lst[i] > max1) max1 = lst[i];\n  }\n  let min2 = Number.MAX_SAFE_INTEGER;\n\
    \  let max2 = Number.MIN_SAFE_INTEGER;\n  for (let j = 0; j < lst.length; j++){\n\
    \    if(lst[j] < min2) min2 = lst[j];\n    if(lst[j] > max2) max2 = lst[j];\n\
    \  }\n  // Return the largest/smallest of the 2 values\n  return (min1 > max2)\
    \ ? [min1, max1] : [max1, min1];\n}\n", "\tvar largest_val = undefined;\n\tvar\
    \ smallest_val = undefined;\n\tfor(var i = 0; i < lst.length; i++){\n\t\tvar n\
    \ = lst[i];\n\t\tif(n < 0 && (smallest_val === undefined || n < smallest_val))\n\
    \t\t\tsmallest_val = n;\n\t\tif(n >= 0 && (largest_val === undefined || n >= largest_val))\n\
    \t\t\tlargest_val = n;\n\t}\n\treturn (largest_val, smallest_val);\n}\n", "  let\
    \ smallest = null;\n  let largest = null;\n  for (let i = 0; i< lst.length; i++)\
    \ {\n    if (smallest == null || lst.slice(i,i+1).reduce((acc, elem)=>acc+elem,\
    \ 0) > smallest) {\n      smallest = lst.slice(i,i+1).reduce((acc, elem)=>acc+elem,\
    \ 0);\n    }\n    if (largest == null || lst.slice(i,i+1).reduce((acc, elem)=>acc+elem,\
    \ 0) < largest) {\n      largest = lst.slice(i,i+1).reduce((acc, elem)=>acc+elem,\
    \ 0);\n    }\n  }\n  return [largest, smallest];\n}\n", "  var large, small, i,\
    \ results;\n  results = [];\n  for (i in lst) {\n    if(lst[i] < 0){\n      large\
    \ = i;\n    } else if(lst[i] > 0) {\n      small = i;\n    } else {\n      results.push(null);\n\
    \    }\n  }\n  return results;\n}\n", "    var largest = -Infinity;\n    var smallest\
    \ = Infinity;\n    var l = lst.length;\n    var result = [None, None];\n    for(var\
    \ i = 0; i < l; i++){\n        if (lst[i] > largest) {\n            largest =\
    \ lst[i];\n        }\n        else if (largest > smallest && lst[i] < smallest)\
    \ {\n            smallest = lst[i];\n        }\n        else if((lst[i] < smallest)\
    \ && (largest < -Infinity)){\n            result = [smallest, largest];\n    \
    \        smallest = Infinity;\n            largest = -Infinity;\n        }\n \
    \   }\n    if (largest > smallest && lst.length > 0) {\n        result = [smallest,\
    \ largest];\n    }\n    return result;\n}\n", "  let positive = 0;\n  let negative\
    \ = 0;\n  let largest = lst[0]\n  let smallest = lst[0]\n  for(let i = 0; i <\
    \ lst.length; i++){\n    let current = lst[i]\n    if(current > largest){\n  \
    \    largest = current\n    } else if(current < smallest){\n      smallest = current\n\
    \    } else if(current < 0 && current > largest){\n      largest =  current *\
    \ -1\n    }\n  }\n  return largest, smallest\n}\n", "    if (lst === null || lst.length\
    \ <= 1){\n        return [None, None];\n    }\n    // Check if the first number\
    \ is negative, positive, or zero\n    var negative = false;\n    var positive\
    \ = false;\n    var zero = false;\n    var firstNumber = lst[0];\n    for (var\
    \ i = 1; i < lst.length; i++){\n        if (lst[i] > firstNumber){\n         \
    \   firstNumber = lst[i];\n            if (firstNumber < 0){\n               \
    \ negative = true;\n            } else if (firstNumber > 0){\n               \
    \ positive = true;\n            } else {\n                zero = true;\n     \
    \       }\n        }\n    }\n    // Return the first number in the list if it\
    \ was negative, positive, or zero\n    return [negative, positive, zero, firstNumber];\n\
    }\n", "  var result = []\n  for(var i=0; i<lst.length; i++){\n    if(lst[i]<0){\n\
    \      result.push([0, lst[i]])\n    }else if(lst[i]>0){\n      result.push([lst[i],\
    \ 0])\n    }\n  }\n  if(result.length==0){\n    return [None, None]\n  }\n  var\
    \ tuple = result[0]\n  for(var i=1; i<result.length; i++){\n    tuple = [Math.max(tuple[0],\
    \ result[i][0]), Math.min(tuple[1], result[i][1])]\n  }\n  return tuple\n}", " \
    \ let n = lst.length\n  let positives = []\n  let negatives = []\n  for (let i\
    \ = 0; i < n; i++){\n    if (lst[i] > 0){\n      positives.push(lst[i])\n    }\n\
    \    else if (lst[i] < 0){\n      negatives.push(lst[i])\n    }\n    else {\n\
    \      continue\n    }\n  }\n  if (positives.length == 0){\n    return (None,\
    \ None)\n  }\n  if (negatives.length == 0){\n    return (positives[0], None)\n\
    \  }\n  return largest_smallest_integer(positives) + largest_smallest_integer(negatives)\n\
    }\n", "  var largest = Number.MIN_VALUE\n  var smallest = Number.MAX_VALUE\n \
    \ var none = undefined\n  for(var i = 0, len = lst.length; i < len; i++){\n  \
    \  var el = lst[i]\n    if(el < smallest || smallest === none){\n      smallest\
    \ = el\n    } else if(el > largest || largest === none){\n      largest = el\n\
    \    }\n  }\n  return largest === none ? null : [largest, smallest]\n}\n\n", " \
    \ var largest = Number.POSITIVE_INFINITY;\n  var smallest = Number.NEGATIVE_INFINITY;\n\
    \  for (var i = 0; i<lst.length; i++){\n    var num = lst[i];\n    if(num < smallest)\n\
    \      smallest = num;\n    if (num > largest)\n      largest = num;\n  }\n  return\
    \ (largest < Number.NEGATIVE_INFINITY)? null : largest;\n}", "  let max = -Infinity;\n\
    \  let min = Infinity;\n  lst.forEach(function(v){\n    if(v > max) max = v;\n\
    \    if(v < min) min = v;\n  });\n  if(min === Infinity) return [None, None, None];\n\
    \  return [max, min, None];\n}\n", "  for(let i = lst.length - 1; i >= 0; i--){\n\
    \    if(lst[i] < 0){\n      return (None, None)\n    }\n  }\n  for(let i = 0;\
    \ i < lst.length; i++){\n    if(lst[i] > 0){\n      return (lst[i], None)\n  \
    \  }\n  }\n  return (None, None)\n}\n", "  let negative_int_list = [];\n  let\
    \ positive_int_list = [];\n  for(let i = lst.length - 1; i >= 0; i--){\n    if(lst[i]\
    \ < 0){\n      negative_int_list.unshift(lst[i]);\n    }else{\n      positive_int_list.unshift(lst[i]);\n\
    \    }\n  }\n  let max_negative = largest_integer(negative_int_list);\n  let min_positive\
    \ = largest_integer(positive_int_list);\n  if(max_negative === undefined){\n \
    \   return [None, None];\n  }else if(min_positive === undefined){\n    return\
    \ [None, max_negative];\n  }else{\n    return [max_negative, min_positive];\n\
    \  }\n}\n", "  const largest = largest_integer(lst);\n  const smallest = smallest_integer(lst);\n\
    \  return [largest, smallest];\n}\n", "    let biggest = undefined;\n    let smallest\
    \ = undefined;\n    for(let i = lst.length-1; i >= 0; i--){\n        if(lst[i]\
    \ >= 0){\n            smallest = lst[i];\n            break;\n        }\n    \
    \    else if(biggest == undefined && lst[i] < 0){\n            biggest = lst[i];\n\
    \        }\n        else if(biggest === undefined && lst[i] > 0){\n          \
    \  biggest = lst[i];\n        }\n    }\n    return biggest !== undefined && smallest\
    \ !== undefined ? [biggest, smallest] : [biggest, null];\n}\n", "\tlst.sort(function(a,\
    \ b){return b - a});\n\twhile(lst.length > 0){\n\t\tvar x = lst[0];\n\t\tfor(var\
    \ i = 1; i < lst.length; i++){\n\t\t\tif(lst[i] < x){\n\t\t\t\tx = lst[i];\n\t\
    \t\t}\n\t\t}\n\t\tif(x !== undefined){\n\t\t\tbreak;\n\t\t}\n\t\tlst.shift();\n\
    \t}\n\treturn [x, lst.length];\n}", "  if (lst.length == 0) {\n    return (None,\
    \ None)\n  }\n\n  var lowest_int = lst[0]\n  var highest_int = lst[0]\n  for (var\
    \ i = 0; i < lst.length; i++) {\n    if (lst[i] < lowest_int) {\n      lowest_int\
    \ = lst[i]\n    } else if (lst[i] > highest_int) {\n      highest_int = lst[i]\n\
    \    }\n  }\n  return (lowest_int, highest_int)\n}\n", "  if (lst.length === 0)\
    \ {\n    return (None, None)\n  }\n\n  var largest = Number.NEGATIVE_INFINITY;\n\
    \  var smallest = Number.POSITIVE_INFINITY;\n\n  for (var num of lst) {\n    if\
    \ (num < smallest) {\n      smallest = num;\n    } else if (num > largest) {\n\
    \      largest = num;\n    }\n  }\n\n  return (largest, smallest)\n}\n", "\tif\
    \ (lst.some(x => x < 0)) return {a:0, b:0};\n\tif (lst.some(x => x > 0)) return\
    \ {a:lst.map(x => Math.max(x,0)).filter(x => !isNaN(x)).map(x => -x)[0], b:lst.map(x\
    \ => Math.min(x,0)).filter(x => !isNaN(x)).map(x => -x)[0]};\n\treturn null;\n\
    }\n", "  if(lst.length < 2){\n    return {\n      first: lst[0],\n      second:\
    \ lst[0]\n    };\n  }\n  if(lst.length == 2){\n    return {\n      first: lst[0],\n\
    \      second: lst[1]\n    };\n  }\n\n  // Find the largest negative integer that\
    \ occurs in the list\n  var max_neg = -Infinity;\n  var max_index = -1;\n  for(var\
    \ i = 0; i < lst.length; i++){\n    if(lst[i] < 0){\n      if(max_neg < 0){\n\
    \        max_neg = -Infinity;\n      }\n      max_neg = -(max_neg < lst[i]) ?\
    \ -max_neg : lst[i];\n      max_index = i;\n    }else if(max_neg > lst[i]){\n\
    \      max_neg = lst[i];\n    }\n  }\n\n  // Find the smallest positive integer\
    \ that occurs in the list\n  var min_pos = +Infinity;\n  var min_index = -1;\n\
    \  for(var i = 0; i < lst.length; i++){\n    if(lst[i] > 0){\n      if(min_pos\
    \ > +Infinity){\n        min_pos = +Infinity;\n      }\n      min_pos = +(min_pos\
    \ > lst[i]) ? min_pos : lst[i];\n      min_index = i;\n    }else if(min_pos <\
    \ lst[i]){\n      min_pos = lst[i];\n    }\n  }\n\n  // Return the largest and\
    \ smallest values\n  return {\n    first: lst[max_index],\n    second: lst[min_index]\n\
    \  };\n}\n", "  var max_min = [];\n  var smallest = Number.MAX_SAFE_INTEGER;\n\
    \  var largest = -Number.MAX_SAFE_INTEGER;\n\n  for (var i = 0; i < lst.length;\
    \ i++){\n    if(lst[i] < smallest){\n      smallest = lst[i];\n    }\n    if(lst[i]\
    \ > largest){\n      largest = lst[i];\n    }\n  }\n  if(smallest >= 0){\n   \
    \ max_min = [smallest, largest];\n  }\n  return max_min;\n}\n", "  if (lst.length\
    \ < 2) return null\n  let min_int = null\n  let max_int = null\n  for (let i=0;i<lst.length;i++){\n\
    \    if (lst[i] < min_int) min_int = lst[i]\n    if (lst[i] > max_int) max_int\
    \ = lst[i]\n  }\n  return [max_int,min_int]\n}\n", "  if (lst.length == 0) return\
    \ (None, None)\n  var smallest = lst[0]\n  var largest = lst[0]\n  for (var i\
    \ = 1; i < lst.length; i++) {\n    if (smallest[1] > lst[i][1]) smallest = (lst[i],\
    \ lst[i][1])\n    else if (smallest[1] < lst[i][1]) largest = (lst[i], lst[i][1])\n\
    \  }\n  return (smallest, largest)\n}\n", "    // Write code here\n    var max;\n\
    \    var min;\n    if (lst.length < 2){\n        max = null;\n        min = null;\n\
    \    }else{\n        max = 0;\n        min = lst[0];\n        for (var i = 1;\
    \ i < lst.length; i++){\n            if (lst[i] < min){\n                min =\
    \ lst[i];\n            }\n            if (lst[i] > max){\n                max\
    \ = lst[i];\n            }\n        }\n    }\n    return([max, min]);\n}\n", " \
    \ var large = Number.NEGATIVE_INFINITY;\n  var small = Number.POSITIVE_INFINITY;\n\
    \  for (var i = 0; i < lst.length; i++){\n    if (lst[i] < small){\n      small\
    \ = lst[i];\n    }\n    if (lst[i] > large){\n      large = lst[i];\n    }\n \
    \ }\n  return [large, small];\n}\n", "  var largest = Number.NEGATIVE_INFINITY;\n\
    \  var smallest = Number.POSITIVE_INFINITY;\n  for(var i = 0; i < lst.length;\
    \ i++){\n    if(lst[i] > largest)\n      largest = lst[i];\n    if(lst[i] < smallest)\n\
    \      smallest = lst[i];\n  }\n  return [largest, smallest];\n}\n", "    var\
    \ is_negative = [];\n    var smallest_integer = null;\n    var largest_integer\
    \ = null;\n\n    for (var i of lst){\n        is_negative.push( i < 0 );\n   \
    \     smallest_integer = is_negative[0]?i:0;\n        largest_integer = is_negative[is_negative.length-1]?i:0;\n\
    \    }\n\n    return {\n        smallest_integer : smallest_integer,\n       \
    \ largest_integer : largest_integer\n    };\n}\n", "  if (lst.length == 0){\n\
    \    return (null, null);\n  }\n  var neg_ind = lst.filter(function(val){return\
    \ val < 0;}).length;\n  var pos_ind = lst.filter(function(val){return val > 0;}).length;\n\
    \  if (neg_ind == 0){\n    return (null, lst[0]);\n  }\n  if (pos_ind == 0){\n\
    \    return (null, null);\n  }\n  var val1 = lst.filter(function(val){return val\
    \ < 0;})[neg_ind-1];\n  var val2 = lst.filter(function(val){return val > 0;})[0];\n\
    \  return (val1, val2);\n}\n", "  var largest = undefined;\n  var smallest = undefined;\n\
    \  for(var i = 0; i < lst.length; i++){\n    if(!smallest){\n      smallest =\
    \ lst[i];\n    } else if(smallest > lst[i]){\n      smallest = lst[i];\n    }\n\
    \  }\n  if(!smallest && !largest){\n    return undefined;\n  }\n  if(smallest\
    \ != undefined && smallest > largest){\n    return smallest;\n  } else if(smallest\
    \ != undefined && largest < smallest){\n    return largest;\n  } else {\n    return\
    \ undefined;\n  }\n}\n", "    \n    var smallest = null;\n    var largest = null;\n\
    \    var max_positive = 0;\n    var min_negative = 0;\n    \n    for (var i =\
    \ 0; i < lst.length; i++){\n        if (lst[i] > 0){\n            if (smallest\
    \ == null || lst[i] < smallest){\n                smallest = lst[i];\n       \
    \     }\n            if (largest == null || lst[i] > largest){\n             \
    \   largest = lst[i];\n            }\n        }\n        if (lst[i] < 0){\n  \
    \          if (smallest == null || lst[i] > largest){\n                smallest\
    \ = lst[i];\n            }\n            if (largest == null || lst[i] < smallest){\n\
    \                largest = lst[i];\n            }\n        }\n    }\n    if (smallest\
    \ == null && largest == null){\n        return [null, null];\n    }\n    return\
    \ [smallest, largest];\n}\n", "    if (lst.length === 0) {\n        return [\"\
    None\", \"None\"];\n    } else if (lst.includes(0)){\n        return [\"None\"\
    , \"None\"];\n    } else if (lst.includes(-1)) {\n        return [-1, lst.indexOf(0)];\n\
    \    }\n    const sorted_list = lst.sort((a,b) => b-a);\n    const smallest =\
    \ sorted_list[0];\n    const largest = sorted_list.pop();\n    return [smallest,\
    \ largest];\n}\n", "  // Create a function that returns a tuple (a, b), where\
    \ 'a' is\n  // the largest of negative integers, and 'b' is the smallest\n  //\
    \ of positive integers in a list.\n  // If there is no negative or positive integers,\
    \ return them as None.\n  // Examples:\n  // largest_smallest_integers([2, 4,\
    \ 1, 3, 5, 7]) == (None, 1)\n  // largest_smallest_integers([]) == (None, None)\n\
    \  // largest_smallest_integers([0]) == (None, None)\n  var largest = undefined;\n\
    \  var smallest = undefined;\n\n  // Check all elements in the list.\n  lst.forEach(function(number)\
    \ {\n    // If the number is negative, make it positive.\n    if (number < 0)\
    \ {\n      number = Math.abs(number);\n    }\n\n    // If the largest is undefined,\
    \ make it the new largest.\n    if (largest === undefined) {\n      largest =\
    \ number;\n    }\n\n    // If the smallest is undefined, make it the new smallest.\n\
    \    if (smallest === undefined) {\n      smallest = number;\n    }\n\n    //\
    \ If the largest is larger than the smallest, make it the new largest.\n    if\
    \ (number > largest) {\n      largest = number;\n    }\n\n    // If the smallest\
    \ is smaller than the largest, make it the new smallest.\n    if (number < smallest)\
    \ {\n      smallest = number;\n    }\n  });\n\n  // Return the tuple (largest,\
    \ smallest)\n  return [largest, smallest];\n}\n", "  for (let i = 0; i < lst.length;\
    \ i++){\n    if (lst[i] < 0){\n      return (lst[i], i); //return tuple (a, b)\n\
    \    } else if (lst[i] > 0){\n      return (lst[i], i); //return tuple (a, b)\n\
    \    }\n  }\n  return null; //if all numbers are the same, return None\n}\n",
  "  let max = null;\n  let min = null;\n  for (let i = 0; i < lst.length; i++){\n\
    \    if (max === null && min === null){\n      max = lst[i];\n      min = lst[i];\n\
    \    } else if (max === null){\n      max = lst[i];\n    } else if (min === null){\n\
    \      min = lst[i];\n    } else if (max < lst[i]){\n      max = lst[i];\n   \
    \ } else if (min > lst[i]){\n      min = lst[i];\n    }\n  }\n  return [max, min];\n\
    }\n", "    let min = 0;\n    let max = lst.length - 1;\n    let positiveInteger\
    \ = null;\n    \n    while (max >= min){\n        let mid = Math.floor((min +\
    \ max)/2);\n        \n        if (mid >= 0 && lst[mid] >= 0){\n            max\
    \ = mid;\n            positiveInteger = lst[mid];\n        }\n        else if\
    \ (mid < 0 && lst[mid] < 0){\n            min = mid + 1;\n        }\n    }\n\n\
    \    return positiveInteger;\n}\n", "  var largest = Math.max.apply(Math, lst);\n\
    \  var smallest = Math.min.apply(Math, lst);\n  return [largest >= 0 ? largest\
    \ : null, smallest != null ? smallest : null];\n}\n", "    // Write your code\
    \ here.\n    let max_idx = 0;\n    let min_idx = lst.length - 1;\n    while (max_idx\
    \ < min_idx){\n        if (lst[max_idx] < lst[min_idx]){\n            max_idx++;\n\
    \        } else if (lst[max_idx] > lst[min_idx]){\n            min_idx--;\n  \
    \      } else {\n            max_idx++;\n            min_idx--;\n        }\n \
    \   }\n    return [lst[max_idx], lst[min_idx]];\n}\n", "  if(lst.length < 2) return\
    \ null;\n  var largest = lst[0];\n  var smallest = lst[0];\n  for(var i = 1; i\
    \ < lst.length; i++){\n    if(lst[i] > largest){\n      largest = lst[i];\n  \
    \  }\n    if(lst[i] < smallest){\n      smallest = lst[i];\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  let max_ints = lst.reduce((acc, val) => {\n \
    \   if (val < 0)\n      return acc;\n    else if (val > acc)\n      return val;\n\
    \    else\n      return acc;\n  }, Number.MAX_SAFE_INTEGER);\n  let min_ints =\
    \ lst.reduce((acc, val) => {\n    if (val > 0)\n      return acc;\n    else if\
    \ (val < acc)\n      return val;\n    else\n      return acc;\n  }, Number.MIN_SAFE_INTEGER);\n\
    \  return max_ints < min_ints ? None : (max_ints, min_ints);\n}\n</cell>\n<text>\n\
    Problem 2\nUse a dictionary to store the numbers 0-999 in groups of three. After\
    \ the dictionary is created, print the value of the smallest positive number in\
    \ the dictionary and store it in a variable named smallest_pos.\n\n\n</text>\n\
    <cell>", "  if (!lst) return (None, None);\n  if(lst.length == 0)\n    return\
    \ (None, None)\n  min = lst[0];\n  max = lst[0];\n  for (let i = 0; i < lst.length;\
    \ i++){\n    if (lst[i] > max){\n      max = lst[i];\n    }\n    if (lst[i] <\
    \ min){\n      min = lst[i];\n    }\n  }\n  return (max, min);\n}\n", "  let max=0;\n\
    \  let min=99999;\n  for(let i=0;i<lst.length;i++){\n    if(lst[i]<min) min=lst[i];\n\
    \    if(lst[i]>max) max=lst[i];\n  }\n  return [max,min];\n}", "    var smallest\
    \ = lst[0];\n    var largest = lst[0];\n    for (var i = 1; i < lst.length; i++){\n\
    \        var x = lst[i];\n        if (x > largest){\n            largest = x;\n\
    \        } else if (x < smallest) {\n            smallest = x;\n        }\n  \
    \  }\n    return {'smallest': smallest, 'largest': largest};\n}\n", "    let max_neg\
    \ = 0;\n    let min_pos = 0;\n    let max_neg_integers = [];\n    let min_pos_integers\
    \ = [];\n    for(var i = 0; i < lst.length; i++){\n        if(lst[i] < 0){\n \
    \           max_neg_integers.push(lst[i]);\n            if(max_neg >= 0){\n  \
    \              max_neg = lst[i];\n            }\n        } else {\n          \
    \  min_pos_integers.push(lst[i]);\n            if(min_pos <= 0){\n           \
    \     min_pos = lst[i];\n            }\n        }\n    }\n    return max_neg,\
    \ min_pos, max_neg_integers, min_pos_integers;\n}\n", "  var min_val = Number.MAX_VALUE;\n\
    \  var max_val = Number.MIN_VALUE;\n  for(var x = 0; x < lst.length; x++){\n \
    \   var val = lst[x];\n    if(val < min_val){\n      min_val = val;\n    } else\
    \ if(val > max_val){\n      max_val = val;\n    }\n  }\n  if(min_val > Number.MAX_VALUE){\n\
    \    return (0, Number.MAX_VALUE);\n  } else if(max_val < Number.MIN_VALUE){\n\
    \    return (0, Number.MIN_VALUE);\n  } else {\n    return (min_val, max_val);\n\
    \  }\n}\n", "    for(var i=0; i<lst.length; i++){\n        if(lst[i] < 0){\n \
    \           smallest = lst[i];\n        }else if(lst[i] > 0){\n            largest\
    \ = lst[i];\n        }\n    }\n    if(smallest == undefined){\n        return\
    \ null;\n    }\n    if(largest == undefined){\n        return smallest;\n    }\n\
    \    return [smallest, largest];\n}\n", "  let smallest = Number.MAX_SAFE_INTEGER;\n\
    \  let largest = -Number.MAX_SAFE_INTEGER;\n  for(let i of lst){\n    if(i < smallest\
    \ || i == smallest){\n      smallest = i;\n    }\n    if(i > largest || i == largest){\n\
    \      largest = i;\n    }\n  }\n  return [smallest, largest];\n}\n", "    var\
    \ largest_i = null;\n    var smallest_i = null;\n    for(var i=0; i<lst.length;\
    \ i++){\n        if(lst[i] < 0){\n            if(smallest_i == null){\n      \
    \          smallest_i = i;\n            }else{\n                //If smallest_i\
    \ is None, then lst[i] is the smallest.\n                //Set smallest to lst[i].\n\
    \                smallest_i = i;\n            }\n        }else{\n            if(largest_i\
    \ == null){\n                largest_i = i;\n            }else{\n            \
    \    //If largest_i is None, then lst[i] is the largest.\n                //Set\
    \ largest to lst[i].\n                largest_i = i;\n            }\n        }\n\
    \    }\n    if (largest_i != null && smallest_i != null){\n        return (lst[largest_i],\
    \ lst[smallest_i]);\n    }else{\n        return (null, null);\n    }\n}\n", " \
    \ const negative = lst.filter(n => n < 0);\n  const positive = lst.filter(n =>\
    \ n > 0);\n  if (negative.length > 0 && positive.length > 0) {\n    const a =\
    \ negative.reduce((a, b) => Math.max(a, b), -Infinity);\n    const b = positive.reduce((a,\
    \ b) => Math.min(a, b), Infinity);\n    return [a, b];\n  } else {\n    return\
    \ [];\n  }\n}\n*/\nconst largest_smallest_integers = arr => {\n  if (!arr || !arr.length)\
    \ {\n    return null;\n  }\n  const [a, b] = largest_smallest_integers_helper(arr);\n\
    \  return [a, b];\n};", "    if(lst.length <= 0) return (None, None)\n    if(lst[0]\
    \ < 0) return (None,lst[0])\n    if(lst[lst.length - 1] < 0) return (lst[0],None)\n\
    \    let max_idx = lst.length - 1\n    let min_idx = 0\n    let largest = None\n\
    \    let smallest = None\n    for(let i = 0; i <= lst.length; i++){\n        if(lst[i]\
    \ > lst[max_idx]){\n            max_idx = i\n        }\n        if(lst[i] < lst[min_idx]){\n\
    \            min_idx = i\n        }\n        if(largest == None){\n          \
    \  largest = lst[i]\n        }else if(largest < lst[i]){\n            largest\
    \ = lst[i]\n        }\n        if(smallest == None){\n            smallest = lst[i]\n\
    \        }else if(smallest > lst[i]){\n            smallest = lst[i]\n       \
    \ }\n    }\n    return (largest, smallest)\n}", "  var max_val = 0;\n  var min_val\
    \ = 9999999999;\n  for(var i = 0; i < lst.length; i++){\n    if(lst[i] < min_val){\n\
    \      min_val = lst[i];\n    }\n    if(lst[i] > max_val){\n      max_val = lst[i];\n\
    \    }\n  }\n  if(max_val < min_val){\n    return (None, None);\n  }else{\n  \
    \  return (max_val, min_val);\n  }\n}\n", "  return lst.filter((x) => x < 0 ||\
    \ (x > 0 && lst.indexOf(x) == lst.lastIndexOf(x)))\n}\n", "  if(lst.length < 2)\n\
    \      return (None, None)\n  var max = 0,\n      min = 0,\n      curr = lst[0],\n\
    \      last = -Infinity\n  for(var i = 1; i < lst.length; i++){\n    var next\
    \ = lst[i]\n    if(curr > next)\n      last = curr;\n    else\n      last = next;\n\
    \    if(max < last)\n      max = last;\n    if(min > last)\n      min = last;\n\
    \    curr = next;\n  }\n  return (max, min);\n}\n", "  if (lst.filter(function(n){\n\
    \    return n < 0\n  }).length == 0){\n    return ('', None)\n  }\n  if (lst.filter(function(n){\n\
    \    return n > 0\n  }).length == 0){\n    return ('', None)\n  }\n  var maxnum\
    \ = lst.filter(function(n){\n    return n > 0\n  }).sort((a,b) => a-b).shift()\n\
    \  var minnum = lst.filter(function(n){\n    return n < 0\n  }).sort((a,b) =>\
    \ b-a).shift()\n  return (maxnum, minnum)\n}\n", "  let max_negative = -1;\n \
    \ let min_positive = 1;\n\n  lst.forEach((el) => {\n    if(el <= 0){\n      if(el\
    \ > max_negative){\n        max_negative = el;\n      }\n    }\n    else if(el\
    \ > 0){\n      if(el < min_positive){\n        min_positive = el;\n      }\n \
    \   }\n  });\n\n  return (max_negative, min_positive);\n}\n", "  let largest =\
    \ null;\n  let smallest = null;\n  lst.sort();\n  let l = lst.length;\n  for(let\
    \ i = 0; i < l; i++){\n    if(smallest == null || smallest > lst[i]){\n      smallest\
    \ = lst[i];\n    }\n    if(largest == null || largest < lst[i]){\n      largest\
    \ = lst[i];\n    }\n  }\n  return [largest, smallest];\n}", "    var largest,\
    \ smallest;\n    largest = smallest = undefined;\n    for(var i = 0, n = lst.length;\
    \ i < n; i++){\n        if (largest === undefined) {\n            if (lst[i] >\
    \ lst[0]) {\n                largest = lst[i];\n            } else {\n       \
    \         smallest = lst[i];\n            }\n        } else if (lst[i] > largest\
    \ ){\n            largest = lst[i];\n        } else if (lst[i] < smallest ){\n\
    \            smallest = lst[i];\n        }\n    }\n    return [largest, smallest];\n\
    }\n", "  var sorted_tuple = lst.sort(function(a, b){return a - b})\n  var highest\
    \ = sorted_tuple.pop()\n  var lowest = sorted_tuple.pop()\n  if (!highest && !lowest){\n\
    \    return null\n  }\n  else if (highest){\n    return (highest, lowest)\n  }\n\
    \  else{\n    return (lowest, highest)\n  }\n}\n", "  var smallest = lst.map(x\
    \ => x > 0 ? x : null);\n  var largest = lst.map(x => x < 0 ? x : null);\n  return\
    \ largest > smallest ? {\n    largest_integer: largest.filter(x => !smallest.includes(x)).pop(),\n\
    \    smallest_integer: smallest.filter(x => !largest.includes(x)).pop()\n  } :\
    \ {\n    largest_integer: null,\n    smallest_integer: null\n  }\n}\n", "    let\
    \ max_neg_in = 0\n    let min_pos_in = 0\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        if (lst[i] > 0){\n            if (max_neg_in<0){\n         \
    \       max_neg_in = lst[i]\n            } else if (max_neg_in>lst[i]){\n    \
    \            max_neg_in = max_neg_in\n            }\n        } else {\n      \
    \      if (min_pos_in<0){\n                min_pos_in = lst[i]\n            }\
    \ else if (min_pos_in>lst[i]){\n                min_pos_in = min_pos_in\n    \
    \        }\n        }\n    }\n    if (max_neg_in == 0) return (None, None)\n \
    \   else if (min_pos_in == 0) return (None, max_neg_in)\n    else return (max_neg_in,\
    \ min_pos_in)\n}", "  // Check our input is valid\n  if (lst == null || lst.length\
    \ == 0) {\n    return (null,null);\n  }\n\n  // Create a variable to hold largest\
    \ and smallest values\n  let max_val = lst[0];\n  let min_val = lst[0];\n\n  //\
    \ Iterate through the list and find the largest and smallest values.\n  for (let\
    \ i = 0; i < lst.length; i++){\n    if (max_val > lst[i]){\n      max_val = lst[i];\n\
    \    }\n    if (min_val < lst[i]){\n      min_val = lst[i];\n    }\n  }\n\n  return\
    \ (max_val,min_val);\n}\n", "\tvar largest = Number.MIN_VALUE;\n\tvar smallest\
    \ = Number.MAX_VALUE;\n\t\n\tfor(var i = 0; i < lst.length; i++){\n\t\tif(lst[i]\
    \ < smallest){\n\t\t\tsmallest = lst[i];\n\t\t}\n\t\tif(lst[i] > largest){\n\t\
    \t\tlargest = lst[i];\n\t\t}\n\t}\n\t\n\tif(smallest == Number.MIN_VALUE && largest\
    \ == Number.MAX_VALUE){\n\t\treturn null;\n\t}\n\telse{\n\t\treturn {\n\t\t\t\
    a: smallest,\n\t\t\tb: largest\n\t\t};\n\t}\n}\n", "\tfor(var i = 0; i < lst.length;\
    \ i++){\n\t\tif(lst[i] < 0){\n\t\t\tif(i > 0){\n\t\t\t\treturn (lst[i - 1],  lst[i]);\n\
    \t\t\t}else{\n\t\t\t\treturn (None, None)\n\t\t\t}\n\t\t}else if(lst[i] > 0){\n\
    \t\t\tif(i < lst.length - 1 ){\n\t\t\t\treturn (lst[i +1], lst[i]);\n\t\t\t}else{\n\
    \t\t\t\treturn (None, None)\n\t\t\t}\n\t\t}\n\t}\n}\n</cell>\n<text>\nTask 3\n\
    The function should return true or false depending on whether the list contains\
    \ only integers from 1 to 5. The list can be of any length and contain only integers\
    \ from 1 to 5. The function must return a Boolean value. That is it will only\
    \ return True if there are no non-integers in the list and False if there are\
    \ any.\n\nExamples:\n\nlargest_smallest_integers([4, 1, 2, 3, 5, 7]) == True\n\
    largest_smallest_integers([4, 1, 2, 3, 5, 7, 4, 3, 2, 1]) == True\nlargest_smallest_integers([4,\
    \ 1, 2, 3, 5, 7, 4, 3, 2, 5, 6]) == False\nlargest_smallest_integers([4, 1, 2,\
    \ 3, 5, 7, 4, 3, 2, 5, 6, 4, 3, 2]) == False\n\n</text>\n<cell>", "  let smallest_negative_integer\
    \ = null;\n  let smallest_positive_integer = null;\n  let largest_negative_integer\
    \ = null;\n  let largest_positive_integer = null;\n\n  for (let index = 0; index\
    \ < lst.length; index++) {\n    if (lst[index] < 0) {\n      if (!smallest_negative_integer\
    \ || smallest_negative_integer > lst[index]) {\n        smallest_negative_integer\
    \ = lst[index];\n      }\n    } else {\n      if (!smallest_positive_integer ||\
    \ smallest_positive_integer < lst[index]) {\n        smallest_positive_integer\
    \ = lst[index];\n      }\n    }\n\n    if (lst[index] < 0) {\n      if (!largest_negative_integer\
    \ || largest_negative_integer < lst[index]) {\n        largest_negative_integer\
    \ = lst[index];\n      }\n    } else {\n      if (!largest_positive_integer ||\
    \ largest_positive_integer > lst[index]) {\n        largest_positive_integer =\
    \ lst[index];\n      }\n    }\n  }\n\n  return smallest_negative_integer && largest_positive_integer\
    \ ?\n    [largest_negative_integer, largest_positive_integer] :\n    [smallest_negative_integer,\
    \ smallest_positive_integer];\n}\n", "  var positive_integers = [];\n  var negative_integers\
    \ = [];\n\n  for(var i = 0; i < lst.length; i++){\n    var current = lst[i];\n\
    \    if(current >= 0){\n      positive_integers.push(current);\n    } else {\n\
    \      negative_integers.push(current);\n    }\n  }\n\n  if(positive_integers.length\
    \ == 0){\n    return (None, None)\n  }\n\n  if(positive_integers.length > 0 &&\
    \ negative_integers.length == 0){\n    return (positive_integers[0], None)\n \
    \ }\n\n  if(negative_integers.length > 0 && positive_integers.length == 0){\n\
    \    return (None, negative_integers[0])\n  }\n\n  if(positive_integers.length\
    \ > 0 && negative_integers.length > 0){\n    var largest_positive = positive_integers.reduce(function(a,\
    \ b){\n      return Math.max(a, b);\n    });\n\n    var largest_negative = negative_integers.reduce(function(a,\
    \ b){\n      return Math.min(a, b);\n    });\n\n    return (largest_positive,\
    \ largest_negative)\n  }\n}\n", "    // sort the list in descending order\n  \
    \  lst = lst.sort((a, b) => b - a);\n    // start with the first integer\n   \
    \ let firstInteger = lst[0];\n    // if there are no integers, return None\n \
    \   if(lst.length === 0) return (null, firstInteger);\n    // initialize an empty\
    \ list for the positive and negative numbers\n    let negatives = [];\n    let\
    \ positives = [];\n    // loop through the list\n    for(let i = 0; i < lst.length;\
    \ i++){\n        if(lst[i] < firstInteger){\n            positives.push(lst[i]);\n\
    \        } else {\n            negatives.push(lst[i]);\n        }\n    }\n   \
    \ // if the length of the negative list is 0, return it\n    if(negatives.length\
    \ === 0) return (null, firstInteger);\n    // otherwise, find the max of the negative\
    \ list\n    let maxOfNegatives = Math.max(...negatives);\n    // return (maxOfNegatives,\
    \ firstInteger)\n    return (maxOfNegatives, firstInteger);\n}\n", "  if(lst.every(function(elem){return\
    \ (elem < 0) == (elem > 0)})){\n    return (null, lst[0]);\n  }\n  let maxIndex\
    \ = lst.findIndex(function(elem){return (elem > 0);});\n  if(maxIndex === -1){\n\
    \    maxIndex = 0;\n  }\n  let minIndex = lst.findIndex(function(elem){return\
    \ (elem < 0);});\n  if(minIndex === -1){\n    minIndex = 0;\n  }\n  return (lst.slice(minIndex,\
    \ maxIndex + 1), \n          lst.slice(maxIndex + 1, minIndex));\n}\n\n", "\t\
    if (lst.constructor === Array) {\n\t\tvar positive = [];\n\t\tvar negative = [];\n\
    \t\tvar positive_count = 0;\n\t\tvar negative_count = 0;\n\t\tvar i;\n\t\tvar\
    \ max = -Infinity;\n\t\tvar min = Infinity;\n\t\tfor (i = 0; i < lst.length; ++i)\
    \ {\n\t\t\tif (lst[i] > 0) {\n\t\t\t\tpositive.push(lst[i]);\n\t\t\t\tpositive_count\
    \ += 1;\n\t\t\t\tif (lst[i] > max) {\n\t\t\t\t\tmax = lst[i];\n\t\t\t\t}\n\t\t\
    \t} else if (lst[i] < 0) {\n\t\t\t\tnegative.push(lst[i]);\n\t\t\t\tnegative_count\
    \ += 1;\n\t\t\t\tif (lst[i] < min) {\n\t\t\t\t\tmin = lst[i];\n\t\t\t\t}\n\t\t\
    \t}\n\t\t}\n\t\tif (positive_count > 0 && negative_count > 0) {\n\t\t\tif (positive_count\
    \ > negative_count) {\n\t\t\t\treturn [max, min];\n\t\t\t} else {\n\t\t\t\treturn\
    \ null;\n\t\t\t}\n\t\t} else {\n\t\t\treturn [max, min];\n\t\t}\n\t} else if (lst.constructor\
    \ === Number) {\n\t\treturn [lst];\n\t}\n}\n", "    let largest = None\n    let\
    \ smallest = None\n    lst.forEach(function(element){\n        if (element < 0){\n\
    \            smallest = element\n        } else if (element > 0){\n          \
    \  largest = element\n        }\n    })\n    return [largest, smallest]\n}\n",
  "  // If there are no integers, return (None, None)\n  if (!lst) return (None, None)\n\
    \n  // Make a list with negative and positive ints sorted from min to max\n  const\
    \ sorted_list = lst.sort((a, b) => a - b)\n  // Get the min and max values\n \
    \ const min_value = sorted_list[0]\n  const max_value = sorted_list[sorted_list.length\
    \ - 1]\n\n  // Return None if the list is empty\n  if (sorted_list.length ===\
    \ 0) return (None, None)\n\n  // Return the minimum and maximum values if the\
    \ list has more than one element\n  if (sorted_list.length > 1) {\n    return\
    \ (min_value, max_value)\n  }\n\n  // If there is only one element, return that\
    \ value\n  return min_value\n}\n", "\tlet largest = 0;\n\tlet smallest = Number.MAX_SAFE_INTEGER;\n\
    \tfor(let item of lst){\n\t\tif(item < smallest || smallest === 0){\n\t\t\tsmallest\
    \ = item;\n\t\t}\n\t\tif(item > largest){\n\t\t\tlargest = item;\n\t\t}\n\t}\n\
    \tif(smallest === Number.MAX_SAFE_INTEGER) return (None, None)\n\treturn (largest,\
    \ smallest)\n}\n", "\tvar largest = -1;\n\tvar smallest = +Infinity;\n\tfor (var\
    \ i=0; i < lst.length; i++){\n\t\tif(lst[i] < smallest){\n\t\t\tsmallest = lst[i]\n\
    \t\t}\n\t\tif(lst[i] > largest){\n\t\t\tlargest = lst[i]\n\t\t}\n\t}\n\treturn\
    \ [largest, smallest];\n}\n", "\tvar smallest;\n\tvar largest;\n\tfor (var i =\
    \ 0; i < lst.length; i++) {\n\t\tvar num = lst[i];\n\t\tif (num < 0) {\n\t\t\t\
    smallest = num;\n\t\t}\n\t\telse {\n\t\t\tlargest = num;\n\t\t}\n\t}\n\treturn\
    \ [smallest, largest];\n}\n", "  let largest = -1;\n  let smallest = 100000000;\n\
    \  for (let num of lst){\n    if (num < smallest){\n      smallest = num;\n  \
    \  }\n    if (num > largest){\n      largest = num;\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  let largest_negative = null;\n  let largest_positive =\
    \ null;\n  lst.forEach((num) => {\n    if (num < 0){\n      largest_negative =\
    \ num;\n    } else if (num > 0){\n      largest_positive = num;\n    }\n  });\n\
    \  return [largest_negative, largest_positive]\n}\n", "    let max = null;\n \
    \   let min = null;\n    lst.forEach((v) => {\n      if(v > max){\n        max\
    \ = v;\n      }\n      if(v < min){\n        min = v;\n      }\n    });\n\n  \
    \  return([max, min]);\n}\n", "  if(!lst.includes(0)) return\n  let minIndex =\
    \ lst.findIndex(x => x < 0)\n  let maxIndex = lst.findIndex(x => x >= 0)\n  return\
    \ (minIndex > -1 && maxIndex > -1) ? [lst[minIndex], lst[maxIndex]] : [null, null]\n\
    }\n", "  if(lst.length < 3)\n    return null;\n  var min = -Infinity;\n  var max\
    \ = Infinity;\n  var smallest = Infinity;\n  var largest = -Infinity;\n  for(var\
    \ i = 0; i < lst.length; i++){\n    if(lst[i] > largest)\n      largest = lst[i];\n\
    \    if(lst[i] < min)\n      min = lst[i];\n    if(lst[i] < smallest)\n      smallest\
    \ = lst[i];\n    if(lst[i] > largest)\n      largest = lst[i];\n  }\n  return\
    \ (smallest > min) ? (smallest, min) : null;\n}\n", "  let largest = Number.MIN_SAFE_INTEGER\n\
    \  let smallest = Number.MAX_SAFE_INTEGER\n  let result = null\n  for (let i =\
    \ 0; i < lst.length; i++){\n    let curr = lst[i]\n    if (curr < smallest) smallest\
    \ = curr\n    if (curr > largest) largest = curr\n  }\n  if (smallest != Number.MAX_SAFE_INTEGER\
    \ && largest != Number.MIN_SAFE_INTEGER){\n    result = [smallest, largest]\n\
    \  }\n  return result\n}\n", "  let max_num = lst[0]\n  let min_num = lst[0]\n\
    \  for (let i = 1; i < lst.length; i++){\n    if (lst[i] < min_num){\n      min_num\
    \ = lst[i]\n    }\n    if (lst[i] > max_num){\n      max_num = lst[i]\n    }\n\
    \  }\n  return [max_num, min_num]\n}\n", "  var min = -Infinity;\n  var max =\
    \ Infinity;\n  for(var i=0; i<lst.length; i++){\n    if(lst.charCodeAt(i) <= 45){\n\
    \      min = Math.min(min, lst[i]);\n    }\n    else{\n      max = Math.max(max,\
    \ lst[i]);\n    }\n  }\n  return [min, max];\n}", "    var max = -Infinity;\n\
    \    var min = -Infinity;\n    for(var i = 0; i < lst.length; i++){\n        if(lst[i]\
    \ < 0 && lst[i] > min){\n            min = lst[i];\n        }else if(lst[i] >\
    \ 0 && lst[i] < max){\n            max = lst[i];\n        }\n    }\n    return\
    \ [max, min];\n}\n", "  \n  // Create a map of positives to positives\n  var positives\
    \ = {}\n  lst.forEach(function(n){\n    positives[Math.abs(n)] = 1\n  })\n  \n\
    \  // Create a map of negatives to negatives\n  var negatives = {}\n  lst.forEach(function(n){\n\
    \    if (n < 0) negatives[Math.abs(n)] = 1\n  })\n  \n  // Find negative and positive\
    \ integers, sort them, and return the smallest\n  // of them and their corresponding\
    \ sign\n  var pos = Object.keys(positives)\n    .sort(function(a, b){return a\
    \ - b})[0]\n  var neg = Object.keys(negatives)\n    .sort(function(a, b){return\
    \ a - b})[0]\n  return [Math.abs(pos), pos < 0 ? -1 : 0]\n}\n", "  var max_val\
    \ = 0;\n  var min_val = Number.MAX_SAFE_INTEGER;\n  lst.forEach(function(item){\n\
    \    if(item < min_val){\n      min_val = item;\n    }\n    if(item > max_val){\n\
    \      max_val = item;\n    }\n  });\n  return [max_val, min_val];\n}\n", "  var\
    \ positives = [];\n  var negatives = [];\n  for(var i = 0; i < lst.length; i++){\n\
    \    var num = lst[i];\n    if(num > 0){\n      positives.push(num);\n    } else\
    \ {\n      negatives.push(num);\n    }\n  }\n  if(negatives.length === 0 && positives.length\
    \ === 0){\n    return (None, None);\n  }\n  if(negatives.length === 0){\n    return\
    \ (None, positives[0]);\n  }\n  if(positives.length === 0){\n    return (positives[0],\
    \ None);\n  }\n  //Return the largest negative number, then the smallest positive\
    \ number\n  //in that order.\n  if(negatives[0] > positives[0]){\n    return (negatives[0],\
    \ positives[0]);\n  } else {\n    return (positives[0], negatives[0]);\n  }\n\
    }\n", "    if (lst.indexOf(null) > -1 || lst.indexOf(undefined) > -1) {\n    \
    \    return [null, null];\n    }\n    var min = lst[0];\n    var max = lst[0];\n\
    \    var minIndex = -1;\n    var maxIndex = -1;\n    for (var i=1; i<lst.length;\
    \ i++){\n        if (lst[i] < min) {\n            minIndex = i;\n            min\
    \ = lst[i];\n        } else if (lst[i] > max) {\n            maxIndex = i;\n \
    \           max = lst[i];\n        }\n    }\n    return [max, min];\n}\n", " \
    \ var max_i = 0; var min_i = 9999999999999;\n  for(var i = 0; i < lst.length;\
    \ i++){\n    if(lst[i] > max_i) { max_i = lst[i]; }\n    if(lst[i] < min_i) {\
    \ min_i = lst[i]; }\n  }\n  return (max_i == min_i) ? None : [max_i, min_i];\n\
    }\n", "    if (lst.length <= 0) {\n        return null\n    }\n    if (lst.length\
    \ == 1) {\n        return [(lst[0])];\n    }\n    const smallest = lst[0];\n \
    \   let largest = smallest;\n    for (let i = 1; i < lst.length; i++) {\n    \
    \    if (lst[i] < smallest) {\n            smallest = lst[i];\n        }\n   \
    \     if (lst[i] > largest) {\n            largest = lst[i];\n        }\n    }\n\
    \    return [smallest, largest];\n}\n", "    var largest_negative = null;\n  \
    \  var smallest_positive = null;\n    \n    for(var i=0; i<lst.length;i++){\n\
    \        //Test if positive and negative are the same value.\n        //If not,\
    \ then return the smaller one.\n        if(lst[i] < 0 && lst[i] > largest_negative)\n\
    \            largest_negative = lst[i];\n        else if(lst[i] > 0 && lst[i]\
    \ < smallest_positive)\n            smallest_positive = lst[i];\n    }\n\n   \
    \ //If no negative integers, return as None\n    if(largest_negative === null)\n\
    \        return (None, None)\n    \n    //If no positive integers, return as None\n\
    \    if(smallest_positive === null)\n        return (None, None)\n    \n    //Else\
    \ return them as the tuple (largest_negative, smallest_positive)\n    return (largest_negative,\
    \ smallest_positive)\n}\n", "  if (lst.length == 0) {\n    return (None, None)\n\
    \  }\n  let max = Number.MAX_SAFE_INTEGER\n  let min = Number.MIN_SAFE_INTEGER\n\
    \  for (let el of lst) {\n    if (el < 0) {\n      max = el\n    } else if (el\
    \ > 0) {\n      min = el\n    }\n  }\n  return ([max, min])\n}\n", "  if(lst.length\
    \ == 0){\n    return (None, None)\n  }\n  var a = [lst[0]];\n  var b = [lst[0]];\n\
    \  var neg = [];\n  var pos = [];\n  var i;\n  for(i = 1; i < lst.length; i++){\n\
    \    if(a[a.length - 1] < lst[i]){\n      a[a.length] = lst[i];\n    }\n    else\
    \ if(neg[neg.length - 1] < lst[i]){\n      neg[neg.length] = lst[i];\n    }\n\
    \    else if(pos[pos.length - 1] < lst[i]){\n      pos[pos.length] = lst[i];\n\
    \    }\n    else{\n      b[b.length - 1] = lst[i];\n    }\n  }\n  return ([a,\
    \ b]);\n}\n", "  var biggest = Number.NEGATIVE_INFINITY;\n  var smallest = Number.POSITIVE_INFINITY;\n\
    \  for(var i = 0; i < lst.length; i++){\n    if(lst[i] < smallest || smallest\
    \ == Number.POSITIVE_INFINITY){\n      smallest = lst[i];\n    } else if(lst[i]\
    \ > biggest){\n      biggest = lst[i];\n    }\n  }\n  return [biggest, smallest];\n\
    }\n", "  \n  // Check each number in the list to see if it is positive\n  // or\
    \ negative, using the 'is_positive' function\n  // Only positive integers should\
    \ be in the list\n  let positives = [];\n  for (let num of lst){\n    if (is_positive(num)){\n\
    \      positives.push(num);\n    }\n  }\n\n  // If the list is empty, return None\
    \ for both values\n  if (positives.length == 0){\n    return (None, None)\n  }\n\
    \n  // Check the list to see if any numbers are negative\n  // If there are any\
    \ negative numbers, return them\n  // together with the smallest non-negative\
    \ number\n  // Otherwise, return None for the values\n  let negatives = [];\n\
    \  for (let num of lst){\n    if (is_negative(num)){\n      negatives.push(num);\n\
    \    }\n  }\n\n  if (negatives.length !== 0){\n    let minNegative = smallest_non_negative(negatives);\n\
    \    return (minNegative, negatives[negatives.length - 1]);\n  } else {\n    return\
    \ (None, None)\n  }\n}\n", "    let smallest = null;\n    let largest = null;\n\
    \    for(const num of lst){\n        if(smallest == null || num < smallest){\n\
    \            smallest = num;\n        }\n        if(largest == null || num > largest){\n\
    \            largest = num;\n        }\n    }\n    return (smallest != null &&\
    \ largest != null && smallest > largest) ? [smallest, largest] : [None, None];\n\
    }\n", "  if(!lst.length){\n    return [None, None, None];\n  }\n  // Initialize\
    \ variables used in our algorithm.\n  var positiveIntegers = lst,\n    negativeIntegers\
    \ = [],\n    largest_negative_integer = 0,\n    smallest_positive_integer = 0,\n\
    \    largest_positive_integer = 0,\n    positive_integer_sum = 0,\n    negative_integer_sum\
    \ = 0;\n  // Find which of lst's elements are both positive\n  // and negative.\
    \ \n  // We can do this by looking at each element and checking if it\n  // is\
    \ greater than zero and smaller than the previous one.\n  for(var i = 0; i < lst.length;\
    \ i++){\n    var el = lst[i];\n    if(el > 0){\n      // If el is greater than\
    \ zero, add it to the positive_integer_sum variable\n      // and make it the\
    \ current largest negative_integer.\n      positive_integer_sum += el;\n     \
    \ if(largest_negative_integer < el){\n        largest_negative_integer = el;\n\
    \      }\n      smallest_positive_integer = el;\n    }\n    else{\n      // If\
    \ the current element in lst (a negative integer) is smaller than\n      // the\
    \ largest negative_integer, the largest negative_integer\n      // becomes the\
    \ current largest negative_integer.\n      if(el < 0){\n        negative_integer_sum\
    \ += el;\n        if(largest_negative_integer < el){\n          largest_negative_integer\
    \ = el;\n        }\n      }\n      // If the current element in lst is less than\
    \ the smallest positive\n      // integer, add it to the positive_integer_sum\
    \ variable and make it the\n      // smallest positive integer in the list, and\
    \ set smallest_positive_integer\n      // to zero. If there is no positive integers,\
    \ add 0 to the positive_integer_sum\n      // variable, and make it the current\
    \ smallest positive integer.\n      if(smallest_positive_integer > el){\n    \
    \    positive_integer_sum += el;\n        if(smallest_positive_integer < el){\n\
    \          smallest_positive_integer = el;\n        }\n      }\n    }\n  }\n \
    \ // If the total of the positive_integer_sum variable is greater than the largest\n\
    \  // positive integer, add the positive_integer_sum variable to the negative_integer_sum\n\
    \  // variable, and make it the current largest negative integer.\n  if(positive_integer_sum\
    \ > largest_positive_integer){\n    negative_integer_sum += positive_integer_sum;\n\
    \    if(largest_negative_integer < negative_integer_sum){\n      largest_negative_integer\
    \ = negative_integer_sum;\n    }\n  }\n  // If the total of the negative_integer_sum\
    \ variable is smaller than the smallest\n  // negative integer, add the negative_integer_sum\
    \ variable to the negative_integer_sum\n  // variable, and make it the current\
    \ smallest negative integer.\n  ", "\tlet smallest_negative = Number.MAX_SAFE_INTEGER;\n\
    \tlet largestPositive = Number.MIN_SAFE_INTEGER;\n\tfor (let i = 0; i < lst.length;\
    \ i++){\n\t\tif (lst[i] < smallest_negative){\n\t\t\tsmallest_negative = lst[i]\n\
    \t\t}\n\t\tif (lst[i] > largestPositive){\n\t\t\tlargestPositive = lst[i]\n\t\t\
    }\n\t}\n\tif (smallest_negative < Number.MIN_SAFE_INTEGER || largestPositive >\
    \ Number.MAX_SAFE_INTEGER){\n\t\treturn None;\n\t}\n\treturn (smallest_negative,\
    \ largestPositive);\n}\n", "  if(lst.every((x) => (x<0))){\n    return (null,\
    \ lst[0]);\n  }\n  if(lst.every((x) => (x>=0))){\n    return (lst[lst.length-1],\
    \ null);\n  }\n  var smallest = Infinity;\n  var largest = -Infinity;\n  for(var\
    \ i=0; i<lst.length; i++){\n    if(lst[i] > largest){\n      largest = lst[i];\n\
    \    }\n    if(lst[i] < smallest){\n      smallest = lst[i];\n    }\n  }\n  return\
    \ (largest, smallest);\n}\n", "  if(lst.length == 0) return (None, None)\n  let\
    \ max_val = lst[0]\n  let min_val = lst[0]\n  for(let i = 1; i < lst.length; i++){\n\
    \    if(lst[i] < min_val) min_val = lst[i]\n    if(lst[i] > max_val) max_val =\
    \ lst[i]\n  }\n  if(max_val < min_val){\n    let tmp\n    tmp = max_val\n    max_val\
    \ = min_val\n    min_val = tmp\n  }\n  return (max_val, min_val)\n}\n", "    if\
    \ (lst.len()==0) {\n        return (None, None)\n    }\n    var largest = null;\n\
    \    var smallest = null;\n    var largestIndex = 0;\n    var smallestIndex =\
    \ 0;\n    for (var i=0;i<lst.len();i++){\n        if (lst[i] < smallest){\n  \
    \          smallest = lst[i];\n            smallestIndex = i;\n        }\n   \
    \     if (lst[i] > largest){\n            largest = lst[i];\n            largestIndex\
    \ = i;\n        }\n    }\n    var ans = (largest, smallest)\n    if (largestIndex\
    \ > smallestIndex) {\n        var temp = largest;\n        largest = smallest;\n\
    \        smallest = temp;\n    }\n    return (ans, largestIndex);\n}\n", "  lst\
    \ = lst.reduce((a, b) => a > b ? a : b);\n  let smallest = lst.reduce((a, b) =>\
    \ a < b ? a : b);\n  let biggest = lst.reduce((a, b) => a > b ? b : a);\n  return\
    \ (smallest, biggest);\n}\n", "  var largest = undefined;\n  var smallest = undefined;\n\
    \  for(var i = 0; i < lst.length; i++){\n    var curr = lst[i];\n    if(curr <\
    \ smallest || smallest == undefined){\n      smallest = curr;\n      largest =\
    \ undefined;\n    }else if(curr > largest){\n      largest = curr;\n    }\n  }\n\
    \  return ([largest, smallest]); \n}\n", "  let largest = lst[0];\n  let smallest\
    \ = lst[0];\n  for (let i = 1; i < lst.length; i++){\n    if (lst[i] > largest){\n\
    \      largest = lst[i];\n    }\n    else if (lst[i] < smallest){\n      smallest\
    \ = lst[i];\n    }\n  }\n  return [largest, smallest];\n}\n", "\tlet neg_integers\
    \ = lst.filter(function(x){return x < 0});\n\tlet pos_integers = lst.filter(function(x){return\
    \ x > 0});\n\tif (neg_integers.length === 0 && pos_integers.length === 0) {\n\t\
    \treturn [None, None];\n\t}\n\telse if (neg_integers.length === 0) {\n\t\treturn\
    \ [pos_integers[0], None];\n\t}\n\telse if (pos_integers.length === 0) {\n\t\t\
    return [None, neg_integers[0]];\n\t}\n\tlet negative = Math.max.apply(null, neg_integers);\n\
    \tlet positive = Math.min.apply(null, pos_integers);\n\treturn [negative, positive];\n\
    }\n", "    if(!lst)\n        return null;\n    var max_neg=Number.NEGATIVE_INFINITY;\n\
    \    var min_pos=Number.POSITIVE_INFINITY;\n    for(var i=0;i<lst.length;i++){\n\
    \        if(lst[i]<0){\n            if(lst[i]>max_neg)\n                max_neg=lst[i];\n\
    \        }\n        else if(lst[i]>min_pos)\n            min_pos=lst[i];\n   \
    \ }\n    return [max_neg,min_pos]\n}", "    var max = -Infinity;\n    var min\
    \ = -Infinity;\n    var found = false;\n    for(var i = 0; i < lst.length; i++){\n\
    \        var num = lst[i];\n        if (num < min || (num == min && num > max)){\n\
    \            min = num;\n        }\n        if(num > max){\n            max =\
    \ num;\n            found = true;\n        }\n    }\n    if(!found){\n       \
    \ return null;\n    }\n    return [min, max];\n}\n", "\tlet max;\n\tlet min;\n\
    \tfor(let i = 0; i < lst.length; i++){\n\t\tif(lst[i] > 0){\n\t\t\tmax = lst[i];\n\
    \t\t\tbreak;\n\t\t}\n\t\tif(lst[i] < 0){\n\t\t\tmin = lst[i];\n\t\t\tbreak;\n\t\
    \t}\n\t}\n\tif(max === undefined){\n\t\treturn [undefined, undefined];\n\t}\n\t\
    return [max, min];\n}\n", "  let largest = None;\n  let smallest = None;\n  for(let\
    \ i = 0; i < lst.length; i++){\n    if(largest == None || (largest < lst[i])){\n\
    \      largest = lst[i];\n    }\n    else if(smallest == None || (smallest > lst[i])){\n\
    \      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n}\n", " \
    \ var negIntegers = lst.filter(function(x) { return x < 0; });\n  var posIntegers\
    \ = lst.filter(function(x) { return x >= 0; });\n  return negIntegers.length ?\
    \ { a: negIntegers[negIntegers.length-1], b: posIntegers[0] } : (negIntegers.length\
    \ ? { a: negIntegers[0], b: posIntegers[posIntegers.length-1] } : (posIntegers.length\
    \ ? { a: posIntegers[0], b: posIntegers[0] } : null);\n}\n", "  if (lst.length\
    \ === 0) {\n    return ([None, None])\n  }\n\n  var is_neg = (lst[0] < 0);\n \
    \ if (is_neg) {\n    lst = [-lst[0], lst[1]];\n  }\n\n  var min_int = Number.MAX_VALUE;\n\
    \  var max_int = -Number.MAX_VALUE;\n  for (var i = 0; i < lst.length; ++i) {\n\
    \    var x = lst[i];\n    if (x < min_int) {\n      min_int = x;\n    }\n    if\
    \ (x > max_int) {\n      max_int = x;\n    }\n  }\n\n  return ([is_neg ? max_int\
    \ : min_int, is_neg ? -min_int : max_int])\n}\n", "  let largest = Number.MAX_SAFE_INTEGER;\n\
    \  let smallest = Number.MIN_SAFE_INTEGER;\n  let i;\n  let l = lst.length;\n\
    \  for (i = 0; i < l; i++){\n    if (lst[i] > largest){\n      largest = lst[i];\n\
    \    }\n    if (lst[i] < smallest){\n      smallest = lst[i];\n    }\n  }\n  if\
    \ (smallest === Number.MAX_SAFE_INTEGER && largest === Number.MIN_SAFE_INTEGER){\n\
    \    return null;\n  }\n  return [largest, smallest];\n}\n", "    let smaller\
    \ = [];\n    let larger = [];\n    for(let i = 0; i < lst.length; i++){\n    \
    \    if(lst[i] < 0){\n            smaller.push(lst[i]);\n        }\n        else\
    \ if(lst[i] > 0){\n            larger.push(lst[i]);\n        }\n        else if(smaller.length\
    \ === 0 && larger.length === 0){\n            return ('None', 0);\n        }\n\
    \    }\n    if(smaller.length === 0 && larger.length === 0){\n        return (None,\
    \ None)\n    }\n    return (larger.pop(), smaller.pop())\n}\n", "  for (let i\
    \ = 0; i < lst.length; i++){\n    const x = lst[i]\n    let largest = -Infinity\n\
    \    let smallest = Infinity\n    for (let j = 0; j < lst.length; j++){\n    \
    \  const y = lst[j]\n      if (x > y){\n        largest = y\n      } else if (x\
    \ < y){\n        smallest = y\n      }\n    }\n    if (largest < -Infinity &&\
    \ smallest > -Infinity){\n      return (largest, smallest)\n    }\n  }\n  return\
    \ (None, None)\n}\n", "  let highest = lst.sort((a, b) => b-a).pop()\n  let smallest\
    \ = lst.sort((a, b) => a-b).shift()\n  return smallest ? {highest, smallest} :\
    \ {highest, None}\n}\n", "  for (let i = 0; i < lst.length; i++){\n    let number\
    \ = lst[i];\n    let sign = 1;\n    if (number < 0){\n      sign = -1;\n    }\n\
    \    if (sign < -Math.abs(number)){\n      return (number, sign);\n    }\n  }\n\
    \  return ('None', 0);\n}\n", "    lst = lst.filter(function(n){\n        return\
    \ n > 0 && n < Number.MAX_VALUE;\n    });\n    if(!lst.length) return (None, None);\n\
    \    var l = Math.min(...lst);\n    var r = Math.max(...lst);\n    return (l,\
    \ r);\n}\n", "    if (lst.length < 1){\n        return null;\n    }\n    var largest\
    \ = lst[0];\n    var smallest = lst[0];\n    for (var i = 1; i < lst.length; i++){\n\
    \        if (largest < lst[i]){\n            largest = lst[i];\n        } else\
    \ if (smallest > lst[i]){\n            smallest = lst[i];\n        }\n    }\n\
    \    return [largest, smallest];\n}\n", "  if(lst.length > 0){\n    var pos =\
    \ lst.sort(function(a, b){\n      return b - a;\n    }).pop();\n    var neg =\
    \ [];\n    for(var i in lst){\n      if(lst[i] < pos){\n        neg.push(lst[i]);\n\
    \      }\n    }\n    if(neg.length > 0){\n      return (pos, neg.sort().pop());\n\
    \    }else{\n      return (pos, undefined);\n    }\n  }\n  else{\n    return (undefined,\
    \ undefined);\n  }\n}\n", "    var largest = null;\n    var smallest = null;\n\
    \    var negatives = [];\n    for(var i = 0; i < lst.length; i++){\n        var\
    \ item = lst[i];\n        if(item < 0){\n            negatives.push(item);\n \
    \           smallest = item;\n        }else{\n            if(largest == null){\n\
    \                largest = item;\n            }else if(item > largest){\n    \
    \            largest = item;\n            }\n        }\n    }\n\n    if(smallest\
    \ == null){\n        smallest = null;\n    }\n\n    return {largest: largest,\
    \ smallest: smallest};\n}\n", "  let max_val = Number.NEGATIVE_INFINITY;\n  let\
    \ min_val = Number.POSITIVE_INFINITY;\n\n  for(let i of lst){\n    if(max_val\
    \ < i){\n      max_val = i;\n    }\n    else if(min_val > i){\n      min_val =\
    \ i;\n    }\n  }\n\n  return (max_val, min_val);\n}\n", "    if (lst.length <=\
    \ 0){\n        return (\"none\", undefined);\n    }\n    const sorted_list = lst.sort((a,\
    \ b) => b - a);\n    let smallest = sorted_list[0];\n    let largest = sorted_list[sorted_list.length-1];\n\
    \    if (smallest === undefined){\n        return (\"none\", undefined);\n   \
    \ }\n    if (largest === undefined){\n        return (\"none\", undefined);\n\
    \    }\n    if (smallest > largest){\n        return (smallest, undefined);\n\
    \    }\n    return (\"smallest\", smallest);\n}\n", "  //If the list has no elements,\
    \ return the tuple (None, None)\n  if (lst.length == 0){\n    return (None, None)\n\
    \  }\n  //Create a variable to hold the max\n  var max = (lst[0] < lst[1]) ? lst[0]\
    \ : lst[1];\n  //Create a variable to hold the min\n  var min = (lst[0] > lst[1])\
    \ ? lst[0] : lst[1];\n  //Loop through all the elements in the list\n  for (var\
    \ i = 0; i < lst.length; i++){\n    if (lst[i] > max){\n      //If the current\
    \ number is greater than the max, update the max\n      max = (lst[i] < min) ?\
    \ lst[i] : min;\n    }\n    if (lst[i] < min){\n      //If the current number\
    \ is less than the min, update the min\n      min = (lst[i] > max) ? lst[i] :\
    \ max;\n    }\n  }\n  //If the current number is greater than the min, return\
    \ (min,\n  // max)\n  return (min, max);\n}\n", "  let max_val=-Infinity;\n  let\
    \ min_val=Infinity;\n  for (let i=0; i<lst.length; i++){\n    if (lst[i]>max_val){\n\
    \      max_val = lst[i];\n    }\n    if (lst[i]<min_val){\n      min_val = lst[i];\n\
    \    }\n  }\n  return max_val < min_val ? [max_val, min_val] : null;\n}\n", " \
    \ let result = (lst[0], Math.max(...lst.slice(1)));\n  let index = lst.indexOf(Math.max(...lst.slice(1)));\n\
    \  if (index === -1) return (None, None)\n  for (let i = index + 1; i < lst.length;\
    \ i++){\n    if (lst[i] > result[result][1]){\n      result = (lst[i], Math.max(...lst.slice(i)));\n\
    \    }\n  }\n  return (result, lst.indexOf(Math.max(...lst.slice(result.length))));\n\
    }\n", "  var smallest = null;\n  var largest = null;\n  var n = 0;\n\n  if (lst.length\
    \ == 0){\n    return [None, None];\n  }\n\n  for (i = 0; i < lst.length; i++){\n\
    \    n = lst[i];\n\n    if (smallest == null || n < smallest){\n      smallest\
    \ = n;\n    }\n\n    if (largest == null || n > largest){\n      largest = n;\n\
    \    }\n  }\n\n  return [smallest, largest];\n}\n", "\tlet smallest = Number.MAX_VALUE;\n\
    \tlet largest = Number.MIN_VALUE;\n\n\tfor (let num of lst){\n\t\tif (num < smallest){\n\
    \t\t\tsmallest = num;\n\t\t} else if (num > largest){\n\t\t\tlargest = num;\n\t\
    \t}\n\t}\n\n\treturn [smallest, largest];\n}\n", "\t// Create a dictionary mapping\
    \ numbers to their positives and negatives\n\tconst numberToPositive = {};\n\t\
    const numberToNegative = {};\n\tlst.forEach((el, i) => {\n\t\tif (numberToPositive[el]\
    \ <= 0) {\n\t\t\tnumberToPositive[el] = i;\n\t\t} else if (numberToNegative[el]\
    \ < 0) {\n\t\t\tnumberToNegative[el] = i;\n\t\t}\n\t});\n\t// Get a list of the\
    \ positive and negative numbers in the list\n\tconst positive = Object.keys(numberToPositive).sort((a,\
    \ b) => a - b);\n\tconst negative = Object.keys(numberToNegative).sort((a, b)\
    \ => b - a);\n\t// If there is no positive and no negative numbers, return them\
    \ as None\n\tif (positive.length === 0 && negative.length === 0) {\n\t\treturn\
    \ {\n\t\t\tpositive: null,\n\t\t\tnegative: null,\n\t\t};\n\t}\n\t// Get the first\
    \ negative number and the last positive number\n\tconst first = negative[0];\n\
    \tconst last = positive[positive.length - 1];\n\tconst positiveNumber = numberToPositive[first];\n\
    \t// If the first number is negative, return it as None\n\tif (positiveNumber\
    \ < 0) {\n\t\treturn {\n\t\t\tpositive: null,\n\t\t\tnegative: positiveNumber,\n\
    \t\t};\n\t}\n\t// If the last number is negative, return it as None\n\tif (numberToNegative[last]\
    \ < 0) {\n\t\treturn {\n\t\t\tpositive: positiveNumber,\n\t\t\tnegative: null,\n\
    \t\t};\n\t}\n\t// If there is a single positive number, return it as None\n\t\
    if (positiveNumber === 1) {\n\t\treturn {\n\t\t\tpositive: null,\n\t\t\tnegative:\
    \ null,\n\t\t};\n\t}\n\t// Get the first negative number\n\tconst firstNegative\
    \ = numberToNegative[first];\n\t// If the first number is positive, return it\
    \ as None\n\tif (firstNegative > 0) {\n\t\treturn {\n\t\t\tpositive: null,\n\t\
    \t\tnegative: firstNegative,\n\t\t};\n\t}\n\t// If the last number is positive,\
    \ return it as None\n\tif (numberToPositive[last] === 1) {\n\t\treturn {\n\t\t\
    \tpositive: firstNegative,\n\t\t\tnegative: null,\n\t\t};\n\t}\n\t// If there\
    \ is a single negative number, return it as None\n\tif (firstNegative === 1) {\n\
    \t\treturn {\n\t\t\tpositive: null,\n\t\t\tnegative: null,\n\t\t};\n\t}\n\t//\
    \ If the first number is greater than the last number\n\tif (numberToPositive[first]\
    \ > numberToNegative[last]) {\n\t\treturn {\n\t\t\tpositive: numberToPositive[first],\n\
    \t\t\tnegative: numberToNegative[last],\n\t\t};\n\t}\n\t// If the last number\
    \ is greater than the first number\n\tif (numberToNegative[first] > numberToPositive[last])\
    \ {\n\t\treturn {\n\t\t\tpositive: numberToPositive[last],\n\t\t\tnegative: numberToPositive[first],\n\
    \t\t};\n\t}\n\t// If the ", "  const max = -Infinity;\n  const min = Infinity;\n\
    \  let max_value = -Infinity;\n  let min_value = Infinity;\n  lst.forEach(el =>\
    \ {\n    if(el > max) max = el;\n    if(el < min) min = el;\n  });\n  if(max >\
    \ -Infinity){\n    max_value = max;\n  }\n  if(min < Infinity){\n    min_value\
    \ = min;\n  }\n  return [max_value, min_value];\n}\n</code>\n<|/ a tags=arrays,javascript,algorithm\
    \ |>\n<| c |>\nI like this approach, but what if the array is all negative numbers?\n\
    <|/ c |>\n<| c |>\nit returns [None, None] instead of [(None, None), (None, None)],\
    \ which is what it should be.\n<|/ c |>\n<| c |>\nWhat if the array is all zeros?\n\
    <|/ c |>\n<| c |>\nI edited the answer to add code for zero values\n<|/ c |>\n\
    <| a |>\nHere's a more verbose way that has two benefits:\n\nIt doesn't use recursion.\n\
    It doesn't require additional variables.\n\nThis code should perform better than\
    \ the other solutions because recursion tends to make code harder to read and\
    \ debug.\nThe basic idea is to break down the array into smaller parts and then\
    \ loop over those smaller parts in succession. For each smaller part, recur on\
    \ the smaller part and keep a record of the maximum so far and its index.\n<code>",
  "  var largest = undefined;\n  var smallest = undefined;\n  var negatives = [];\n\
    \  var positives = [];\n  for (var i = 0; i < lst.length; i++){\n    if (lst[i]\
    \ < 0){\n      negatives.push(lst[i]);\n    }\n    if (lst[i] > 0){\n      positives.push(lst[i]);\n\
    \    }\n  }\n  if (negatives.length > 0){\n    largest = negatives[negatives.length\
    \ - 1];\n  }\n  else if (positives.length > 0){\n    smallest = positives[0];\n\
    \  }\n  return [largest, smallest];\n}\n", "    // Write your code here\n    if\
    \ (lst.length <= 0) {\n        return null;\n    }\n    var largest_negative =\
    \ Number.MAX_SAFE_INTEGER;\n    var largest_positive = Number.MIN_SAFE_INTEGER;\n\
    \    var smallest_positive = Number.MAX_SAFE_INTEGER;\n    var smallest_negative\
    \ = Number.MIN_SAFE_INTEGER;\n    for(var i=0;i<lst.length;i++){\n        if (lst[i]\
    \ < 0) {\n            if (lst[i] > largest_negative) {\n                largest_negative\
    \ = lst[i];\n            }\n        }\n        if (lst[i] > 0) {\n           \
    \ if (lst[i] < largest_positive) {\n                largest_positive = lst[i];\n\
    \            }\n            if (lst[i] < smallest_positive) {\n              \
    \  smallest_positive = lst[i];\n            }\n            if (lst[i] > smallest_negative)\
    \ {\n                smallest_negative = lst[i];\n            }\n        }\n \
    \   }\n    return {negative: largest_negative, positive: largest_positive, positive2:\
    \ smallest_positive, negative2: smallest_negative};\n}\n", "  if(lst === null\
    \ || lst.length === 0){\n    return (null, null);\n  }\n  let largest = lst[0];\n\
    \  let smallest = lst[0];\n  for (let i = 1; i < lst.length; i++){\n    if(lst[i]\
    \ > largest){\n      largest = lst[i];\n    }\n    if(lst[i] < smallest){\n  \
    \    smallest = lst[i];\n    }\n  }\n  return (largest, smallest);\n}\n", "  let\
    \ largest = 0;\n  let smallest = 0;\n  for(let i = 0; i < lst.length; i++){\n\
    \    if (lst[i] < smallest){\n      smallest = lst[i];\n    }\n    if (lst[i]\
    \ > largest){\n      largest = lst[i];\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "    // Write your code here\n    if (lst.length < 2) return (None, None)\n\
    \    let min = Math.min(...lst)\n    let max = Math.max(...lst)\n    if(min >=\
    \ max) return (None, None)\n    return ([min], [max])\n}\n", "  let max = null;\n\
    \  let min = null;\n  for(let i = 0; i < lst.length; i++){\n    if (lst[i] > max){\n\
    \      max = lst[i];\n    } else if (lst[i] < min){\n      min = lst[i];\n   \
    \ }\n  }\n  return [max, min];\n}\n", "    var largest = (0 | Infinity),\n   \
    \     smallest = Infinity,\n        max = -Infinity;\n    for (var i = 0; i <\
    \ lst.length; i++){\n        if (lst[i] > largest){\n            largest = lst[i];\n\
    \        }\n        if (lst[i] < smallest){\n            smallest = lst[i];\n\
    \        }\n        if (largest < smallest || largest === max){\n            largest\
    \ = null;\n            smallest = null;\n            max = -Infinity;\n      \
    \  } else if (largest === -Infinity){\n            largest = null;\n         \
    \   smallest = null;\n            max = -Infinity;\n        } else if (smallest\
    \ === Infinity){\n            largest = null;\n            smallest = null;\n\
    \            max = -Infinity;\n        }\n    }\n    return [largest, smallest];\n\
    }\n", "  // Initialize largest and smallest to None\n  var largest = None;\n \
    \ var smallest = None;\n  \n  // Check all elements in the list\n  for(var i =\
    \ 0; i < lst.length; i++){\n    if(largest == None){\n      largest = lst[i];\n\
    \      continue;\n    }\n    if(smallest == None){\n      smallest = lst[i];\n\
    \    }\n    if(largest < lst[i]){\n      largest = lst[i];\n    }\n    if(smallest\
    \ > lst[i]){\n      smallest = lst[i];\n    }\n  }\n  \n  return largest, smallest;\n\
    }\n", "   var max_int = 0;\n   var min_int = 1;\n   var largest_int = 1;\n   var\
    \ smallest_int = 1;\n\n   for (var i of lst) {\n      if (i < 0)\n         return\
    \ (None, None)\n      if (i > max_int)\n         max_int = i;\n      if (i < min_int)\n\
    \         return (None, None)\n      if (i > largest_int)\n         largest_int\
    \ = i;\n      if (i < smallest_int)\n         smallest_int = i;\n   }\n   return\
    \ ([max_int, smallest_int])\n}\n", "\tif (lst.length <= 0) {\n\t\treturn [None,\
    \ None];\n\t}\n\t\n\tvar smallest = lst.shift();\n\tvar largest_of_rest = lst;\n\
    \t\n\tfor (let i = 0; i < largest_of_rest.length; i++) {\n\t\tif (smallest<largest_of_rest[i])\
    \ {\n\t\t\tsmallest = largest_of_rest[i];\n\t\t}\n\t\tif (smallest>largest_of_rest[i])\
    \ {\n\t\t\tlargest_of_rest.splice(i,1);\n\t\t\tlargest_of_rest.unshift(smallest);\n\
    \t\t\t\n\t\t\tif (smallest<0) {\n\t\t\t\tsmallest = None;\n\t\t\t}\n\t\t\tif (largest_of_rest.length\
    \ <= 0) {\n\t\t\t\treturn [None, None];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn [smallest,\
    \ largest_of_rest];\n}\n", "  var min;\n  var max;\n  var a = 0;\n  var b = 0;\n\
    \  for(var i=0; i<lst.length; i++){\n    if(lst[i] > max){\n      max = lst[i];\n\
    \      a = i;\n    }\n    if(lst[i] < min){\n      min = lst[i];\n      b = i;\n\
    \    }\n  }\n  return [a, b];\n}\n", "\tlet minNum = lst[0]\n\tlet maxNum = lst[0]\n\
    \n\t// Loop through the entire list and find the smallest and largest numbers.\n\
    \tfor (let i of lst) {\n\t\tif (i < minNum) {\n\t\t\tminNum = i\n\t\t}\n\t\tif\
    \ (i > maxNum) {\n\t\t\tmaxNum = i\n\t\t}\n\t}\n\n\treturn [minNum, maxNum]\n\
    }\n", "    let largest = -1\n    let smallest = 1000000000;\n    for (let num\
    \ of lst){\n        if (num > largest) largest = num\n        if (num < smallest)\
    \ smallest = num\n    }\n    return (largest, smallest)\n}\n", "\tlet largest\
    \ = -Infinity;\n\tlet smallest = Infinity;\n\tfor (let i = 0; i < lst.length;\
    \ i++){\n\t\tif (lst[i] > largest){\n\t\t\tlargest = lst[i];\n\t\t} else if (lst[i]\
    \ < smallest){\n\t\t\tsmallest = lst[i];\n\t\t}\n\t}\n\tif (smallest > largest\
    \ && smallest){\n\t\treturn smallest, smallest;\n\t} else if (smallest < largest\
    \ && largest){\n\t\treturn largest, largest;\n\t} else if (smallest === largest\
    \ && smallest === undefined){\n\t\treturn largest, smallest;\n\t} else if (smallest\
    \ === largest && smallest !== undefined){\n\t\treturn smallest, largest;\n\t}\
    \ else {\n\t\treturn null, null;\n\t}\n}\n", "    var largest = -1, smallest =\
    \ Number.MAX_VALUE;\n    for(var i = 0; i < lst.length; i++){\n        if(lst[i]\
    \ > largest){\n            largest = lst[i];\n        }\n        if(lst[i] < smallest){\n\
    \            smallest = lst[i];\n        }\n    }\n    return [largest, smallest];\n\
    }\n", "    if (lst.indexOf(Infinity) >= 0){\n        return (None, None)\n   \
    \ }\n    var min_negative = Infinity\n    var min_positive = Infinity\n    for(var\
    \ i=0;i<lst.length;i++){\n        var n = lst[i]\n        if (n < 0){\n      \
    \      if (n < min_negative){\n                min_negative = n\n            }\n\
    \        }else{\n            if (n < min_positive){\n                min_positive\
    \ = n\n            }\n        }\n    }\n    return (min_negative, min_positive)\n\
    }\n", "    // Write your code here\n    if(lst.length===0){\n        return null;\n\
    \    }\n    var largest=null;\n    var smallest=null;\n    for(var i=0;i<lst.length;i++){\n\
    \        if(lst[i]<0){\n            largest=lst[i];\n        }\n        if(smallest==null){\n\
    \            smallest=lst[i];\n        }\n        else if(smallest>lst[i]){\n\
    \            smallest=lst[i];\n        }\n    }\n    return largest,smallest;\n\
    }", "  var largest_integer = null;\n  var smallest_integer = null;\n  var max_integer\
    \ = null;\n\n  if (lst.length === 0) {\n    return (None, None)\n  }\n\n  for\
    \ (var i=0; i < lst.length; i++) {\n    var current_number = lst[i];\n\n    if\
    \ (current_number > max_integer) {\n      largest_integer = current_number;\n\
    \      max_integer = current_number;\n    }\n    if (current_number < min_integer)\
    \ {\n      smallest_integer = current_number;\n      min_integer = current_number;\n\
    \    }\n  }\n  return (largest_integer, smallest_integer);\n}\n", "  let max_num\
    \ = null;\n  let min_num = null;\n  for (let i = 0; i < lst.length; i++){\n  \
    \  if (max_num == null || max_num > lst[i])\n      max_num = lst[i];\n    if (min_num\
    \ == null || min_num < lst[i])\n      min_num = lst[i];\n  }\n  return [max_num,\
    \ min_num];\n}\n", "\tlet max_value_index = 0;\n\tlet min_value_index = 0;\n\t\
    for(let i = 0; i < lst.length; i++){\n\t\tif(lst[i] > lst[max_value_index]){\n\
    \t\t\tmax_value_index = i;\n\t\t}\n\t\tif(lst[i] < lst[min_value_index]){\n\t\t\
    \tmin_value_index = i;\n\t\t}\n\t}\n\treturn [lst[max_value_index], lst[min_value_index]];\n\
    }\n", "  for (let i = 0; i < lst.length; i++){\n    if (lst[i] > 0){\n      return\
    \ (lst[i], i);\n    }\n  }\n  return (None, lst.length);\n}", "  // Write your\
    \ code here\n  if(lst.length <= 0){\n    return ('None', None)\n  }\n\n  let smallest\
    \ = lst[0]\n  let largest = lst[0]\n\n  for(let i=0; i<lst.length; i++){\n   \
    \ if(lst[i] < smallest){\n      smallest = lst[i]\n    }\n    if(lst[i] > largest){\n\
    \      largest = lst[i]\n    }\n  }\n  return ('None', largest)\n}\n", "  // If\
    \ there are no integers, return None instead.\n  if(lst.every(function(x){\n \
    \   return !isNaN(x);\n  })){\n    return (lst.sort(function(a, b){\n      return\
    \ a < b\n    }).pop(), lst.sort(function(a, b){\n      return a > b\n    }).pop());\n\
    \  }\n}\n", "\t// Get the first number in the list.\n\t// If the list is empty,\
    \ this will be undefined.\n\t// If there is no first number, return (None, None)\n\
    \tvar firstNumber = lst[0];\n\t\n\t// Get the largest and smallest integers in\
    \ the list.\n\t// If the list is empty, this will be undefined.\n\t// If the first\
    \ number is undefined, return (None, None)\n\tvar smallestNum = firstNumber;\n\
    \tvar largestNum = firstNumber;\n\t\n\tfor (var i = 1; i < lst.length; i++){\n\
    \t\tif (lst[i] < smallestNum){\n\t\t\tsmallestNum = lst[i];\n\t\t} else if (lst[i]\
    \ > largestNum){\n\t\t\tlargestNum = lst[i];\n\t\t}\n\t}\n\t\n\treturn (largestNum,\
    \ smallestNum);\n}\n", "  if(lst.length == 0) return (None, None)\n  var max =\
    \ -Infinity\n  var min = -Infinity\n  var i = -1\n  for(var value of lst){\n \
    \   if(value < min) min = value\n    if(value > max) max = value\n    i++\n  }\n\
    \  if(i == -1) return (None, None)\n  if(min == -Infinity) return (None, max)\n\
    \  if(max == Infinity) return (None, min)\n  return ((min, max), i)\n}\n</cell>\n\
    <text>\nThe following function is from the Python standard library. It is used\
    \ to parse a date from a string in a given format.\n\n\n</text>\n<cell>", "  \
    \  var max;\n    var min;\n    if (lst.every(function(val){\n        return val\
    \ >= 0;\n    })) {\n        max = min = null;\n        lst.forEach(function(val){\n\
    \            if (!max || val > max) {\n                max = val;\n          \
    \  }\n            if (!min || val < min) {\n                min = val;\n     \
    \       }\n        });\n    } else {\n        max = null;\n        min = null;\n\
    \    }\n    return [min, max];\n}\n", "    for(let i = 0; i < lst.length; i++){\n\
    \        if(lst[i] < 0){\n            let temp = lst[i];\n            lst[i] =\
    \ lst[lst.length - 1];\n            lst[lst.length - 1] = temp;\n        }\n \
    \   }\n    return (lst[0], lst[lst.length - 1]);\n}\n", "  if (lst.length ===\
    \ 0) return [None, None];\n  let largest = Number.POSITIVE_INFINITY;\n  let smallest\
    \ = Number.NEGATIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ number = lst[i];\n    if (number > largest) {\n      largest = number;\n   \
    \ } else if (number < smallest) {\n      smallest = number;\n    }\n  }\n  return\
    \ [smallest, largest];\n}\n", "    var smallest_integer = null;\n    var largest_integer\
    \ = null;\n\n    for(var i = 0; i < lst.length; i++){\n        var num = lst[i];\n\
    \        if(smallest_integer === null){\n            smallest_integer = num;\n\
    \            if(num < 0) largest_integer = num;\n        }\n        else if(num\
    \ < smallest_integer){\n            smallest_integer = num;\n            if(num\
    \ < 0) largest_integer = num;\n        }\n        else if(num > largest_integer){\n\
    \            largest_integer = num;\n        }\n    }\n\n    if(smallest_integer\
    \ === null && largest_integer === null){\n        return (null, null);\n    }\n\
    \    else{\n        return (largest_integer, smallest_integer);\n    }\n}\n",
  "  if (lst == [] || lst == null || lst === {}){\n    return null;\n  }\n  var smallest\
    \ = -Infinity;\n  var largest = Infinity;\n  var smallest_index = null;\n  for\
    \ (var i = 0; i < lst.length; i++){\n    if (smallest * lst.slice(i).reduce(function(a,\
    \ b){return a + b;}) > lst[i]) smallest = lst[i];\n    if (largest < lst[i]) largest\
    \ = lst[i];\n    if (smallest_index == null || smallest * lst.slice(i).reduce(function(a,\
    \ b){return a + b;}) <= smallest_index){\n      smallest_index = smallest * lst.slice(i).reduce(function(a,\
    \ b){return a + b});\n    }\n  }\n  return [smallest_index, largest];\n}\n", " \
    \ var smaller_int = null;\n  var larger_int = null;\n  var smallest_int = null;\n\
    \n  for(var i = 0; i < lst.length; i++){\n    var x = lst[i];\n    if(x < 0){\n\
    \      smaller_int = x;\n    }\n    else if(x > 0){\n      larger_int = x;\n \
    \   }\n    else{\n      smallest_int = x;\n    }\n  }\n\n  return smallest_int\
    \ === null ? larger_int : smaller_int;\n}\n", "  var largest = Number.NEGATIVE_INFINITY;\n\
    \  var smallest = Number.POSITIVE_INFINITY;\n  var maxInt = 0;\n  var minInt =\
    \ 999999999;\n\n  for(var i = 0; i < lst.length; i++){\n    var n = lst[i];\n\n\
    \    if(n < minInt){\n      minInt = n;\n    }\n    if(n > maxInt){\n      maxInt\
    \ = n;\n    }\n\n    if(n > largest){\n      largest = n;\n    }\n    if(n < smallest){\n\
    \      smallest = n;\n    }\n  }\n\n  return (largest == smallest) ? [largest,\
    \ minInt] : [largest, minInt, maxInt];\n}\n", "  let largest = -Infinity, smallest\
    \ = Infinity;\n  let i, tmp, num;\n  let max = -Infinity;\n  \n  for (i = 0; i\
    \ < lst.length; i++){\n    num = lst[i];\n    \n    if (num < smallest){\n   \
    \   smallest = num;\n    }\n    \n    if (num > largest){\n      largest = num;\n\
    \    }\n    \n    max = num;\n  }\n  \n  return [largest, smallest];\n}\n", " \
    \ for(var i=0;i<lst.length;i++){\n    if((lst[i] < 0)&&(lst[i+1] > 0)){\n    \
    \  return ([lst[i], lst[i+1]]);\n    }\n    else if((lst[i] < 0)&&(lst[i+1] ==\
    \ 0)){\n      return ([lst[i], None]);\n    }\n    else if((lst[i] > 0)&&(lst[i+1]\
    \ < 0)){\n      return ([None, lst[i+1]]);\n    }\n  }\n  return ([None, None]);\n\
    }\n", "    var largest = null;\n    var smallest = null;\n    for(var i = 0; i\
    \ < lst.length; i++){\n        if(largest === null || largest < lst[i]){\n   \
    \         largest = lst[i];\n        }\n        if(smallest === null || smallest\
    \ > lst[i]){\n            smallest = lst[i];\n        }\n    }\n    return [largest,\
    \ smallest];\n}\n", "  lst = lst.sort();\n  for (let i = 0; i < lst.length; i++){\n\
    \    if (lst[i] < 0){\n      return (lst[i], None);\n    }\n    if (lst[i] > 0){\n\
    \      return (None, lst[i]);\n    }\n  }\n  return (None, lst[0]);\n}\n", " \
    \ if(lst.length < 2) {\n    return (None, None)\n  }\n  let max_ = Number.MIN_VALUE;\n\
    \  let min_ = Number.MAX_VALUE;\n  for(let num of lst) {\n    if(num < 0) {\n\
    \      max_ = -num;\n    } else {\n      min_ = num;\n    }\n  }\n  if(max_ >\
    \ min_) {\n    return (min_, max_)\n  }\n  return (None, None)\n}\n", "  let smallest\
    \ = Number.MAX_VALUE\n  let largest = Number.MIN_VALUE\n  for(const value of lst){\n\
    \    if(value < smallest) smallest = value\n    if(value > largest) largest =\
    \ value\n  }\n  return [smallest, largest]\n}\n", "  // Create a list of all integers\
    \ in list\n  var all_ints = lst.map(function(x) { return +x; });\n\n  // Find\
    \ the smallest negative number\n  var smallest_neg = all_ints.reduce(function(prev,cur,idx,arr){\n\
    \    if(cur < 0) return cur;\n    if(prev < 0) return prev;\n    return idx;\n\
    \  },0);\n\n  // Find the largest positive number\n  var largest_pos = all_ints.reduce(function(prev,cur,idx,arr){\n\
    \    if(cur > 0) return cur;\n    if(prev > 0) return prev;\n    return idx;\n\
    \  },0);\n\n  // If no negative/positive integers were found, return them as None\n\
    \  if(smallest_neg == -1 && largest_pos == -1){\n    return null;\n  }\n\n  //\
    \ Return the largest negative or smallest positive integer\n  if(smallest_neg\
    \ == -1){\n    return all_ints[largest_pos];\n  }\n  if(largest_pos == -1){\n\
    \    return all_ints[smallest_neg];\n  }\n  return all_ints[largest_pos];\n}\n",
  "  var negative = [];\n  var positive = [];\n  for (var i=0; i<lst.length; i++){\n\
    \    if (lst[i] < 0){\n      negative.push(lst[i]);\n    }\n    else if (lst[i]\
    \ > 0){\n      positive.push(lst[i]);\n    }\n  }\n  if (negative.length < 1){\n\
    \    return (None, None)\n  }\n  if (negative.length > 0){\n    negative = largest_smallest_integers(negative);\n\
    \    if (negative[1] < 0){\n      return (None, None)\n    }\n  }\n  if (positive.length\
    \ < 1){\n    return (None, None)\n  }\n  if (positive.length > 0){\n    positive\
    \ = largest_smallest_integers(positive);\n    if (positive[1] > 0){\n      return\
    \ (None, None)\n    }\n  }\n  return (positive[0], negative[0]);\n}\n", "  if\
    \ (lst.indexOf(0)===-1){\n    return null;\n  }\n  let min = 0;\n  let max = lst.indexOf(0);\
    \ // index of largest positive integer\n  for (let i = 1; i<lst.length; i++){\n\
    \    if (lst[i]<0){\n      min = i;\n    } else {\n      max = i;\n    }\n   \
    \ if (max===i){ // if all positive are max\n      break;\n    }\n  }\n  return\
    \ [min, max];\n}", "  // Return None if we are passed an empty list.\n  if(lst.length\
    \ === 0) {\n    return [null, null];\n  }\n\n  var smallest = lst[0];\n  var largest\
    \ = lst[0];\n\n  for(var i = 1; i < lst.length; i++) {\n    var current = lst[i];\n\
    \n    if(current > largest) {\n      largest = current;\n    }\n\n    if(current\
    \ < smallest) {\n      smallest = current;\n    }\n  }\n\n  return [largest, smallest];\n\
    }", "\tvar max_val = 0;\n\tvar min_val = Number.MAX_SAFE_INTEGER;\n\tfor(var i\
    \ in lst){\n\t\tvar val = lst[i];\n\t\tif(val > max_val){\n\t\t\tmax_val = val;\n\
    \t\t} else if(val < min_val){\n\t\t\tmin_val = val;\n\t\t}\n\t}\n\treturn [max_val,\
    \ min_val];\n}\n", "    if (lst.length == 0) return (None, None)\n    var max\
    \ = -Infinity\n    var min = Infinity\n    for(var i = 0; i < lst.length; i++){\n\
    \        if (lst[i] < 0){\n            min = lst[i]\n        } else if (lst[i]\
    \ > 0){\n            max = lst[i]\n        }\n    }\n    return (max, min)\n}\n",
  "    if(lst.length < 3){\n        return [lst];\n    }\n\n    let max_i = lst.length\
    \ - 1;\n    let min_i = lst.length - 1;\n\n    for(let i = lst.length - 1; i >=\
    \ 0; i--){\n        if(lst[i] < lst[min_i]){\n            min_i = i;\n       \
    \ }\n\n        if(lst[i] > lst[max_i]){\n            max_i = i;\n        }\n \
    \   }\n\n    if(min_i === 0){\n        return [None, None];\n    }\n\n    if(max_i\
    \ === 0){\n        return [lst[0], None];\n    }\n\n    return [lst[min_i], lst[max_i]];\n\
    }\n</code>\nNow you just need to write something that returns what your function\
    \ returns. I used the Python library for this.\n<code>\n# python 3.6\nfrom funcy\
    \ import fmap, recursive_map\ndef largest_smallest_integers(lst):\n    return\
    \ recursive_map(largest_smallest_integers, lst)\n</code>\nThe function largest_smallest_integers(lst)\
    \ returns the list that contains the largest and smallest integers from your original\
    \ list. \nFor example, largest_smallest_integers([2, 4, 1, 3, 5, 7]) == [1, 3]\n\
    <|/ a dscore=0 |>\n<| a tags=algorithm,python |>\n<code>\ndef largest_smallest_integers(lst):\n\
    \  smallest = largest_integer(lst)\n  largest = smallest\n  for i in range(len(lst)):\n\
    \    current = lst[i]\n    next = lst[i + 1]\n    if current > next:\n      largest\
    \ = next\n    elif current < next:\n      smallest = current\n  return smallest,\
    \ largest\n\ndef largest_integer(lst):\n  if len(lst) <= 2:\n    return lst[0]\n\
    \  largest = lst[0]\n  smallest = lst[0]\n  for i in range(1, len(lst)):\n   \
    \ if lst[i] > largest:\n      largest = lst[i]\n    elif lst[i] < smallest:\n\
    \      smallest = lst[i]\n  return largest\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,python\
    \ |>\nHere is my solution:\n<code>\ndef largest_smallest_integers(lst):\n    smallest\
    \ = lst[0]\n    largest = lst[0]\n    for num in lst[1:]:\n        if num < largest:\n\
    \            largest = num\n        elif num > smallest:\n            smallest\
    \ = num\n    return smallest, largest\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,python\
    \ |>\n<code>\n    def largest_smallest_integers(lst):\n        if lst:\n     \
    \       smallest = lst[0]\n            largest = lst", "  let largest = undefined;\n\
    \  let smallest = undefined;\n  for(let value of lst){\n    if(largest === undefined){\n\
    \      largest = value;\n    }else{\n      if(value < largest){\n        largest\
    \ = value;\n      }\n    }\n    if(smallest === undefined || value < smallest){\n\
    \      smallest = value;\n    }\n  }\n  return [largest, smallest];\n}\n", " \
    \ if(lst.includes(null)) return (null, null);\n  let max = null\n  let min = null\n\
    \  for(let i = 0; i < lst.length; i++){\n    for(let j = 0; j < lst.length; j++){\n\
    \      if(i === j) continue;\n      if(lst.includes(lst[j])){\n        if(max\
    \ == null || lst[j] > max)\n          max = (lst[j], j)\n        if(min == null\
    \ || lst[j] < min)\n          min = (lst[j], j)\n      }\n    }\n  }\n  return\
    \ [max, min]\n}\n", "  if(lst.length == 0){\n    return [None, None];\n  }\n \
    \ var min = 0;\n  var max = 0;\n  for(var i=0; i<lst.length; i++){\n    var x\
    \ = lst[i];\n    if(x<min){\n      min = x;\n    } else if(x>max){\n      max\
    \ = x;\n    }\n  }\n  return [max, min];\n}\n", "  var smaller_than_largest_positive\
    \ = [];\n  var smaller_than_largest_negative = [];\n\n  for (var i = 0; i < lst.length;\
    \ i++){\n    if(lst[i] >= 0){\n      smaller_than_largest_positive.push(lst[i]);\n\
    \    } else {\n      smaller_than_largest_negative.push(lst[i]);\n    }\n  }\n\
    \  if (smaller_than_largest_positive.length > smaller_than_largest_negative.length){\n\
    \    return smaller_than_largest_positive;\n  } else {\n    return smaller_than_largest_negative;\n\
    \  }\n}\nvar test_large_st_sm_int =\n  largest_smallest_integers([1, 3, 5, 2,\
    \ 4, 7]).join(',') + '\\n';\nvar test_large_st_sm_nt =\n  largest_smallest_integers([-1,\
    \ 2, 5, -2, 4, 7]).join(',') + '\\n';\nvar test_large_st_sm_nl = largest_smallest_integers([-1,\
    \ 2, -3, 5, -2, 4, 7]).join(',') + '\\n';\n", "  var max_num = -Infinity\n  var\
    \ min_num = Infinity\n  var max_num = -Infinity\n  var min_num = Infinity\n  for\
    \ (var x = 0; x < lst.length; x++){\n    if (lst[x] < min_num){\n      min_num\
    \ = lst[x]\n    }\n    if (lst[x] > max_num){\n      max_num = lst[x]\n    }\n\
    \  }\n  if (max_num == -Infinity){\n    return (None, None)\n  } else if (min_num\
    \ == Infinity){\n    return (None, None)\n  }\n  return (max_num, min_num)\n}\n",
  "    var largest = None;\n    var smallest = None;\n    \n    for (i in lst){\n\
    \        if (lst[i]>largest && largest != None)\n            largest = lst[i];\n\
    \        if (lst[i]<smallest && smallest != None)\n            smallest = lst[i];\n\
    \    }\n    return largest, smallest;\n}\n", "  if (lst.every((number) => number\
    \ > 0)){\n    return (lst.sort((a,b)=>a-b).slice(-1)[0],lst.slice(-1)[0])\n  }\n\
    \  if (lst.every((number) => number < 0)){\n    return (lst.sort((a,b)=>b-a).slice(-1)[0],lst.slice(-1)[0])\n\
    \  }\n  return (None, None)\n}\n", "  var max = -Infinity;\n  var min = Infinity;\n\
    \  for(var i = 0; i < lst.length; i++){\n    if(lst[i] < min)\n      min = lst[i];\n\
    \    else if(lst[i] > max)\n      max = lst[i];\n  }\n  return [max, min];\n}\n",
  "  let smallest = 0;\n  let largest = 0;\n  for(let element of lst){\n    smallest\
    \ = smallest < element ? element : smallest;\n    largest = largest > element\
    \ ? element : largest;\n  }\n  return [smallest, largest]\n}\n", "\tvar max =\
    \ -1;\n\tvar min = +Infinity;\n\tfor (var i = 0; i < lst.length; i++) {\n\t\t\
    if (lst[i] < min) min = lst[i];\n\t\tif (lst[i] > max) max = lst[i];\n\t}\n\t\
    return [max, min];\n}\n", "  // Your code here\n  var max = -Infinity;\n  var\
    \ min = -Infinity;\n\n  for (var i = 0; i < lst.length; i++){\n    if (lst[i]\
    \ < min) min = lst[i];\n    if (lst[i] > max) max = lst[i];\n  }\n  return [max,\
    \ min];\n}\n", "  let max_num;\n  let min_num;\n  lst.forEach(function(item){\n\
    \    if(item < 0) {\n      if(max_num == null || item > max_num){\n        max_num\
    \ = item\n      }\n    } else if(item > 0) {\n      if(min_num == null || item\
    \ < min_num){\n        min_num = item\n      }\n    }\n  })\n  return [max_num,\
    \ min_num]\n}", "\tvar largest = Number.MAX_VALUE;\n\tvar smallest = Number.MIN_VALUE;\n\
    \tvar i;\n\tvar lenlst = lst.length;\n\tfor (i=0; i< lenlst; i++){\n\t\tif (lst[i]\
    \ < smallest){ smallest = lst[i]; }\n\t\tif (lst[i] > largest){ largest = lst[i];\
    \ }\n\t}\n\treturn [largest,smallest];\n}\n", "  if (lst.length === 0) {\n   \
    \ return [0, 0];\n  }\n  const max_num = Math.max.apply(null, lst);\n  const min_num\
    \ = Math.min.apply(null, lst);\n  if (max_num < min_num){\n    return [max_num,\
    \ min_num];\n  }\n  else { //if both are negative, pick the smallest\n    return\
    \ [min_num, max_num];\n  }\n}\n", "    // First sort the list into descending\
    \ order by the number of negative\n    // and positive integers.\n    lst.sort(function(a,\
    \ b){\n        let is_neg = (a<0)?true:false;\n        let is_pos = (b<0)?true:false;\n\
    \        return (is_neg && !is_pos)-(is_pos && is_neg);\n    });\n\n    // Now\
    \ go through the list, keeping track of the first non-negative\n    // integer\
    \ and the first non-positive integer, and return the largest.\n    let first_non_neg\
    \ = null;\n    let first_non_pos = null;\n    let curr_non_neg = null;\n    let\
    \ curr_non_pos = null;\n    let ret = null;\n    for(let i=0; i<lst.length; i++){\n\
    \        // If this isn't the first iteration, make some changes to the\n    \
    \    // current non-negative/non-positive integer.\n        if(i !== 0){\n   \
    \         curr_non_neg = first_non_neg;\n            curr_non_pos = first_non_pos;\n\
    \        }\n\n        // If this is the first iteration, 'curr_non_neg' is 'lst[i]',\n\
    \        // otherwise the current non-negative/non-positive integer is\n     \
    \   // 'lst[i]'.\n        if(i === 0){\n            first_non_neg = lst[i];\n\
    \            first_non_pos = lst[i];\n        } else {\n            // Find the\
    \ largest of these two integers, and store that value\n            // in the current\
    \ non-negative/non-positive integer.\n            curr_non_neg = (curr_non_neg\
    \ < first_non_neg) ? curr_non_neg : first_non_neg;\n            curr_non_pos =\
    \ (curr_non_pos > first_non_pos) ? curr_non_pos : first_non_pos;\n        }\n\
    \        // If a negative integer has been encountered, return the largest\n \
    \       // of those two.\n        if((curr_non_neg < 0) || (curr_non_pos < 0)){\n\
    \            ret = Math.max(first_non_neg, first_non_pos);\n            break;\n\
    \        }\n    }\n\n    // Return the result of the largest_smallest_integers()\
    \ function.\n    return ret;\n}\n", "    \n  // Initialize a tuple containing\
    \ all possible negative integers\n  let neg_ints = Array(lst.length).fill(0).map((_,i)=>{\n\
    \    if (i%2 == 1) return -(i+1);\n    else return -i;\n  });\n  \n  // Initialize\
    \ a tuple containing all possible positive integers\n  let pos_ints = Array(lst.length).fill(0).map((_,i)=>{\n\
    \    if (i%2 == 1) return i+1;\n    else return i;\n  });\n  \n  // Initialize\
    \ a tuple containing all possible integers\n  let all_ints = Array(lst.length).fill(0).map((_,i)=>{\n\
    \    return (i%2 == 0) ? pos_ints[i] : neg_ints[i];\n  });\n  \n  // Find largest\
    \ and smallest values in all possible integers tuples\n  let greatest = all_ints.reduce((max,val)=>{\n\
    \    if (val > max) return val;\n  }, Number.NEGATIVE_INFINITY);\n  let smallest\
    \ = all_ints.reduce((min,val)=>{\n    if (val < min) return val;\n  }, Number.POSITIVE_INFINITY);\n\
    \  \n  // Return tuple containing largest and smallest values\n  return [greatest,\
    \ smallest]\n}\n</cell>\n<cell>", "    if(lst.length < 1){\n        return [None,\
    \ None];\n    }\n\n    var largest = undefined;\n    var smallest = undefined;\n\
    \    for(var i = 0; i < lst.length; i++){\n        if(largest === undefined ||\
    \ largest < lst[i]){\n            largest = lst[i];\n        }\n        if(smallest\
    \ === undefined || smallest > lst[i]){\n            smallest = lst[i];\n     \
    \   }\n    }\n\n    return [largest, smallest];\n}\n", "  var max = -Infinity;\n\
    \  var min = Infinity;\n  for(var i = 0; i < lst.length; i++){\n    if(lst[i]\
    \ < min){\n      min = lst[i];\n    }\n    if(lst[i] > max){\n      max = lst[i];\n\
    \    }\n  }\n  return [max, min];\n}\n", "\tconst smallest = lst.filter(x => x\
    \ < 0).length;\n\tconst largest = lst.filter(x => x > 0).length;\n\tif (smallest\
    \ < largest) return (lst.filter(x => x < 0).length, (lst.filter(x => x > 0).length));\n\
    \treturn (None, None)\n}\n", "  let max_number = lst[0]\n  let min_number = lst[0]\n\
    \  \n  for (let i = 1; i < lst.length; i++){\n    if (lst[i] > max_number) max_number\
    \ = lst[i]\n    else if (lst[i] < min_number) min_number = lst[i]\n  }\n  \n \
    \ return [max_number, min_number]\n}\n</cell>\n<cell>", "  if (lst.includes(-Infinity))\
    \ {\n    return [null,-Infinity];\n  } else if (lst.includes(Infinity)) {\n  \
    \  return [null, Infinity];\n  }\n  // A queue of numbers. Queue is implemented\
    \ as a max heap,\n  // since finding the largest or smallest value in it takes\
    \ O(n) time\n  // where 'n' is the length of the queue.\n  let queue = [];\n \
    \ queue.push(0);\n  while (queue.length > 0) {\n    // Get a number from the queue,\
    \ and remove it from the queue\n    let curr = queue.pop();\n    let largest =\
    \ curr > 0 ? curr : null;\n    let smallest = curr < 0 ? curr : null;\n    //\
    \ Compare it to the rest of the numbers in the queue\n    for (let num of lst)\
    \ {\n      if (num > curr) {\n        queue.push(num);\n      } else if (num <\
    \ curr) {\n        if (smallest == null) {\n          smallest = num;\n      \
    \  } else if (num < smallest) {\n          smallest = num;\n        }\n      }\n\
    \    }\n    // If the queue is non-empty, store it in 'a' and 'b'.\n    if (queue.length\
    \ > 0) {\n      [largest, smallest] = [smallest, largest];\n    }\n    return\
    \ [largest, smallest];\n  }\n}", "  let smallest=Number.MAX_SAFE_INTEGER;\n  let\
    \ largest=Number.MIN_SAFE_INTEGER;\n  for (const num of lst) {\n    if (num<smallest)\
    \ {smallest=num};\n    if (num>largest) {largest=num};\n  }\n  if (smallest==Number.MIN_SAFE_INTEGER\
    \ && largest==Number.MAX_SAFE_INTEGER){\n    return (None,None);\n  }\n  else\
    \ {\n    return (smallest,largest);\n  }\n}\n", "  if (lst.includes(0) || lst.includes(-1)){\n\
    \    return (\"None\", \"None\");\n  }\n  else{\n    if (lst.includes(lst.sort(function(a,b){return\
    \ b-a;}).pop())){\n      return (\"None\", \"None\");\n    }\n    else {\n   \
    \   var largest = lst.sort(function(a,b){return b-a;}).pop();\n      var smallest\
    \ = lst.sort(function(a,b){return a - b;}).pop();\n      return (largest, smallest);\n\
    \    }\n  }\n}\n", "\tlet max_val = lst[0];\n\tlet min_val = lst[0];\n\tfor(let\
    \ i = 1; i < lst.length; i++){\n\t\tconst el = lst[i];\n\t\tif(max_val < el){\n\
    \t\t\tmax_val = el;\n\t\t} else if(min_val > el){\n\t\t\tmin_val = el;\n\t\t}\n\
    \t}\n\treturn [max_val, min_val];\n}\n", "    if(lst.length < 2){\n        return\
    \ [None, None];\n    }\n    // find largest and smallest numbers\n    let max_num\
    \ = lst[0];\n    let min_num = lst[0];\n    for(let i = 1; i < lst.length; i++){\n\
    \        if(lst[i] > max_num){\n            max_num = lst[i];\n        }\n   \
    \     if(lst[i] < min_num){\n            min_num = lst[i];\n        }\n    }\n\
    \    return [max_num, min_num];\n}\n", "    var l = lst.length;\n    if(l===0)\
    \ return (None, None)\n    if(l===1) return (lst[0], None)\n    if(l<0){\n   \
    \     var largest = largest_smallest_integers(lst.slice(0,l));\n        if(largest[0]!==None)\n\
    \            return (largest[0], largest[1])\n    }\n    var m = lst.length >>\
    \ 1;\n    \n    var left = [\n        largest_smallest_integers(lst.slice(0, m)),\n\
    \        largest_smallest_integers(lst.slice(m))\n    ];\n    \n    if(left[0]!==None){\n\
    \        var right = [\n            largest_smallest_integers(lst.slice(m, 2*m)),\n\
    \            largest_smallest_integers(lst.slice(2*m))\n        ];\n        \n\
    \        var a = right[0];\n        var b = left[0];\n        \n        if(a ===\
    \ None){\n            return (None, None)\n        }else if(b === None){\n   \
    \         return (None, None)\n        }else if(a[0]>b[0]){\n            return\
    \ (right[0], a[1])\n        }else{\n            return (left[0], b[1])\n     \
    \   }\n    }else if(left[0]===None){\n        return (None, None)\n    }else{\n\
    \        return (left[0], left[1])\n    }\n}\n", "   var largest, smallest, i,\
    \ j, len;\n   len = lst.length;\n   largest = smallest = Number.POSITIVE_INFINITY;\n\
    \n   for (i = 0; i < len; i++) {\n      if (lst[i] > largest) {\n         largest\
    \ = lst[i];\n      }\n      if (lst[i] < smallest) {\n         smallest = lst[i];\n\
    \      }\n   }\n   return [largest, smallest];\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
