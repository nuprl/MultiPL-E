language: jl
name: HumanEval_87_get_row
results:
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    for i in 1:length(result)\n        if i != 1 && result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by=x->x[2], rev=true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpjvu5hlov.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpjvu5hlov.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpjvu5hlov.jl:40\ntest set: Test Failed at /tmp/tmpjvu5hlov.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpjvu5hlov.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpjvu5hlov.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for (i, row) in enumerate(lst)\n\
    \        for (j, elem) in enumerate(row)\n            if elem == x\n         \
    \       push!(res, (i, j))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    for i in 1:length(res)\n        sort!(res[i], by = x ->\
    \ -x[2])\n    end\n    return res\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmp5pa27yjl.jl:39\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    no method matching sort!(::Tuple{Int64, Int64}; by=var"#2#4"())\n  Closest candidates
    are:\n    sort!(!Matched::AbstractUnitRange) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1305
    got unsupported keyword argument "by"\n    sort!(!Matched::AbstractVector{<:Union{Missing,
    Float32, Float64}}, !Matched::Base.Sort.Algorithm, !Matched::Base.Order.DirectOrdering)
    at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1234 got unsupported keyword
    argument "by"\n    sort!(!Matched::Vector{Int64}, !Matched::Base.Sort.Algorithm,
    !Matched::Base.Order.Perm{<:Base.Order.DirectOrdering, <:Vector{<:Union{Missing,
    Float32, Float64}}}) at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1236
    got unsupported keyword argument "by"\n    ...\n  Stacktrace:\n   [1] get_row(lst::Vector{Vector{Int64}},
    x::Int64)\n     @ Main /tmp/tmp5pa27yjl.jl:30\n   [2] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [3]
    macro expansion\n     @ /tmp/tmp5pa27yjl.jl:39 [inlined]\n   [4] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [5]
    top-level scope\n     @ /tmp/tmp5pa27yjl.jl:38\ntest set: Error During Test at
    /tmp/tmp5pa27yjl.jl:40\n  Test threw exception\n  Expression: candidate([[1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1),
    (5, 1)]\n  MethodError: no method matching sort!(::Tuple{Int64, Int64}; by=var"#2#4"())\n  Closest
    candidates are:\n    sort!(!Matched::AbstractUnitRange) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1305
    got unsupported keyword argument "by"\n    sort!(!Matched::AbstractVector{<:Union{Missing,
    Float32, Float64}}, !Matched::Bas'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmphhs6al1d.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmphhs6al1d.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmphhs6al1d.jl:27\ntest set: Test Failed
    at /tmp/tmphhs6al1d.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmphhs6al1d.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmphhs6al1d.jl:27\ntest set: Test Failed
    at /tmp/tmphhs6al1d.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmphhs6al1d.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmp3f8zie6y.jl:27\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    Cannot `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,
    Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmp3f8zie6y.jl:21\n   [2]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3f8zie6y.jl:27 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3f8zie6y.jl:26\ntest set: Error
    During Test at /tmp/tmp3f8zie6y.jl:28\n  Test threw exception\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,
    1), (5, 1)]\n  MethodError: Cannot `convert` an object of type Nothing to an object
    of type Vector{Tuple{Int64, Int64}}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/jul'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = (x->x[1]))\n    sort!(result, by = (x->x[2]), rev=true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpnxq4urjh.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpnxq4urjh.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpnxq4urjh.jl:36\ntest set: Test Failed at /tmp/tmpnxq4urjh.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpnxq4urjh.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpnxq4urjh.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmp8dzwagd8.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp8dzwagd8.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmp8dzwagd8.jl:27\ntest set: Test Failed
    at /tmp/tmp8dzwagd8.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp8dzwagd8.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmp8dzwagd8.jl:27\ntest set: Test Failed
    at /tmp/tmp8dzwagd8.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp8dzwagd8.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    for i in 1:length(result)\n        if i > 1 && result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by=x->x[2], rev=true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpog1pmek7.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpog1pmek7.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpog1pmek7.jl:40\ntest set: Test Failed at /tmp/tmpog1pmek7.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpog1pmek7.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpog1pmek7.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by = x -> x[1])\n    for i in 1:length(result)\n\
    \        if i > 1 && result[i][1] == result[i-1][1]\n            sort!(result[i-1:i],\
    \ by = x -> x[2], rev = true)\n        end\n    end\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpaej0g912.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpaej0g912.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpaej0g912.jl:40\ntest set: Test Failed at /tmp/tmpaej0g912.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpaej0g912.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpaej0g912.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by = x -> x[1])\n    for i in 1:length(result)\n\
    \        if i != 1 && result[i][1] == result[i-1][1]\n            sort!(result[i-1:i],\
    \ by = x -> x[2], rev = true)\n        end\n    end\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpd7x4r3ql.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpd7x4r3ql.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpd7x4r3ql.jl:40\ntest set: Test Failed at /tmp/tmpd7x4r3ql.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpd7x4r3ql.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpd7x4r3ql.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpi9egfn3e.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpi9egfn3e.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpi9egfn3e.jl:36\ntest set: Test Failed at /tmp/tmpi9egfn3e.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpi9egfn3e.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpi9egfn3e.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpu49hyhkr.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpu49hyhkr.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpu49hyhkr.jl:27\ntest set: Test Failed
    at /tmp/tmpu49hyhkr.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpu49hyhkr.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpu49hyhkr.jl:27\ntest set: Test Failed
    at /tmp/tmpu49hyhkr.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpu49hyhkr.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpd2kz6zso.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpd2kz6zso.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpd2kz6zso.jl:27\ntest set: Test Failed
    at /tmp/tmpd2kz6zso.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpd2kz6zso.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpd2kz6zso.jl:27\ntest set: Test Failed
    at /tmp/tmpd2kz6zso.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpd2kz6zso.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    for i in 1:length(result)\n        if i > 1 && result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by=x->x[2], rev=true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpfqc4dssg.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpfqc4dssg.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpfqc4dssg.jl:40\ntest set: Test Failed at /tmp/tmpfqc4dssg.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpfqc4dssg.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpfqc4dssg.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> (x[1], -x[2]))\n    return result\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Error During Test at /tmp/tmplz5p75f4.jl:41\n  Test threw
    exception\n  Expression: candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError:
    no method matching get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates
    are:\n    get_row(!Matched::Vector{Vector{Int64}}, ::Int64) at /tmp/tmplz5p75f4.jl:19\n  Stacktrace:\n   [1]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [2] macro expansion\n     @ /tmp/tmplz5p75f4.jl:41 [inlined]\n   [3]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [4] top-level scope\n     @ /tmp/tmplz5p75f4.jl:35\nTest Summary:
    | Pass  Error  Total\ntest set      |    5      1      6\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    for i in 1:length(result)\n        if i > 1 && result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by = x -> x[2], rev = true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptck653jq.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmptck653jq.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmptck653jq.jl:40\ntest set: Test Failed at /tmp/tmptck653jq.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptck653jq.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptck653jq.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmp6wu529wz.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmp6wu529wz.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmp6wu529wz.jl:36\ntest set: Test Failed at /tmp/tmp6wu529wz.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp6wu529wz.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmp6wu529wz.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpq1etxsjg.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpq1etxsjg.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpq1etxsjg.jl:36\ntest set: Test Failed at /tmp/tmpq1etxsjg.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpq1etxsjg.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpq1etxsjg.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    for i in 1:length(result)\n        if i > 1 && result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by = x -> x[2], rev = true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptck653jq.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmptck653jq.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmptck653jq.jl:40\ntest set: Test Failed at /tmp/tmptck653jq.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptck653jq.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptck653jq.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    res = []\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(res, (i-1, j-1))\n            end\n  \
    \      end\n    end\n    sort!(res, by=x->x[1])\n    sort!(res, by=x->x[2], rev=true)\n\
    \    return res\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 1 errored,
    0 broken.\nin expression starting at /tmp/tmpa8mkltln.jl:35\n'''
  stdout: 'b''test set: Test Failed at /tmp/tmpa8mkltln.jl:38\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpa8mkltln.jl:38 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpa8mkltln.jl:37\ntest set: Test Failed at /tmp/tmpa8mkltln.jl:40\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpa8mkltln.jl:40 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpa8mkltln.jl:37\ntest set: Error
    During Test at /tmp/tmpa8mkltln.jl:43\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpa8mkltln.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpa8mkltln.jl:43 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code goes here\n    return\
    \ []\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpqrt3qstb.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpqrt3qstb.jl:28\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqrt3qstb.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqrt3qstb.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpqrt3qstb.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1),\
    \ (4, 1), (5, 1)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqrt3qstb.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqrt3qstb.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpqrt3qstb.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqrt3qstb.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tm"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmp3f8zie6y.jl:27\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    Cannot `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,
    Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmp3f8zie6y.jl:21\n   [2]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3f8zie6y.jl:27 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3f8zie6y.jl:26\ntest set: Error
    During Test at /tmp/tmp3f8zie6y.jl:28\n  Test threw exception\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,
    1), (5, 1)]\n  MethodError: Cannot `convert` an object of type Nothing to an object
    of type Vector{Tuple{Int64, Int64}}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/jul'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    sort!(res, by = x -> x[2], rev = true)\n    return res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpex9w7l6z.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Test Failed at /tmp/tmpex9w7l6z.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Error
    During Test at /tmp/tmpex9w7l6z.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpex9w7l6z.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpex9w7l6z.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    sort!(res, by = x -> x[2], rev = true)\n    return res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpex9w7l6z.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Test Failed at /tmp/tmpex9w7l6z.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Error
    During Test at /tmp/tmpex9w7l6z.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpex9w7l6z.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpex9w7l6z.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    sort!(result, by=x->x[2], rev=true)\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmp0b8ms53j.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmp0b8ms53j.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmp0b8ms53j.jl:36\ntest set: Test Failed at /tmp/tmp0b8ms53j.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp0b8ms53j.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmp0b8ms53j.jl:36\ntest set: Error
    During Test at /tmp/tmp0b8ms53j.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmp0b8ms53j.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmp0b8ms53j.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Tuple{Int64, Int64}[]\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by=x->x[1])\n    sort!(result, by=x->x[2],\
    \ rev=true)\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpcb4doapt.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpcb4doapt.jl:37\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0),\
    \ (2, 0)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcb4doapt.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcb4doapt.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpcb4doapt.jl:39\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0), (1, 0), (2, 0),\
    \ (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcb4doapt.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcb4doapt.jl:36\ntest set: Error\
    \ During Test at /tmp/tmpcb4doapt.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching\
    \ get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},\
    \ ::Int64) at /tmp/tmpcb4doapt.jl:19\n  Stacktrace:\n   [1] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [2] macro expansion\n     @ /tmp/tmpcb4doapt.jl:42 [inlined]\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1."
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmp3f8zie6y.jl:27\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    Cannot `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,
    Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmp3f8zie6y.jl:21\n   [2]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3f8zie6y.jl:27 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3f8zie6y.jl:26\ntest set: Error
    During Test at /tmp/tmp3f8zie6y.jl:28\n  Test threw exception\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,
    1), (5, 1)]\n  MethodError: Cannot `convert` an object of type Nothing to an object
    of type Vector{Tuple{Int64, Int64}}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/jul'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    # return\
    \ []\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpqy0etxkl.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmpqy0etxkl.jl:28\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,\
    \ Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmpqy0etxkl.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqy0etxkl.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqy0etxkl.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpqy0etxkl.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Tuple{Int64, Int64}}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abs"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    sort!(result, by=x->x[2], rev=true)\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmp0b8ms53j.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmp0b8ms53j.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmp0b8ms53j.jl:36\ntest set: Test Failed at /tmp/tmp0b8ms53j.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp0b8ms53j.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmp0b8ms53j.jl:36\ntest set: Error
    During Test at /tmp/tmp0b8ms53j.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmp0b8ms53j.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmp0b8ms53j.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for (i, row) in\
    \ enumerate(lst)\n        for (j, item) in enumerate(row)\n            if item\
    \ == x\n                push!(result, (i, j))\n            end\n        end\n\
    \    end\n    sort!(result, by=x->x[1])\n    for i in 1:length(result)\n     \
    \   if i > 1 && result[i][1] == result[i-1][1]\n            sort!(result[i-1:i],\
    \ by=x->x[2], rev=true)\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: '''
  stdout: 'b''test set: Test Failed at /tmp/tmp300_89am.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(1, 1), (2, 1), (2, 5), (3, 1), (3, 6)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmp300_89am.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmp300_89am.jl:40\ntest set: Test Failed at /tmp/tmp300_89am.jl:42\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2,
    1), (3, 1), (4, 1), (5, 1)]\n   Evaluated: [(1, 2), (2, 2), (3, 2), (4, 2), (5,
    2), (6, 2)] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp300_89am.jl:42 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmp300_89am.jl:40\ntest set: Test Failed
    at /tmp/tmp300_89am.jl:43\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: [(1, 1),
    (2, 1), (3, 1), (3, 2), (4, 1), (4, 3), (5, 1), (5, 4), (6, 1), (6, 5), (7, 1),
    (7, 6)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp300_89am.j'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    for i in 1:length(result)\n        if i != 1 && result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by = x -> x[2], rev = true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: '''
  stdout: 'b''test set: Test Failed at /tmp/tmp3jl1py2s.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmp3jl1py2s.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmp3jl1py2s.jl:40\ntest set: Test Failed at /tmp/tmp3jl1py2s.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp3jl1py2s.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmp3jl1py2s.jl:40\ntest set: Error
    During Test at /tmp/tmp3jl1py2s.jl:46\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmp3jl1py2s.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmp3jl1py2s.jl:46 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    sort!(res, by = x -> x[2], rev = true)\n    return res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpex9w7l6z.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Test Failed at /tmp/tmpex9w7l6z.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Error
    During Test at /tmp/tmpex9w7l6z.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpex9w7l6z.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpex9w7l6z.jl:42 [inlined]\n   [3] macro expa'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    for i in 1:length(res)\n        if res[i][1] == res[i-1][1]\n\
    \            sort!(res[i-1:i], by = x -> x[2], rev = true)\n        end\n    end\n\
    \    return res\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp218mng4c.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmp218mng4c.jl:41\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  BoundsError: attempt\
    \ to access 5-element Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmp218mng4c.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp218mng4c.jl:41 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp218mng4c.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp218mng4c.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  BoundsError: attempt to access 6-element\
    \ Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861\
    \ [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main\
    \ /tmp/tmp218mng4c.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp218mng4c.jl:42 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp218mng4c.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp218mng4c.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,\
    \ 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\
    \ == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]\n  BoundsError: attempt to access 12-element Vector{Any}\
    \ at index [0]\n  Stacktrace:\n   [1] ge"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    row_col = []\n    for (i, row)\
    \ in enumerate(lst)\n        for (j, col) in enumerate(row)\n            if col\
    \ == x\n                push!(row_col, (i, j))\n            end\n        end\n\
    \    end\n    sort!(row_col, by = x -> x[1])\n    for i in 1:length(row_col)\n\
    \        sort!(row_col[i], by = x -> x[2], rev = true)\n    end\n    return row_col\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp9wvbzlzo.jl:36

    '
  stdout: "test set: Error During Test at /tmp/tmp9wvbzlzo.jl:39\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: no method\
    \ matching sort!(::Tuple{Int64, Int64}; by=var\"#2#4\"(), rev=true)\n  Closest\
    \ candidates are:\n    sort!(!Matched::AbstractUnitRange) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1305\
    \ got unsupported keyword arguments \"by\", \"rev\"\n    sort!(!Matched::AbstractVector{<:Union{Missing,\
    \ Float32, Float64}}, !Matched::Base.Sort.Algorithm, !Matched::Base.Order.DirectOrdering)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1234 got unsupported\
    \ keyword arguments \"by\", \"rev\"\n    sort!(!Matched::Vector{Int64}, !Matched::Base.Sort.Algorithm,\
    \ !Matched::Base.Order.Perm{<:Base.Order.DirectOrdering, <:Vector{<:Union{Missing,\
    \ Float32, Float64}}}) at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1236\
    \ got unsupported keyword arguments \"by\", \"rev\"\n    ...\n  Stacktrace:\n\
    \   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmp9wvbzlzo.jl:30\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9wvbzlzo.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9wvbzlzo.jl:38\ntest set:\
    \ Error During Test at /tmp/tmp9wvbzlzo.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  MethodError: no method matching sort!(::Tuple{Int64,\
    \ Int64}; by=var\"#2#4\"(), rev=true)\n  Closest candidates are:\n    sort!(!Matched::AbstractUnitRange)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1305 got unsupported\
    \ keyword arguments \"by\", \"rev\"\n    sort!(!Matched::AbstractVector{<:Union{Missing,\
    \ Float32, "
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    sort!(res, by = x -> x[2], rev = true)\n    return res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpex9w7l6z.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Test Failed at /tmp/tmpex9w7l6z.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Error
    During Test at /tmp/tmpex9w7l6z.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpex9w7l6z.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpex9w7l6z.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmp3f8zie6y.jl:27\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    Cannot `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,
    Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmp3f8zie6y.jl:21\n   [2]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3f8zie6y.jl:27 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3f8zie6y.jl:26\ntest set: Error
    During Test at /tmp/tmp3f8zie6y.jl:28\n  Test threw exception\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,
    1), (5, 1)]\n  MethodError: Cannot `convert` an object of type Nothing to an object
    of type Vector{Tuple{Int64, Int64}}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/jul'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by = x -> x[1])\n    sort!(result, by\
    \ = x -> x[2], rev = true)\n    return result\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpe4tlqv40.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpe4tlqv40.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpe4tlqv40.jl:36\ntest set: Test Failed at /tmp/tmpe4tlqv40.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpe4tlqv40.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpe4tlqv40.jl:36\ntest set: Error
    During Test at /tmp/tmpe4tlqv40.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpe4tlqv40.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpe4tlqv40.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    # hint: use\
    \ findall\n    # hint: use sort\n    # hint: use sort!\n    # hint: use reverse!\n\
    \    # hint: use zip\n    # hint: use map\n    # hint: use collect\n    # hint:\
    \ use enumerate\n    # hint: use filter\n    # hint: use map\n    # hint: use\
    \ collect\n    # hint: use sort\n    # hint: use sort!\n    # hint: use reverse!\n\
    \    # hint: use map\n    # hint: use collect\n    # hint: use sort\n    # hint:\
    \ use sort!\n    # hint: use reverse!\n    # hint: use map\n    # hint: use collect\n\
    \    # hint: use sort\n    # hint: use sort!\n    # hint: use reverse!\n    #\
    \ hint: use map\n    # hint: use collect\n    # hint: use sort\n    # hint: use\
    \ sort!\n    # hint: use reverse!\n    # hint: use map\n    # hint: use collect\n\
    \    # hint: use sort\n    # hint: use sort!\n    # hint: use reverse!\n    #\
    \ hint: use map\n    # hint: use collect\n    # hint: use sort\n    # hint: use\
    \ sort!\n    # hint: use reverse!\n    # hint: use map\n    # hint: use collect\n\
    \    # hint: use sort\n    # hint: use sort!\n    # hint: use reverse!\n    #\
    \ hint: use map\n    # hint: use collect\n    # hint: use sort\n    # hint: use\
    \ sort!\n    # hint: use reverse!\n    # hint: use map\n    # hint: use collect\n\
    \    # hint: use sort\n    # hint: use sort!\n    # hint: use reverse!\n    #\
    \ hint: use map\n    # hint: use collect\n    # hint: use sort\n    # hint: use\
    \ sort!\n    # hint: use reverse!\n    # hint: use map\n    # hint: use collect\n\
    \    # hint: use sort\n    # hint: use sort!\n    # hint: use reverse!\n    #\
    \ hint: use map\n    # hint: use collect\n    # hint: use sort\n    # hint: use\
    \ sort!\n    #\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpuqp6zc5t.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpuqp6zc5t.jl:1\n\
    in expression starting at /tmp/tmpuqp6zc5t.jl:1\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    for i in 1:length(result)\n        if i != 1 && result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by = x -> x[2], rev = true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: '''
  stdout: 'b''test set: Test Failed at /tmp/tmp3jl1py2s.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmp3jl1py2s.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmp3jl1py2s.jl:40\ntest set: Test Failed at /tmp/tmp3jl1py2s.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp3jl1py2s.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmp3jl1py2s.jl:40\ntest set: Error
    During Test at /tmp/tmp3jl1py2s.jl:46\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmp3jl1py2s.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmp3jl1py2s.jl:46 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpdqcfd2mu.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpdqcfd2mu.jl:27\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,\
    \ Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmpdqcfd2mu.jl:21\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdqcfd2mu.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdqcfd2mu.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpdqcfd2mu.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Tuple{Int64, Int64}}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abs"
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmph96stm38.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmph96stm38.jl:27\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,\
    \ Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmph96stm38.jl:21\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph96stm38.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph96stm38.jl:26\ntest set:\
    \ Error During Test at /tmp/tmph96stm38.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Tuple{Int64, Int64}}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abs"
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    for i in 1:length(result)\n        if result[i][1] == result[i-1][1]\n\
    \            sort!(result[i-1:i], by=x->x[2], rev=true)\n        end\n    end\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpzs_0a9d6.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpzs_0a9d6.jl:41\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  BoundsError: attempt\
    \ to access 5-element Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmpzs_0a9d6.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpzs_0a9d6.jl:41 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpzs_0a9d6.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpzs_0a9d6.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  BoundsError: attempt to access 6-element\
    \ Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861\
    \ [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main\
    \ /tmp/tmpzs_0a9d6.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpzs_0a9d6.jl:42 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpzs_0a9d6.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpzs_0a9d6.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,\
    \ 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\
    \ == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]\n  BoundsError: attempt to access 12-element Vector{Any}\
    \ at index [0]\n  Stacktrace:\n   [1] ge"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    row_col = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(row_col, (i-1, j-1))\n            end\n        end\n    end\n   \
    \ sort!(row_col, by = x -> x[1])\n    sort!(row_col, by = x -> x[2], rev = true)\n\
    \    return row_col\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpkiieqrv9.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpkiieqrv9.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpkiieqrv9.jl:36\ntest set: Test Failed at /tmp/tmpkiieqrv9.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpkiieqrv9.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpkiieqrv9.jl:36\ntest set: Error
    During Test at /tmp/tmpkiieqrv9.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpkiieqrv9.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpkiieqrv9.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    sort!(result, by=x->x[2], rev=true)\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmp0b8ms53j.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmp0b8ms53j.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmp0b8ms53j.jl:36\ntest set: Test Failed at /tmp/tmp0b8ms53j.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp0b8ms53j.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmp0b8ms53j.jl:36\ntest set: Error
    During Test at /tmp/tmp0b8ms53j.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmp0b8ms53j.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmp0b8ms53j.jl:42 [inlined]\n   [3] macro expa'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by=x->x[1])\n    for i in 1:length(result)\n\
    \        if i != 1 && result[i][1] == result[i-1][1]\n            sort!(result[i-1:i],\
    \ by=x->x[2], rev=true)\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmp6ruyzarz.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmp6ruyzarz.jl:41\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0),\
    \ (2, 5)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6ruyzarz.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6ruyzarz.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6ruyzarz.jl:43\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2), (4, 0), (4, 3),\
    \ (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6ruyzarz.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6ruyzarz.jl:40\ntest set: Error\
    \ During Test at /tmp/tmp6ruyzarz.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching\
    \ get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},\
    \ ::Int64) at /tmp/tmp6ruyzarz.jl:19\n  Stacktrace:\n   [1] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [2] macro expansion\n     @ /tmp/tmp6ruyzarz.jl:46 [inlined]\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1."
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    res = []\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(res, (i-1, j-1))\n            end\n  \
    \      end\n    end\n    sort!(res, by = x -> x[1])\n    sort!(res, by = x ->\
    \ x[2], rev = true)\n    return res\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpkcbi7m5m.jl:38\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpkcbi7m5m.jl:38 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpkcbi7m5m.jl:37\ntest set: Test Failed at /tmp/tmpkcbi7m5m.jl:40\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpkcbi7m5m.jl:40 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpkcbi7m5m.jl:37\ntest set: Error
    During Test at /tmp/tmpkcbi7m5m.jl:43\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpkcbi7m5m.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpkcbi7m5m.jl:43 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by = x -> x[1])\n    for i in 1:length(result)\n\
    \        if i != 1 && result[i][1] == result[i-1][1]\n            sort!(result[i-1:i],\
    \ by = x -> x[2], rev = true)\n        end\n    end\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpd7x4r3ql.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpd7x4r3ql.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpd7x4r3ql.jl:40\ntest set: Test Failed at /tmp/tmpd7x4r3ql.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpd7x4r3ql.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpd7x4r3ql.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by = x -> (x[1], -x[2]))\n    return\
    \ result\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 0 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpi2rp5kst.jl:33

    '
  stdout: "test set: Error During Test at /tmp/tmpi2rp5kst.jl:41\n  Test threw exception\n\
    \  Expression: candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError:\
    \ no method matching get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates\
    \ are:\n    get_row(!Matched::Vector{Vector{Int64}}, ::Int64) at /tmp/tmpi2rp5kst.jl:19\n\
    \  Stacktrace:\n   [1] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [2] macro expansion\n     @ /tmp/tmpi2rp5kst.jl:41 [inlined]\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpi2rp5kst.jl:35\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    5      1      6\n"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    for i in 1:length(result)\n        if result[i][1] == result[i-1][1]\n\
    \            sort!(result[i-1:i], by=x->x[2], rev=true)\n        end\n    end\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpzs_0a9d6.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpzs_0a9d6.jl:41\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  BoundsError: attempt\
    \ to access 5-element Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmpzs_0a9d6.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpzs_0a9d6.jl:41 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpzs_0a9d6.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpzs_0a9d6.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  BoundsError: attempt to access 6-element\
    \ Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861\
    \ [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main\
    \ /tmp/tmpzs_0a9d6.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpzs_0a9d6.jl:42 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpzs_0a9d6.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpzs_0a9d6.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,\
    \ 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\
    \ == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]\n  BoundsError: attempt to access 12-element Vector{Any}\
    \ at index [0]\n  Stacktrace:\n   [1] ge"
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    # sort by\
    \ row\n    # sort by column\n    # return vector of tuples\n    # [(x1, y1), (x2,\
    \ y2) ...]\n    # (row, columns)\n    # starting with 0\n    # sort coordinates\
    \ initially by rows in ascending order\n    # Also, sort coordinates of the row\
    \ by columns in descending order\n    # get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    # [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)]\n    # get_row([], 1)\n    # []\n    # get_row([[], [1], [1, 2, 3]], 3)\n\
    \    # [(2, 2)]\n    # get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1)\n    # [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    # get_row([],\
    \ 1)\n    # []\n    # get_row([[], [1], [1, 2, 3]], 3)\n    # [(2, 2)]\n    #\
    \ get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n \
    \   # [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    # get_row([], 1)\n    # []\n\
    \    # get_row([[], [1], [1, 2, 3]], 3)\n    # [(2, 2)]\n    # get_row([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    # [(0, 0), (1,\
    \ 4), (1\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp82huuipg.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp82huuipg.jl:1\n\
    in expression starting at /tmp/tmp82huuipg.jl:1\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> (x[1], -x[2]))\n    return result\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Error During Test at /tmp/tmplz5p75f4.jl:41\n  Test threw
    exception\n  Expression: candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError:
    no method matching get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates
    are:\n    get_row(!Matched::Vector{Vector{Int64}}, ::Int64) at /tmp/tmplz5p75f4.jl:19\n  Stacktrace:\n   [1]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [2] macro expansion\n     @ /tmp/tmplz5p75f4.jl:41 [inlined]\n   [3]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [4] top-level scope\n     @ /tmp/tmplz5p75f4.jl:35\nTest Summary:
    | Pass  Error  Total\ntest set      |    5      1      6\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by = x -> x[1])\n    sort!(result, by\
    \ = x -> x[2], rev = true)\n    return result\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpe4tlqv40.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpe4tlqv40.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpe4tlqv40.jl:36\ntest set: Test Failed at /tmp/tmpe4tlqv40.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpe4tlqv40.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpe4tlqv40.jl:36\ntest set: Error
    During Test at /tmp/tmpe4tlqv40.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpe4tlqv40.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpe4tlqv40.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = (x -> x[1]))\n    for i in 1:length(result)\n        if i == 1\n      \
    \      continue\n        end\n        if result[i][1] == result[i-1][1]\n    \
    \        sort!(result[i-1:i], by = (x -> x[2]), rev = true)\n        end\n   \
    \ end\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: '''
  stdout: 'b''test set: Test Failed at /tmp/tmppcpp8yn_.jl:44\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmppcpp8yn_.jl:44 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmppcpp8yn_.jl:43\ntest set: Test Failed at /tmp/tmppcpp8yn_.jl:46\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmppcpp8yn_.jl:46 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmppcpp8yn_.jl:43\ntest set: Error
    During Test at /tmp/tmppcpp8yn_.jl:49\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmppcpp8yn_.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmppcpp8yn_.jl:49 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for (i, row) in\
    \ enumerate(lst)\n        for (j, elem) in enumerate(row)\n            if elem\
    \ == x\n                push!(result, (i, j))\n            end\n        end\n\
    \    end\n    sort!(result, by = x -> x[1])\n    for i in 1:length(result)\n \
    \       if i == 1\n            continue\n        end\n        if result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by = x -> x[2], rev = true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpntpt9tin.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmpntpt9tin.jl:44\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(1, 1), (2, 1), (2, 5), (3, 1),\
    \ (3, 6)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpntpt9tin.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpntpt9tin.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpntpt9tin.jl:45\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)]\n   Evaluated: [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2)] == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpntpt9tin.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpntpt9tin.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpntpt9tin.jl:46\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: [(1, 1), (2, 1), (3, 1), (3, 2), (4, 1), (4, 3), (5, 1), (5, 4),\
    \ (6, 1), (6, 5), (7, 1), (7, 6)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpntpt9tin.jl:46 [inlined]\n [3]\
    \ macro expansi"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code goes here\n    res\
    \ = []\n    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n      \
    \      if lst[i][j] == x\n                push!(res, (i-1, j-1))\n           \
    \ end\n        end\n    end\n    sort!(res, by = x -> x[1])\n    for i in 1:length(res)\n\
    \        if i > 1 && res[i][1] == res[i-1][1]\n            sort!(res[i-1:i], by\
    \ = x -> x[2], rev = true)\n        end\n    end\n    return res\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpiurnlipp.jl:42\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpiurnlipp.jl:42 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpiurnlipp.jl:41\ntest set: Test Failed at /tmp/tmpiurnlipp.jl:44\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpiurnlipp.jl:44 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpiurnlipp.jl:41\ntest set: Error
    During Test at /tmp/tmpiurnlipp.jl:47\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpiurnlipp.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpiurnlipp.jl:47 [inlined]\n   [3] macro expa'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpdqcfd2mu.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpdqcfd2mu.jl:27\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,\
    \ Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmpdqcfd2mu.jl:21\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdqcfd2mu.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdqcfd2mu.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpdqcfd2mu.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Tuple{Int64, Int64}}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abs"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    sort!(res, by = x -> x[2], rev = true)\n    return res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpex9w7l6z.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Test Failed at /tmp/tmpex9w7l6z.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Error
    During Test at /tmp/tmpex9w7l6z.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpex9w7l6z.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpex9w7l6z.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmp3f8zie6y.jl:27\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    Cannot `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,
    Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmp3f8zie6y.jl:21\n   [2]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3f8zie6y.jl:27 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3f8zie6y.jl:26\ntest set: Error
    During Test at /tmp/tmp3f8zie6y.jl:28\n  Test threw exception\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,
    1), (5, 1)]\n  MethodError: Cannot `convert` an object of type Nothing to an object
    of type Vector{Tuple{Int64, Int64}}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/jul'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    for i in 1:length(result)\n        sort!(result[i], by\
    \ = x -> x[2], rev = true)\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpu33resiv.jl:36

    '
  stdout: "test set: Error During Test at /tmp/tmpu33resiv.jl:39\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: no method\
    \ matching sort!(::Tuple{Int64, Int64}; by=var\"#2#4\"(), rev=true)\n  Closest\
    \ candidates are:\n    sort!(!Matched::AbstractUnitRange) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1305\
    \ got unsupported keyword arguments \"by\", \"rev\"\n    sort!(!Matched::AbstractVector{<:Union{Missing,\
    \ Float32, Float64}}, !Matched::Base.Sort.Algorithm, !Matched::Base.Order.DirectOrdering)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1234 got unsupported\
    \ keyword arguments \"by\", \"rev\"\n    sort!(!Matched::Vector{Int64}, !Matched::Base.Sort.Algorithm,\
    \ !Matched::Base.Order.Perm{<:Base.Order.DirectOrdering, <:Vector{<:Union{Missing,\
    \ Float32, Float64}}}) at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1236\
    \ got unsupported keyword arguments \"by\", \"rev\"\n    ...\n  Stacktrace:\n\
    \   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmpu33resiv.jl:30\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpu33resiv.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpu33resiv.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpu33resiv.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  MethodError: no method matching sort!(::Tuple{Int64,\
    \ Int64}; by=var\"#2#4\"(), rev=true)\n  Closest candidates are:\n    sort!(!Matched::AbstractUnitRange)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1305 got unsupported\
    \ keyword arguments \"by\", \"rev\"\n    sort!(!Matched::AbstractVector{<:Union{Missing,\
    \ Float32, "
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = Tuple{Int64, Int64}[]\n \
    \   for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(res, (i-1, j-1))\n            end\n  \
    \      end\n    end\n    sort!(res, by = x -> x[1])\n    sort!(res, by = x ->\
    \ x[2], rev = true)\n    return res\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpsbmiiin0.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpsbmiiin0.jl:37\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0),\
    \ (2, 0)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsbmiiin0.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsbmiiin0.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpsbmiiin0.jl:39\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0), (1, 0), (2, 0),\
    \ (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsbmiiin0.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsbmiiin0.jl:36\ntest set: Error\
    \ During Test at /tmp/tmpsbmiiin0.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching\
    \ get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},\
    \ ::Int64) at /tmp/tmpsbmiiin0.jl:19\n  Stacktrace:\n   [1] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [2] macro expansion\n     @ /tmp/tmpsbmiiin0.jl:42 [inlined]\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1."
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by=x->x[1])\n    for i in 1:length(res)\n        if res[i][1] == res[i-1][1]\n\
    \            sort!(res[i-1:i], by=x->x[2], rev=true)\n        end\n    end\n \
    \   return res\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmphgjhp1an.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmphgjhp1an.jl:41\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  BoundsError: attempt\
    \ to access 5-element Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmphgjhp1an.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmphgjhp1an.jl:41 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmphgjhp1an.jl:40\ntest set:\
    \ Error During Test at /tmp/tmphgjhp1an.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  BoundsError: attempt to access 6-element\
    \ Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861\
    \ [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main\
    \ /tmp/tmphgjhp1an.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmphgjhp1an.jl:42 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmphgjhp1an.jl:40\ntest set:\
    \ Error During Test at /tmp/tmphgjhp1an.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,\
    \ 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\
    \ == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]\n  BoundsError: attempt to access 12-element Vector{Any}\
    \ at index [0]\n  Stacktrace:\n   [1] ge"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by = x -> x[1])\n    for i in 1:length(result)\n\
    \        if i != 1 && result[i][1] == result[i-1][1]\n            sort!(result[i-1:i],\
    \ by = x -> x[2], rev = true)\n        end\n    end\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpd7x4r3ql.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpd7x4r3ql.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpd7x4r3ql.jl:40\ntest set: Test Failed at /tmp/tmpd7x4r3ql.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpd7x4r3ql.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpd7x4r3ql.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    row_col = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(row_col, (i-1, j-1))\n            end\n        end\n    end\n   \
    \ sort!(row_col, by=x->x[1])\n    sort!(row_col, by=x->x[2], rev=true)\n    return\
    \ row_col\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpkwdkmmqm.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpkwdkmmqm.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpkwdkmmqm.jl:36\ntest set: Test Failed at /tmp/tmpkwdkmmqm.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpkwdkmmqm.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpkwdkmmqm.jl:36\ntest set: Error
    During Test at /tmp/tmpkwdkmmqm.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpkwdkmmqm.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpkwdkmmqm.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    sort!(res, by = x -> x[2], rev = true)\n    return res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpex9w7l6z.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Test Failed at /tmp/tmpex9w7l6z.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Error
    During Test at /tmp/tmpex9w7l6z.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpex9w7l6z.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpex9w7l6z.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by=x->x[1])\n    for i in 1:length(result)\n\
    \        if i != 1 && result[i][1] == result[i-1][1]\n            sort!(result[i-1:i],\
    \ by=x->x[2], rev=true)\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmp6ruyzarz.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmp6ruyzarz.jl:41\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0),\
    \ (2, 5)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6ruyzarz.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6ruyzarz.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6ruyzarz.jl:43\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2), (4, 0), (4, 3),\
    \ (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6ruyzarz.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6ruyzarz.jl:40\ntest set: Error\
    \ During Test at /tmp/tmp6ruyzarz.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching\
    \ get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},\
    \ ::Int64) at /tmp/tmp6ruyzarz.jl:19\n  Stacktrace:\n   [1] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [2] macro expansion\n     @ /tmp/tmp6ruyzarz.jl:46 [inlined]\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1."
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    sort!(result, by=x->x[2], rev=true)\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmp0b8ms53j.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmp0b8ms53j.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmp0b8ms53j.jl:36\ntest set: Test Failed at /tmp/tmp0b8ms53j.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp0b8ms53j.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmp0b8ms53j.jl:36\ntest set: Error
    During Test at /tmp/tmp0b8ms53j.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmp0b8ms53j.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmp0b8ms53j.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    sort!(res, by = x -> x[2], rev = true)\n    return res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpex9w7l6z.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Test Failed at /tmp/tmpex9w7l6z.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Error
    During Test at /tmp/tmpex9w7l6z.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpex9w7l6z.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpex9w7l6z.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    sort!(result, by=x->x[2], rev=true)\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmp0b8ms53j.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmp0b8ms53j.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmp0b8ms53j.jl:36\ntest set: Test Failed at /tmp/tmp0b8ms53j.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp0b8ms53j.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmp0b8ms53j.jl:36\ntest set: Error
    During Test at /tmp/tmp0b8ms53j.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmp0b8ms53j.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmp0b8ms53j.jl:42 [inlined]\n   [3] macro expa'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    for i in 1:length(res)\n        if res[i][1] == res[i-1][1]\n\
    \            sort!(res[i-1:i], by = x -> x[2], rev = true)\n        end\n    end\n\
    \    return res\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp218mng4c.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmp218mng4c.jl:41\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  BoundsError: attempt\
    \ to access 5-element Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmp218mng4c.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp218mng4c.jl:41 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp218mng4c.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp218mng4c.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  BoundsError: attempt to access 6-element\
    \ Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861\
    \ [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main\
    \ /tmp/tmp218mng4c.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp218mng4c.jl:42 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp218mng4c.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp218mng4c.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,\
    \ 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\
    \ == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]\n  BoundsError: attempt to access 12-element Vector{Any}\
    \ at index [0]\n  Stacktrace:\n   [1] ge"
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    return\
    \ sort(result, by = x -> (x[1], -x[2]))\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 0 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmppvsy5vdq.jl:32

    '
  stdout: "test set: Error During Test at /tmp/tmppvsy5vdq.jl:40\n  Test threw exception\n\
    \  Expression: candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError:\
    \ no method matching get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates\
    \ are:\n    get_row(!Matched::Vector{Vector{Int64}}, ::Int64) at /tmp/tmppvsy5vdq.jl:19\n\
    \  Stacktrace:\n   [1] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [2] macro expansion\n     @ /tmp/tmppvsy5vdq.jl:40 [inlined]\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmppvsy5vdq.jl:34\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    5      1      6\n"
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    for i in 1:length(result)\n        sort!(result[i], by\
    \ = x -> x[2], rev = true)\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpu33resiv.jl:36

    '
  stdout: "test set: Error During Test at /tmp/tmpu33resiv.jl:39\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: no method\
    \ matching sort!(::Tuple{Int64, Int64}; by=var\"#2#4\"(), rev=true)\n  Closest\
    \ candidates are:\n    sort!(!Matched::AbstractUnitRange) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1305\
    \ got unsupported keyword arguments \"by\", \"rev\"\n    sort!(!Matched::AbstractVector{<:Union{Missing,\
    \ Float32, Float64}}, !Matched::Base.Sort.Algorithm, !Matched::Base.Order.DirectOrdering)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1234 got unsupported\
    \ keyword arguments \"by\", \"rev\"\n    sort!(!Matched::Vector{Int64}, !Matched::Base.Sort.Algorithm,\
    \ !Matched::Base.Order.Perm{<:Base.Order.DirectOrdering, <:Vector{<:Union{Missing,\
    \ Float32, Float64}}}) at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1236\
    \ got unsupported keyword arguments \"by\", \"rev\"\n    ...\n  Stacktrace:\n\
    \   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmpu33resiv.jl:30\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpu33resiv.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpu33resiv.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpu33resiv.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  MethodError: no method matching sort!(::Tuple{Int64,\
    \ Int64}; by=var\"#2#4\"(), rev=true)\n  Closest candidates are:\n    sort!(!Matched::AbstractUnitRange)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1305 got unsupported\
    \ keyword arguments \"by\", \"rev\"\n    sort!(!Matched::AbstractVector{<:Union{Missing,\
    \ Float32, "
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by=x->x[1])\n    sort!(res, by=x->x[2], rev=true)\n    return res\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpeo840m9y.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpeo840m9y.jl:37\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0),\
    \ (2, 0)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeo840m9y.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeo840m9y.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpeo840m9y.jl:39\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0), (1, 0), (2, 0),\
    \ (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeo840m9y.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeo840m9y.jl:36\ntest set: Error\
    \ During Test at /tmp/tmpeo840m9y.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching\
    \ get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},\
    \ ::Int64) at /tmp/tmpeo840m9y.jl:19\n  Stacktrace:\n   [1] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [2] macro expansion\n     @ /tmp/tmpeo840m9y.jl:42 [inlined]\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1."
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmp3f8zie6y.jl:27\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    Cannot `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,
    Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmp3f8zie6y.jl:21\n   [2]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3f8zie6y.jl:27 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3f8zie6y.jl:26\ntest set: Error
    During Test at /tmp/tmp3f8zie6y.jl:28\n  Test threw exception\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,
    1), (5, 1)]\n  MethodError: Cannot `convert` an object of type Nothing to an object
    of type Vector{Tuple{Int64, Int64}}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/jul'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    sort!(res, by = x -> x[2], rev = true)\n    return res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpex9w7l6z.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Test Failed at /tmp/tmpex9w7l6z.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Error
    During Test at /tmp/tmpex9w7l6z.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpex9w7l6z.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpex9w7l6z.jl:42 [inlined]\n   [3] macro expa'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    # return\
    \ a vector of tuples\n    # [(x1, y1), (x2, y2) ...]\n    # where (x1, y1) is\
    \ a coordinate - (row, columns)\n    # starting with 0\n    # sort coordinates\
    \ initially by rows in ascending order\n    # also, sort coordinates of the row\
    \ by columns in descending order\n    # if x is not in the vector, return empty\
    \ vector\n    # if lst is empty, return empty vector\n    # hint: use findall()\n\
    \    # hint: use sort()\n    # hint: use tuple()\n    # hint: use reverse()\n\
    \    # hint: use length()\n    # hint: use zip()\n    # hint: use enumerate()\n\
    \    # hint: use map()\n    # hint: use filter()\n    # hint: use reduce()\n \
    \   # hint: use foldl()\n    # hint: use foldr()\n    # hint: use any()\n    #\
    \ hint: use all()\n    # hint: use isempty()\n    # hint: use isequal()\n    #\
    \ hint: use isless()\n    # hint: use islessequal()\n    # hint: use isequal()\n\
    \    # hint: use isless()\n    # hint: use islessequal()\n    # hint: use isless()\n\
    \    # hint: use islessequal()\n    # hint: use isless()\n    # hint: use islessequal()\n\
    \    # hint: use isless()\n    # hint: use islessequal()\n    # hint: use isless()\n\
    \    # hint: use islessequal()\n    # hint: use isless()\n    # hint: use islessequal()\n\
    \    # hint: use isless()\n    # hint: use islessequal()\n    # hint: use isless()\n\
    \    # hint: use islessequal()\n    # hint: use isless()\n    # hint: use islessequal()\n\
    \    # hint: use isless()\n    # hint: use islessequal()\n    # hint: use isless()\n\
    \    # hint: use islessequal()\n    # hint: use isless()\n    # hint: use islessequal()\n\
    \    # hint: use isless()\n\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpp1ecl8jn.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpp1ecl8jn.jl:1\n\
    in expression starting at /tmp/tmpp1ecl8jn.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = Tuple{Int64, Int64}[]\n \
    \   for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(res, (i-1, j-1))\n            end\n  \
    \      end\n    end\n    sort!(res, by = x -> x[1])\n    for i in 1:length(res)\n\
    \        if i > 1 && res[i][1] == res[i-1][1]\n            sort!(res[i-1:i], by\
    \ = x -> x[2], rev = true)\n        end\n    end\n    return res\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpf5jzifu6.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmpf5jzifu6.jl:41\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0),\
    \ (2, 5)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf5jzifu6.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf5jzifu6.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpf5jzifu6.jl:43\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2), (4, 0), (4, 3),\
    \ (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf5jzifu6.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf5jzifu6.jl:40\ntest set: Error\
    \ During Test at /tmp/tmpf5jzifu6.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching\
    \ get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},\
    \ ::Int64) at /tmp/tmpf5jzifu6.jl:19\n  Stacktrace:\n   [1] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [2] macro expansion\n     @ /tmp/tmpf5jzifu6.jl:46 [inlined]\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1."
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    #raise NotImplementedError()\n\
    \    result = []\n    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n\
    \            if lst[i][j] == x\n                push!(result, (i-1, j-1))\n  \
    \          end\n        end\n    end\n    return sort(result, by = x->x[1])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpihrbhdwi.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpihrbhdwi.jl:37\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0),\
    \ (2, 5)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpihrbhdwi.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpihrbhdwi.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpihrbhdwi.jl:39\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2), (4, 0), (4, 3),\
    \ (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpihrbhdwi.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpihrbhdwi.jl:36\ntest set: Error\
    \ During Test at /tmp/tmpihrbhdwi.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching\
    \ get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},\
    \ ::Int64) at /tmp/tmpihrbhdwi.jl:19\n  Stacktrace:\n   [1] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [2] macro expansion\n     @ /tmp/tmpihrbhdwi.jl:42 [inlined]\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1."
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by=x->x[1])\n    sort!(result, by=x->x[2],\
    \ rev=true)\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpubjh6zi1.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpubjh6zi1.jl:37\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0),\
    \ (2, 0)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpubjh6zi1.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpubjh6zi1.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpubjh6zi1.jl:39\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0), (1, 0), (2, 0),\
    \ (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpubjh6zi1.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpubjh6zi1.jl:36\ntest set: Error\
    \ During Test at /tmp/tmpubjh6zi1.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching\
    \ get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},\
    \ ::Int64) at /tmp/tmpubjh6zi1.jl:19\n  Stacktrace:\n   [1] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [2] macro expansion\n     @ /tmp/tmpubjh6zi1.jl:42 [inlined]\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1."
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    for i in 1:length(result)\n        if i > 1 && result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by=x->x[2], rev=true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpfqc4dssg.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpfqc4dssg.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpfqc4dssg.jl:40\ntest set: Test Failed at /tmp/tmpfqc4dssg.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpfqc4dssg.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpfqc4dssg.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmp3f8zie6y.jl:27\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    Cannot `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,
    Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmp3f8zie6y.jl:21\n   [2]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3f8zie6y.jl:27 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3f8zie6y.jl:26\ntest set: Error
    During Test at /tmp/tmp3f8zie6y.jl:28\n  Test threw exception\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,
    1), (5, 1)]\n  MethodError: Cannot `convert` an object of type Nothing to an object
    of type Vector{Tuple{Int64, Int64}}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/jul'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    for i in 1:length(result)\n        if i > 1 && result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by=x->x[2], rev=true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpfqc4dssg.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpfqc4dssg.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpfqc4dssg.jl:40\ntest set: Test Failed at /tmp/tmpfqc4dssg.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpfqc4dssg.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpfqc4dssg.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    res = []\n\
    \    for (i, row) in enumerate(lst)\n        for (j, elem) in enumerate(row)\n\
    \            if elem == x\n                push!(res, (i, j))\n            end\n\
    \        end\n    end\n    return sort(res, by = x -> x[1])\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpg3zjkdxx.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmpg3zjkdxx.jl:36\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(1, 1), (2, 1), (2, 5), (3, 1),\
    \ (3, 6)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg3zjkdxx.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg3zjkdxx.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpg3zjkdxx.jl:37\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)]\n   Evaluated: [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2), (6, 2)] == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg3zjkdxx.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg3zjkdxx.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpg3zjkdxx.jl:38\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: [(1, 1), (2, 1), (3, 1), (3, 2), (4, 1), (4, 3), (5, 1), (5, 4),\
    \ (6, 1), (6, 5), (7, 1), (7, 6)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg3zjkdxx.jl:38 [inlined]\n [3]\
    \ macro expansi"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    sort!(result, by=x->x[2], rev=true)\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmp0b8ms53j.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmp0b8ms53j.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmp0b8ms53j.jl:36\ntest set: Test Failed at /tmp/tmp0b8ms53j.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp0b8ms53j.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmp0b8ms53j.jl:36\ntest set: Error
    During Test at /tmp/tmp0b8ms53j.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmp0b8ms53j.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmp0b8ms53j.jl:42 [inlined]\n   [3] macro expa'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    for i in 1:length(result)\n        sort!(result[i], by\
    \ = x -> x[2], rev = true)\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2,\
    \ 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0,\
    \ 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2,\
    \ 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
    \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpu33resiv.jl:36

    '
  stdout: "test set: Error During Test at /tmp/tmpu33resiv.jl:39\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: no method\
    \ matching sort!(::Tuple{Int64, Int64}; by=var\"#2#4\"(), rev=true)\n  Closest\
    \ candidates are:\n    sort!(!Matched::AbstractUnitRange) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1305\
    \ got unsupported keyword arguments \"by\", \"rev\"\n    sort!(!Matched::AbstractVector{<:Union{Missing,\
    \ Float32, Float64}}, !Matched::Base.Sort.Algorithm, !Matched::Base.Order.DirectOrdering)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1234 got unsupported\
    \ keyword arguments \"by\", \"rev\"\n    sort!(!Matched::Vector{Int64}, !Matched::Base.Sort.Algorithm,\
    \ !Matched::Base.Order.Perm{<:Base.Order.DirectOrdering, <:Vector{<:Union{Missing,\
    \ Float32, Float64}}}) at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1236\
    \ got unsupported keyword arguments \"by\", \"rev\"\n    ...\n  Stacktrace:\n\
    \   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmpu33resiv.jl:30\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpu33resiv.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpu33resiv.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpu33resiv.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  MethodError: no method matching sort!(::Tuple{Int64,\
    \ Int64}; by=var\"#2#4\"(), rev=true)\n  Closest candidates are:\n    sort!(!Matched::AbstractUnitRange)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1305 got unsupported\
    \ keyword arguments \"by\", \"rev\"\n    sort!(!Matched::AbstractVector{<:Union{Missing,\
    \ Float32, "
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by = x -> x[1])\n    for i in 1:length(result)\n\
    \        if i != 1 && result[i][1] == result[i-1][1]\n            sort!(result[i-1:i],\
    \ by = x -> x[2], rev = true)\n        end\n    end\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpd7x4r3ql.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpd7x4r3ql.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpd7x4r3ql.jl:40\ntest set: Test Failed at /tmp/tmpd7x4r3ql.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpd7x4r3ql.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpd7x4r3ql.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    res = []\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(res, (i-1, j-1))\n            end\n  \
    \      end\n    end\n    sort!(res, by = x -> x[1])\n    sort!(res, by = x ->\
    \ x[2], rev = true)\n    return res\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpkcbi7m5m.jl:38\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpkcbi7m5m.jl:38 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpkcbi7m5m.jl:37\ntest set: Test Failed at /tmp/tmpkcbi7m5m.jl:40\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpkcbi7m5m.jl:40 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpkcbi7m5m.jl:37\ntest set: Error
    During Test at /tmp/tmpkcbi7m5m.jl:43\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpkcbi7m5m.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpkcbi7m5m.jl:43 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    sort!(res, by = x -> x[2], rev = true)\n    return res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpex9w7l6z.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Test Failed at /tmp/tmpex9w7l6z.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Error
    During Test at /tmp/tmpex9w7l6z.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpex9w7l6z.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpex9w7l6z.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = Tuple{Int64, Int64}[]\n \
    \   for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(res, (i-1, j-1))\n            end\n  \
    \      end\n    end\n    sort!(res, by = x -> x[1])\n    for i in 1:length(res)\n\
    \        if res[i][1] == res[i-1][1]\n            sort!(res[i-1:i], by = x ->\
    \ x[2], rev = true)\n        end\n    end\n    return res\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpuxpwzsct.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpuxpwzsct.jl:41\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  BoundsError: attempt\
    \ to access 5-element Vector{Tuple{Int64, Int64}} at index [0]\n  Stacktrace:\n\
    \   [1] getindex\n     @ ./array.jl:861 [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)\n     @ Main /tmp/tmpuxpwzsct.jl:30\n   [3] macro expansion\n    \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [4] macro expansion\n     @ /tmp/tmpuxpwzsct.jl:41 [inlined]\n   [5] macro\
    \ expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpuxpwzsct.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpuxpwzsct.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  BoundsError: attempt to access 6-element\
    \ Vector{Tuple{Int64, Int64}} at index [0]\n  Stacktrace:\n   [1] getindex\n \
    \    @ ./array.jl:861 [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmpuxpwzsct.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpuxpwzsct.jl:42 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpuxpwzsct.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpuxpwzsct.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,\
    \ 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\
    \ == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]\n  BoundsError: attempt to access 12-element Vector{Tuple{Int"
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    # return\
    \ a vector of tuples\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpwihjjg13.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmpwihjjg13.jl:28\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,\
    \ Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmpwihjjg13.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwihjjg13.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwihjjg13.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpwihjjg13.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Tuple{Int64, Int64}}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abs"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    for i in 1:length(result)\n        if result[i][1] == result[i-1][1]\n\
    \            sort!(result[i-1:i], by = x -> x[2], rev = true)\n        end\n \
    \   end\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpcysxt04g.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpcysxt04g.jl:41\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  BoundsError: attempt\
    \ to access 5-element Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmpcysxt04g.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpcysxt04g.jl:41 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpcysxt04g.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpcysxt04g.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  BoundsError: attempt to access 6-element\
    \ Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861\
    \ [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main\
    \ /tmp/tmpcysxt04g.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpcysxt04g.jl:42 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpcysxt04g.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpcysxt04g.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,\
    \ 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\
    \ == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]\n  BoundsError: attempt to access 12-element Vector{Any}\
    \ at index [0]\n  Stacktrace:\n   [1] ge"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    for i in 1:length(result)\n        if i != 1 && result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by=x->x[2], rev=true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpjvu5hlov.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpjvu5hlov.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpjvu5hlov.jl:40\ntest set: Test Failed at /tmp/tmpjvu5hlov.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpjvu5hlov.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpjvu5hlov.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmp3f8zie6y.jl:27\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    Cannot `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,
    Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmp3f8zie6y.jl:21\n   [2]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3f8zie6y.jl:27 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3f8zie6y.jl:26\ntest set: Error
    During Test at /tmp/tmp3f8zie6y.jl:28\n  Test threw exception\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,
    1), (5, 1)]\n  MethodError: Cannot `convert` an object of type Nothing to an object
    of type Vector{Tuple{Int64, Int64}}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/jul'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> (x[1], -x[2]))\n    return result\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Error During Test at /tmp/tmplz5p75f4.jl:41\n  Test threw
    exception\n  Expression: candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError:
    no method matching get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates
    are:\n    get_row(!Matched::Vector{Vector{Int64}}, ::Int64) at /tmp/tmplz5p75f4.jl:19\n  Stacktrace:\n   [1]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [2] macro expansion\n     @ /tmp/tmplz5p75f4.jl:41 [inlined]\n   [3]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [4] top-level scope\n     @ /tmp/tmplz5p75f4.jl:35\nTest Summary:
    | Pass  Error  Total\ntest set      |    5      1      6\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmp3f8zie6y.jl:27\n  Test threw
    exception\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,
    2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError:
    Cannot `convert` an object of type Nothing to an object of type Vector{Tuple{Int64,
    Int64}}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main /tmp/tmp3f8zie6y.jl:21\n   [2]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3f8zie6y.jl:27 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3f8zie6y.jl:26\ntest set: Error
    During Test at /tmp/tmp3f8zie6y.jl:28\n  Test threw exception\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,
    1), (5, 1)]\n  MethodError: Cannot `convert` an object of type Nothing to an object
    of type Vector{Tuple{Int64, Int64}}\n  Closest candidates are:\n    convert(::Type{T},
    !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/jul'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    #raise NotImplementedError()\n\
    \    result = []\n    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n\
    \            if lst[i][j] == x\n                push!(result, (i-1, j-1))\n  \
    \          end\n        end\n    end\n    return sort(result, by = x->x[1])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpihrbhdwi.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpihrbhdwi.jl:37\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0),\
    \ (2, 5)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpihrbhdwi.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpihrbhdwi.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpihrbhdwi.jl:39\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2), (4, 0), (4, 3),\
    \ (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpihrbhdwi.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpihrbhdwi.jl:36\ntest set: Error\
    \ During Test at /tmp/tmpihrbhdwi.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching\
    \ get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},\
    \ ::Int64) at /tmp/tmpihrbhdwi.jl:19\n  Stacktrace:\n   [1] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [2] macro expansion\n     @ /tmp/tmpihrbhdwi.jl:42 [inlined]\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1."
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    #raise NotImplementedError()\n\
    \    res = []\n    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n\
    \            if lst[i][j] == x\n                push!(res, (i-1, j-1))\n     \
    \       end\n        end\n    end\n    sort!(res, by = x -> x[1])\n    for i in\
    \ 1:length(res)\n        sort!(res[i], by = x -> -x[2])\n    end\n    return res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp4w3hr_u0.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmp4w3hr_u0.jl:41\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  MethodError: no method\
    \ matching sort!(::Tuple{Int64, Int64}; by=var\"#2#4\"())\n  Closest candidates\
    \ are:\n    sort!(!Matched::AbstractUnitRange) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1305\
    \ got unsupported keyword argument \"by\"\n    sort!(!Matched::AbstractVector{<:Union{Missing,\
    \ Float32, Float64}}, !Matched::Base.Sort.Algorithm, !Matched::Base.Order.DirectOrdering)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1234 got unsupported\
    \ keyword argument \"by\"\n    sort!(!Matched::Vector{Int64}, !Matched::Base.Sort.Algorithm,\
    \ !Matched::Base.Order.Perm{<:Base.Order.DirectOrdering, <:Vector{<:Union{Missing,\
    \ Float32, Float64}}}) at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1236\
    \ got unsupported keyword argument \"by\"\n    ...\n  Stacktrace:\n   [1] get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)\n     @ Main /tmp/tmp4w3hr_u0.jl:32\n   [2] macro expansion\n    \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [3] macro expansion\n     @ /tmp/tmp4w3hr_u0.jl:41 [inlined]\n   [4] macro\
    \ expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4w3hr_u0.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp4w3hr_u0.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  MethodError: no method matching sort!(::Tuple{Int64,\
    \ Int64}; by=var\"#2#4\"())\n  Closest candidates are:\n    sort!(!Matched::AbstractUnitRange)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1305 got unsupported\
    \ keyword argument \"by\"\n    sort!(!Matched::AbstractVector{<:Union{Missing,\
    \ Float32, Float64}}, !Matched::Base.Sort.Algorithm, !Matched::"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by = x -> x[1])\n    sort!(res, by = x -> x[2], rev = true)\n    return res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Test Failed at /tmp/tmpex9w7l6z.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Test Failed at /tmp/tmpex9w7l6z.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpex9w7l6z.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpex9w7l6z.jl:36\ntest set: Error
    During Test at /tmp/tmpex9w7l6z.jl:42\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmpex9w7l6z.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmpex9w7l6z.jl:42 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # your code here\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpzs2hyxb9.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpzs2hyxb9.jl:27\ntest set: Test Failed
    at /tmp/tmpzs2hyxb9.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpzs2hyxb9.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(res, (i-1, j-1))\n            end\n        end\n    end\n    sort!(res,\
    \ by=x->x[1])\n    for i in 1:length(res)\n        if res[i][1] == res[i-1][1]\n\
    \            sort!(res[i-1:i], by=x->x[2], rev=true)\n        end\n    end\n \
    \   return res\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmphgjhp1an.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmphgjhp1an.jl:41\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  BoundsError: attempt\
    \ to access 5-element Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmphgjhp1an.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmphgjhp1an.jl:41 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmphgjhp1an.jl:40\ntest set:\
    \ Error During Test at /tmp/tmphgjhp1an.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  BoundsError: attempt to access 6-element\
    \ Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861\
    \ [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main\
    \ /tmp/tmphgjhp1an.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmphgjhp1an.jl:42 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmphgjhp1an.jl:40\ntest set:\
    \ Error During Test at /tmp/tmphgjhp1an.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,\
    \ 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\
    \ == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]\n  BoundsError: attempt to access 12-element Vector{Any}\
    \ at index [0]\n  Stacktrace:\n   [1] ge"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    #raise NotImplementedError()\n\
    \    #return []\n    #return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    #return\
    \ [(2, 2)]\n    #return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    #return\
    \ [(2, 2)]\n    #return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    #return\
    \ [(2, 2)]\n    #return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    #return\
    \ [(2, 2)]\n    #return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    #return\
    \ [(2, 2)]\n    #return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    #return\
    \ [(2, 2)]\n    #return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    #return\
    \ [(2, 2)]\n    #return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    #return\
    \ [(2, 2)]\n    #return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    #return\
    \ [(2, 2)]\n    #return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    #return\
    \ [(2, 2)]\n    #return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    #return\
    \ [(2, 2)]\n    #return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    #return\
    \ [(2, 2)]\n    #return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    #return\
    \ [(2\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp572wmn5_.jl:19\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp572wmn5_.jl:1\n\
    in expression starting at /tmp/tmp572wmn5_.jl:1\n"
  stdout: ''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    for i in 1:length(result)\n        if i > 1 && result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by = x -> x[2], rev = true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptck653jq.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmptck653jq.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmptck653jq.jl:40\ntest set: Test Failed at /tmp/tmptck653jq.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptck653jq.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptck653jq.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> (x[1], -x[2]))\n    return result\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1,\
    \ 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t\
    @test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
    \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: '''
  stdout: 'b''test set: Error During Test at /tmp/tmplz5p75f4.jl:41\n  Test threw
    exception\n  Expression: candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError:
    no method matching get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates
    are:\n    get_row(!Matched::Vector{Vector{Int64}}, ::Int64) at /tmp/tmplz5p75f4.jl:19\n  Stacktrace:\n   [1]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [2] macro expansion\n     @ /tmp/tmplz5p75f4.jl:41 [inlined]\n   [3]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [4] top-level scope\n     @ /tmp/tmplz5p75f4.jl:35\nTest Summary:
    | Pass  Error  Total\ntest set      |    5      1      6\n'''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    for i in 1:length(result)\n        if result[i][1] == result[i+1][1]\n\
    \            sort!(result, by = x -> x[2], rev = true)\n        end\n    end\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\
    \t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0),\
    \ (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpmygu_q60.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpmygu_q60.jl:41\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  BoundsError: attempt\
    \ to access 5-element Vector{Any} at index [6]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmpmygu_q60.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpmygu_q60.jl:41 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpmygu_q60.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpmygu_q60.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  BoundsError: attempt to access 6-element\
    \ Vector{Any} at index [7]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861\
    \ [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main\
    \ /tmp/tmpmygu_q60.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpmygu_q60.jl:42 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpmygu_q60.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpmygu_q60.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,\
    \ 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\
    \ == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]\n  BoundsError: attempt to access 12-element Vector{Any}\
    \ at index [13]\n  Stacktrace:\n   [1] g"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by=x->x[1])\n    for i in 1:length(result)\n\
    \        if i != 1 && result[i][1] == result[i-1][1]\n            sort!(result[i-1:i],\
    \ by=x->x[2], rev=true)\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]],\
    \ 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmp6ruyzarz.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmp6ruyzarz.jl:41\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0),\
    \ (2, 5)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6ruyzarz.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6ruyzarz.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6ruyzarz.jl:43\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2), (4, 0), (4, 3),\
    \ (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6ruyzarz.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6ruyzarz.jl:40\ntest set: Error\
    \ During Test at /tmp/tmp6ruyzarz.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching\
    \ get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},\
    \ ::Int64) at /tmp/tmp6ruyzarz.jl:19\n  Stacktrace:\n   [1] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [2] macro expansion\n     @ /tmp/tmp6ruyzarz.jl:46 [inlined]\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1."
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    res = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(res, (i-1, j-1))\n            end\n  \
    \      end\n    end\n    sort!(res, by = x -> x[1])\n    sort!(res, by = x ->\
    \ x[2], rev = true)\n    return res\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpjn7lr3u3.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpjn7lr3u3.jl:37\n  Expression: candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0),\
    \ (2, 0)] == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjn7lr3u3.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjn7lr3u3.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpjn7lr3u3.jl:39\n  Expression: candidate([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1),\
    \ (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n  \
    \ Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0), (1, 0), (2, 0),\
    \ (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),\
    \ (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjn7lr3u3.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjn7lr3u3.jl:36\ntest set: Error\
    \ During Test at /tmp/tmpjn7lr3u3.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching\
    \ get_row(::Vector{Vector{Any}}, ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},\
    \ ::Int64) at /tmp/tmpjn7lr3u3.jl:19\n  Stacktrace:\n   [1] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [2] macro expansion\n     @ /tmp/tmpjn7lr3u3.jl:42 [inlined]\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1."
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = Vector{Tuple{Int64, Int64}}()\n\
    \    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if\
    \ lst[i][j] == x\n                push!(result, (i-1, j-1))\n            end\n\
    \        end\n    end\n    sort!(result, by = x -> x[1])\n    for i in 1:length(result)\n\
    \        if i != 1 && result[i][1] == result[i-1][1]\n            sort!(result[i-1:i],\
    \ by = x -> x[2], rev = true)\n        end\n    end\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\
    \t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpd7x4r3ql.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpd7x4r3ql.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpd7x4r3ql.jl:40\ntest set: Test Failed at /tmp/tmpd7x4r3ql.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpd7x4r3ql.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpd7x4r3ql.jl:40\n'''
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    for i in 1:length(result)\n        if i != 1 && result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by = x -> x[2], rev = true)\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: '''
  stdout: 'b''test set: Test Failed at /tmp/tmp3jl1py2s.jl:41\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmp3jl1py2s.jl:41 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmp3jl1py2s.jl:40\ntest set: Test Failed at /tmp/tmp3jl1py2s.jl:43\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(0, 0), (1, 0), (2, 0), (2, 1), (3, 0), (3, 2),
    (4, 0), (4, 3), (5, 0), (5, 4), (6, 0), (6, 5)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmp3jl1py2s.jl:43 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmp3jl1py2s.jl:40\ntest set: Error
    During Test at /tmp/tmp3jl1py2s.jl:46\n  Test threw exception\n  Expression: candidate([[],
    [1], [1, 2, 3]], 3) == [(2, 2)]\n  MethodError: no method matching get_row(::Vector{Vector{Any}},
    ::Int64)\n  Closest candidates are:\n    get_row(!Matched::Vector{Vector{Int64}},
    ::Int64) at /tmp/tmp3jl1py2s.jl:19\n  Stacktrace:\n   [1] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [2]
    macro expansion\n     @ /tmp/tmp3jl1py2s.jl:46 [inlined]\n   [3] macro expa'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    # YOUR CODE HERE\n    return []\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmptbeq9vr3.jl:28\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: Tuple{Int64, Int64}[] == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:28 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:29\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n   Evaluated:
    Tuple{Int64, Int64}[] == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:29 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmptbeq9vr3.jl:27\ntest set: Test Failed
    at /tmp/tmptbeq9vr3.jl:30\n  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2,
    3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,
    3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2),
    (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n   Evaluated: Tuple{Int64,
    Int64}[] == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5,
    4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmptbeq9vr3.jl:30 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inl'
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
- exit_code: 1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    for i in 1:length(result)\n        if result[i][1] == result[i-1][1]\n\
    \            sort!(result[i:end], by = x -> x[2], rev = true)\n            break\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_row;\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3,\
    \ 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]),\
    \ 1) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp0_vpcj10.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp0_vpcj10.jl:42\n  Test threw exception\n\
    \  Expression: candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4,\
    \ 5, 1]], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  BoundsError: attempt\
    \ to access 5-element Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n\
    \     @ Main /tmp/tmp0_vpcj10.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp0_vpcj10.jl:42 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp0_vpcj10.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp0_vpcj10.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1),\
    \ (2, 1), (3, 1), (4, 1), (5, 1)]\n  BoundsError: attempt to access 6-element\
    \ Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861\
    \ [inlined]\n   [2] get_row(lst::Vector{Vector{Int64}}, x::Int64)\n     @ Main\
    \ /tmp/tmp0_vpcj10.jl:30\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp0_vpcj10.jl:43 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp0_vpcj10.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp0_vpcj10.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,\
    \ 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\
    \ == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]\n  BoundsError: attempt to access 12-element Vector{Any}\
    \ at index [0]\n  Stacktrace:\n   [1] ge"
- exit_code: -1
  program: "\"\"\"\n    You are given a 2 dimensional data, as a nested vectors,\n\
    \    which is similar to matrix, however, unlike matrices,\n    each row may contain\
    \ a different number of columns.\n    Given lst, and integer x, find integers\
    \ x in the vector,\n    and return vector of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates\
    \ of the row by columns in descending order.\n    \n    Examples:\n    >>> get_row([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[],\
    \ [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
    \ x::Int64)::Vector{Tuple{Int64, Int64}} \n    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by = x -> x[1])\n    sort!(result, by = x -> x[2], rev = true)\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t\
    @test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1,\
    \ 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)])\n\t@test(candidate(Vector{Vector{Int64}}([]), 1) ==\
    \ Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[1]], 2) == Vector{Tuple{Int64,\
    \ Int64}}([]))\n\t@test(candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmpyrswprf_.jl:37\n  Expression: candidate([[1,
    2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),
    (1, 0), (2, 5), (2, 0)]\n   Evaluated: [(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]
    == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nStacktrace:\n [1] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n
    [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:37 [inlined]\n [3] macro expansion\n   @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n
    [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\ntest set: Test Failed at /tmp/tmpyrswprf_.jl:39\n  Expression:
    candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2,
    1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) ==
    [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),
    (6, 5), (6, 0)]\n   Evaluated: [(6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (0, 0),
    (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)] == [(0, 0), (1, 0), (2, 1), (2,
    0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\nStacktrace:\n
    [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmpyrswprf_.jl:39 [inlined]\n [3] macro
    expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmpyrswprf_.jl:36\n'''
