name: HumanEval_68_pluck
language: jl
results:
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    return [min_even, findfirst(arr, min_even)]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp68b5xatt.jl:46\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp68b5xatt.jl:39\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp68b5xatt.jl:46 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp68b5xatt.jl:45\\ntest set:\
    \ Error During Test at /tmp/tmp68b5xatt.jl:47\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp68b5xatt.jl:39\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp68b5xatt.jl:47 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp68b5xatt.jl:45\\ntest set:\
    \ Error During Test at /tmp/tmp68b5xatt.jl:49\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpyjg7ahhk.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpyjg7ahhk.jl:43\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpyjg7ahhk.jl:51 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpyjg7ahhk.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpyjg7ahhk.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpyjg7ahhk.jl:43\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpyjg7ahhk.jl:52 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpyjg7ahhk.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpyjg7ahhk.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    return [min_even, findfirst(arr, min_even)]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpn3fehqzl.jl:46\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpn3fehqzl.jl:39\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpn3fehqzl.jl:46 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpn3fehqzl.jl:45\\ntest set:\
    \ Error During Test at /tmp/tmpn3fehqzl.jl:47\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpn3fehqzl.jl:39\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpn3fehqzl.jl:47 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpn3fehqzl.jl:45\\ntest set:\
    \ Error During Test at /tmp/tmpn3fehqzl.jl:49\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [x for x\
    \ in arr if x % 2 == 0]\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpzgdlccvy.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpzgdlccvy.jl:43\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpzgdlccvy.jl:51 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpzgdlccvy.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpzgdlccvy.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpzgdlccvy.jl:43\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpzgdlccvy.jl:52 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpzgdlccvy.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpzgdlccvy.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpeti7aw7u.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpeti7aw7u.jl:36\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpeti7aw7u.jl:42 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpeti7aw7u.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmpeti7aw7u.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpeti7aw7u.jl:36\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpksziikfh.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpksziikfh.jl:43\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpksziikfh.jl:51 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpksziikfh.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpksziikfh.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpksziikfh.jl:43\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpksziikfh.jl:52 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpksziikfh.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpksziikfh.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpp4kw2b1g.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpp4kw2b1g.jl:43\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpp4kw2b1g.jl:51 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpp4kw2b1g.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpp4kw2b1g.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpp4kw2b1g.jl:43\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpp4kw2b1g.jl:52 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpp4kw2b1g.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpp4kw2b1g.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpm9p57qr0.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpm9p57qr0.jl:43\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpm9p57qr0.jl:51 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpm9p57qr0.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpm9p57qr0.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpm9p57qr0.jl:43\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpm9p57qr0.jl:52 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpm9p57qr0.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpm9p57qr0.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpx9srxoqs.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpx9srxoqs.jl:43\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpx9srxoqs.jl:51 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpx9srxoqs.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpx9srxoqs.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpx9srxoqs.jl:43\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpx9srxoqs.jl:52 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpx9srxoqs.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpx9srxoqs.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code goes here\n    if length(arr) == 0\n        return []\n  \
    \  end\n    evens = [x for x in arr if x % 2 == 0]\n    if length(evens) == 0\n\
    \        return []\n    end\n    evens_sorted = sort(evens)\n    evens_sorted_first\
    \ = evens_sorted[1]\n    evens_sorted_first_index = findfirst(arr, evens_sorted_first)\n\
    \    return [evens_sorted_first, evens_sorted_first_index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4u4bocjm.jl:53\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp4u4bocjm.jl:45\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp4u4bocjm.jl:53 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp4u4bocjm.jl:52\\ntest set:\
    \ Error During Test at /tmp/tmp4u4bocjm.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp4u4bocjm.jl:45\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp4u4bocjm.jl:54 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp4u4bocjm.jl:52\\ntest set:\
    \ Error During Test at /tmp/tmp4u4bocjm.jl:56\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp2wncc_0_.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp2wncc_0_.jl:43\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp2wncc_0_.jl:51 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp2wncc_0_.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp2wncc_0_.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp2wncc_0_.jl:43\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp2wncc_0_.jl:52 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp2wncc_0_.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp2wncc_0_.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_values)\n        return\
    \ []\n    end\n    return minimum(even_values)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpt4xpl334.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt4xpl334.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt4xpl334.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpt4xpl334.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpt4xpl334.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt4xpl334.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpt4xpl334.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt4xpl334.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt4xpl334.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpt4xpl334.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt4xpl334.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt4xpl334.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpt4xpl334.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt4xpl334.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return [0, 0]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpieo0gzes.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpieo0gzes.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpieo0gzes.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpieo0gzes.jl:44\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpieo0gzes.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpieo0gzes.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpieo0gzes.jl:45\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpieo0gzes.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpieo0gzes.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpieo0gzes.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpieo0gzes.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpieo0gzes.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpieo0gzes.jl:47\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 0] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpieo0gzes.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [i for i in\
    \ arr if i % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpq028z_2n.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpq028z_2n.jl:43\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpq028z_2n.jl:51 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpq028z_2n.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpq028z_2n.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpq028z_2n.jl:43\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpq028z_2n.jl:52 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpq028z_2n.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpq028z_2n.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [node for\
    \ node in arr if node % 2 == 0]\n    if isempty(even_nodes)\n        return []\n\
    \    end\n    smallest_even_value = minimum(even_nodes)\n    smallest_even_index\
    \ = findfirst(arr, smallest_even_value)\n    return [smallest_even_value, smallest_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp1f7irdyc.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp1f7irdyc.jl:43\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp1f7irdyc.jl:51 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp1f7irdyc.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp1f7irdyc.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp1f7irdyc.jl:43\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp1f7irdyc.jl:52 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp1f7irdyc.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp1f7irdyc.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpwojswxme.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwojswxme.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwojswxme.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpwojswxme.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwojswxme.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwojswxme.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpwojswxme.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwojswxme.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwojswxme.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpwojswxme.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwojswxme.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwojswxme.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpwojswxme.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwojswxme.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfae2z0in.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfae2z0in.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfae2z0in.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpfae2z0in.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfae2z0in.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfae2z0in.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpfae2z0in.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfae2z0in.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfae2z0in.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpfae2z0in.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfae2z0in.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfae2z0in.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpfae2z0in.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfae2z0in.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return [0, 0]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpaps2txaf.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaps2txaf.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaps2txaf.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpaps2txaf.jl:44\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpaps2txaf.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaps2txaf.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpaps2txaf.jl:45\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaps2txaf.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaps2txaf.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpaps2txaf.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaps2txaf.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaps2txaf.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpaps2txaf.jl:47\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 0] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaps2txaf.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpmdv009ej.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpmdv009ej.jl:43\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpmdv009ej.jl:51 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpmdv009ej.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpmdv009ej.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpmdv009ej.jl:43\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpmdv009ej.jl:52 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpmdv009ej.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpmdv009ej.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given a vector representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a vector, [ smalest_value, its index ],\n    If there are no even values or\
    \ the given vector is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2,\
    \ 3])\n    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n  \
    \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5,\
    \ 0, 3, 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but \
    \ there are two zeros,\n                 so we will choose the first zero, which\
    \ has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <=\
    \ 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp8hp3zaru.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp8hp3zaru.jl:43\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp8hp3zaru.jl:51 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp8hp3zaru.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp8hp3zaru.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp8hp3zaru.jl:43\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp8hp3zaru.jl:52 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp8hp3zaru.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp8hp3zaru.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method match"
  stderr: None
  exit_code: -1
  status: Timeout
