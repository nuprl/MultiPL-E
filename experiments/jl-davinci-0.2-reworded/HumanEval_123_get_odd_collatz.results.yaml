language: jl
name: HumanEval_123_get_odd_collatz
results:
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6cxsnorp.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp6cxsnorp.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6cxsnorp.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6cxsnorp.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp6cxsnorp.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6cxsnorp.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6cxsnorp.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp6cxsnorp.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6cxsnorp.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6cxsnorp.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwx0doe2l.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpwx0doe2l.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwx0doe2l.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwx0doe2l.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpwx0doe2l.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwx0doe2l.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwx0doe2l.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpwx0doe2l.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwx0doe2l.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwx0doe2l.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpwx0doe2l.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwx0doe2l.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwx0doe2l.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7t49hwza.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7t49hwza.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7t49hwza.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7t49hwza.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7t49hwza.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7t49hwza.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7t49hwza.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7t49hwza.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7t49hwza.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7t49hwza.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7oumo_pp.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7oumo_pp.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7oumo_pp.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7oumo_pp.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7oumo_pp.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7oumo_pp.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7oumo_pp.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7oumo_pp.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7oumo_pp.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7oumo_pp.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7oumo_pp.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7oumo_pp.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7oumo_pp.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqlf90by7.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpqlf90by7.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqlf90by7.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqlf90by7.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpqlf90by7.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqlf90by7.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqlf90by7.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpqlf90by7.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqlf90by7.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqlf90by7.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpqlf90by7.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqlf90by7.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqlf90by7.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    v = [n]\n    while n != 1\n        if n % 2 == 0\n\
    \            n = n/2\n        else\n            n = 3*n + 1\n        end\n   \
    \     push!(v, n)\n    end\n    return v[v .% 2 .!= 0]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpym8f1qmy.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpym8f1qmy.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpym8f1qmy.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpym8f1qmy.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpym8f1qmy.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpym8f1qmy.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpym8f1qmy.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpym8f1qmy.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpym8f1qmy.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpym8f1qmy.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    odd_collatz = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        if n % 2 != 0\n            push!(odd_collatz,\
    \ n)\n        end\n    end\n    return sort(odd_collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpldc1t9v8.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmpldc1t9v8.jl:41\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpldc1t9v8.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpldc1t9v8.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpldc1t9v8.jl:43\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpldc1t9v8.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpldc1t9v8.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpi8st_i2w.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpi8st_i2w.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi8st_i2w.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi8st_i2w.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpi8st_i2w.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi8st_i2w.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi8st_i2w.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpi8st_i2w.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi8st_i2w.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi8st_i2w.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpi8st_i2w.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi8st_i2w.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi8st_i2w.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpr7ay10aw.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpr7ay10aw.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr7ay10aw.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr7ay10aw.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr7ay10aw.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr7ay10aw.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr7ay10aw.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr7ay10aw.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr7ay10aw.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr7ay10aw.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7mvekjcv.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7mvekjcv.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7mvekjcv.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7mvekjcv.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7mvekjcv.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7mvekjcv.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7mvekjcv.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7mvekjcv.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7mvekjcv.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7mvekjcv.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7mvekjcv.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7mvekjcv.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7mvekjcv.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3w57lb74.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp3w57lb74.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3w57lb74.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3w57lb74.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp3w57lb74.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3w57lb74.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3w57lb74.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp3w57lb74.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3w57lb74.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3w57lb74.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp3w57lb74.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3w57lb74.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3w57lb74.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp1o6upm5x.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp1o6upm5x.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1o6upm5x.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1o6upm5x.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp1o6upm5x.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1o6upm5x.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1o6upm5x.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp1o6upm5x.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1o6upm5x.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1o6upm5x.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp1o6upm5x.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1o6upm5x.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1o6upm5x.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpn3jghb47.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpn3jghb47.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn3jghb47.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn3jghb47.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpn3jghb47.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn3jghb47.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn3jghb47.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpn3jghb47.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn3jghb47.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn3jghb47.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpn3jghb47.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn3jghb47.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn3jghb47.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpdmdqvm48.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpdmdqvm48.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdmdqvm48.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdmdqvm48.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpdmdqvm48.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdmdqvm48.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdmdqvm48.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpdmdqvm48.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdmdqvm48.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdmdqvm48.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpdmdqvm48.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdmdqvm48.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdmdqvm48.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpcxzlmh_w.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpcxzlmh_w.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcxzlmh_w.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcxzlmh_w.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpcxzlmh_w.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcxzlmh_w.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcxzlmh_w.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpcxzlmh_w.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcxzlmh_w.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcxzlmh_w.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpcxzlmh_w.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcxzlmh_w.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcxzlmh_w.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp824843z_.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp824843z_.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp824843z_.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp824843z_.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp824843z_.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp824843z_.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp824843z_.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp824843z_.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp824843z_.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp824843z_.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp824843z_.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp824843z_.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp824843z_.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmulgcyd7.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmulgcyd7.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmulgcyd7.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmulgcyd7.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmulgcyd7.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmulgcyd7.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmulgcyd7.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmulgcyd7.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmulgcyd7.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmulgcyd7.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmulgcyd7.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmulgcyd7.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmulgcyd7.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmpatp6nlmn.jl:27\n  Test threw
    exception\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError:
    Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n  Closest
    candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpatp6nlmn.jl:21\n   [2] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [3]
    macro expansion\n     @ /tmp/tmpatp6nlmn.jl:27 [inlined]\n   [4] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [5]
    top-level scope\n     @ /tmp/tmpatp6nlmn.jl:26\ntest set: Error During Test at
    /tmp/tmpatp6nlmn.jl:28\n  Test threw exception\n  Expression: candidate(5) ==
    [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object
    of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpatp6nlmn.jl:21\n   [2] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [3]
    macro expansion\n     @ /tmp/'
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    v = [n]\n    while n != 1\n \
    \       if n % 2 == 0\n            n = n / 2\n        else\n            n = 3\
    \ * n + 1\n        end\n        push!(v, n)\n    end\n    return v[v .% 2 .!=\
    \ 0]\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmple6jtv96.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmple6jtv96.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmple6jtv96.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmple6jtv96.jl:38\ntest set: Test\
    \ Failed at /tmp/tmple6jtv96.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmple6jtv96.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmple6jtv96.jl:38\ntest set: Test\
    \ Failed at /tmp/tmple6jtv96.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmple6jtv96.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmple6jtv96.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    odd_collatz = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        if n % 2 != 0\n            push!(odd_collatz,\
    \ n)\n        end\n    end\n    return sort(odd_collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpldc1t9v8.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmpldc1t9v8.jl:41\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpldc1t9v8.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpldc1t9v8.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpldc1t9v8.jl:43\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpldc1t9v8.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpldc1t9v8.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp98zq_395.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp98zq_395.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp98zq_395.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp98zq_395.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp98zq_395.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp98zq_395.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp98zq_395.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp98zq_395.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp98zq_395.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp98zq_395.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp98zq_395.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp98zq_395.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp98zq_395.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpjo9hkx5y.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpjo9hkx5y.jl:27\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpjo9hkx5y.jl:21\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjo9hkx5y.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjo9hkx5y.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpjo9hkx5y.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(5) == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpjo9hkx5y.jl:21\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjo9hkx5y.jl:28 [inlined]\n\
    \   [4] ma"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n < 1\n        return []\n    end\n    v = [n]\n    while n != 1\n   \
    \     if n % 2 == 0\n            n = n / 2\n        else\n            n = 3 *\
    \ n + 1\n        end\n        push!(v, n)\n    end\n    return filter(x -> x %\
    \ 2 == 1, v)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2skzisis.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmp2skzisis.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2skzisis.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2skzisis.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp2skzisis.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2skzisis.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2skzisis.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp2skzisis.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2skzisis.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2skzisis.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbv693460.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpbv693460.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbv693460.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbv693460.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpbv693460.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbv693460.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbv693460.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpbv693460.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbv693460.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbv693460.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpbv693460.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbv693460.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbv693460.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    collatz_seq = [n]\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n \xF7 2\n        else\n            n = 3n + 1\n        end\n        push!(collatz_seq,\
    \ n)\n    end\n    return filter(x -> x % 2 != 0, collatz_seq)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjab0i1o7.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmpjab0i1o7.jl:36\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjab0i1o7.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjab0i1o7.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpjab0i1o7.jl:37\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjab0i1o7.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjab0i1o7.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpjab0i1o7.jl:38\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpjab0i1o7.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjab0i1o7.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    if n == 1\n        return [1]\n    end\n    result\
    \ = [n]\n    while n != 1\n        if n % 2 == 0\n            n = n / 2\n    \
    \    else\n            n = 3 * n + 1\n        end\n        push!(result, n)\n\
    \    end\n    return filter(x -> x % 2 != 0, result)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp34f1nf5m.jl:37

    '
  stdout: "test set: Test Failed at /tmp/tmp34f1nf5m.jl:40\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp34f1nf5m.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp34f1nf5m.jl:39\ntest set: Test\
    \ Failed at /tmp/tmp34f1nf5m.jl:41\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp34f1nf5m.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp34f1nf5m.jl:39\ntest set: Test\
    \ Failed at /tmp/tmp34f1nf5m.jl:42\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp34f1nf5m.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp34f1nf5m.jl:39\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    odd_collatz = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n            push!(odd_collatz, n)\n        end\n    end\n\
    \    return sort(odd_collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9shjozy8.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmp9shjozy8.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 16, 22, 34, 40, 52] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9shjozy8.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9shjozy8.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp9shjozy8.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9shjozy8.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9shjozy8.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp9shjozy8.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [10, 12, 16] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9shjozy8.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9shjozy8.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n !=\
    \ 1\n        if n % 2 == 0\n            n = n / 2\n        else\n            n\
    \ = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return filter(x\
    \ -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpncurgl8e.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpncurgl8e.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpncurgl8e.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpncurgl8e.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpncurgl8e.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpncurgl8e.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpncurgl8e.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpncurgl8e.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpncurgl8e.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpncurgl8e.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    odd_collatz = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n/2\n        else\n         \
    \   n = 3*n + 1\n        end\n        if n % 2 != 0\n            push!(odd_collatz,\
    \ n)\n        end\n    end\n    return sort(odd_collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpi3h90a67.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmpi3h90a67.jl:41\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi3h90a67.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi3h90a67.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi3h90a67.jl:43\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi3h90a67.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi3h90a67.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1, 5]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpky1efs32.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpky1efs32.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpky1efs32.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 5] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpky1efs32.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ [1, 5] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    v = [n]\n    while n != 1\n \
    \       if n % 2 == 0\n            n = n / 2\n        else\n            n = 3\
    \ * n + 1\n        end\n        push!(v, n)\n    end\n    return v[v .% 2 .!=\
    \ 0]\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmple6jtv96.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmple6jtv96.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmple6jtv96.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmple6jtv96.jl:38\ntest set: Test\
    \ Failed at /tmp/tmple6jtv96.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmple6jtv96.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmple6jtv96.jl:38\ntest set: Test\
    \ Failed at /tmp/tmple6jtv96.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmple6jtv96.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmple6jtv96.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1, 5]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpky1efs32.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpky1efs32.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpky1efs32.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 5] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpky1efs32.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ [1, 5] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    odd_collatz = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n            push!(odd_collatz, n)\n        end\n    end\n\
    \    return sort(odd_collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9shjozy8.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmp9shjozy8.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 16, 22, 34, 40, 52] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9shjozy8.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9shjozy8.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp9shjozy8.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9shjozy8.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9shjozy8.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp9shjozy8.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [10, 12, 16] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9shjozy8.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9shjozy8.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: -1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmpatp6nlmn.jl:27\n  Test threw
    exception\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError:
    Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n  Closest
    candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpatp6nlmn.jl:21\n   [2] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [3]
    macro expansion\n     @ /tmp/tmpatp6nlmn.jl:27 [inlined]\n   [4] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n   [5]
    top-level scope\n     @ /tmp/tmpatp6nlmn.jl:26\ntest set: Error During Test at
    /tmp/tmpatp6nlmn.jl:28\n  Test threw exception\n  Expression: candidate(5) ==
    [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing to an object
    of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)
    where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n    convert(::Type{T},
    !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n    convert(::Type{T},
    !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n    ...\n  Stacktrace:\n   [1]
    get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpatp6nlmn.jl:21\n   [2] macro expansion\n     @
    /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n   [3]
    macro expansion\n     @ /tmp/'
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    v = [n]\n    while n != 1\n \
    \       if n % 2 == 0\n            n = n / 2\n        else\n            n = 3\
    \ * n + 1\n        end\n        push!(v, n)\n    end\n    return v[v .% 2 .!=\
    \ 0]\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmple6jtv96.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmple6jtv96.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmple6jtv96.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmple6jtv96.jl:38\ntest set: Test\
    \ Failed at /tmp/tmple6jtv96.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmple6jtv96.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmple6jtv96.jl:38\ntest set: Test\
    \ Failed at /tmp/tmple6jtv96.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmple6jtv96.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmple6jtv96.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    # raise NotImplementedError()\n    v = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        push!(v, n)\n    end\n    return filter(x\
    \ -> x % 2 != 0, v)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp86nmx6sf.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmp86nmx6sf.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp86nmx6sf.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp86nmx6sf.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp86nmx6sf.jl:39\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp86nmx6sf.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp86nmx6sf.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp86nmx6sf.jl:40\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp86nmx6sf.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp86nmx6sf.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpjo9hkx5y.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpjo9hkx5y.jl:27\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpjo9hkx5y.jl:21\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjo9hkx5y.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjo9hkx5y.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpjo9hkx5y.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(5) == [1, 5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpjo9hkx5y.jl:21\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjo9hkx5y.jl:28 [inlined]\n\
    \   [4] ma"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    result = [n]\n    while n !=\
    \ 1\n        if n % 2 == 0\n            n = n / 2\n        else\n            n\
    \ = 3 * n + 1\n        end\n        if n % 2 != 0\n            push!(result, n)\n\
    \        end\n    end\n    sort(result)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpz4mub1t7.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmpz4mub1t7.jl:41\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz4mub1t7.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz4mub1t7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpz4mub1t7.jl:43\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz4mub1t7.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz4mub1t7.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1, 5]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpky1efs32.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpky1efs32.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpky1efs32.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 5] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpky1efs32.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ [1, 5] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    collatz = [n]\n    while n != 1\n        if n % 2 == 0\n            n = n/2\n\
    \        else\n            n = 3*n + 1\n        end\n        push!(collatz, n)\n\
    \    end\n    return filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpgmryk_ci.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmpgmryk_ci.jl:36\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgmryk_ci.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgmryk_ci.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpgmryk_ci.jl:37\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgmryk_ci.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgmryk_ci.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpgmryk_ci.jl:38\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgmryk_ci.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgmryk_ci.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1, 5]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpky1efs32.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpky1efs32.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpky1efs32.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 5] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpky1efs32.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ [1, 5] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1, 5]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpky1efs32.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpky1efs32.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpky1efs32.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 5] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpky1efs32.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ [1, 5] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    #raise NotImplementedError()\n    if n == 1\n     \
    \   return [1]\n    end\n    if n % 2 == 0\n        return [1]\n    end\n    return\
    \ [1, n]\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpulf217nv.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmpulf217nv.jl:35\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpulf217nv.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulf217nv.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpulf217nv.jl:37\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpulf217nv.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulf217nv.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # your code here\n    return [1, 5]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkys4gdhc.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpkys4gdhc.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkys4gdhc.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkys4gdhc.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpkys4gdhc.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 5] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkys4gdhc.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkys4gdhc.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpkys4gdhc.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ [1, 5] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkys4gdhc.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkys4gdhc.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1, 5]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpky1efs32.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpky1efs32.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpky1efs32.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 5] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpky1efs32.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ [1, 5] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky1efs32.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky1efs32.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n !=\
    \ 1\n        if n % 2 == 0\n            n = n / 2\n        else\n            n\
    \ = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return filter(x\
    \ -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpncurgl8e.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpncurgl8e.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpncurgl8e.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpncurgl8e.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpncurgl8e.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpncurgl8e.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpncurgl8e.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpncurgl8e.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpncurgl8e.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpncurgl8e.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    #raise NotImplementedError()\n    #return [1, 5]\n\
    \    v = []\n    while n != 1\n        push!(v, n)\n        if n % 2 == 0\n  \
    \          n = n / 2\n        else\n            n = 3 * n + 1\n        end\n \
    \   end\n    push!(v, n)\n    return v\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp85ndy4h7.jl:37

    '
  stdout: "test set: Test Failed at /tmp/tmp85ndy4h7.jl:40\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 7, 22, 11, 34, 17, 52, 26, 13,\
    \ 40, 20, 10, 5, 16, 8, 4, 2, 1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp85ndy4h7.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp85ndy4h7.jl:39\ntest set: Test\
    \ Failed at /tmp/tmp85ndy4h7.jl:41\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 16, 8, 4, 2, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp85ndy4h7.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp85ndy4h7.jl:39\ntest set: Test\
    \ Failed at /tmp/tmp85ndy4h7.jl:42\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [12, 6, 3, 10, 5, 16, 8, 4, 2, 1] == [1, 3, 5]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp85ndy4h7.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp85ndy4h7.jl:39\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    odd_collatz = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n/2\n        else\n         \
    \   n = 3*n + 1\n        end\n        if n % 2 != 0\n            push!(odd_collatz,\
    \ n)\n        end\n    end\n    sort(odd_collatz)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp42a4vlgn.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmp42a4vlgn.jl:41\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp42a4vlgn.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp42a4vlgn.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp42a4vlgn.jl:43\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp42a4vlgn.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp42a4vlgn.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    v = [n]\n    while n != 1\n        if n % 2 == 0\n\
    \            n = n/2\n        else\n            n = 3*n + 1\n        end\n   \
    \     push!(v, n)\n    end\n    return filter(x -> x % 2 != 0, v)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpk2ufovjv.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpk2ufovjv.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpk2ufovjv.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk2ufovjv.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpk2ufovjv.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpk2ufovjv.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk2ufovjv.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpk2ufovjv.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpk2ufovjv.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk2ufovjv.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp98zq_395.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp98zq_395.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp98zq_395.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp98zq_395.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp98zq_395.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp98zq_395.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp98zq_395.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp98zq_395.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp98zq_395.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp98zq_395.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp98zq_395.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp98zq_395.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp98zq_395.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp98zq_395.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp98zq_395.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp98zq_395.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp98zq_395.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp98zq_395.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp98zq_395.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp98zq_395.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp98zq_395.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp98zq_395.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp98zq_395.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp98zq_395.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp98zq_395.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp98zq_395.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    result = [n]\n    while n !=\
    \ 1\n        if n % 2 == 0\n            n = n / 2\n        else\n            n\
    \ = 3 * n + 1\n        end\n        push!(result, n)\n    end\n    return filter(x\
    \ -> x % 2 != 0, result)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbge6o8ru.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpbge6o8ru.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbge6o8ru.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbge6o8ru.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpbge6o8ru.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbge6o8ru.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbge6o8ru.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpbge6o8ru.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbge6o8ru.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbge6o8ru.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    collatz_seq = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        push!(collatz_seq, n)\n    end\n   \
    \ return collatz_seq[collatz_seq .% 2 .!= 0]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpezror5yz.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpezror5yz.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpezror5yz.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpezror5yz.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpezror5yz.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpezror5yz.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpezror5yz.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpezror5yz.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpezror5yz.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpezror5yz.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    #raise NotImplementedError()\n    if n==1\n       \
    \ return [1]\n    end\n    v=[]\n    while n!=1\n        if n%2==0\n         \
    \   n=n/2\n        else\n            n=3*n+1\n            push!(v,n)\n       \
    \ end\n    end\n    return sort(v)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqxtx5_dp.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmpqxtx5_dp.jl:41\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [16, 22, 34, 40, 52] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqxtx5_dp.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqxtx5_dp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqxtx5_dp.jl:42\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqxtx5_dp.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqxtx5_dp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqxtx5_dp.jl:43\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [10, 16] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqxtx5_dp.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqxtx5_dp.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    v = [n]\n    while n != 1\n        if n % 2 == 0\n\
    \            n = n/2\n        else\n            n = 3*n + 1\n        end\n   \
    \     push!(v, n)\n    end\n    return v[v .% 2 .!= 0]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpym8f1qmy.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpym8f1qmy.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpym8f1qmy.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpym8f1qmy.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpym8f1qmy.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpym8f1qmy.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpym8f1qmy.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpym8f1qmy.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpym8f1qmy.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpym8f1qmy.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    odd_collatz = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        if n % 2 != 0\n            push!(odd_collatz,\
    \ n)\n        end\n    end\n    sort(odd_collatz)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6cpx45xa.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmp6cpx45xa.jl:41\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6cpx45xa.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6cpx45xa.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6cpx45xa.jl:43\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6cpx45xa.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6cpx45xa.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    collatz_seq = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        push!(collatz_seq, n)\n    end\n   \
    \ return filter(x -> x % 2 != 0, collatz_seq)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpa5_m0u6t.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpa5_m0u6t.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa5_m0u6t.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa5_m0u6t.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpa5_m0u6t.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa5_m0u6t.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa5_m0u6t.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpa5_m0u6t.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa5_m0u6t.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa5_m0u6t.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    v = Vector{Int64}()\n    while n != 1\n        push!(v,\
    \ n)\n        if n % 2 == 0\n            n = n / 2\n        else\n           \
    \ n = 3 * n + 1\n        end\n    end\n    push!(v, 1)\n    return v\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpggo02xgn.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmpggo02xgn.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 7, 22, 11, 34, 17, 52, 26, 13,\
    \ 40, 20, 10, 5, 16, 8, 4, 2, 1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpggo02xgn.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpggo02xgn.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpggo02xgn.jl:39\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 16, 8, 4, 2, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpggo02xgn.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpggo02xgn.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpggo02xgn.jl:40\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [12, 6, 3, 10, 5, 16, 8, 4, 2, 1] == [1, 3, 5]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpggo02xgn.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpggo02xgn.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # your code here\n    return [1, 5]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkys4gdhc.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpkys4gdhc.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkys4gdhc.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkys4gdhc.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpkys4gdhc.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 5] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkys4gdhc.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkys4gdhc.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpkys4gdhc.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ [1, 5] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkys4gdhc.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkys4gdhc.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmpplcv6n.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmpplcv6n.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmpplcv6n.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmpplcv6n.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmpplcv6n.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted vector that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned vector sorted in increasing order.\n\n    For example:\n\
    \    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16,\
    \ 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7da5dlwh.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp7da5dlwh.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp7da5dlwh.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7da5dlwh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7da5dlwh.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
