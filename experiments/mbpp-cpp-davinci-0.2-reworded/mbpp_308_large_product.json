{
  "name": "mbpp_308_large_product",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "reworded",
  "tests": "}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto [product, pair] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = pair.first, j = pair.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> temp;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            temp.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(temp.begin(), temp.end());\n    for(int i = 0; i < N; i++) {\n        result.push_back(temp[temp.size() - 1 - i]);\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        res.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            pq.push(nums1[i] * nums2[j]);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    for (int i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (s.find({x, y + 1}) == s.end()) {\n            pq.push({nums1[x] * nums2[y + 1], {x, y + 1}});\n            s.insert({x, y + 1});\n        }\n        if (s.find({x + 1, y}) == s.end()) {\n            pq.push({nums1[x + 1] * nums2[y], {x + 1, y}});\n            s.insert({x + 1, y});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>, std::vector<std::pair<long, std::pair<int, int>>>, std::greater<std::pair<long, std::pair<int, int>>>> pq;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    std::unordered_set<int> visited;\n    visited.insert(0);\n    while(N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if(i + 1 < nums1.size() && visited.find((i + 1) * nums2.size() + j) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert((i + 1) * nums2.size() + j);\n        }\n        if(j + 1 < nums2.size() && visited.find(i * nums2.size() + j + 1) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert(i * nums2.size() + j + 1);\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, idx] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = idx.first, j = idx.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "  std::vector<long> res;\n  std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n  std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n  std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n  pq.push({nums1[0] * nums2[0], {0, 0}});\n  std::set<std::pair<int, int>> visited;\n  visited.insert({0, 0});\n  while(N-- > 0 && pq.size() > 0) {\n    auto curr = pq.top();\n    pq.pop();\n    res.push_back(curr.first);\n    int i = curr.second.first, j = curr.second.second;\n    if(i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n      pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n      visited.insert({i + 1, j});\n    }\n    if(j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n      pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n      visited.insert({i, j + 1});\n    }\n  }\n  return res;",
    "    std::vector<long> result;\n    std::vector<long>::iterator it1, it2;\n    std::vector<long>::iterator it1_end = nums1.end();\n    std::vector<long>::iterator it2_end = nums2.end();\n    std::vector<long>::iterator it1_begin = nums1.begin();\n    std::vector<long>::iterator it2_begin = nums2.begin();\n    std::vector<long>::iterator it1_max = nums1.begin();\n    std::vector<long>::iterator it2_max = nums2.begin();\n    long max_product = 0;\n    while(N > 0) {\n        max_product = 0;\n        for(it1 = it1_begin; it1 != it1_end; it1++) {\n            for(it2 = it2_begin; it2 != it2_end; it2++) {\n                if(*it1 * *it2 > max_product) {\n                    max_product = *it1 * *it2;\n                    it1_max = it1;\n                    it2_max = it2;\n                }\n            }\n        }\n        result.push_back(max_product);\n        it1_begin = it1_max + 1;\n        it2_begin = it2_max + 1;\n        N--;\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> max_heap;\n    std::set<std::pair<int, int>> visited;\n    max_heap.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    visited.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        long result_i = max_heap.top().first;\n        int idx1 = max_heap.top().second.first;\n        int idx2 = max_heap.top().second.second;\n        result.push_back(result_i);\n        max_heap.pop();\n        if (idx1 + 1 < nums1.size() && visited.find(std::make_pair(idx1 + 1, idx2)) == visited.end()) {\n            max_heap.push(std::make_pair(nums1[idx1 + 1] * nums2[idx2], std::make_pair(idx1 + 1, idx2)));\n            visited.insert(std::make_pair(idx1 + 1, idx2));\n        }\n        if (idx2 + 1 < nums2.size() && visited.find(std::make_pair(idx1, idx2 + 1)) == visited.end()) {\n            max_heap.push(std::make_pair(nums1[idx1] * nums2[idx2 + 1], std::make_pair(idx1, idx2 + 1)));\n            visited.insert(std::make_pair(idx1, idx2 + 1));\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    s.insert({nums1.size() - 1, nums2.size() - 1});\n    for (int i = 0; i < N; i++) {\n        auto a = pq.top();\n        pq.pop();\n        result.push_back(a.first);\n        int x = a.second.first;\n        int y = a.second.second;\n        if (s.find({x - 1, y}) == s.end()) {\n            pq.push({nums1[x - 1] * nums2[y], {x - 1, y}});\n            s.insert({x - 1, y});\n        }\n        if (s.find({x, y - 1}) == s.end()) {\n            pq.push({nums1[x] * nums2[y - 1], {x, y - 1}});\n            s.insert({x, y - 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> nums1_sorted = nums1;\n    std::vector<long> nums2_sorted = nums2;\n    std::sort(nums1_sorted.begin(), nums1_sorted.end());\n    std::sort(nums2_sorted.begin(), nums2_sorted.end());\n    std::vector<long>::iterator it1 = nums1_sorted.begin();\n    std::vector<long>::iterator it2 = nums2_sorted.begin();\n    while(N--) {\n        if(*it1 > *it2) {\n            result.push_back(*it1);\n            it1++;\n        } else {\n            result.push_back(*it2);\n            it2++;\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if(pq.size() < N) {\n                pq.push(product);\n            } else {\n                if(product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto a = pq.top();\n        pq.pop();\n        result.push_back(a.first);\n        int i = a.second.first, j = a.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "  std::vector<long> result;\n  std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n  std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n  std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n  pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n  std::set<std::pair<int, int>> visited;\n  visited.insert(std::make_pair(0, 0));\n  while (N--) {\n    auto top = pq.top();\n    pq.pop();\n    result.push_back(top.first);\n    int i = top.second.first;\n    int j = top.second.second;\n    if (i + 1 < nums1.size() && visited.find(std::make_pair(i + 1, j)) == visited.end()) {\n      pq.push(std::make_pair(nums1[i + 1] * nums2[j], std::make_pair(i + 1, j)));\n      visited.insert(std::make_pair(i + 1, j));\n    }\n    if (j + 1 < nums2.size() && visited.find(std::make_pair(i, j + 1)) == visited.end()) {\n      pq.push(std::make_pair(nums1[i] * nums2[j + 1], std::make_pair(i, j + 1)));\n      visited.insert(std::make_pair(i, j + 1));\n    }\n  }\n  return result;",
    "\tstd::vector<long> result;\n\tstd::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n\tstd::set<std::pair<int, int>> visited;\n\tpq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n\tvisited.insert(std::make_pair(0, 0));\n\tfor (long i = 0; i < N; i++) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back(p.first);\n\t\tint left = p.second.first, right = p.second.second;\n\t\tif (visited.find(std::make_pair(left + 1, right)) == visited.end()) {\n\t\t\tpq.push(std::make_pair(nums1[left + 1] * nums2[right], std::make_pair(left + 1, right)));\n\t\t\tvisited.insert(std::make_pair(left + 1, right));\n\t\t}\n\t\tif (visited.find(std::make_pair(left, right + 1)) == visited.end()) {\n\t\t\tpq.push(std::make_pair(nums1[left] * nums2[right + 1], std::make_pair(left, right + 1)));\n\t\t\tvisited.insert(std::make_pair(left, right + 1));\n\t\t}\n\t}\n\treturn result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (pq.top() < product) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;"
  ]
}