{
  "name": "mbpp_308_large_product",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "reworded",
  "tests": "}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto [product, pair] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = pair.first, j = pair.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> temp;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            temp.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(temp.begin(), temp.end());\n    for(int i = 0; i < N; i++) {\n        result.push_back(temp[temp.size() - 1 - i]);\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        res.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            pq.push(nums1[i] * nums2[j]);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    for (int i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (s.find({x, y + 1}) == s.end()) {\n            pq.push({nums1[x] * nums2[y + 1], {x, y + 1}});\n            s.insert({x, y + 1});\n        }\n        if (s.find({x + 1, y}) == s.end()) {\n            pq.push({nums1[x + 1] * nums2[y], {x + 1, y}});\n            s.insert({x + 1, y});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>, std::vector<std::pair<long, std::pair<int, int>>>, std::greater<std::pair<long, std::pair<int, int>>>> pq;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    std::unordered_set<int> visited;\n    visited.insert(0);\n    while(N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if(i + 1 < nums1.size() && visited.find((i + 1) * nums2.size() + j) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert((i + 1) * nums2.size() + j);\n        }\n        if(j + 1 < nums2.size() && visited.find(i * nums2.size() + j + 1) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert(i * nums2.size() + j + 1);\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, idx] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = idx.first, j = idx.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "  std::vector<long> res;\n  std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n  std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n  std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n  pq.push({nums1[0] * nums2[0], {0, 0}});\n  std::set<std::pair<int, int>> visited;\n  visited.insert({0, 0});\n  while(N-- > 0 && pq.size() > 0) {\n    auto curr = pq.top();\n    pq.pop();\n    res.push_back(curr.first);\n    int i = curr.second.first, j = curr.second.second;\n    if(i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n      pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n      visited.insert({i + 1, j});\n    }\n    if(j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n      pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n      visited.insert({i, j + 1});\n    }\n  }\n  return res;",
    "    std::vector<long> result;\n    std::vector<long>::iterator it1, it2;\n    std::vector<long>::iterator it1_end = nums1.end();\n    std::vector<long>::iterator it2_end = nums2.end();\n    std::vector<long>::iterator it1_begin = nums1.begin();\n    std::vector<long>::iterator it2_begin = nums2.begin();\n    std::vector<long>::iterator it1_max = nums1.begin();\n    std::vector<long>::iterator it2_max = nums2.begin();\n    long max_product = 0;\n    while(N > 0) {\n        max_product = 0;\n        for(it1 = it1_begin; it1 != it1_end; it1++) {\n            for(it2 = it2_begin; it2 != it2_end; it2++) {\n                if(*it1 * *it2 > max_product) {\n                    max_product = *it1 * *it2;\n                    it1_max = it1;\n                    it2_max = it2;\n                }\n            }\n        }\n        result.push_back(max_product);\n        it1_begin = it1_max + 1;\n        it2_begin = it2_max + 1;\n        N--;\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> max_heap;\n    std::set<std::pair<int, int>> visited;\n    max_heap.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    visited.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        long result_i = max_heap.top().first;\n        int idx1 = max_heap.top().second.first;\n        int idx2 = max_heap.top().second.second;\n        result.push_back(result_i);\n        max_heap.pop();\n        if (idx1 + 1 < nums1.size() && visited.find(std::make_pair(idx1 + 1, idx2)) == visited.end()) {\n            max_heap.push(std::make_pair(nums1[idx1 + 1] * nums2[idx2], std::make_pair(idx1 + 1, idx2)));\n            visited.insert(std::make_pair(idx1 + 1, idx2));\n        }\n        if (idx2 + 1 < nums2.size() && visited.find(std::make_pair(idx1, idx2 + 1)) == visited.end()) {\n            max_heap.push(std::make_pair(nums1[idx1] * nums2[idx2 + 1], std::make_pair(idx1, idx2 + 1)));\n            visited.insert(std::make_pair(idx1, idx2 + 1));\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    s.insert({nums1.size() - 1, nums2.size() - 1});\n    for (int i = 0; i < N; i++) {\n        auto a = pq.top();\n        pq.pop();\n        result.push_back(a.first);\n        int x = a.second.first;\n        int y = a.second.second;\n        if (s.find({x - 1, y}) == s.end()) {\n            pq.push({nums1[x - 1] * nums2[y], {x - 1, y}});\n            s.insert({x - 1, y});\n        }\n        if (s.find({x, y - 1}) == s.end()) {\n            pq.push({nums1[x] * nums2[y - 1], {x, y - 1}});\n            s.insert({x, y - 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> nums1_sorted = nums1;\n    std::vector<long> nums2_sorted = nums2;\n    std::sort(nums1_sorted.begin(), nums1_sorted.end());\n    std::sort(nums2_sorted.begin(), nums2_sorted.end());\n    std::vector<long>::iterator it1 = nums1_sorted.begin();\n    std::vector<long>::iterator it2 = nums2_sorted.begin();\n    while(N--) {\n        if(*it1 > *it2) {\n            result.push_back(*it1);\n            it1++;\n        } else {\n            result.push_back(*it2);\n            it2++;\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if(pq.size() < N) {\n                pq.push(product);\n            } else {\n                if(product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto a = pq.top();\n        pq.pop();\n        result.push_back(a.first);\n        int i = a.second.first, j = a.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "  std::vector<long> result;\n  std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n  std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n  std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n  pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n  std::set<std::pair<int, int>> visited;\n  visited.insert(std::make_pair(0, 0));\n  while (N--) {\n    auto top = pq.top();\n    pq.pop();\n    result.push_back(top.first);\n    int i = top.second.first;\n    int j = top.second.second;\n    if (i + 1 < nums1.size() && visited.find(std::make_pair(i + 1, j)) == visited.end()) {\n      pq.push(std::make_pair(nums1[i + 1] * nums2[j], std::make_pair(i + 1, j)));\n      visited.insert(std::make_pair(i + 1, j));\n    }\n    if (j + 1 < nums2.size() && visited.find(std::make_pair(i, j + 1)) == visited.end()) {\n      pq.push(std::make_pair(nums1[i] * nums2[j + 1], std::make_pair(i, j + 1)));\n      visited.insert(std::make_pair(i, j + 1));\n    }\n  }\n  return result;",
    "\tstd::vector<long> result;\n\tstd::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n\tstd::set<std::pair<int, int>> visited;\n\tpq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n\tvisited.insert(std::make_pair(0, 0));\n\tfor (long i = 0; i < N; i++) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back(p.first);\n\t\tint left = p.second.first, right = p.second.second;\n\t\tif (visited.find(std::make_pair(left + 1, right)) == visited.end()) {\n\t\t\tpq.push(std::make_pair(nums1[left + 1] * nums2[right], std::make_pair(left + 1, right)));\n\t\t\tvisited.insert(std::make_pair(left + 1, right));\n\t\t}\n\t\tif (visited.find(std::make_pair(left, right + 1)) == visited.end()) {\n\t\t\tpq.push(std::make_pair(nums1[left] * nums2[right + 1], std::make_pair(left, right + 1)));\n\t\t\tvisited.insert(std::make_pair(left, right + 1));\n\t\t}\n\t}\n\treturn result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (pq.top() < product) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n        N--;\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while(N-- > 0 && pq.size() > 0) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first, j = top.second.second;\n        if(i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if(j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else if (pq.top() < product) {\n                pq.pop();\n                pq.push(product);\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(auto i:nums1) {\n        for(auto j:nums2) {\n            pq.push(i*j);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while (N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n        if (s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    visited.insert({nums1.size() - 1, nums2.size() - 1});\n    for (int i = 0; i < N; i++) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int r = top.second.first, c = top.second.second;\n        if (r > 0 && visited.find({r - 1, c}) == visited.end()) {\n            pq.push({nums1[r - 1] * nums2[c], {r - 1, c}});\n            visited.insert({r - 1, c});\n        }\n        if (c > 0 && visited.find({r, c - 1}) == visited.end()) {\n            pq.push({nums1[r] * nums2[c - 1], {r, c - 1}});\n            visited.insert({r, c - 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::multiset<long> products;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            products.insert(i * j);\n        }\n    }\n    for (auto i = products.rbegin(); i != products.rend(); i++) {\n        if (N == 0) {\n            break;\n        }\n        result.push_back(*i);\n        N--;\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        res.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> products;\n    for(int i=0;i<nums1.size();i++){\n        for(int j=0;j<nums2.size();j++){\n            products.push_back(nums1[i]*nums2[j]);\n        }\n    }\n    std::sort(products.begin(),products.end());\n    for(int i=0;i<N;i++){\n        result.push_back(products[products.size()-i-1]);\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    visited.insert({nums1.size() - 1, nums2.size() - 1});\n    while(N--) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first;\n        int j = top.second.second;\n        if(i > 0 && visited.find({i - 1, j}) == visited.end()) {\n            pq.push({nums1[i - 1] * nums2[j], {i - 1, j}});\n            visited.insert({i - 1, j});\n        }\n        if(j > 0 && visited.find({i, j - 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j - 1], {i, j - 1}});\n            visited.insert({i, j - 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> nums1_sorted = nums1;\n    std::vector<long> nums2_sorted = nums2;\n    std::sort(nums1_sorted.begin(), nums1_sorted.end());\n    std::sort(nums2_sorted.begin(), nums2_sorted.end());\n    std::vector<long>::iterator it1 = nums1_sorted.end() - 1;\n    std::vector<long>::iterator it2 = nums2_sorted.end() - 1;\n    while (N > 0) {\n        if (*it1 > *it2) {\n            result.push_back(*it1 * *it2);\n            it2--;\n        } else {\n            result.push_back(*it1 * *it2);\n            it1--;\n        }\n        N--;\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i=0; i<nums1.size(); i++) {\n        for(int j=0; j<nums2.size(); j++) {\n            pq.push(nums1[i]*nums2[j]);\n        }\n    }\n    for(int i=0; i<N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i=0;i<nums1.size();i++) {\n        for(int j=0;j<nums2.size();j++) {\n            pq.push(nums1[i]*nums2[j]);\n        }\n    }\n    for(int i=0;i<N;i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first, j = top.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first, j = top.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && pq.size() > 0) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push(i*j);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<long> res;\n    std::multiset<long> ms;\n    for (int i = 0; i < nums1.size(); ++i) {\n        for (int j = 0; j < nums2.size(); ++j) {\n            ms.insert(nums1[i] * nums2[j]);\n        }\n    }\n    auto it = ms.end();\n    while (N--) {\n        res.push_back(*(--it));\n    }\n    return res;",
    "    std::vector<long> result;\n    std::vector<long> product;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            product.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(product.begin(), product.end());\n    for (int i = 0; i < N; i++) {\n        result.push_back(product[product.size() - 1 - i]);\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (pq.top() < product) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else if (product > pq.top()) {\n                pq.pop();\n                pq.push(product);\n            }\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::unordered_set<int> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert(0 * nums2.size() + 0);\n    for (int i = 0; i < N; i++) {\n        auto idx_pair = pq.top().second; pq.pop();\n        res.push_back(nums1[idx_pair.first] * nums2[idx_pair.second]);\n        if (idx_pair.first + 1 < nums1.size() && visited.find((idx_pair.first + 1) * nums2.size() + idx_pair.second) == visited.end()) {\n            pq.push({nums1[idx_pair.first + 1] * nums2[idx_pair.second], {idx_pair.first + 1, idx_pair.second}});\n            visited.insert((idx_pair.first + 1) * nums2.size() + idx_pair.second);\n        }\n        if (idx_pair.second + 1 < nums2.size() && visited.find(idx_pair.first * nums2.size() + idx_pair.second + 1) == visited.end()) {\n            pq.push({nums1[idx_pair.first] * nums2[idx_pair.second + 1], {idx_pair.first, idx_pair.second + 1}});\n            visited.insert(idx_pair.first * nums2.size() + idx_pair.second + 1);\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && pq.size()) {\n        auto t = pq.top();\n        pq.pop();\n        res.push_back(t.first);\n        int i = t.second.first, j = t.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    for (int i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (x + 1 < nums1.size() && visited.find({x + 1, y}) == visited.end()) {\n            pq.push({nums1[x + 1] * nums2[y], {x + 1, y}});\n            visited.insert({x + 1, y});\n        }\n        if (y + 1 < nums2.size() && visited.find({x, y + 1}) == visited.end()) {\n            pq.push({nums1[x] * nums2[y + 1], {x, y + 1}});\n            visited.insert({x, y + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n            if(pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "\tstd::vector<long> res;\n\tstd::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n\tstd::set<std::pair<int, int>> visited;\n\tpq.push({nums1[0] * nums2[0], {0, 0}});\n\tvisited.insert({0, 0});\n\twhile(N--) {\n\t\tauto curr = pq.top();\n\t\tpq.pop();\n\t\tres.push_back(curr.first);\n\t\tint i = curr.second.first, j = curr.second.second;\n\t\tif(i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n\t\t\tpq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n\t\t\tvisited.insert({i + 1, j});\n\t\t}\n\t\tif(j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n\t\t\tpq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n\t\t\tvisited.insert({i, j + 1});\n\t\t}\n\t}\n\treturn res;",
    "  std::vector<long> result;\n  std::multimap<long, std::pair<long, long>> products;\n  for (auto it1 = nums1.begin(); it1 != nums1.end(); it1++) {\n    for (auto it2 = nums2.begin(); it2 != nums2.end(); it2++) {\n      products.insert(std::make_pair(*it1 * *it2, std::make_pair(*it1, *it2)));\n    }\n  }\n  auto it = products.rbegin();\n  for (long i = 0; i < N; i++) {\n    result.push_back(it->second.first);\n    result.push_back(it->second.second);\n    it++;\n  }\n  return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    s.insert({nums1.size() - 1, nums2.size() - 1});\n    while (N--) {\n        auto temp = pq.top();\n        pq.pop();\n        result.push_back(temp.first);\n        int i = temp.second.first;\n        int j = temp.second.second;\n        if (s.find({i - 1, j}) == s.end()) {\n            pq.push({nums1[i - 1] * nums2[j], {i - 1, j}});\n            s.insert({i - 1, j});\n        }\n        if (s.find({i, j - 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j - 1], {i, j - 1}});\n            s.insert({i, j - 1});\n        }\n    }\n    return result;",
    "  std::vector<long> result;\n  std::multiset<long> products;\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      products.insert(nums1[i] * nums2[j]);\n    }\n  }\n  for (long i = 0; i < N; i++) {\n    result.push_back(*products.rbegin());\n    products.erase(--products.end());\n  }\n  return result;",
    "\tstd::vector<long> result;\n\tstd::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n\tstd::set<std::pair<int, int>> s;\n\tstd::sort(nums1.begin(), nums1.end());\n\tstd::sort(nums2.begin(), nums2.end());\n\tpq.push({ nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1} });\n\ts.insert({ nums1.size() - 1, nums2.size() - 1 });\n\twhile (N--) {\n\t\tauto a = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back(a.first);\n\t\tint i = a.second.first;\n\t\tint j = a.second.second;\n\t\tif (s.find({ i - 1, j }) == s.end()) {\n\t\t\tpq.push({ nums1[i - 1] * nums2[j], { i - 1, j } });\n\t\t\ts.insert({ i - 1, j });\n\t\t}\n\t\tif (s.find({ i, j - 1 }) == s.end()) {\n\t\t\tpq.push({ nums1[i] * nums2[j - 1], { i, j - 1 } });\n\t\t\ts.insert({ i, j - 1 });\n\t\t}\n\t}\n\treturn result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto n1 : nums1) {\n        for (auto n2 : nums2) {\n            pq.push(n1 * n2);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        res.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first, j = top.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    std::unordered_set<std::string> visited;\n    visited.insert(\"0,0\");\n    for (int i = 0; i < N; i++) {\n        auto t = pq.top();\n        pq.pop();\n        res.push_back(t.first);\n        int n = t.second.first, m = t.second.second;\n        if (visited.find(std::to_string(n + 1) + \",\" + std::to_string(m)) == visited.end()) {\n            pq.push({nums1[n + 1] * nums2[m], {n + 1, m}});\n            visited.insert(std::to_string(n + 1) + \",\" + std::to_string(m));\n        }\n        if (visited.find(std::to_string(n) + \",\" + std::to_string(m + 1)) == visited.end()) {\n            pq.push({nums1[n] * nums2[m + 1], {n, m + 1}});\n            visited.insert(std::to_string(n) + \",\" + std::to_string(m + 1));\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    visited.insert({nums1.size() - 1, nums2.size() - 1});\n    for (int i = 0; i < N; i++) {\n        auto curr = pq.top();\n        pq.pop();\n        result.push_back(curr.first);\n        int x = curr.second.first;\n        int y = curr.second.second;\n        if (x > 0 && visited.find({x - 1, y}) == visited.end()) {\n            pq.push({nums1[x - 1] * nums2[y], {x - 1, y}});\n            visited.insert({x - 1, y});\n        }\n        if (y > 0 && visited.find({x, y - 1}) == visited.end()) {\n            pq.push({nums1[x] * nums2[y - 1], {x, y - 1}});\n            visited.insert({x, y - 1});\n        }\n    }\n    return result;",
    "  std::vector<long> result;\n  std::vector<long> products;\n  for (int i = 0; i < nums1.size(); i++) {\n    for (int j = 0; j < nums2.size(); j++) {\n      products.push_back(nums1[i] * nums2[j]);\n    }\n  }\n  std::sort(products.begin(), products.end());\n  for (int i = products.size() - 1; i >= products.size() - N; i--) {\n    result.push_back(products[i]);\n  }\n  return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i=0;i<nums1.size();i++) {\n        for(int j=0;j<nums2.size();j++) {\n            pq.push(nums1[i]*nums2[j]);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > s;\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    s.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        long curr = pq.top().first;\n        int x = pq.top().second.first;\n        int y = pq.top().second.second;\n        pq.pop();\n        result.push_back(curr);\n        if (x + 1 < nums1.size() && s.find(std::make_pair(x + 1, y)) == s.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            s.insert(std::make_pair(x + 1, y));\n        }\n        if (y + 1 < nums2.size() && s.find(std::make_pair(x, y + 1)) == s.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            s.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(auto i:nums1) {\n        for(auto j:nums2) {\n            pq.push(i*j);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            min_heap.push(num1 * num2);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        res.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push({nums1.back() * nums2.back(), {(int)nums1.size() - 1, (int)nums2.size() - 1}});\n    visited.insert({(int)nums1.size() - 1, (int)nums2.size() - 1});\n    for (int i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (x > 0 && visited.find({x - 1, y}) == visited.end()) {\n            pq.push({nums1[x - 1] * nums2[y], {x - 1, y}});\n            visited.insert({x - 1, y});\n        }\n        if (y > 0 && visited.find({x, y - 1}) == visited.end()) {\n            pq.push({nums1[x] * nums2[y - 1], {x, y - 1}});\n            visited.insert({x, y - 1});\n        }\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto t = pq.top();\n        pq.pop();\n        res.push_back(t.first);\n        int i = t.second.first, j = t.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            pq.push(num1 * num2);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    std::unordered_set<long> set;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(std::make_pair(product, std::make_pair(i, j)));\n                set.insert(product);\n            } else {\n                if (product > pq.top().first) {\n                    long old_product = pq.top().first;\n                    pq.pop();\n                    pq.push(std::make_pair(product, std::make_pair(i, j)));\n                    set.erase(old_product);\n                    set.insert(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top().first);\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> nums1_copy = nums1;\n    std::vector<long> nums2_copy = nums2;\n    std::sort(nums1_copy.begin(), nums1_copy.end());\n    std::sort(nums2_copy.begin(), nums2_copy.end());\n    std::vector<long>::iterator it1 = nums1_copy.end() - 1;\n    std::vector<long>::iterator it2 = nums2_copy.end() - 1;\n    while (N--) {\n        if (*it1 > *it2) {\n            result.push_back(*it1);\n            it1--;\n        } else {\n            result.push_back(*it2);\n            it2--;\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        result.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long>::iterator it1 = nums1.begin();\n    std::vector<long>::iterator it2 = nums2.begin();\n    std::vector<long>::iterator it3 = nums1.begin();\n    std::vector<long>::iterator it4 = nums2.begin();\n    std::vector<long>::iterator it5 = nums1.begin();\n    std::vector<long>::iterator it6 = nums2.begin();\n    std::vector<long>::iterator it7 = nums1.begin();\n    std::vector<long>::iterator it8 = nums2.begin();\n    std::vector<long>::iterator it9 = nums1.begin();\n    std::vector<long>::iterator it10 = nums2.begin();\n    std::vector<long>::iterator it11 = nums1.begin();\n    std::vector<long>::iterator it12 = nums2.begin();\n    std::vector<long>::iterator it13 = nums1.begin();\n    std::vector<long>::iterator it14 = nums2.begin();\n    std::vector<long>::iterator it15 = nums1.begin();\n    std::vector<long>::iterator it16 = nums2.begin();\n    std::vector<long>::iterator it17 = nums1.begin();\n    std::vector<long>::iterator it18 = nums2.begin();\n    std::vector<long>::iterator it19 = nums1.begin();\n    std::vector<long>::iterator it20 = nums2.begin();\n    std::vector<long>::iterator it21 = nums1.begin();\n    std::vector<long>::iterator it22 = nums2.begin();\n    std::vector<long>::iterator it23 = nums1.begin();\n    std::vector<long>::iterator it24 = nums2.begin();\n    std::vector<long>::iterator it25 = nums1.begin();\n    std::vector<long>::iterator it26 = nums2.begin();\n    std::vector<long>",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        res.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;",
    "  std::vector<long> result;\n  std::priority_queue<long> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push(nums1[i] * nums2[j]);\n    }\n  }\n  for (long i = 0; i < N; i++) {\n    result.push_back(pq.top());\n    pq.pop();\n  }\n  return result;",
    "    std::vector<long> result;\n    std::multimap<long, std::pair<long, long>> map;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            map.insert(std::make_pair(i * j, std::make_pair(i, j)));\n        }\n    }\n    auto it = map.rbegin();\n    while (N--) {\n        result.push_back(it->first);\n        it++;\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    std::set<std::pair<int, int>> visited;\n    visited.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; ++i) {\n        auto a = pq.top();\n        pq.pop();\n        res.push_back(a.first);\n        int x = a.second.first, y = a.second.second;\n        if (visited.find(std::make_pair(x + 1, y)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            visited.insert(std::make_pair(x + 1, y));\n        }\n        if (visited.find(std::make_pair(x, y + 1)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            visited.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        result.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto [product, pair] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = pair.first, j = pair.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > visited;\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    visited.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        long val = pq.top().first;\n        int x = pq.top().second.first;\n        int y = pq.top().second.second;\n        pq.pop();\n        result.push_back(val);\n        if (x + 1 < nums1.size() && visited.find(std::make_pair(x + 1, y)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            visited.insert(std::make_pair(x + 1, y));\n        }\n        if (y + 1 < nums2.size() && visited.find(std::make_pair(x, y + 1)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            visited.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    visited.insert(std::make_pair(0, 0));\n    for (long i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (x + 1 < nums1.size() && visited.find(std::make_pair(x + 1, y)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            visited.insert(std::make_pair(x + 1, y));\n        }\n        if (y + 1 < nums2.size() && visited.find(std::make_pair(x, y + 1)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            visited.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::multimap<long, std::pair<long, long>> products;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            products.insert(std::make_pair(num1 * num2, std::make_pair(num1, num2)));\n        }\n    }\n    auto it = products.rbegin();\n    while (N--) {\n        result.push_back(it->first);\n        it++;\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto n1 : nums1) {\n        for (auto n2 : nums2) {\n            pq.push(n1 * n2);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto t = pq.top();\n        pq.pop();\n        res.push_back(t.first);\n        int i = t.second.first, j = t.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while (N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n        if (s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "\tstd::vector<long> res;\n\tstd::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n\tstd::set<std::pair<int, int>> s;\n\tpq.push({ nums1[0] * nums2[0], {0, 0} });\n\ts.insert({ 0, 0 });\n\tfor (int i = 0; i < N; i++) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tres.push_back(p.first);\n\t\tint x = p.second.first, y = p.second.second;\n\t\tif (s.find({ x + 1, y }) == s.end()) {\n\t\t\tpq.push({ nums1[x + 1] * nums2[y], { x + 1, y } });\n\t\t\ts.insert({ x + 1, y });\n\t\t}\n\t\tif (s.find({ x, y + 1 }) == s.end()) {\n\t\t\tpq.push({ nums1[x] * nums2[y + 1], { x, y + 1 } });\n\t\t\ts.insert({ x, y + 1 });\n\t\t}\n\t}\n\treturn res;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::unordered_set<int> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert(0 * nums2.size() + 0);\n    for (int i = 0; i < N; ++i) {\n        auto a = pq.top();\n        pq.pop();\n        res.push_back(a.first);\n        int x = a.second.first, y = a.second.second;\n        if (x + 1 < nums1.size() && visited.find((x + 1) * nums2.size() + y) == visited.end()) {\n            pq.push({nums1[x + 1] * nums2[y], {x + 1, y}});\n            visited.insert((x + 1) * nums2.size() + y);\n        }\n        if (y + 1 < nums2.size() && visited.find(x * nums2.size() + y + 1) == visited.end()) {\n            pq.push({nums1[x] * nums2[y + 1], {x, y + 1}});\n            visited.insert(x * nums2.size() + y + 1);\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (pq.top() < product) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> products;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            products.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(products.begin(), products.end());\n    for (int i = products.size() - 1; i >= products.size() - N; i--) {\n        result.push_back(products[i]);\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long>::iterator it1, it2;\n    std::vector<long>::iterator it1_end = nums1.end();\n    std::vector<long>::iterator it2_end = nums2.end();\n    std::vector<long>::iterator it1_begin = nums1.begin();\n    std::vector<long>::iterator it2_begin = nums2.begin();\n    long product;\n    for(long i = 0; i < N; i++) {\n        product = 0;\n        for(it1 = it1_begin; it1 != it1_end; it1++) {\n            for(it2 = it2_begin; it2 != it2_end; it2++) {\n                if(*it1 * *it2 > product) {\n                    product = *it1 * *it2;\n                }\n            }\n        }\n        result.push_back(product);\n        it1_end--;\n        it2_end--;\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            long prod = i * j;\n            if (pq.size() < N) {\n                pq.push(prod);\n            } else {\n                if (prod > pq.top()) {\n                    pq.pop();\n                    pq.push(prod);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(auto i:nums1) {\n        for(auto j:nums2) {\n            pq.push(i*j);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    for (int i = 0; i < N; i++) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int x = top.second.first, y = top.second.second;\n        if (x + 1 < nums1.size() && visited.find({x + 1, y}) == visited.end()) {\n            pq.push({nums1[x + 1] * nums2[y], {x + 1, y}});\n            visited.insert({x + 1, y});\n        }\n        if (y + 1 < nums2.size() && visited.find({x, y + 1}) == visited.end()) {\n            pq.push({nums1[x] * nums2[y + 1], {x, y + 1}});\n            visited.insert({x, y + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::vector<long>::iterator it1 = nums1.begin();\n    std::vector<long>::iterator it2 = nums2.begin();\n    while(N--) {\n        if(*it1 < *it2) {\n            result.push_back(*it1 * *(nums2.end() - 1));\n            it1++;\n        }\n        else {\n            result.push_back(*it2 * *(nums1.end() - 1));\n            it2++;\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (min_heap.size() < N) {\n                min_heap.push(product);\n            } else {\n                if (product > min_heap.top()) {\n                    min_heap.pop();\n                    min_heap.push(product);\n                }\n            }\n        }\n    }\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first, j = top.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> products;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            products.push_back(i * j);\n        }\n    }\n    std::sort(products.begin(), products.end());\n    for (int i = products.size() - 1; i >= products.size() - N; i--) {\n        result.push_back(products[i]);\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> product;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            product.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(product.begin(), product.end());\n    for(int i = product.size() - 1; i > product.size() - N - 1; i--) {\n        result.push_back(product[i]);\n    }\n    return result;",
    "    std::vector<long> result;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    visited.insert({nums1.size() - 1, nums2.size() - 1});\n    for (long i = 0; i < N; i++) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int x = top.second.first, y = top.second.second;\n        if (x - 1 >= 0 && visited.find({x - 1, y}) == visited.end()) {\n            pq.push({nums1[x - 1] * nums2[y], {x - 1, y}});\n            visited.insert({x - 1, y});\n        }\n        if (y - 1 >= 0 && visited.find({x, y - 1}) == visited.end()) {\n            pq.push({nums1[x] * nums2[y - 1], {x, y - 1}});\n            visited.insert({x, y - 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> nums1_copy = nums1;\n    std::vector<long> nums2_copy = nums2;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::vector<long>::iterator it1 = nums1.end() - 1;\n    std::vector<long>::iterator it2 = nums2.end() - 1;\n    while (N > 0) {\n        long product = (*it1) * (*it2);\n        result.push_back(product);\n        if (it1 != nums1.begin()) {\n            it1--;\n        } else {\n            it2--;\n        }\n        N--;\n    }\n    return result;",
    "    std::vector<long> result;\n    std::multimap<long, std::pair<long, long>> map;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            map.insert(std::make_pair(nums1[i] * nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    auto it = map.end();\n    for(int i = 0; i < N; i++) {\n        it--;\n        result.push_back(it->first);\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > s;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push(std::make_pair(nums1[nums1.size() - 1] * nums2[nums2.size() - 1], std::make_pair(nums1.size() - 1, nums2.size() - 1)));\n    s.insert(std::make_pair(nums1.size() - 1, nums2.size() - 1));\n    for (int i = 0; i < N; i++) {\n        long product = pq.top().first;\n        int index1 = pq.top().second.first;\n        int index2 = pq.top().second.second;\n        pq.pop();\n        result.push_back(product);\n        if (index1 - 1 >= 0 && s.find(std::make_pair(index1 - 1, index2)) == s.end()) {\n            pq.push(std::make_pair(nums1[index1 - 1] * nums2[index2], std::make_pair(index1 - 1, index2)));\n            s.insert(std::make_pair(index1 - 1, index2));\n        }\n        if (index2 - 1 >= 0 && s.find(std::make_pair(index1, index2 - 1)) == s.end()) {\n            pq.push(std::make_pair(nums1[index1] * nums2[index2 - 1], std::make_pair(index1, index2 - 1)));\n            s.insert(std::make_pair(index1, index2 - 1));\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > visited;\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    visited.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (x + 1 < nums1.size() && visited.find(std::make_pair(x + 1, y)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            visited.insert(std::make_pair(x + 1, y));\n        }\n        if (y + 1 < nums2.size() && visited.find(std::make_pair(x, y + 1)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            visited.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::multimap<long, std::pair<long, long>> products;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            products.insert(std::make_pair(i * j, std::make_pair(i, j)));\n        }\n    }\n    auto it = products.rbegin();\n    while (N--) {\n        result.push_back(it->first);\n        it++;\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, pair] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = pair.first, j = pair.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    int m = nums1.size(), n = nums2.size();\n    std::vector<std::vector<bool>> visited(m, std::vector<bool>(n, false));\n    pq.push({nums1[m - 1] * nums2[n - 1], {m - 1, n - 1}});\n    visited[m - 1][n - 1] = true;\n    while (N-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i > 0 && !visited[i - 1][j]) {\n            pq.push({nums1[i - 1] * nums2[j], {i - 1, j}});\n            visited[i - 1][j] = true;\n        }\n        if (j > 0 && !visited[i][j - 1]) {\n            pq.push({nums1[i] * nums2[j - 1], {i, j - 1}});\n            visited[i][j - 1] = true;\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while (N--) {\n        auto [product, pair] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = pair.first, j = pair.second;\n        if (i + 1 < nums1.size() && s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "  std::vector<long> result;\n  std::priority_queue<long> pq;\n  for (auto i : nums1) {\n    for (auto j : nums2) {\n      pq.push(i * j);\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    result.push_back(pq.top());\n    pq.pop();\n  }\n  return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first, j = top.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::multimap<long, std::pair<long, long>> map;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            map.insert(std::make_pair(nums1[i] * nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    for (auto it = map.rbegin(); it != map.rend(); it++) {\n        result.push_back(it->first);\n        if (result.size() == N) {\n            break;\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (long i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long> > pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::reverse(nums1.begin(), nums1.end());\n    std::reverse(nums2.begin(), nums2.end());\n    for (long i = 0; i < N; i++) {\n        result.push_back(nums1[i] * nums2[i]);\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i=0;i<nums1.size();i++){\n        for(int j=0;j<nums2.size();j++){\n            pq.push(nums1[i]*nums2[j]);\n        }\n    }\n    for(int i=0;i<N;i++){\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while(N-- > 0 && !pq.empty()) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if(i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if(j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::unordered_set<int> visited;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] * nums2[j], std::make_pair(i, j)));\n        }\n    }\n    while (N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        if (visited.find(p.second.first) == visited.end()) {\n            visited.insert(p.second.first);\n            for (int j = 0; j < nums2.size(); j++) {\n                pq.push(std::make_pair(nums1[p.second.first] * nums2[j], std::make_pair(p.second.first, j)));\n            }\n        }\n        if (visited.find(p.second.second) == visited.end()) {\n            visited.insert(p.second.second);\n            for (int i = 0; i < nums1.size(); i++) {\n                pq.push(std::make_pair(nums1[i] * nums2[p.second.second], std::make_pair(i, p.second.second)));\n            }\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto a = pq.top();\n        pq.pop();\n        result.push_back(a.first);\n        int i = a.second.first, j = a.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    std::set<std::pair<long, long>> s;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while (N--) {\n        auto [product, [i, j]] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        if (i + 1 < nums1.size() && s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::multimap<long, std::pair<int, int>> map;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            map.insert(std::pair<long, std::pair<int, int>>(nums1[i] * nums2[j], std::pair<int, int>(i, j)));\n        }\n    }\n    auto it = map.rbegin();\n    while (it != map.rend() && N > 0) {\n        result.push_back(it->first);\n        it++;\n        N--;\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto [product, idx] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = idx.first, j = idx.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            if (pq.size() < N) {\n                pq.push(nums1[i] * nums2[j]);\n            } else {\n                if (nums1[i] * nums2[j] > pq.top()) {\n                    pq.pop();\n                    pq.push(nums1[i] * nums2[j]);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while(N--) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while (N--) {\n        auto [product, idx] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = idx.first, j = idx.second;\n        if (i + 1 < nums1.size() && s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            long product = num1 * num2;\n            if (min_heap.size() < N) {\n                min_heap.push(product);\n            } else if (product > min_heap.top()) {\n                min_heap.pop();\n                min_heap.push(product);\n            }\n        }\n    }\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> q;\n    std::set<std::pair<int, int>> s;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    q.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    s.insert({nums1.size() - 1, nums2.size() - 1});\n    while (N--) {\n        auto temp = q.top();\n        q.pop();\n        result.push_back(temp.first);\n        int i = temp.second.first;\n        int j = temp.second.second;\n        if (s.find({i - 1, j}) == s.end()) {\n            q.push({nums1[i - 1] * nums2[j], {i - 1, j}});\n            s.insert({i - 1, j});\n        }\n        if (s.find({i, j - 1}) == s.end()) {\n            q.push({nums1[i] * nums2[j - 1], {i, j - 1}});\n            s.insert({i, j - 1});\n        }\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i=0;i<nums1.size();i++)\n    {\n        for(int j=0;j<nums2.size();j++)\n        {\n            pq.push(nums1[i]*nums2[j]);\n            if(pq.size()>N)\n                pq.pop();\n        }\n    }\n    while(!pq.empty())\n    {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(result.begin(),result.end());\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    visited.insert({nums1.size() - 1, nums2.size() - 1});\n    while (N--) {\n        auto [product, pair] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = pair.first, j = pair.second;\n        if (i > 0 && visited.find({i - 1, j}) == visited.end()) {\n            pq.push({nums1[i - 1] * nums2[j], {i - 1, j}});\n            visited.insert({i - 1, j});\n        }\n        if (j > 0 && visited.find({i, j - 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j - 1], {i, j - 1}});\n            visited.insert({i, j - 1});\n        }\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push(i*j);\n            if(pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while(!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > s;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    s.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        std::pair<long, std::pair<int, int> > curr = pq.top();\n        pq.pop();\n        result.push_back(curr.first);\n        int x = curr.second.first;\n        int y = curr.second.second;\n        if (s.find(std::make_pair(x + 1, y)) == s.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            s.insert(std::make_pair(x + 1, y));\n        }\n        if (s.find(std::make_pair(x, y + 1)) == s.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            s.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;",
    "\tstd::vector<long> result;\n\tstd::sort(nums1.begin(), nums1.end());\n\tstd::sort(nums2.begin(), nums2.end());\n\tlong i = 0, j = 0;\n\twhile (N--) {\n\t\tif (nums1[i] > nums2[j]) {\n\t\t\tresult.push_back(nums1[i] * nums2[j]);\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\tresult.push_back(nums1[i] * nums2[j]);\n\t\t\tj++;\n\t\t}\n\t}\n\treturn result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    for (long i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> products;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            products.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(products.begin(), products.end());\n    for (long i = products.size() - 1; i >= products.size() - N; i--) {\n        result.push_back(products[i]);\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > s;\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    s.insert(std::make_pair(0, 0));\n    while (N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && s.find(std::make_pair(i + 1, j)) == s.end()) {\n            pq.push(std::make_pair(nums1[i + 1] * nums2[j], std::make_pair(i + 1, j)));\n            s.insert(std::make_pair(i + 1, j));\n        }\n        if (j + 1 < nums2.size() && s.find(std::make_pair(i, j + 1)) == s.end()) {\n            pq.push(std::make_pair(nums1[i] * nums2[j + 1], std::make_pair(i, j + 1)));\n            s.insert(std::make_pair(i, j + 1));\n        }\n    }\n    return result;",
    "    std::vector<long> ans;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while(N--) {\n        auto [product, idx] = pq.top();\n        pq.pop();\n        ans.push_back(product);\n        int i = idx.first, j = idx.second;\n        if(i + 1 < nums1.size() && s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n        if(j + 1 < nums2.size() && s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n    }\n    return ans;",
    "    std::vector<long> result;\n    std::vector<long> products;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            products.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(products.begin(), products.end());\n    for (long i = products.size() - 1; i >= products.size() - N; i--) {\n        result.push_back(products[i]);\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    std::set<std::pair<int, int>> visited;\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        res.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (long i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::unordered_set<int> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert(0 * nums2.size() + 0);\n    for (int i = 0; i < N; ++i) {\n        auto a = pq.top(); pq.pop();\n        res.push_back(a.first);\n        int x = a.second.first, y = a.second.second;\n        if (x + 1 < nums1.size() && visited.find((x + 1) * nums2.size() + y) == visited.end()) {\n            pq.push({nums1[x + 1] * nums2[y], {x + 1, y}});\n            visited.insert((x + 1) * nums2.size() + y);\n        }\n        if (y + 1 < nums2.size() && visited.find(x * nums2.size() + y + 1) == visited.end()) {\n            pq.push({nums1[x] * nums2[y + 1], {x, y + 1}});\n            visited.insert(x * nums2.size() + y + 1);\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto n1 : nums1) {\n        for (auto n2 : nums2) {\n            pq.push(n1 * n2);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(auto i:nums1) {\n        for(auto j:nums2) {\n            pq.push(i*j);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            long product = num1 * num2;\n            if (min_heap.size() < N) {\n                min_heap.push(product);\n            } else {\n                if (product > min_heap.top()) {\n                    min_heap.pop();\n                    min_heap.push(product);\n                }\n            }\n        }\n    }\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else if (pq.top() < product) {\n                pq.pop();\n                pq.push(product);\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    for (int i = 0; i < N; i++) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int row = top.second.first, col = top.second.second;\n        if (row + 1 < nums1.size() && visited.find({row + 1, col}) == visited.end()) {\n            pq.push({nums1[row + 1] * nums2[col], {row + 1, col}});\n            visited.insert({row + 1, col});\n        }\n        if (col + 1 < nums2.size() && visited.find({row, col + 1}) == visited.end()) {\n            pq.push({nums1[row] * nums2[col + 1], {row, col + 1}});\n            visited.insert({row, col + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, idx] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = idx.first, j = idx.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    for (int i = 0; i < N; i++) {\n        auto [product, idx] = pq.top(); pq.pop();\n        result.push_back(product);\n        int i = idx.first, j = idx.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    visited.insert(std::make_pair(0, 0));\n    for (long i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first;\n        int y = p.second.second;\n        if (x + 1 < nums1.size() && visited.find(std::make_pair(x + 1, y)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            visited.insert(std::make_pair(x + 1, y));\n        }\n        if (y + 1 < nums2.size() && visited.find(std::make_pair(x, y + 1)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            visited.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long>::iterator it1, it2;\n    std::vector<long>::iterator it1_end = nums1.end();\n    std::vector<long>::iterator it2_end = nums2.end();\n    for (it1 = nums1.begin(); it1 != it1_end; ++it1) {\n        for (it2 = nums2.begin(); it2 != it2_end; ++it2) {\n            result.push_back(*it1 * *it2);\n        }\n    }\n    std::sort(result.begin(), result.end(), std::greater<long>());\n    result.resize(N);\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while (N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n        if (s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push(i * j);\n            if(pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        result.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    visited.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (x + 1 < nums1.size() && visited.find(std::make_pair(x + 1, y)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            visited.insert(std::make_pair(x + 1, y));\n        }\n        if (y + 1 < nums2.size() && visited.find(std::make_pair(x, y + 1)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            visited.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::multimap<long, std::pair<long, long>> m;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            m.insert(std::make_pair(nums1[i] * nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    for (auto it = m.rbegin(); it != m.rend(); it++) {\n        if (N == 0) {\n            break;\n        }\n        result.push_back(it->first);\n        N--;\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (long i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > s;\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    s.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        std::pair<long, std::pair<int, int> > p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (s.find(std::make_pair(x + 1, y)) == s.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            s.insert(std::make_pair(x + 1, y));\n        }\n        if (s.find(std::make_pair(x, y + 1)) == s.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            s.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<long> pq;\n    std::unordered_set<long> s;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n                s.insert(product);\n            } else {\n                if (product > pq.top() && s.find(product) == s.end()) {\n                    pq.pop();\n                    pq.push(product);\n                    s.insert(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<long> max_heap;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            max_heap.push(num1 * num2);\n            if (max_heap.size() > N)\n                max_heap.pop();\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while(N--) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while(N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if(i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if(j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::vector<long> products;\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            products.push_back(i*j);\n        }\n    }\n    std::sort(products.begin(), products.end());\n    for(long i = products.size()-1; i >= products.size()-N; i--) {\n        result.push_back(products[i]);\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> max_heap;\n    std::unordered_set<std::pair<int, int>, pair_hash> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    max_heap.emplace(nums1[0] * nums2[0], std::make_pair(0, 0));\n    visited.emplace(0, 0);\n    for (int i = 0; i < N; ++i) {\n        long number = max_heap.top().first;\n        int row = max_heap.top().second.first, col = max_heap.top().second.second;\n        max_heap.pop();\n        result.emplace_back(number);\n        if (row + 1 < nums1.size() && visited.count(std::make_pair(row + 1, col)) == 0) {\n            max_heap.emplace(nums1[row + 1] * nums2[col], std::make_pair(row + 1, col));\n            visited.emplace(row + 1, col);\n        }\n        if (col + 1 < nums2.size() && visited.count(std::make_pair(row, col + 1)) == 0) {\n            max_heap.emplace(nums1[row] * nums2[col + 1], std::make_pair(row, col + 1));\n            visited.emplace(row, col + 1);\n        }\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    std::unordered_set<long> set;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (set.find(i * nums2.size() + j) == set.end()) {\n                pq.push({nums1[i] * nums2[j], {i, j}});\n                set.insert(i * nums2.size() + j);\n            }\n        }\n    }\n    for (long i = 0; i < N; i++) {\n        result.push_back(pq.top().first);\n        pq.pop();\n    }\n    return result;",
    "    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && pq.size()) {\n        auto [product, pair] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = pair.first, j = pair.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;",
    "    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::unordered_set<int> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert(0 * nums2.size() + 0);\n    for (int i = 0; i < N; i++) {\n        auto idx_pair = pq.top().second;\n        pq.pop();\n        res.push_back(nums1[idx_pair.first] * nums2[idx_pair.second]);\n        if (idx_pair.first + 1 < nums1.size() && visited.find((idx_pair.first + 1) * nums2.size() + idx_pair.second) == visited.end()) {\n            pq.push({nums1[idx_pair.first + 1] * nums2[idx_pair.second], {idx_pair.first + 1, idx_pair.second}});\n            visited.insert((idx_pair.first + 1) * nums2.size() + idx_pair.second);\n        }\n        if (idx_pair.second + 1 < nums2.size() && visited.find(idx_pair.first * nums2.size() + idx_pair.second + 1) == visited.end()) {\n            pq.push({nums1[idx_pair.first] * nums2[idx_pair.second + 1], {idx_pair.first, idx_pair.second + 1}});\n            visited.insert(idx_pair.first * nums2.size() + idx_pair.second + 1);\n        }\n    }\n    return res;",
    "    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (pq.top() < product) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;"
  ]
}