{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long>{0, 0});\n    while (k-- > 0 && !max_heap.empty()) {\n        std::vector<long> pair = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long>{nums1[pair[0]], nums2[pair[1]]});\n        if (pair[0] + 1 < nums1.size()) {\n            max_heap.emplace(std::vector<long>{pair[0] + 1, pair[1]});\n        }\n        if (pair[0] == 0 && pair[1] + 1 < nums2.size()) {\n            max_heap.emplace(std::vector<long>{pair[0], pair[1] + 1});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(!pq.empty() && k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [&](std::vector<long> a, std::vector<long> b) {\n            return a[0] + a[1] < b[0] + b[1];\n        }\n    );\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            max_heap.push({i, j});\n            if(max_heap.size() > k)\n                max_heap.pop();\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n            if (pq.size() > k) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            max_heap.push({i, j});\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.emplace_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        long i = pq.top().second.first;\n        long j = pq.top().second.second;\n        result.push_back({nums1[i], nums2[j]});\n        pq.pop();\n        if(j + 1 < nums2.size()) {\n            pq.push({nums1[i] + nums2[j + 1], {i, j + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;"
  ]
}