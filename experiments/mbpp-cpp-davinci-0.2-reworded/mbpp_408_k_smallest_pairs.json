{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long>{0, 0});\n    while (k-- > 0 && !max_heap.empty()) {\n        std::vector<long> pair = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long>{nums1[pair[0]], nums2[pair[1]]});\n        if (pair[0] + 1 < nums1.size()) {\n            max_heap.emplace(std::vector<long>{pair[0] + 1, pair[1]});\n        }\n        if (pair[0] == 0 && pair[1] + 1 < nums2.size()) {\n            max_heap.emplace(std::vector<long>{pair[0], pair[1] + 1});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(!pq.empty() && k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [&](std::vector<long> a, std::vector<long> b) {\n            return a[0] + a[1] < b[0] + b[1];\n        }\n    );\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            max_heap.push({i, j});\n            if(max_heap.size() > k)\n                max_heap.pop();\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n            if (pq.size() > k) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            max_heap.push({i, j});\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.emplace_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        long i = pq.top().second.first;\n        long j = pq.top().second.second;\n        result.push_back({nums1[i], nums2[j]});\n        pq.pop();\n        if(j + 1 < nums2.size()) {\n            pq.push({nums1[i] + nums2[j + 1], {i, j + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n    return result;\n  }\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n      [](std::vector<long> a, std::vector<long> b) { return a[0] + a[1] < b[0] + b[1]; });\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      if (max_heap.size() < k) {\n        max_heap.push({nums1[i], nums2[j]});\n      } else {\n        if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n          max_heap.pop();\n          max_heap.push({nums1[i], nums2[j]});\n        }\n      }\n    }\n  }\n  while (!max_heap.empty()) {\n    result.push_back(max_heap.top());\n    max_heap.pop();\n  }\n  return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> min_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (min_heap.size() < k) {\n                min_heap.push({nums1[i], nums2[j], i, j});\n            } else {\n                if (nums1[i] + nums2[j] < min_heap.top()[0] + min_heap.top()[1]) {\n                    min_heap.pop();\n                    min_heap.push({nums1[i], nums2[j], i, j});\n                }\n            }\n        }\n    }\n    while (!min_heap.empty()) {\n        result.push_back({min_heap.top()[0], min_heap.top()[1]});\n        min_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            max_heap.push({i, j});\n            if(max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            max_heap.push({i, j});\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < std::min(k, (long)nums1.size()); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto pair = pq.top();\n        pq.pop();\n        result.push_back({nums1[pair.second.first], nums2[pair.second.second]});\n        if (pair.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[pair.second.first] + nums2[pair.second.second + 1], std::make_pair(pair.second.first, pair.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [](std::vector<long> a, std::vector<long> b) {\n            return a[0] + a[1] < b[0] + b[1];\n        });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if(p.second.second + 1 < nums2.size()) {\n            pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty())\n            break;\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> min_heap;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tmin_heap.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k > 0 && !min_heap.empty()) {\n\t\tstd::pair<long, std::pair<long, long>> top = min_heap.top();\n\t\tmin_heap.pop();\n\t\tresult.push_back({nums1[top.second.first], nums2[top.second.second]});\n\t\tif (top.second.second + 1 < nums2.size()) {\n\t\t\tmin_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n\t\t}\n\t\tk--;\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> min_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (min_heap.size() < k) {\n                min_heap.push({nums1[i], nums2[j], i, j});\n            } else {\n                if (nums1[i] + nums2[j] < min_heap.top()[0] + min_heap.top()[1]) {\n                    min_heap.pop();\n                    min_heap.push({nums1[i], nums2[j], i, j});\n                }\n            }\n        }\n    }\n    while (!min_heap.empty()) {\n        result.push_back({min_heap.top()[0], min_heap.top()[1]});\n        min_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (!max_heap.empty() && k > 0) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto temp = pq.top();\n        pq.pop();\n        result.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n        if (temp.second.second + 1 < nums2.size()) {\n            pq.push({nums1[temp.second.first] + nums2[temp.second.second + 1], {temp.second.first, temp.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return (a[0] + a[1]) > (b[0] + b[1]);\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.emplace_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); ++i) {\n        for(long j = 0; j < nums2.size(); ++j) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(std::vector<long>{pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            if (pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n            if (max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {i, j}});\n        }\n    }\n    while (k--) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {i, j}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        auto [sum, pair] = pq.top();\n        pq.pop();\n        result.push_back({nums1[pair.first], nums2[pair.second]});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tmax_heap.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        k--;\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] > nums1[b[0]] + nums2[b[1]];\n    });\n    pq.push({0, 0});\n    while(k-- && !pq.empty()) {\n        auto [i, j] = pq.top();\n        pq.pop();\n        result.push_back({nums1[i], nums2[j]});\n        if(j + 1 < nums2.size()) pq.push({i, j + 1});\n        if(j == 0 && i + 1 < nums1.size()) pq.push({i + 1, j});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long>{0, 0});\n    while(k-- > 0 && !max_heap.empty()) {\n        std::vector<long> top = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long>{nums1[top[0]], nums2[top[1]]});\n        if(top[0] + 1 < nums1.size()) {\n            max_heap.emplace(std::vector<long>{top[0] + 1, top[1]});\n        }\n        if(top[0] == 0 && top[1] + 1 < nums2.size()) {\n            max_heap.emplace(std::vector<long>{top[0], top[1] + 1});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (auto i = 0; i < nums1.size(); ++i) {\n        for (auto j = 0; j < nums2.size(); ++j) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- && !pq.empty()) {\n        auto pair = pq.top();\n        pq.pop();\n        result.push_back({pair.second.first, pair.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push({nums1[i], nums2[j]});\n    }\n  }\n  while (k--) {\n    result.push_back(pq.top());\n    pq.pop();\n  }\n  return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [](std::vector<long> a, std::vector<long> b) {\n            return a[0] + a[1] < b[0] + b[1];\n        });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while(!pq.empty() && k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            max_heap.push({i, j});\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            pq.push({num1, num2});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long> {0, 0});\n    while (k-- > 0 && !max_heap.empty()) {\n        std::vector<long> pair = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long> {nums1[pair[0]], nums2[pair[1]]});\n        if (pair[0] + 1 < nums1.size())\n            max_heap.emplace(std::vector<long> {pair[0] + 1, pair[1]});\n        if (pair[0] == 0 && pair[1] + 1 < nums2.size())\n            max_heap.emplace(std::vector<long> {pair[0], pair[1] + 1});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::vector<long> sums;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            sums.push_back(nums1[i] + nums2[j]);\n        }\n    }\n    std::sort(sums.begin(), sums.end());\n    for(long i = 0; i < k; i++) {\n        std::vector<long> temp;\n        temp.push_back(sums[i]);\n        temp.push_back(sums[i] - temp[0]);\n        result.push_back(temp);\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.empty() || nums2.empty()) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t});\n\tfor (auto i : nums1) {\n\t\tfor (auto j : nums2) {\n\t\t\tmax_heap.push({i, j});\n\t\t\tif (max_heap.size() > k) {\n\t\t\t\tmax_heap.pop();\n\t\t\t}\n\t\t}\n\t}\n\twhile (!max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> min_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        min_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !min_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = min_heap.top();\n        min_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            min_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    std::unordered_set<std::string> visited;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            std::string key = std::to_string(i) + \"|\" + std::to_string(j);\n            if (visited.find(key) == visited.end()) {\n                max_heap.push({nums1[i] + nums2[j], {i, j}});\n                visited.insert(key);\n            }\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            max_heap.push({i, j});\n            if(max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {i, j}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k == 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] > nums1[b[0]] + nums2[b[1]];\n    });\n    pq.push({ 0, 0 });\n    while (k-- > 0 && !pq.empty()) {\n        auto idx_pair = pq.top();\n        pq.pop();\n        result.push_back({ nums1[idx_pair[0]], nums2[idx_pair[1]] });\n        if (idx_pair[0] + 1 < nums1.size())\n            pq.push({ idx_pair[0] + 1, idx_pair[1] });\n        if (idx_pair[0] == 0 && idx_pair[1] + 1 < nums2.size())\n            pq.push({ idx_pair[0], idx_pair[1] + 1 });\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [](std::vector<long> a, std::vector<long> b) { return a[0] + a[1] > b[0] + b[1]; });\n    for (long i = 0; i < nums1.size() && i < k; i++)\n        max_heap.push({nums1[i], nums2[0], 0});\n    while (k-- > 0 && !max_heap.empty()) {\n        auto curr = max_heap.top();\n        max_heap.pop();\n        result.push_back({curr[0], curr[1]});\n        if (curr[2] == nums2.size() - 1)\n            continue;\n        max_heap.push({curr[0], nums2[curr[2] + 1], curr[2] + 1});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  if (nums1.empty() || nums2.empty()) {\n    return result;\n  }\n  std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n  }\n  while (k > 0 && !pq.empty()) {\n    auto p = pq.top();\n    pq.pop();\n    result.push_back({nums1[p.second.first], nums2[p.second.second]});\n    if (p.second.second + 1 < nums2.size()) {\n      pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n    }\n    k--;\n  }\n  return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto pair = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[pair.second.first], nums2[pair.second.second]});\n        if (pair.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[pair.second.first] + nums2[pair.second.second + 1], std::make_pair(pair.second.first, pair.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  if (nums1.size() == 0 || nums2.size() == 0) {\n    return result;\n  }\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n    return a[0] + a[1] > b[0] + b[1];\n  });\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push({nums1[i], nums2[j]});\n    }\n  }\n  while (k-- > 0 && !pq.empty()) {\n    result.push_back(pq.top());\n    pq.pop();\n  }\n  return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n        k--;\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[top.second.first], nums2[top.second.second]});\n\t\tif (top.second.second + 1 < nums2.size()) {\n\t\t\tpq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n\t\t}\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n    return a[0] + a[1] > b[0] + b[1];\n  });\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push({nums1[i], nums2[j]});\n    }\n  }\n  while (k-- > 0 && !pq.empty()) {\n    result.push_back(pq.top());\n    pq.pop();\n  }\n  return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n    }\n  }\n  while (k--) {\n    if (pq.empty()) {\n      break;\n    }\n    std::pair<long, std::pair<long, long>> top = pq.top();\n    pq.pop();\n    result.push_back({top.second.first, top.second.second});\n  }\n  return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto temp = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n        if (temp.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[temp.second.first] + nums2[temp.second.second + 1], std::make_pair(temp.second.first, temp.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty() || k <= 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b){\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            max_heap.push({i, j});\n            if(max_heap.size() > k)\n                max_heap.pop();\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) return result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tpq.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long> {0, 0});\n    while (k-- > 0 && !max_heap.empty()) {\n        auto idx_pair = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long> {nums1[idx_pair[0]], nums2[idx_pair[1]]});\n        if (idx_pair[0] + 1 < nums1.size())\n            max_heap.emplace(std::vector<long> {idx_pair[0] + 1, idx_pair[1]});\n        if (idx_pair[0] == 0 && idx_pair[1] + 1 < nums2.size())\n            max_heap.emplace(std::vector<long> {idx_pair[0], idx_pair[1] + 1});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) return result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto pair = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[pair.second.first], nums2[pair.second.second]});\n        if (pair.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[pair.second.first] + nums2[pair.second.second + 1], std::make_pair(pair.second.first, pair.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0 || k == 0) return result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tpq.push({ nums1[i], nums2[j] });\n\t\t}\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (!pq.empty() && k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> min_heap;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            min_heap.push({num1, num2});\n        }\n    }\n    while (k--) {\n        if (min_heap.empty()) {\n            break;\n        }\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (!pq.empty() && k--) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (!pq.empty() && k--) {\n        result.push_back(std::vector<long>{pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> min_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        min_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !min_heap.empty()) {\n        std::pair<long, std::pair<long, long>> current = min_heap.top();\n        min_heap.pop();\n        result.push_back({nums1[current.second.first], nums2[current.second.second]});\n        if(current.second.second + 1 < nums2.size()) {\n            min_heap.push({nums1[current.second.first] + nums2[current.second.second + 1], {current.second.first, current.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[top.second.first], nums2[top.second.second]});\n\t\tif (top.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n\t\t}\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            max_heap.push({i, j});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b){\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if(p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> temp = pq.top();\n        pq.pop();\n        result.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n        if(temp.second.second + 1 < nums2.size()) {\n            pq.push({nums1[temp.second.first] + nums2[temp.second.second + 1], {temp.second.first, temp.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k <= 0)\n        return result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size() && i < k; i++)\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    while (k-- > 0 && max_heap.empty() == false) {\n        auto idx_pair = max_heap.top().second;\n        max_heap.pop();\n        result.push_back({nums1[idx_pair.first], nums2[idx_pair.second]});\n        if (idx_pair.second == nums2.size() - 1)\n            continue;\n        max_heap.push(std::make_pair(nums1[idx_pair.first] + nums2[idx_pair.second + 1], std::make_pair(idx_pair.first, idx_pair.second + 1)));\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n            if (max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            max_heap.push({num1, num2});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(std::vector<long>{pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> res;\n    if (nums1.empty() || nums2.empty() || k <= 0) return res;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n            if (pq.size() > k) pq.pop();\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (!pq.empty() && k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> temp = pq.top();\n        pq.pop();\n        result.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n        if(temp.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[temp.second.first] + nums2[temp.second.second + 1], std::make_pair(temp.second.first, temp.second.second + 1)));\n        }\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  if(nums1.size() == 0 || nums2.size() == 0) {\n    return result;\n  }\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n    return a[0] + a[1] < b[0] + b[1];\n  });\n  for(long i = 0; i < nums1.size(); i++) {\n    for(long j = 0; j < nums2.size(); j++) {\n      if(max_heap.size() < k) {\n        max_heap.push({nums1[i], nums2[j]});\n      } else {\n        if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n          max_heap.pop();\n          max_heap.push({nums1[i], nums2[j]});\n        }\n      }\n    }\n  }\n  while(!max_heap.empty()) {\n    result.push_back(max_heap.top());\n    max_heap.pop();\n  }\n  return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> min_heap;\n    min_heap.push({nums1[0] + nums2[0], {0, 0}});\n    while (k-- > 0 && !min_heap.empty()) {\n        auto top = min_heap.top();\n        min_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.first + 1 < nums1.size()) {\n            min_heap.push({nums1[top.second.first + 1] + nums2[top.second.second], {top.second.first + 1, top.second.second}});\n        }\n        if (top.second.first == 0 && top.second.second + 1 < nums2.size()) {\n            min_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top()[1], pq.top()[2]});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "\tstd::vector<std::vector<long>> result;\n\tif (nums1.empty() || nums2.empty()) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tmax_heap.push({nums1[i], nums2[0], 0});\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tauto top = max_heap.top();\n\t\tmax_heap.pop();\n\t\tresult.push_back({top[0], top[1]});\n\t\tif (top[2] == nums2.size() - 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tmax_heap.push({top[0], nums2[top[2] + 1], top[2] + 1});\n\t}\n\treturn result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  if (nums1.empty() || nums2.empty() || k <= 0) {\n    return result;\n  }\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n    return a[0] + a[1] > b[0] + b[1];\n  });\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      if (max_heap.size() < k) {\n        max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n      } else {\n        if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n          max_heap.pop();\n          max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n        }\n      }\n    }\n  }\n  while (!max_heap.empty()) {\n    result.emplace_back(max_heap.top());\n    max_heap.pop();\n  }\n  return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (!pq.empty() && k > 0) {\n        result.push_back(pq.top());\n        pq.pop();\n        k--;\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b){\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long>{0, 0});\n    while(k-- > 0 && !max_heap.empty()) {\n        auto idx_pair = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long>{nums1[idx_pair[0]], nums2[idx_pair[1]]});\n        if(idx_pair[0] + 1 < nums1.size()) {\n            max_heap.emplace(std::vector<long>{idx_pair[0] + 1, idx_pair[1]});\n        }\n        if(idx_pair[0] == 0 && idx_pair[1] + 1 < nums2.size()) {\n            max_heap.emplace(std::vector<long>{idx_pair[0], idx_pair[1] + 1});\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto temp = pq.top();\n        pq.pop();\n        result.push_back({temp.second.first, temp.second.second});\n    }\n    return result;",
    "  std::vector<std::vector<long>> result;\n  if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n    return result;\n  }\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n    return a[0] + a[1] > b[0] + b[1];\n  });\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      if (max_heap.size() < k) {\n        max_heap.push({nums1[i], nums2[j]});\n      } else {\n        if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n          max_heap.pop();\n          max_heap.push({nums1[i], nums2[j]});\n        }\n      }\n    }\n  }\n  while (!max_heap.empty()) {\n    result.push_back(max_heap.top());\n    max_heap.pop();\n  }\n  return result;",
    "    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;",
    "    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;"
  ]
}