{
  "name": "mbpp_440_find_adverb_position",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Write a function to find the first adverb and their positions in a given sentence.\nUnion_std_string_long find_adverb_position(std::string text) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_440_find_adverb_position.py",
  "prompt_terminology": "reworded",
  "tests": "}\nint main() {\n    auto candidate = find_adverb_position;\n    assert(candidate((\"clearly!! we can see the sky\")) == std::make_tuple(0, 7, \"clearly\"));\n    assert(candidate((\"seriously!! there are many roses\")) == std::make_tuple(0, 9, \"seriously\"));\n    assert(candidate((\"unfortunately!! sita is going to home\")) == std::make_tuple(0, 13, \"unfortunately\"));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    std::regex adverb_regex(\"\\\\b[A-Za-z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return m.str(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"(([^.!?]*\\\\b)([a-zA-Z]+ly)(\\\\b[^.!?]*[.!?]))\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart(text.cbegin());\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        std::cout << \"adverb found: \" << adverb_match[3] << '\\n';\n        std::cout << \"at position: \" << adverb_match.position(3) << '\\n';\n        searchStart += adverb_match.position(3) + adverb_match.length(3);\n        return Union_std_string_long(adverb_match[3]);\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(m.str(1));",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(std::string(\"No adverb found\"));\n    }\n    return Union_std_string_long(long(adverb_match.position(0)));",
    "    std::regex re(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, re)) {\n        return Union_std_string_long(match.str());\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\"};\n    std::string text_lower = \"\";\n    for (int i = 0; i < text.length(); i++) {\n        text_lower += tolower(text[i]);\n    }\n    for (int i = 0; i < 5; i++) {\n        int pos = text_lower.find(adverbs[i]);\n        if (pos != std::string::npos) {\n            return pos;\n        }\n    }\n    return \"Not found\";",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if(std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return std::string(\"No adverb found\");",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return Union_std_string_long(m.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"(\\\\w+ly)\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() > 1) {\n        return Union_std_string_long(m.str(1));\n    }\n    return Union_std_string_long(-1);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex r(\"\\\\b[^\\\\s]+\\\\b\");\n    std::smatch m;\n    std::string::const_iterator searchStart( text.cbegin() );\n    std::string::const_iterator searchEnd( text.cend() );\n    std::string adverb;\n    long position = -1;\n    while (std::regex_search(searchStart, searchEnd, m, r)) {\n        std::string word = m[0];\n        if (word.back() == 'ly') {\n            adverb = word;\n            position = m.position(0);\n            break;\n        }\n        searchStart = m.suffix().first;\n    }\n    return Union_std_string_long(adverb);",
    "    std::regex adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::string::const_iterator searchStart(text.cbegin());\n    while (std::regex_search(searchStart, text.cend(), match, adverb)) {\n        return Union_std_string_long(match[1]);\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return adverb_match[0].str();\n    }\n    return -1;",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() > 0) {\n        return Union_std_string_long(m.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);"
  ]
}