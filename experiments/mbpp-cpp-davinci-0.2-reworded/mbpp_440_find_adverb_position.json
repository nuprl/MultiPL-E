{
  "name": "mbpp_440_find_adverb_position",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Write a function to find the first adverb and their positions in a given sentence.\nUnion_std_string_long find_adverb_position(std::string text) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_440_find_adverb_position.py",
  "prompt_terminology": "reworded",
  "tests": "}\nint main() {\n    auto candidate = find_adverb_position;\n    assert(candidate((\"clearly!! we can see the sky\")) == std::make_tuple(0, 7, \"clearly\"));\n    assert(candidate((\"seriously!! there are many roses\")) == std::make_tuple(0, 9, \"seriously\"));\n    assert(candidate((\"unfortunately!! sita is going to home\")) == std::make_tuple(0, 13, \"unfortunately\"));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    std::regex adverb_regex(\"\\\\b[A-Za-z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return m.str(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"(([^.!?]*\\\\b)([a-zA-Z]+ly)(\\\\b[^.!?]*[.!?]))\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart(text.cbegin());\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        std::cout << \"adverb found: \" << adverb_match[3] << '\\n';\n        std::cout << \"at position: \" << adverb_match.position(3) << '\\n';\n        searchStart += adverb_match.position(3) + adverb_match.length(3);\n        return Union_std_string_long(adverb_match[3]);\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(m.str(1));",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(std::string(\"No adverb found\"));\n    }\n    return Union_std_string_long(long(adverb_match.position(0)));",
    "    std::regex re(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, re)) {\n        return Union_std_string_long(match.str());\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\"};\n    std::string text_lower = \"\";\n    for (int i = 0; i < text.length(); i++) {\n        text_lower += tolower(text[i]);\n    }\n    for (int i = 0; i < 5; i++) {\n        int pos = text_lower.find(adverbs[i]);\n        if (pos != std::string::npos) {\n            return pos;\n        }\n    }\n    return \"Not found\";",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if(std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return std::string(\"No adverb found\");",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return Union_std_string_long(m.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"(\\\\w+ly)\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() > 1) {\n        return Union_std_string_long(m.str(1));\n    }\n    return Union_std_string_long(-1);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex r(\"\\\\b[^\\\\s]+\\\\b\");\n    std::smatch m;\n    std::string::const_iterator searchStart( text.cbegin() );\n    std::string::const_iterator searchEnd( text.cend() );\n    std::string adverb;\n    long position = -1;\n    while (std::regex_search(searchStart, searchEnd, m, r)) {\n        std::string word = m[0];\n        if (word.back() == 'ly') {\n            adverb = word;\n            position = m.position(0);\n            break;\n        }\n        searchStart = m.suffix().first;\n    }\n    return Union_std_string_long(adverb);",
    "    std::regex adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::string::const_iterator searchStart(text.cbegin());\n    while (std::regex_search(searchStart, text.cend(), match, adverb)) {\n        return Union_std_string_long(match[1]);\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return adverb_match[0].str();\n    }\n    return -1;",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() > 0) {\n        return Union_std_string_long(m.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\w+ly\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if(adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb)) {\n        return Union_std_string_long(match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex re(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), match, re)) {\n        return Union_std_string_long(match.str());\n        searchStart += match.position() + match.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str(1));\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"merrily\", \"sweetly\", \"loudly\", \"quietly\", \"sadly\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"happily\", \"angrily\", \"madly\", \"badly\", \"suddenly\", \"sadly\", \"",
    "    std::regex adverb_regex(\"\\\\b[\\\\w]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb(\"\\\\w+ly\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"loudly\", \"happily\", \"sadly\", \"angrily\", \"quietly\", \"well\", \"badly\", \"hard\", \"fast\", \"early\", \"late\"};\n    std::string text_lower = text;\n    std::transform(text_lower.begin(), text_lower.end(), text_lower.begin(), ::tolower);\n    std::vector<std::string> words;\n    std::stringstream ss(text_lower);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    for (int i = 0; i < words.size(); i++) {\n        for (int j = 0; j < 14; j++) {\n            if (words[i] == adverbs[j]) {\n                return Union_std_string_long(adverbs[j]);\n            }\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::string::const_iterator searchStart(text.cbegin());\n    while (std::regex_search(searchStart, text.cend(), match, regex)) {\n        return Union_std_string_long(match[1]);\n    }\n    return Union_std_string_long(-1);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\", \"loudly\", \"quietly\"};\n    int adverbs_size = sizeof(adverbs) / sizeof(adverbs[0]);\n    for (int i = 0; i < adverbs_size; i++) {\n        std::size_t found = text.find(adverbs[i]);\n        if (found != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() == 0) {\n        return -1;\n    }\n    return m.str(1);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[^aeiouAEIOU]*ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(0);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if(std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return m.str(1);\n    }\n    return -1;",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), m, r)) {\n        return Union_std_string_long(m.str());\n        searchStart += m.position() + m.length();\n    }\n    return Union_std_string_long(0);",
    "    std::vector<std::string> words = split(text, ' ');\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i].back() == 'y' && words[i].size() > 2) {\n            return Union_std_string_long(words[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex re(\"\\\\w+ly\");\n    std::smatch match;\n    std::regex_search(text, match, re);\n    if (match.size() == 0) {\n        return Union_std_string_long(std::string(\"\"));\n    }\n    return Union_std_string_long(match.str());",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if(std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"[a-zA-Z]+ly\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return adverb_match.str(0);\n    } else {\n        return -1;\n    }",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if(m.size() > 0) {\n        return Union_std_string_long(m.str(1));\n    }\n    return Union_std_string_long(-1);",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return match.position(0);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 0) {\n        return Union_std_string_long(match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"eagerly\", \"happily\", \"sadly\"};\n    std::string text_lower = \"\";\n    for (int i = 0; i < text.length(); i++) {\n        text_lower += std::tolower(text[i]);\n    }\n    for (int i = 0; i < 6; i++) {\n        int found = text_lower.find(adverbs[i]);\n        if (found != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b[^\\\\s]+\\\\b\");\n    std::smatch m;\n    std::string::const_iterator searchStart( text.cbegin() );\n    std::string::const_iterator searchEnd( text.cend() );\n    std::string word;\n    int i = 0;\n    while (std::regex_search(searchStart, searchEnd, m, r)) {\n        word = m.str();\n        if (word.back() == 'ly') {\n            return Union_std_string_long(word);\n        }\n        searchStart = m.suffix().first;\n        i++;\n    }\n    return Union_std_string_long(-1);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return m.str(1);\n    }\n    return -1;",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\"};\n    std::string::size_type pos = 0;\n    for (int i = 0; i < 5; i++) {\n        pos = text.find(adverbs[i]);\n        if (pos != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"\";",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"elegantly\", \"noisily\", \"badly\", \"well\", \"happily\"};\n    std::string words[] = {\"The\", \"fox\", \"jumped\", \"over\", \"the\", \"fence\", \".\"};\n    std::vector<std::string> adverbs_vector(adverbs, adverbs + sizeof(adverbs) / sizeof(adverbs[0]));\n    std::vector<std::string> words_vector(words, words + sizeof(words) / sizeof(words[0]));\n    std::vector<std::string>::iterator it;\n    it = std::find(words_vector.begin(), words_vector.end(), \".\");\n    if (it != words_vector.end()) {\n        words_vector.erase(it);\n    }\n    it = std::find(words_vector.begin(), words_vector.end(), \",\");\n    if (it != words_vector.end()) {\n        words_vector.erase(it);\n    }\n    it = std::find(words_vector.begin(), words_vector.end(), \"!\");\n    if (it != words_vector.end()) {\n        words_vector.erase(it);\n    }\n    it = std::find(words_vector.begin(), words_vector.end(), \"?\");\n    if (it != words_vector.end()) {\n        words_vector.erase(it);\n    }\n    std::vector<std::string>::iterator it2;\n    it2 = std::find_first_of(words_vector.begin(), words_vector.end(), adverbs_vector.begin(), adverbs_vector.end());\n    if (it2 != words_vector.end()) {\n        return Union_std_string_long(*it2);\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.str();\n    }\n    return -1;",
    "    std::regex adverb_regex(\"((\\\\w+ly))\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        std::cout << \"Adverb: \" << adverb_match[0] << \" at position \" << adverb_match.position(0) << '\\n';\n        searchStart += adverb_match.position(0) + adverb_match.length(0);\n        return Union_std_string_long(adverb_match[0]);\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return adverb_match[0];\n    } else {\n        return -1;\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if(std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n        searchStart += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(-1);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\", \"loudly\", \"quietly\", \"well\", \"badly\"};\n    std::string text_lower = \"\";\n    for (int i = 0; i < text.size(); i++) {\n        text_lower += tolower(text[i]);\n    }\n    for (int i = 0; i < 9; i++) {\n        size_t found = text_lower.find(adverbs[i]);\n        if (found != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::string adverb = \"\";\n    long position = 0;\n    std::string word = \"\";\n    std::stringstream ss(text);\n    while (ss >> word) {\n        if (word.back() == 'y' && word.length() > 2 && word.at(word.length() - 2) != 'a' && word.at(word.length() - 2) != 'e' && word.at(word.length() - 2) != 'i' && word.at(word.length() - 2) != 'o' && word.at(word.length() - 2) != 'u') {\n            adverb = word;\n            position = text.find(word);\n            break;\n        }\n        else if (word.back() == 'e' && word.length() > 2 && word.at(word.length() - 2) != 'a' && word.at(word.length() - 2) != 'e' && word.at(word.length() - 2) != 'i' && word.at(word.length() - 2) != 'o' && word.at(word.length() - 2) != 'u') {\n            adverb = word;\n            position = text.find(word);\n            break;\n        }\n        else if (word.back() == 'l' && word.length() > 2 && word.at(word.length() - 2) == 'l') {\n            adverb = word;\n            position = text.find(word);\n            break;\n        }\n    }\n    if (adverb == \"\") {\n        return Union_std_string_long(position);\n    }\n    else {\n        return Union_std_string_long(adverb);\n    }",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return match.str(0);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return -1;\n    }\n    return adverb_match.str(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if(adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(adverb_match.str(1));",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 0) {\n        return Union_std_string_long(match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"[a-zA-Z]+ly\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return adverb_match.str(0);\n    } else {\n        return -1;\n    }",
    "    std::string adverbs[8] = {\"quickly\", \"slowly\", \"happily\", \"sadly\", \"angrily\", \"cheerfully\", \"merrily\", \"quietly\"};\n    std::string text_lower = \"\";\n    for(int i = 0; i < text.length(); i++) {\n        text_lower += tolower(text[i]);\n    }\n    std::string word = \"\";\n    std::vector<std::string> words;\n    for(int i = 0; i < text_lower.length(); i++) {\n        if(text_lower[i] == ' ') {\n            words.push_back(word);\n            word = \"\";\n        } else {\n            word += text_lower[i];\n        }\n    }\n    words.push_back(word);\n    for(int i = 0; i < words.size(); i++) {\n        for(int j = 0; j < 8; j++) {\n            if(words[i] == adverbs[j]) {\n                return Union_std_string_long(words[i]);\n            }\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"sadly\", \"happily\", \"loudly\", \"quietly\"};\n    std::string words[] = {\"The\", \"fox\", \"jumped\", \"over\", \"the\", \"fence\", \".\"};\n    std::string adverb = \"\";\n    long position = 0;\n    for (int i = 0; i < 7; i++) {\n        if (text.find(adverbs[i]) != std::string::npos) {\n            adverb = adverbs[i];\n            position = text.find(adverbs[i]);\n            break;\n        }\n    }\n    if (adverb != \"\") {\n        return Union_std_string_long(adverb);\n    } else {\n        return Union_std_string_long(position);\n    }",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"well\", \"badly\", \"hard\", \"softly\", \"loudly\", \"quietly\"};\n    std::string text_lower = \"\";\n    for (int i = 0; i < text.size(); i++) {\n        text_lower += tolower(text[i]);\n    }\n    std::string adverb = \"\";\n    int position = -1;\n    for (int i = 0; i < 8; i++) {\n        if (text_lower.find(adverbs[i]) != std::string::npos) {\n            adverb = adverbs[i];\n            position = text_lower.find(adverbs[i]);\n            break;\n        }\n    }\n    if (position == -1) {\n        return Union_std_string_long(position);\n    } else {\n        return Union_std_string_long(adverb);\n    }",
    "    std::regex regex_adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, regex_adverb);\n    if (match.size() > 1) {\n        return match.position(1);\n    }\n    return std::string(\"No adverb found\");",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return match.position(1);\n    }\n    return std::string(\"\");",
    "    std::string adverb = \"\";\n    long position = 0;\n    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\"};\n    std::string words[] = {\"The\", \"fox\", \"jumped\", \"over\", \"the\", \"fence\", \".\"};\n    for (int i = 0; i < 7; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (words[i] == adverbs[j]) {\n                adverb = adverbs[j];\n                position = i;\n                return Union_std_string_long(adverb);\n            }\n        }\n    }\n    return Union_std_string_long(position);",
    "    std::regex regex(\"(\\\\w+ly)\");\n    std::smatch match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), match, regex)) {\n        return Union_std_string_long(match.str());\n        searchStart += match.position() + match.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 0) {\n        return match.str(0);\n    } else {\n        return -1;\n    }",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, regex);\n    if (match.size() > 1) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        std::string adverb = adverb_match[1];\n        long position = adverb_match.position(1);\n        return Union_std_string_long(adverb);\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"[a-zA-Z]+ly\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() == 0) {\n        return Union_std_string_long(std::string(\"\"));\n    }\n    return Union_std_string_long(m.position(0));",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if(std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.position(1));\n    }\n    return Union_std_string_long(\"No adverb found\");",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return m.position(1);\n    }\n    return -1;",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return m.position(1);\n    }\n    return -1;",
    "    std::regex r(\"[^\\\\s]+\");\n    std::sregex_iterator next(text.begin(), text.end(), r);\n    std::sregex_iterator end;\n    std::vector<std::string> words;\n    while (next != end) {\n        std::smatch match = *next;\n        words.push_back(match.str());\n        next++;\n    }\n    std::regex r1(\"ly\");\n    std::sregex_iterator next1(text.begin(), text.end(), r1);\n    std::sregex_iterator end1;\n    std::vector<std::string> words1;\n    while (next1 != end1) {\n        std::smatch match = *next1;\n        words1.push_back(match.str());\n        next1++;\n    }\n    std::vector<std::string>::iterator it;\n    std::vector<std::string>::iterator it1;\n    std::vector<std::string>::iterator it2;\n    std::vector<std::string>::iterator it3;\n    std::vector<std::string>::iterator it4;\n    std::vector<std::string>::iterator it5;\n    std::vector<std::string>::iterator it6;\n    std::vector<std::string>::iterator it7;\n    std::vector<std::string>::iterator it8;\n    std::vector<std::string>::iterator it9;\n    std::vector<std::string>::iterator it10;\n    std::vector<std::string>::iterator it11;\n    std::vector<std::string>::iterator it12;\n    std::vector<std::string>::iterator it13;\n    std::vector<std::string>::iterator it14;\n    std::vector<std::string>::iterator it15;\n    std::vector<std::string>::iterator it16;\n    std::vector<std::string>::iterator it17;\n    std::vector<std::string>::iterator it18;\n    std::vector<std::string>::iterator it19;\n    std::vector<std::string>::iterator it",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        std::string adverb = adverb_match[1];\n        long position = adverb_match.position(1);\n        return Union_std_string_long(adverb);\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\w+ly\");\n    std::smatch m;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), m, r)) {\n        return Union_std_string_long(m.str());\n        searchStart += m.position() + m.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex(\"(\\\\w+ly)\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return match.str(1);\n    }\n    return -1;",
    "    std::regex regex(\"(\\\\w+)\");\n    std::smatch match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    int pos = 0;\n    while (std::regex_search(searchStart, text.cend(), match, regex)) {\n        std::string word = match.str();\n        if (word.back() == 'ly') {\n            return Union_std_string_long(word);\n        }\n        searchStart += match.position() + match.length();\n        pos += match.position() + match.length();\n    }\n    return Union_std_string_long(-1);",
    "    std::regex r(\"\\\\w+ly\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() > 0) {\n        return Union_std_string_long(m.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 0) {\n        return Union_std_string_long(match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex regex(\"(\\\\w+ly)\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return match.str(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart(text.cbegin());\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n        searchStart += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(0);",
    "    std::string adverb = \"\";\n    long position = 0;\n    std::stringstream ss(text);\n    std::string word;\n    while(ss >> word) {\n        if(word.back() == 'ly') {\n            adverb = word;\n            break;\n        }\n        position += word.length() + 1;\n    }\n    if(adverb == \"\") {\n        return Union_std_string_long(position);\n    }\n    return Union_std_string_long(adverb);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(long(-1));",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"eagerly\", \"happily\", \"merrily\", \"sweetly\", \"angrily\", \"sadly\", \"loudly\", \"quietly\", \"badly\", \"well\", \"fast\", \"hard\", \"early\", \"late\", \"soon\", \"far\", \"long\", \"high\", \"low\", \"near\", \"far\", \"right\", \"left\", \"straight\", \"round\", \"up\", \"down\", \"in\", \"out\", \"together\", \"apart\", \"home\", \"abroad\", \"inside\", \"outside\", \"ahead\", \"behind\", \"today\", \"yesterday\", \"tomorrow\", \"ago\", \"now\", \"then\", \"here\", \"there\", \"everywhere\", \"nowhere\", \"always\", \"never\", \"sometimes\", \"often\", \"usually\", \"seldom\", \"again\", \"ever\", \"never\", \"also\", \"too\", \"besides\", \"further\", \"finally\", \"thus\", \"hence\", \"instead\", \"meanwhile\", \"anyway\", \"incidentally\", \"meantime\", \"presently\", \"consequently\", \"furthermore\", \"likewise\", \"moreover\", \"nevertheless\", \"otherwise\", \"similarly\", \"conversely\", \"however\", \"nonetheless\", \"still\", \"alternatively\", \"conversely\", \"else\", \"instead\", \"likewise\", \"moreover\", \"nevertheless\", \"otherwise\", \"similarly\", \"conversely\", \"however\", \"nonetheless\", \"still\", \"alternatively\", \"conversely\", \"else\", \"instead\", \"likewise\", \"moreover\", \"nevertheless\", \"otherwise\", \"similarly\", \"conversely\", \"however\", \"nonetheless\", \"still\", \"alternatively\", \"conversely\", \"else\", \"instead\", \"likewise\", \"moreover\", \"nevertheless\", \"otherwise\", \"similarly\", \"conversely\", \"however\", \"nonetheless\", \"still\", \"alternatively\", \"conversely\", \"else\", \"instead\", \"likewise\", \"moreover\", \"nevertheless\", \"otherwise\", \"similarly\", \"conversely\", \"however\", \"nonetheless\", \"still\", \"alternatively\", \"conversely\", \"else\", \"instead\",",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+)ly\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.empty()) {\n        return -1;\n    }\n    return m.str(0);",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(0);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return match.position(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match[0]);\n        searchStart += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(-1);",
    "    std::regex regex(\"[A-Za-z]+ly\");\n    std::smatch match;\n    std::regex_search(text, match, regex);\n    if (match.size() > 0) {\n        return match.str(0);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\w+ly\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return Union_std_string_long(m.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 2) {\n        return adverb_match[1].str();\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\w+ly\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::regex adverb_regex(\"\\\\b[A-Za-z]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return match.str(0);\n    }\n    return -1;",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return match.str(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    } else {\n        return \"No adverb found\";\n    }",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"elegantly\", \"noisily\"};\n    for (int i = 0; i < 4; i++) {\n        size_t found = text.find(adverbs[i]);\n        if (found != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex(\"\\\\w+ly\");\n    std::smatch match;\n    if(std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return Union_std_string_long(m.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\w+ly\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"eagerly\", \"happily\", \"lazily\", \"noisily\", \"noiselessly\", \"silently\", \"merrily\", \"humbly\", \"proudly\", \"sadly\", \"angrily\", \"foolishly\", \"madly\", \"crazily\", \"quietly\", \"loudly\", \"softly\", \"sweetly\", \"tenderly\", \"greedily\", \"joyfully\", \"jovially\", \"jokingly\", \"kindly\", \"kindheartedly\", \"warmheartedly\", \"fervently\", \"ardently\", \"zealously\", \"earnestly\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"impatiently\", \"anxiously\", \"eagerly\", \"im",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return -1;\n    }\n    return adverb_match.str(1);",
    "    std::vector<std::string> words = split(text, ' ');\n    for (int i = 0; i < words.size(); i++) {\n        if (words[i].back() == 'ly') {\n            return Union_std_string_long(words[i]);\n        }\n    }\n    return Union_std_string_long(-1);",
    "    std::regex regex_adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, regex_adverb);\n    if (match.size() > 1) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"((\\\\s+)([a-zA-Z]+ly)(\\\\s+))\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return -1;\n    }\n    return adverb_match.str(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 1) {\n        return adverb_match[1].str();\n    } else {\n        return -1;\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 1) {\n        return Union_std_string_long(adverb_match.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 1) {\n        return Union_std_string_long(adverb_match.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return match.position(1);\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\", \"loudly\", \"quietly\", \"angrily\"};\n    std::string text_lower = \"\";\n    for (int i = 0; i < text.size(); i++) {\n        text_lower += tolower(text[i]);\n    }\n    for (int i = 0; i < 8; i++) {\n        int pos = text_lower.find(adverbs[i]);\n        if (pos != std::string::npos) {\n            return adverbs[i];\n        }\n    }\n    return -1;",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(m[1].str());",
    "    std::regex adverb_regex(\"\\\\b[^\\\\s]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    if (std::regex_search(text, m, r)) {\n        return Union_std_string_long(m.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex re(\"\\\\w+ly\");\n    std::smatch match;\n    if (std::regex_search(text, match, re)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex re(\"\\\\w+ly\");\n    std::smatch match;\n    std::regex_search(text, match, re);\n    if (match.size() == 0) {\n        return -1;\n    }\n    return match.str();",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"elegantly\", \"noisily\"};\n    for (int i = 0; i < 4; i++) {\n        int pos = text.find(adverbs[i]);\n        if (pos != std::string::npos) {\n            return adverbs[i];\n        }\n    }\n    return -1;",
    "    std::regex regex_adverb(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch match;\n    std::string::const_iterator searchStart(text.cbegin());\n    while (std::regex_search(searchStart, text.cend(), match, regex_adverb)) {\n        return Union_std_string_long(match.str());\n        searchStart += match.position() + match.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(adverb_match.str());",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 2) {\n        return Union_std_string_long(adverb_match.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb)) {\n        return match.position(1);\n    }\n    return -1;",
    "    std::vector<std::string> words = split(text, ' ');\n    std::vector<std::string> adverbs = { \"quickly\", \"slowly\", \"well\", \"badly\" };\n    for (int i = 0; i < words.size(); i++) {\n        for (int j = 0; j < adverbs.size(); j++) {\n            if (words[i] == adverbs[j]) {\n                return i;\n            }\n        }\n    }\n    return \"No adverb found\";",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"elegantly\", \"noisily\", \"badly\", \"well\"};\n    std::string word;\n    std::stringstream ss(text);\n    std::vector<std::string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n    for (int i = 0; i < words.size(); i++) {\n        for (int j = 0; j < 6; j++) {\n            if (words[i] == adverbs[j]) {\n                return Union_std_string_long(words[i]);\n            }\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator search_start( text.cbegin() );\n    while (std::regex_search(search_start, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match[0]);\n        search_start += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(-1);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"No adverb found\";",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"sadly\"};\n    std::string::size_type pos = 0;\n    for (int i = 0; i < 5; i++) {\n        pos = text.find(adverbs[i], pos);\n        if (pos != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 1) {\n        return match[1].str();\n    } else {\n        return -1;\n    }",
    "    std::string adverb_list[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"merrily\", \"sweetly\", \"angrily\", \"sadly\", \"loudly\", \"quietly\"};\n    std::string adverb = \"\";\n    long position = -1;\n    for (int i = 0; i < 10; i++) {\n        std::size_t found = text.find(adverb_list[i]);\n        if (found != std::string::npos) {\n            adverb = adverb_list[i];\n            position = found;\n            break;\n        }\n    }\n    if (adverb == \"\") {\n        return Union_std_string_long(position);\n    } else {\n        return Union_std_string_long(adverb);\n    }",
    "    std::regex adverb_regex(\"\\\\w+ly\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(adverb_match.str());",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match[0]);\n        searchStart += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex(\"(\\\\w+ly)\");\n    std::smatch match;\n    std::regex_search(text, match, regex);\n    if (match.size() > 1) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::smatch m;\n    std::regex_search(text, m, std::regex(\"\\\\b(\\\\w+ly)\\\\b\"));\n    if (m.size() > 0) {\n        return Union_std_string_long(m.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 0) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(-1);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"loudly\", \"quietly\"};\n    std::string words[100];\n    int i = 0;\n    std::stringstream ssin(text);\n    while (ssin.good() && i < 100){\n        ssin >> words[i];\n        ++i;\n    }\n    for(int j = 0; j < i; j++){\n        for(int k = 0; k < 5; k++){\n            if(words[j] == adverbs[k]){\n                return Union_std_string_long(words[j]);\n            }\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[A-Za-z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return -1;\n    }\n    return adverb_match.str(0);",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return match.str(1);\n    }\n    return -1;",
    "    std::regex r(\"\\\\b[^aeiou]*ly\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() > 0) {\n        return m.str(0);\n    } else {\n        return -1;\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str(1));\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::regex regex_adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, regex_adverb);\n    if (match.size() > 0) {\n        return Union_std_string_long(match.str(1));\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::regex r(\"([^\\\\s]*\\\\s+){1}(\\\\w+ly)\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() == 3) {\n        return Union_std_string_long(m.str(2));\n    } else {\n        return Union_std_string_long(0);\n    }",
    "    std::regex r(\"(\\\\w+ly)\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if(m.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(m[0]);",
    "    std::regex adverb_regex(\"\\\\b[A-Za-z]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match[0];\n    }\n    return -1;",
    "    std::regex regex_adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex_adverb)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex re(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, re);\n    if (match.size() > 1) {\n        return match.str(1);\n    }\n    return -1;",
    "    std::regex regex(\"(\\\\w+ly)\");\n    std::smatch match;\n    std::regex_search(text, match, regex);\n    if (match.size() > 1) {\n        return Union_std_string_long(match.position(1));\n    } else {\n        return Union_std_string_long(std::string(\"Not found\"));\n    }",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if(m.size() == 0)\n        return Union_std_string_long(0);\n    return Union_std_string_long(m.str(1));",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(0);\n    }\n    return std::string(\"No adverb found\");",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex re(\"\\\\w+ly\");\n    std::smatch match;\n    std::regex_search(text, match, re);\n    if (match.size() == 0) {\n        return -1;\n    }\n    return match.str(0);",
    "    std::string adverb_list[] = {\"quickly\", \"slowly\", \"carefully\", \"loudly\", \"quietly\", \"happily\", \"sadly\", \"angrily\", \"anxiously\", \"eagerly\", \"fearfully\", \"joyfully\", \"nervously\", \"sadly\", \"worriedly\", \"calmly\", \"cautiously\", \"cheerfully\", \"eagerly\", \"fearfully\", \"gratefully\", \"happily\", \"joyfully\", \"nervously\", \"patiently\", \"playfully\", \"quietly\", \"sadly\", \"worriedly\", \"bravely\", \"calmly\", \"carefully\", \"cautiously\", \"cheerfully\", \"eagerly\", \"fearfully\", \"gratefully\", \"happily\", \"joyfully\", \"nervously\", \"patiently\", \"playfully\", \"quietly\", \"sadly\", \"worriedly\", \"bravely\", \"calmly\", \"carefully\", \"cautiously\", \"cheerfully\", \"eagerly\", \"fearfully\", \"gratefully\", \"happily\", \"joyfully\", \"nervously\", \"patiently\", \"playfully\", \"quietly\", \"sadly\", \"worriedly\", \"bravely\", \"calmly\", \"carefully\", \"cautiously\", \"cheerfully\", \"eagerly\", \"fearfully\", \"gratefully\", \"happily\", \"joyfully\", \"nervously\", \"patiently\", \"playfully\", \"quietly\", \"sadly\", \"worriedly\", \"bravely\", \"calmly\", \"carefully\", \"cautiously\", \"cheerfully\", \"eagerly\", \"fearfully\", \"gratefully\", \"happily\", \"joyfully\", \"nervously\", \"patiently\", \"playfully\", \"quietly\", \"sadly\", \"worriedly\", \"bravely\", \"calmly\", \"carefully\", \"cautiously\", \"cheerfully\", \"eagerly\", \"fearfully\", \"gratefully\", \"happily\", \"joyfully\", \"nervously\", \"patiently\", \"playfully",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex)) {\n        return Union_std_string_long(match.str(1));\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return \"\";",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return match.position(1);\n    }\n    return -1;",
    "    std::regex regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, regex);\n    if(match.size() == 0) {\n        return -1;\n    }\n    return match.position(0);",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"happily\", \"merrily\", \"sweetly\", \"angrily\", \"sadly\", \"loudly\", \"quietly\", \"noisily\", \"silently\", \"well\", \"badly\", \"hard\", \"fast\", \"early\", \"late\", \"soon\", \"now\", \"today\", \"tomorrow\", \"yesterday\", \"ago\", \"here\", \"there\", \"inside\", \"outside\", \"away\", \"home\", \"up\", \"down\", \"left\", \"right\", \"forward\", \"backward\", \"together\", \"apart\", \"again\", \"ahead\", \"far\", \"near\", \"forward\", \"backward\", \"together\", \"apart\", \"again\", \"ahead\", \"far\", \"near\", \"in\", \"out\", \"on\", \"off\", \"over\", \"under\", \"above\", \"below\", \"behind\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"across\", \"around\", \"beyond\", \"ac",
    "    std::regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.str();\n    }\n    return -1;",
    "    std::regex adverb_regex(\"((\\\\s+)((quickly)|(slowly)|(happily)|(sadly)|(angrily)|(cheerfully)|(excitedly)|(fearfully)|(joyfully)|(lazily)|(loudly)|(noisily)|(quietly)|(sleepily)|(wildly)|(worriedly)|(anxiously)|(bravely)|(calmly)|(carefully)|(cautiously)|(cleverly)|(crazily)|(eagerly)|(elegantly)|(energetically)|(enormously)|(enthusiastically)|(foolishly)|(frantically)|(generously)|(gleefully)|(gracefully)|(greedily)|(happily)|(hastily)|(honestly)|(hopelessly)|(hungrily)|(innocently)|(inquisitively)|(jealously)|(jovially)|(joyfully)|(kindly)|(lazily)|(loosely)|(madly)|(merrily)|(nervously)|(noisily)|(obediently)|(obnoxiously)|(oddly)|(openly)|(patiently)|(perfectly)|(politely)|(poorly)|(powerfully)|(promptly)|(quickly)|(quietly)|(rapidly)|(recklessly)|(reluctantly)|(repeatedly)|(rudely)|(sadly)|(safely)|(selfishly)|(seriously)|(shakily)|(sharply)|(silently)|(sleepily)|(slowly)|(smoothly)|(softly)|(solemnly)|(speedily)|(stealthily)|(sternly)|(strictly)|(strongly)|(stubbornly)|(suspiciously)|(tenderly)|(tensely)|(thoughtfully)|(tightly)|(tremendously)|(triumphantly)|(unexpectedly)|(vastly)|(vivaciously)|(warmly)|(weakly)|(wearily)|(wildly)|(worriedly)|(zealously)|(zestfully))(\\\\s+))\");\n    std::smatch",
    "    std::regex regex_adverb(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, regex_adverb)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 1) {\n        return Union_std_string_long(match[1].str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b[a-zA-Z]+ly\\\\b\");\n    std::smatch match;\n    if (std::regex_search(text, match, adverb_regex)) {\n        return Union_std_string_long(match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"(\\\\w+ly)\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if(adverb_match.size() > 0) {\n        return Union_std_string_long(adverb_match[0].str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(adverb_match.str(1));",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+)ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(0);\n    }\n    return \"No adverb found\";",
    "    std::vector<std::string> adverbs = {\"quickly\", \"slowly\", \"elegantly\", \"noisily\"};\n    std::vector<std::string> words = {\"The\", \"fox\", \"jumped\", \"over\", \"the\", \"fence\", \".\"};\n    std::vector<std::string>::iterator it;\n    it = std::find(adverbs.begin(), adverbs.end(), text);\n    if (it != adverbs.end()) {\n        return Union_std_string_long(std::distance(adverbs.begin(), it));\n    }\n    return Union_std_string_long(\"No adverb found\");",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch match;\n    std::regex_search(text, match, adverb_regex);\n    if (match.size() > 1) {\n        return Union_std_string_long(match.str(1));\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::regex_search(text, adverb_match, adverb_regex);\n    if (adverb_match.size() == 0) {\n        return Union_std_string_long(0);\n    }\n    return Union_std_string_long(adverb_match.str(1));",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() > 1) {\n        return Union_std_string_long(m[1].str());\n    } else {\n        return Union_std_string_long(-1);\n    }",
    "    std::regex adverb_regex(\"\\\\b[^\\\\W\\\\d_]+ly\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    std::string::const_iterator searchStart( text.cbegin() );\n    while (std::regex_search(searchStart, text.cend(), adverb_match, adverb_regex)) {\n        return Union_std_string_long(adverb_match.str());\n        searchStart += adverb_match.position() + adverb_match.length();\n    }\n    return Union_std_string_long(0);",
    "    std::regex adverb_regex(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch adverb_match;\n    if (std::regex_search(text, adverb_match, adverb_regex)) {\n        return adverb_match.position(1);\n    }\n    return std::string(\"\");",
    "    std::string adverbs[] = {\"quickly\", \"slowly\", \"carefully\", \"loudly\", \"silently\"};\n    std::string text_lower = text;\n    std::transform(text_lower.begin(), text_lower.end(), text_lower.begin(), ::tolower);\n    for (int i = 0; i < 5; i++) {\n        std::size_t found = text_lower.find(adverbs[i]);\n        if (found != std::string::npos) {\n            return Union_std_string_long(adverbs[i]);\n        }\n    }\n    return Union_std_string_long(0);",
    "    std::regex r(\"\\\\b(\\\\w+ly)\\\\b\");\n    std::smatch m;\n    std::regex_search(text, m, r);\n    if (m.size() > 0) {\n        return Union_std_string_long(m.str(1));\n    }\n    return Union_std_string_long(0);"
  ]
}