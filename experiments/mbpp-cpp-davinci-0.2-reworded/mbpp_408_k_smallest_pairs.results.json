{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpkmm7njj9: /tmp/tmpkmm7njj9.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long>{0, 0});\n    while (k-- > 0 && !max_heap.empty()) {\n        std::vector<long> pair = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long>{nums1[pair[0]], nums2[pair[1]]});\n        if (pair[0] + 1 < nums1.size()) {\n            max_heap.emplace(std::vector<long>{pair[0] + 1, pair[1]});\n        }\n        if (pair[0] == 0 && pair[1] + 1 < nums2.size()) {\n            max_heap.emplace(std::vector<long>{pair[0], pair[1] + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpa2qq4wd1: /tmp/tmpa2qq4wd1.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmp7kjk5cmz: /tmp/tmp7kjk5cmz.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmp8vccamdo: /tmp/tmp8vccamdo.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpkeydb3vm: /tmp/tmpkeydb3vm.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpvx86ol8v: /tmp/tmpvx86ol8v.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(!pq.empty() && k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [&](std::vector<long> a, std::vector<long> b) {\n            return a[0] + a[1] < b[0] + b[1];\n        }\n    );\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            max_heap.push({i, j});\n            if(max_heap.size() > k)\n                max_heap.pop();\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpa6um74pe: /tmp/tmpa6um74pe.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n            if (pq.size() > k) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmp4p5olv6p: /tmp/tmp4p5olv6p.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            max_heap.push({i, j});\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmp58lwstf7: /tmp/tmp58lwstf7.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpaz77oqck: /tmp/tmpaz77oqck.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpp348h6_h: /tmp/tmpp348h6_h.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.emplace_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpsmv635yp: /tmp/tmpsmv635yp.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        long i = pq.top().second.first;\n        long j = pq.top().second.second;\n        result.push_back({nums1[i], nums2[j]});\n        pq.pop();\n        if(j + 1 < nums2.size()) {\n            pq.push({nums1[i] + nums2[j + 1], {i, j + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmp8p25d9pw: /tmp/tmp8p25d9pw.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpswb19_a9: /tmp/tmpswb19_a9.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n    return result;\n  }\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n      [](std::vector<long> a, std::vector<long> b) { return a[0] + a[1] < b[0] + b[1]; });\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      if (max_heap.size() < k) {\n        max_heap.push({nums1[i], nums2[j]});\n      } else {\n        if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n          max_heap.pop();\n          max_heap.push({nums1[i], nums2[j]});\n        }\n      }\n    }\n  }\n  while (!max_heap.empty()) {\n    result.push_back(max_heap.top());\n    max_heap.pop();\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpiyxdds5x: /tmp/tmpiyxdds5x.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> min_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (min_heap.size() < k) {\n                min_heap.push({nums1[i], nums2[j], i, j});\n            } else {\n                if (nums1[i] + nums2[j] < min_heap.top()[0] + min_heap.top()[1]) {\n                    min_heap.pop();\n                    min_heap.push({nums1[i], nums2[j], i, j});\n                }\n            }\n        }\n    }\n    while (!min_heap.empty()) {\n        result.push_back({min_heap.top()[0], min_heap.top()[1]});\n        min_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpqzj0mp_d: /tmp/tmpqzj0mp_d.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            max_heap.push({i, j});\n            if(max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpv9_2koep: /tmp/tmpv9_2koep.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpt_q8h95x: /tmp/tmpt_q8h95x.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpqw3q7y8c: /tmp/tmpqw3q7y8c.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmp6je07smw: /tmp/tmp6je07smw.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpabk4h_wf: /tmp/tmpabk4h_wf.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpp348h6_h: /tmp/tmpp348h6_h.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            max_heap.push({i, j});\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpozwdd0ia: /tmp/tmpozwdd0ia.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < std::min(k, (long)nums1.size()); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto pair = pq.top();\n        pq.pop();\n        result.push_back({nums1[pair.second.first], nums2[pair.second.second]});\n        if (pair.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[pair.second.first] + nums2[pair.second.second + 1], std::make_pair(pair.second.first, pair.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpexjv_u0y: /tmp/tmpexjv_u0y.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpkb47vire: /tmp/tmpkb47vire.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [](std::vector<long> a, std::vector<long> b) {\n            return a[0] + a[1] < b[0] + b[1];\n        });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122944,
      "stdout": "",
      "stderr": "tmpur8g5nns: /tmp/tmpur8g5nns.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if(p.second.second + 1 < nums2.size()) {\n            pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmp09__q0mb: /tmp/tmp09__q0mb.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpi4j9kwae: /tmp/tmpi4j9kwae.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmp10sycg2i: /tmp/tmp10sycg2i.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpgi04h3om: /tmp/tmpgi04h3om.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpmtu0y1gm: /tmp/tmpmtu0y1gm.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpgk_0x5gk: /tmp/tmpgk_0x5gk.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty())\n            break;\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpnuwp73h3: /tmp/tmpnuwp73h3.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> min_heap;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tmin_heap.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k > 0 && !min_heap.empty()) {\n\t\tstd::pair<long, std::pair<long, long>> top = min_heap.top();\n\t\tmin_heap.pop();\n\t\tresult.push_back({nums1[top.second.first], nums2[top.second.second]});\n\t\tif (top.second.second + 1 < nums2.size()) {\n\t\t\tmin_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n\t\t}\n\t\tk--;\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> min_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (min_heap.size() < k) {\n                min_heap.push({nums1[i], nums2[j], i, j});\n            } else {\n                if (nums1[i] + nums2[j] < min_heap.top()[0] + min_heap.top()[1]) {\n                    min_heap.pop();\n                    min_heap.push({nums1[i], nums2[j], i, j});\n                }\n            }\n        }\n    }\n    while (!min_heap.empty()) {\n        result.push_back({min_heap.top()[0], min_heap.top()[1]});\n        min_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpqzj0mp_d: /tmp/tmpqzj0mp_d.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmppppd5434: /tmp/tmppppd5434.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpp9rlgbb6: /tmp/tmpp9rlgbb6.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpeopsuo66: /tmp/tmpeopsuo66.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmpza6hm_0k: /tmp/tmpza6hm_0k.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "tmpdgsht79d: /tmp/tmpdgsht79d.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (!max_heap.empty() && k > 0) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "tmp36de9dsi: /tmp/tmp36de9dsi.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmphmvztasl: /tmp/tmphmvztasl.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpgk_0x5gk: /tmp/tmpgk_0x5gk.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto temp = pq.top();\n        pq.pop();\n        result.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n        if (temp.second.second + 1 < nums2.size()) {\n            pq.push({nums1[temp.second.first] + nums2[temp.second.second + 1], {temp.second.first, temp.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmp2o3zh92m: /tmp/tmp2o3zh92m.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return (a[0] + a[1]) > (b[0] + b[1]);\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmpnd79yng6: /tmp/tmpnd79yng6.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpvx86ol8v: /tmp/tmpvx86ol8v.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.emplace_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmpr8f7fil5: /tmp/tmpr8f7fil5.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpp348h6_h: /tmp/tmpp348h6_h.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpp348h6_h: /tmp/tmpp348h6_h.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmptdwnrmju: /tmp/tmptdwnrmju.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "tmpw7m1xbn1: /tmp/tmpw7m1xbn1.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); ++i) {\n        for(long j = 0; j < nums2.size(); ++j) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(std::vector<long>{pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmpzby5rico: /tmp/tmpzby5rico.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            if (pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmp_645x7yv: /tmp/tmp_645x7yv.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n            if (max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmpiqj5lrbr: /tmp/tmpiqj5lrbr.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {i, j}});\n        }\n    }\n    while (k--) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmp_lbar30s: /tmp/tmp_lbar30s.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "tmp5fb3zc5w: /tmp/tmp5fb3zc5w.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {i, j}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        auto [sum, pair] = pq.top();\n        pq.pop();\n        result.push_back({nums1[pair.first], nums2[pair.second]});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpqw3q7y8c: /tmp/tmpqw3q7y8c.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmp3hfm8kpv: /tmp/tmp3hfm8kpv.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tmax_heap.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        k--;\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpb1x6xkw4: /tmp/tmpb1x6xkw4.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] > nums1[b[0]] + nums2[b[1]];\n    });\n    pq.push({0, 0});\n    while(k-- && !pq.empty()) {\n        auto [i, j] = pq.top();\n        pq.pop();\n        result.push_back({nums1[i], nums2[j]});\n        if(j + 1 < nums2.size()) pq.push({i, j + 1});\n        if(j == 0 && i + 1 < nums1.size()) pq.push({i + 1, j});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122947,
      "stdout": "",
      "stderr": "/tmp/tmpblmphwmc.cpp: In function \u2018std::vector<std::vector<long int> > k_smallest_pairs(std::vector<long int>, std::vector<long int>, long int)\u2019:\n/tmp/tmpblmphwmc.cpp:11:14: error: 2 names provided for structured binding\n   11 |         auto [i, j] = pq.top();\n      |              ^~~~~~\n/tmp/tmpblmphwmc.cpp:11:14: note: while \u2018std::vector<long int>\u2019 decomposes into 1 element\n/tmp/tmpblmphwmc.cpp:13:46: error: no matching function for call to \u2018std::vector<std::vector<long int> >::push_back(<brace-enclosed initializer list>)\u2019\n   13 |         result.push_back({nums1[i], nums2[j]});\n      |                                              ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:62,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/pstl/glue_algorithm_defs.h:13,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:71,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n                 from /tmp/tmpblmphwmc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7: note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::vector<long int>; _Alloc = std::allocator<std::vector<long int> >; std::vector<_Tp, _Alloc>::value_type = std::vector<long int>]\u2019\n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35: note:   no known conversion for argument 1 from \u2018<brace-enclosed initializer list>\u2019 to \u2018const value_type&\u2019 {aka \u2018const std::vector<long int>&\u2019}\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long>{0, 0});\n    while(k-- > 0 && !max_heap.empty()) {\n        std::vector<long> top = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long>{nums1[top[0]], nums2[top[1]]});\n        if(top[0] + 1 < nums1.size()) {\n            max_heap.emplace(std::vector<long>{top[0] + 1, top[1]});\n        }\n        if(top[0] == 0 && top[1] + 1 < nums2.size()) {\n            max_heap.emplace(std::vector<long>{top[0], top[1] + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpado57s3i: /tmp/tmpado57s3i.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (auto i = 0; i < nums1.size(); ++i) {\n        for (auto j = 0; j < nums2.size(); ++j) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- && !pq.empty()) {\n        auto pair = pq.top();\n        pq.pop();\n        result.push_back({pair.second.first, pair.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmphm_788ni: /tmp/tmphm_788ni.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpogy3pwoa: /tmp/tmpogy3pwoa.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push({nums1[i], nums2[j]});\n    }\n  }\n  while (k--) {\n    result.push_back(pq.top());\n    pq.pop();\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmp3fpgg95t: /tmp/tmp3fpgg95t.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "tmpdgsht79d: /tmp/tmpdgsht79d.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpz216_otv: /tmp/tmpz216_otv.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [](std::vector<long> a, std::vector<long> b) {\n            return a[0] + a[1] < b[0] + b[1];\n        });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpaiuivv72: /tmp/tmpaiuivv72.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            std::vector<long> temp;\n            temp.push_back(nums1[i]);\n            temp.push_back(nums2[j]);\n            pq.push(temp);\n        }\n    }\n    while(!pq.empty() && k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpnf2ktk4m: /tmp/tmpnf2ktk4m.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpnxovol11: /tmp/tmpnxovol11.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmp1380ym0i: /tmp/tmp1380ym0i.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpi4j9kwae: /tmp/tmpi4j9kwae.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmptdwnrmju: /tmp/tmptdwnrmju.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            max_heap.push({i, j});\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpldl4o5pz: /tmp/tmpldl4o5pz.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpuc_44zhs: /tmp/tmpuc_44zhs.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmp6u9mmr51: /tmp/tmp6u9mmr51.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            pq.push({num1, num2});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long> {0, 0});\n    while (k-- > 0 && !max_heap.empty()) {\n        std::vector<long> pair = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long> {nums1[pair[0]], nums2[pair[1]]});\n        if (pair[0] + 1 < nums1.size())\n            max_heap.emplace(std::vector<long> {pair[0] + 1, pair[1]});\n        if (pair[0] == 0 && pair[1] + 1 < nums2.size())\n            max_heap.emplace(std::vector<long> {pair[0], pair[1] + 1});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpydfz_gqj: /tmp/tmpydfz_gqj.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpss3x12uh: /tmp/tmpss3x12uh.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::vector<long> sums;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            sums.push_back(nums1[i] + nums2[j]);\n        }\n    }\n    std::sort(sums.begin(), sums.end());\n    for(long i = 0; i < k; i++) {\n        std::vector<long> temp;\n        temp.push_back(sums[i]);\n        temp.push_back(sums[i] - temp[0]);\n        result.push_back(temp);\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpzt0ihel8: /tmp/tmpzt0ihel8.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.empty() || nums2.empty()) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t});\n\tfor (auto i : nums1) {\n\t\tfor (auto j : nums2) {\n\t\t\tmax_heap.push({i, j});\n\t\t\tif (max_heap.size() > k) {\n\t\t\t\tmax_heap.pop();\n\t\t\t}\n\t\t}\n\t}\n\twhile (!max_heap.empty()) {\n\t\tresult.push_back(max_heap.top());\n\t\tmax_heap.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmptl40zr7g: /tmp/tmptl40zr7g.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> min_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        min_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !min_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = min_heap.top();\n        min_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            min_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122949,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    std::unordered_set<std::string> visited;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            std::string key = std::to_string(i) + \"|\" + std::to_string(j);\n            if (visited.find(key) == visited.end()) {\n                max_heap.push({nums1[i] + nums2[j], {i, j}});\n                visited.insert(key);\n            }\n        }\n    }\n    while (k > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmpn8y4tixq: /tmp/tmpn8y4tixq.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmp9nr64vgq: /tmp/tmp9nr64vgq.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmph06agzbt: /tmp/tmph06agzbt.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            max_heap.push({i, j});\n            if(max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmp54qh2u7f: /tmp/tmp54qh2u7f.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {i, j}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k == 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] > nums1[b[0]] + nums2[b[1]];\n    });\n    pq.push({ 0, 0 });\n    while (k-- > 0 && !pq.empty()) {\n        auto idx_pair = pq.top();\n        pq.pop();\n        result.push_back({ nums1[idx_pair[0]], nums2[idx_pair[1]] });\n        if (idx_pair[0] + 1 < nums1.size())\n            pq.push({ idx_pair[0] + 1, idx_pair[1] });\n        if (idx_pair[0] == 0 && idx_pair[1] + 1 < nums2.size())\n            pq.push({ idx_pair[0], idx_pair[1] + 1 });\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmp6qf7e_l0: /tmp/tmp6qf7e_l0.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap(\n        [](std::vector<long> a, std::vector<long> b) { return a[0] + a[1] > b[0] + b[1]; });\n    for (long i = 0; i < nums1.size() && i < k; i++)\n        max_heap.push({nums1[i], nums2[0], 0});\n    while (k-- > 0 && !max_heap.empty()) {\n        auto curr = max_heap.top();\n        max_heap.pop();\n        result.push_back({curr[0], curr[1]});\n        if (curr[2] == nums2.size() - 1)\n            continue;\n        max_heap.push({curr[0], nums2[curr[2] + 1], curr[2] + 1});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmpj5ufjsh0: /tmp/tmpj5ufjsh0.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmpuox9lckf: /tmp/tmpuox9lckf.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmphi2f4y1m: /tmp/tmphi2f4y1m.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  if (nums1.empty() || nums2.empty()) {\n    return result;\n  }\n  std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n  }\n  while (k > 0 && !pq.empty()) {\n    auto p = pq.top();\n    pq.pop();\n    result.push_back({nums1[p.second.first], nums2[p.second.second]});\n    if (p.second.second + 1 < nums2.size()) {\n      pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n    }\n    k--;\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmpa1s4fqq3: /tmp/tmpa1s4fqq3.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto pair = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[pair.second.first], nums2[pair.second.second]});\n        if (pair.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[pair.second.first] + nums2[pair.second.second + 1], std::make_pair(pair.second.first, pair.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmpok_lk8ux: /tmp/tmpok_lk8ux.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmphgm29ucw: /tmp/tmphgm29ucw.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpuc_44zhs: /tmp/tmpuc_44zhs.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  if (nums1.size() == 0 || nums2.size() == 0) {\n    return result;\n  }\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n    return a[0] + a[1] > b[0] + b[1];\n  });\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push({nums1[i], nums2[j]});\n    }\n  }\n  while (k-- > 0 && !pq.empty()) {\n    result.push_back(pq.top());\n    pq.pop();\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmptdwnrmju: /tmp/tmptdwnrmju.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmpqz0ddsqn: /tmp/tmpqz0ddsqn.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmp6ykii8p6: /tmp/tmp6ykii8p6.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[top.second.first], nums2[top.second.second]});\n\t\tif (top.second.second + 1 < nums2.size()) {\n\t\t\tpq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmppt0avg6x: /tmp/tmppt0avg6x.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmp6je07smw: /tmp/tmp6je07smw.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpi4j9kwae: /tmp/tmpi4j9kwae.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n    return a[0] + a[1] > b[0] + b[1];\n  });\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push({nums1[i], nums2[j]});\n    }\n  }\n  while (k-- > 0 && !pq.empty()) {\n    result.push_back(pq.top());\n    pq.pop();\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmptdwnrmju: /tmp/tmptdwnrmju.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n    }\n  }\n  while (k--) {\n    if (pq.empty()) {\n      break;\n    }\n    std::pair<long, std::pair<long, long>> top = pq.top();\n    pq.pop();\n    result.push_back({top.second.first, top.second.second});\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmpfik33puw: /tmp/tmpfik33puw.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "tmpdgsht79d: /tmp/tmpdgsht79d.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto temp = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n        if (temp.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[temp.second.first] + nums2[temp.second.second + 1], std::make_pair(temp.second.first, temp.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmp2l4q0b61: /tmp/tmp2l4q0b61.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty() || k <= 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b){\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            max_heap.push({i, j});\n            if(max_heap.size() > k)\n                max_heap.pop();\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "tmp3dfietg_: /tmp/tmp3dfietg_.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) return result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tpq.push({nums1[i], nums2[j]});\n\t\t}\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122950,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpvx86ol8v: /tmp/tmpvx86ol8v.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push({nums1[p.second.first] + nums2[p.second.second + 1], {p.second.first, p.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpn57a8c3a: /tmp/tmpn57a8c3a.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpld5l8iz7: /tmp/tmpld5l8iz7.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b) {\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long> {0, 0});\n    while (k-- > 0 && !max_heap.empty()) {\n        auto idx_pair = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long> {nums1[idx_pair[0]], nums2[idx_pair[1]]});\n        if (idx_pair[0] + 1 < nums1.size())\n            max_heap.emplace(std::vector<long> {idx_pair[0] + 1, idx_pair[1]});\n        if (idx_pair[0] == 0 && idx_pair[1] + 1 < nums2.size())\n            max_heap.emplace(std::vector<long> {idx_pair[0], idx_pair[1] + 1});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmp66go6fj8: /tmp/tmp66go6fj8.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) return result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            max_heap.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpvx6j9eqm: /tmp/tmpvx6j9eqm.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto pair = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[pair.second.first], nums2[pair.second.second]});\n        if (pair.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[pair.second.first] + nums2[pair.second.second + 1], std::make_pair(pair.second.first, pair.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpi53r6o7z: /tmp/tmpi53r6o7z.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpx6rvvfn5: /tmp/tmpx6rvvfn5.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0 || k == 0) return result;\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] > b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tfor (long j = 0; j < nums2.size(); j++) {\n\t\t\tpq.push({ nums1[i], nums2[j] });\n\t\t}\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tresult.push_back(pq.top());\n\t\tpq.pop();\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmp6je07smw: /tmp/tmp6je07smw.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmppro_kmxd: /tmp/tmppro_kmxd.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpo_vq4pr5: /tmp/tmpo_vq4pr5.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmpza6hm_0k: /tmp/tmpza6hm_0k.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (!pq.empty() && k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmppvfeaeiu: /tmp/tmppvfeaeiu.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> min_heap;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            min_heap.push({num1, num2});\n        }\n    }\n    while (k--) {\n        if (min_heap.empty()) {\n            break;\n        }\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpddncqu4b: /tmp/tmpddncqu4b.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpcdf9hyoe: /tmp/tmpcdf9hyoe.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpeopsuo66: /tmp/tmpeopsuo66.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (!pq.empty() && k--) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpntbpjfs3: /tmp/tmpntbpjfs3.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (!pq.empty() && k--) {\n        result.push_back(std::vector<long>{pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpdn1fao4k: /tmp/tmpdn1fao4k.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpdpcg8chl: /tmp/tmpdpcg8chl.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122945,
      "stdout": "",
      "stderr": "tmpdgsht79d: /tmp/tmpdgsht79d.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> min_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        min_heap.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !min_heap.empty()) {\n        std::pair<long, std::pair<long, long>> current = min_heap.top();\n        min_heap.pop();\n        result.push_back({nums1[current.second.first], nums2[current.second.second]});\n        if(current.second.second + 1 < nums2.size()) {\n            min_heap.push({nums1[current.second.first] + nums2[current.second.second + 1], {current.second.first, current.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpte_qjma5: /tmp/tmpte_qjma5.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.size() == 0 || nums2.size() == 0) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tpq.push({nums1[i] + nums2[0], {i, 0}});\n\t}\n\twhile (k-- > 0 && !pq.empty()) {\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back({nums1[top.second.first], nums2[top.second.second]});\n\t\tif (top.second.second + 1 < nums2.size()) {\n\t\t\tpq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmp73uxdox5: /tmp/tmp73uxdox5.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmp7kjk5cmz: /tmp/tmp7kjk5cmz.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpvx86ol8v: /tmp/tmpvx86ol8v.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            max_heap.push({i, j});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpaond_sd1: /tmp/tmpaond_sd1.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0)\n        return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b){\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpo9j8zv75: /tmp/tmpo9j8zv75.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- && !max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122948,
      "stdout": "",
      "stderr": "tmpnf2ktk4m: /tmp/tmpnf2ktk4m.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmpjv34092b: /tmp/tmpjv34092b.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if(p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while(k-- > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> temp = pq.top();\n        pq.pop();\n        result.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n        if(temp.second.second + 1 < nums2.size()) {\n            pq.push({nums1[temp.second.first] + nums2[temp.second.second + 1], {temp.second.first, temp.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push({nums1[i] + nums2[0], {i, 0}});\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmpk2s3a0be: /tmp/tmpk2s3a0be.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k <= 0)\n        return result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size() && i < k; i++)\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    while (k-- > 0 && max_heap.empty() == false) {\n        auto idx_pair = max_heap.top().second;\n        max_heap.pop();\n        result.push_back({nums1[idx_pair.first], nums2[idx_pair.second]});\n        if (idx_pair.second == nums2.size() - 1)\n            continue;\n        max_heap.push(std::make_pair(nums1[idx_pair.first] + nums2[idx_pair.second + 1], std::make_pair(idx_pair.first, idx_pair.second + 1)));\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmp5uhsvbhr: /tmp/tmp5uhsvbhr.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        auto top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmpt6w93cng: /tmp/tmpt6w93cng.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122946,
      "stdout": "",
      "stderr": "tmptdwnrmju: /tmp/tmptdwnrmju.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmproxxur2r: /tmp/tmproxxur2r.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            max_heap.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n            if (max_heap.size() > k) {\n                max_heap.pop();\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back({max_heap.top().second.first, max_heap.top().second.second});\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmpo2ajhrdb: /tmp/tmpo2ajhrdb.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            max_heap.push({num1, num2});\n        }\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmpgxf8o8hu: /tmp/tmpgxf8o8hu.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while(k-- && !pq.empty()) {\n        result.push_back(std::vector<long>{pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmpnaby6345: /tmp/tmpnaby6345.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> res;\n    if (nums1.empty() || nums2.empty() || k <= 0) return res;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n            if (pq.size() > k) pq.pop();\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmpm5umrgfm: /tmp/tmpm5umrgfm.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (!pq.empty() && k--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmppvfeaeiu: /tmp/tmppvfeaeiu.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({nums1[p.second.first], nums2[p.second.second]});\n        if (p.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[p.second.first] + nums2[p.second.second + 1], std::make_pair(p.second.first, p.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpkb47vire: /tmp/tmpkb47vire.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] + nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmp5gxqe7o5: /tmp/tmp5gxqe7o5.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !pq.empty()) {\n        std::pair<long, std::pair<long, long>> temp = pq.top();\n        pq.pop();\n        result.push_back({nums1[temp.second.first], nums2[temp.second.second]});\n        if(temp.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[temp.second.first] + nums2[temp.second.second + 1], std::make_pair(temp.second.first, temp.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmp588t36gd: /tmp/tmp588t36gd.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  if(nums1.size() == 0 || nums2.size() == 0) {\n    return result;\n  }\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n    return a[0] + a[1] < b[0] + b[1];\n  });\n  for(long i = 0; i < nums1.size(); i++) {\n    for(long j = 0; j < nums2.size(); j++) {\n      if(max_heap.size() < k) {\n        max_heap.push({nums1[i], nums2[j]});\n      } else {\n        if(nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n          max_heap.pop();\n          max_heap.push({nums1[i], nums2[j]});\n        }\n      }\n    }\n  }\n  while(!max_heap.empty()) {\n    result.push_back(max_heap.top());\n    max_heap.pop();\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmpir3pvy23: /tmp/tmpir3pvy23.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> min_heap;\n    min_heap.push({nums1[0] + nums2[0], {0, 0}});\n    while (k-- > 0 && !min_heap.empty()) {\n        auto top = min_heap.top();\n        min_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.first + 1 < nums1.size()) {\n            min_heap.push({nums1[top.second.first + 1] + nums2[top.second.second], {top.second.first + 1, top.second.second}});\n        }\n        if (top.second.first == 0 && top.second.second + 1 < nums2.size()) {\n            min_heap.push({nums1[top.second.first] + nums2[top.second.second + 1], {top.second.first, top.second.second + 1}});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({top.second.first, top.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1665510132,
      "stdout": "",
      "stderr": "tmpvx86ol8v: /tmp/tmpvx86ol8v.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty() || k <= 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] < b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (max_heap.size() < k) {\n                max_heap.push({nums1[i], nums2[j]});\n            } else {\n                if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n                    max_heap.pop();\n                    max_heap.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122952,
      "stdout": "",
      "stderr": "tmpcdf9hyoe: /tmp/tmpcdf9hyoe.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], nums1[i], nums2[j]});\n        }\n    }\n    while (k-- > 0 && !pq.empty()) {\n        result.push_back({pq.top()[1], pq.top()[2]});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmphi6amvuf: /tmp/tmphi6amvuf.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n\tstd::vector<std::vector<long>> result;\n\tif (nums1.empty() || nums2.empty()) {\n\t\treturn result;\n\t}\n\tstd::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n\t\treturn a[0] + a[1] < b[0] + b[1];\n\t});\n\tfor (long i = 0; i < nums1.size(); i++) {\n\t\tmax_heap.push({nums1[i], nums2[0], 0});\n\t}\n\twhile (k-- > 0 && !max_heap.empty()) {\n\t\tauto top = max_heap.top();\n\t\tmax_heap.pop();\n\t\tresult.push_back({top[0], top[1]});\n\t\tif (top[2] == nums2.size() - 1) {\n\t\t\tcontinue;\n\t\t}\n\t\tmax_heap.push({top[0], nums2[top[2] + 1], top[2] + 1});\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmpaesqr2yl: /tmp/tmpaesqr2yl.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while(k-- && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back({p.second.first, p.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmpo9rm8moi: /tmp/tmpo9rm8moi.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for (long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmpc9ybn_pp: /tmp/tmpc9ybn_pp.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  if (nums1.empty() || nums2.empty() || k <= 0) {\n    return result;\n  }\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n    return a[0] + a[1] > b[0] + b[1];\n  });\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      if (max_heap.size() < k) {\n        max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n      } else {\n        if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n          max_heap.pop();\n          max_heap.emplace(std::vector<long>{nums1[i], nums2[j]});\n        }\n      }\n    }\n  }\n  while (!max_heap.empty()) {\n    result.emplace_back(max_heap.top());\n    max_heap.pop();\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "tmpf0n3puva: /tmp/tmpf0n3puva.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while (!pq.empty() && k > 0) {\n        result.push_back(pq.top());\n        pq.pop();\n        k--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122954,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) return result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([&nums1, &nums2](std::vector<long> a, std::vector<long> b){\n        return nums1[a[0]] + nums2[a[1]] < nums1[b[0]] + nums2[b[1]];\n    });\n    max_heap.emplace(std::vector<long>{0, 0});\n    while(k-- > 0 && !max_heap.empty()) {\n        auto idx_pair = max_heap.top();\n        max_heap.pop();\n        result.emplace_back(std::vector<long>{nums1[idx_pair[0]], nums2[idx_pair[1]]});\n        if(idx_pair[0] + 1 < nums1.size()) {\n            max_heap.emplace(std::vector<long>{idx_pair[0] + 1, idx_pair[1]});\n        }\n        if(idx_pair[0] == 0 && idx_pair[1] + 1 < nums2.size()) {\n            max_heap.emplace(std::vector<long>{idx_pair[0], idx_pair[1] + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122956,
      "stdout": "",
      "stderr": "tmpbli705zp: /tmp/tmpbli705zp.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.empty() || nums2.empty()) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            if(pq.size() < k) {\n                pq.push({nums1[i], nums2[j]});\n            } else {\n                if(nums1[i] + nums2[j] < pq.top()[0] + pq.top()[1]) {\n                    pq.pop();\n                    pq.push({nums1[i], nums2[j]});\n                }\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122956,
      "stdout": "",
      "stderr": "tmpu0u60rh0: /tmp/tmpu0u60rh0.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([&](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i], nums2[j]});\n        }\n    }\n    while(k-- > 0 && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122956,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        if (pq.empty()) {\n            break;\n        }\n        auto temp = pq.top();\n        pq.pop();\n        result.push_back({temp.second.first, temp.second.second});\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122956,
      "stdout": "",
      "stderr": "tmpwm4m6zyh: /tmp/tmpwm4m6zyh.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n  std::vector<std::vector<long>> result;\n  if (nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n    return result;\n  }\n  std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> max_heap([](std::vector<long> a, std::vector<long> b) {\n    return a[0] + a[1] > b[0] + b[1];\n  });\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      if (max_heap.size() < k) {\n        max_heap.push({nums1[i], nums2[j]});\n      } else {\n        if (nums1[i] + nums2[j] < max_heap.top()[0] + max_heap.top()[1]) {\n          max_heap.pop();\n          max_heap.push({nums1[i], nums2[j]});\n        }\n      }\n    }\n  }\n  while (!max_heap.empty()) {\n    result.push_back(max_heap.top());\n    max_heap.pop();\n  }\n  return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122956,
      "stdout": "",
      "stderr": "tmptihnj8j4: /tmp/tmptihnj8j4.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if(nums1.size() == 0 || nums2.size() == 0 || k == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>> max_heap;\n    for(long i = 0; i < nums1.size(); i++) {\n        max_heap.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while(k-- > 0 && !max_heap.empty()) {\n        std::pair<long, std::pair<long, long>> top = max_heap.top();\n        max_heap.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if(top.second.second + 1 < nums2.size()) {\n            max_heap.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122943,
      "stdout": "",
      "stderr": "tmpeopsuo66: /tmp/tmpeopsuo66.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push({nums1[i] + nums2[j], {nums1[i], nums2[j]}});\n        }\n    }\n    while (k--) {\n        result.push_back({pq.top().second.first, pq.top().second.second});\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122956,
      "stdout": "",
      "stderr": "tmpow50qsdx: /tmp/tmpow50qsdx.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>, std::function<bool(std::vector<long>, std::vector<long>)>> pq([](std::vector<long> a, std::vector<long> b) {\n        return a[0] + a[1] > b[0] + b[1];\n    });\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push({i, j});\n        }\n    }\n    while (k-- && !pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122956,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nstd::vector<std::vector<long>> k_smallest_pairs(std::vector<long> nums1, std::vector<long> nums2, long k) {\n    std::vector<std::vector<long>> result;\n    if (nums1.size() == 0 || nums2.size() == 0) {\n        return result;\n    }\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        pq.push(std::make_pair(nums1[i] + nums2[0], std::make_pair(i, 0)));\n    }\n    while (k-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back({nums1[top.second.first], nums2[top.second.second]});\n        if (top.second.second + 1 < nums2.size()) {\n            pq.push(std::make_pair(nums1[top.second.first] + nums2[top.second.second + 1], std::make_pair(top.second.first, top.second.second + 1)));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = k_smallest_pairs;\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (2)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (1)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2})})));\n    assert(candidate((std::vector<long>({(long)1, (long)3, (long)7})), (std::vector<long>({(long)2, (long)4, (long)6})), (7)) == (std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)2}), (std::vector<long>)std::vector<long>({(long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)2})})));\n}\n",
      "timestamp": 1666122956,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}