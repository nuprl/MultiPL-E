{
  "name": "mbpp_773_occurance_substring",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Write a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\nstd::optional<Union_std_string_long> occurance_substring(std::string text, std::string pattern) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_773_occurance_substring.py",
  "prompt_terminology": "reworded",
  "tests": "}\nint main() {\n    auto candidate = occurance_substring;\n    assert(candidate((\"python programming, python language\"), (\"python\")) == std::make_tuple(\"python\", 0, 6));\n    assert(candidate((\"python programming,programming language\"), (\"programming\")) == std::make_tuple(\"programming\", 7, 18));\n    assert(candidate((\"python programming,programming language\"), (\"language\")) == std::make_tuple(\"language\", 31, 39));\n    assert(candidate((\"c++ programming, c++ language\"), (\"python\")) == std::nullopt);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(pos);\n    }",
    "    std::size_t found = text.find(pattern);\n    if (found!=std::string::npos)\n        return Union_std_string_long(found);\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return std::make_optional(Union_std_string_long(text.find(pattern)));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if(pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    } else {\n        return std::nullopt;\n    }",
    "    if (text.find(pattern) == std::string::npos) {\n        return {};\n    } else {\n        return Union_std_string_long(text.find(pattern));\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos != std::string::npos) {\n        return Union_std_string_long(pos);\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if(pos != std::string::npos) {\n        return Union_std_string_long(pos);\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return std::make_optional<Union_std_string_long>(text.find(pattern));\n    } else {\n        return std::nullopt;\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    int len_text = text.length();\n    int len_pattern = pattern.length();\n    int i,j;\n    for(i=0;i<=len_text-len_pattern;i++) {\n        for(j=0;j<len_pattern;j++) {\n            if(text[i+j] != pattern[j]) {\n                break;\n            }\n        }\n        if(j == len_pattern) {\n            return Union_std_string_long(i);\n        }\n    }\n    return std::nullopt;",
    "    std::vector<int> lps(pattern.size());\n    int i = 1, j = 0;\n    while(i < pattern.size()) {\n        if(pattern[i] == pattern[j]) {\n            lps[i] = j + 1;\n            i++;\n            j++;\n        } else {\n            if(j != 0) {\n                j = lps[j - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    i = 0;\n    j = 0;\n    int count = 0;\n    while(i < text.size()) {\n        if(text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if(j == pattern.size()) {\n            count++;\n            j = lps[j - 1];\n        } else if(i < text.size() && text[i] != pattern[j]) {\n            if(j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if(count == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(count);\n    }",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return {};",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return {};\n    }\n    return Union_std_string_long(pos);",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::vector<int> indexes;\n    int index = 0;\n    while(index != -1) {\n        index = text.find(pattern, index);\n        if(index != -1) {\n            indexes.push_back(index);\n            index++;\n        }\n    }\n    if(indexes.size() == 0) {\n        return std::nullopt;\n    }\n    return indexes.size();",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return {};",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    std::string::size_type pos = text.find(pattern);\n    if(pos != std::string::npos) {\n        return Union_std_string_long(pos);\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    int n = text.length();\n    int m = pattern.length();\n    for (int i = 0; i <= n - m; i++) {\n        int j;\n        for (j = 0; j < m; j++)\n            if (text[i + j] != pattern[j])\n                break;\n        if (j == m)\n            return Union_std_string_long(i);\n    }\n    return std::nullopt;",
    "    if(text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return pos;",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    if(text.find(pattern) != std::string::npos){\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if(text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return pos;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    } else {\n        return std::nullopt;\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    int count = 0;\n    int pos = 0;\n    for (int i = 0; i < text.length(); i++) {\n        if (text[i] == pattern[0]) {\n            int j = 0;\n            while (j < pattern.length() && text[i + j] == pattern[j]) {\n                j++;\n            }\n            if (j == pattern.length()) {\n                count++;\n                pos = i;\n            }\n        }\n    }\n    if (count == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(pos);\n    }",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos != std::string::npos) {\n        return Union_std_string_long(pos);\n    }\n    return std::nullopt;",
    "    std::vector<int> lps = compute_lps(pattern);\n    int i = 0, j = 0;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            return Union_std_string_long(i - j);\n        } else if (i < text.size() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    } else {\n        return std::nullopt;\n    }",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos != std::string::npos) {\n        return Union_std_string_long(pos);\n    }\n    return std::nullopt;",
    "    int n = text.size();\n    int m = pattern.size();\n    if (n < m) {\n        return std::nullopt;\n    }\n    int i = 0;\n    int j = 0;\n    int lps[m];\n    computeLPSArray(pattern, m, lps);\n    while (i < n) {\n        if (pattern[j] == text[i]) {\n            j++;\n            i++;\n        }\n        if (j == m) {\n            return Union_std_string_long(i - j);\n            j = lps[j - 1];\n        } else if (i < n && pattern[j] != text[i]) {\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i = i + 1;\n        }\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    std::vector<int> lps = compute_lps(pattern);\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    int pos = 0;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            count++;\n            pos = i - j;\n            j = lps[j - 1];\n        } else if (i < text.size() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (count == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(pos);\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return {};",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    } else {\n        return std::nullopt;\n    }",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    std::string::size_type n = text.find(pattern);\n    if (n != std::string::npos) {\n        return Union_std_string_long(n);\n    }\n    return std::nullopt;",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    } else {\n        return std::nullopt;\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return std::make_optional(Union_std_string_long(text.find(pattern)));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    } else {\n        return std::nullopt;\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if(text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    std::vector<int> lps = compute_lps(pattern);\n    int i = 0, j = 0;\n    while (i < text.length()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.length()) {\n            return Union_std_string_long(i - j);\n        }\n        else if (i < text.length() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            }\n            else {\n                i++;\n            }\n        }\n    }\n    return std::nullopt;",
    "    std::vector<int> lps = computeLPSArray(pattern);\n    int i = 0;\n    int j = 0;\n    while (i < text.length()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.length()) {\n            return Union_std_string_long(i - j);\n        }\n        else if (i < text.length() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            }\n            else {\n                i = i + 1;\n            }\n        }\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos != std::string::npos) {\n        return Union_std_string_long(pos);\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if(text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::vector<int> lps = compute_lps(pattern);\n    int i = 0, j = 0;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            return i - j;\n        }\n        else if (i < text.size() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            }\n            else {\n                i++;\n            }\n        }\n    }\n    return std::nullopt;",
    "    std::vector<int> lps(pattern.size());\n    int i = 1, j = 0;\n    lps[0] = 0;\n    while(i < pattern.size()) {\n        if(pattern[i] == pattern[j]) {\n            lps[i] = j + 1;\n            i++;\n            j++;\n        } else {\n            if(j != 0) {\n                j = lps[j - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    i = 0;\n    j = 0;\n    std::vector<int> indices;\n    while(i < text.size()) {\n        if(text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if(j == pattern.size()) {\n            indices.push_back(i - j);\n            j = lps[j - 1];\n        } else if(i < text.size() && text[i] != pattern[j]) {\n            if(j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if(indices.size() == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(indices.size());\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    std::vector<int> result;\n    int M = pattern.length();\n    int N = text.length();\n    for (int i = 0; i <= N - M; i++) {\n        int j;\n        for (j = 0; j < M; j++)\n            if (text[i + j] != pattern[j])\n                break;\n        if (j == M)\n            result.push_back(i);\n    }\n    if (result.size() == 0) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(result.size());",
    "    std::string::size_type n = text.find(pattern);\n    if (n != std::string::npos) {\n        return Union_std_string_long(n);\n    }\n    return std::nullopt;",
    "    std::vector<int> lps(pattern.size());\n    int i = 1;\n    int j = 0;\n    while (i < pattern.size()) {\n        if (pattern[i] == pattern[j]) {\n            lps[i] = j + 1;\n            i++;\n            j++;\n        } else {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    i = 0;\n    j = 0;\n    std::vector<int> positions;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            positions.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < text.size() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (positions.size() == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(positions.size());\n    }",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(pos);\n    }",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos != std::string::npos) {\n        return Union_std_string_long(pos);\n    } else {\n        return std::nullopt;\n    }",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos != std::string::npos) {\n        return Union_std_string_long(pos);\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return pos;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos != std::string::npos) {\n        return Union_std_string_long(pos);\n    } else {\n        return {};\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::vector<int> lps = computeLPSArray(pattern);\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            count++;\n            j = lps[j - 1];\n        } else if (i < text.size() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (count > 0) {\n        return Union_std_string_long(count);\n    } else {\n        return std::nullopt;\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if(pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    int count = 0;\n    int pos = 0;\n    for (int i = 0; i < text.length(); i++) {\n        if (text[i] == pattern[0]) {\n            int j = 0;\n            while (j < pattern.length() && text[i + j] == pattern[j]) {\n                j++;\n            }\n            if (j == pattern.length()) {\n                count++;\n                pos = i;\n            }\n        }\n    }\n    if (count == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(pos);\n    }",
    "    std::string::size_type pos = text.find(pattern);\n    if(pos == std::string::npos)\n        return std::nullopt;\n    return Union_std_string_long(pos);",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    } else {\n        return std::nullopt;\n    }",
    "    std::vector<int> lps(pattern.size());\n    int i = 1, j = 0;\n    lps[0] = 0;\n    while(i < pattern.size()) {\n        if(pattern[i] == pattern[j]) {\n            lps[i] = j + 1;\n            i++;\n            j++;\n        } else {\n            if(j != 0) {\n                j = lps[j-1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    i = 0;\n    j = 0;\n    std::vector<int> positions;\n    while(i < text.size()) {\n        if(text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if(j == pattern.size()) {\n            positions.push_back(i - j);\n            j = lps[j-1];\n        } else if(i < text.size() && text[i] != pattern[j]) {\n            if(j != 0) {\n                j = lps[j-1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if(positions.size() == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(positions.size());\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    int n = text.size();\n    int m = pattern.size();\n    for (int i = 0; i <= n - m; i++) {\n        int j;\n        for (j = 0; j < m; j++) {\n            if (text[i + j] != pattern[j]) {\n                break;\n            }\n        }\n        if (j == m) {\n            return Union_std_string_long(i);\n        }\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    } else {\n        return std::nullopt;\n    }",
    "    std::vector<int> lps(pattern.length());\n    int i = 1, j = 0;\n    lps[0] = 0;\n    while (i < pattern.length()) {\n        if (pattern[i] == pattern[j]) {\n            lps[i] = j + 1;\n            i++;\n            j++;\n        } else {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    i = 0;\n    j = 0;\n    std::vector<int> positions;\n    while (i < text.length()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.length()) {\n            positions.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < text.length() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (positions.size() == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(positions.size());\n    }",
    "    std::vector<int> lps = computeLPSArray(pattern);\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < text.length()) {\n        if (pattern[j] == text[i]) {\n            j++;\n            i++;\n        }\n        if (j == pattern.length()) {\n            count++;\n            j = lps[j - 1];\n        } else if (i < text.length() && pattern[j] != text[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (count > 0) {\n        return Union_std_string_long(count);\n    } else {\n        return std::nullopt;\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::vector<int> result;\n    int M = pattern.length();\n    int N = text.length();\n    for (int i = 0; i <= N - M; i++) {\n        int j;\n        for (j = 0; j < M; j++)\n            if (text[i + j] != pattern[j])\n                break;\n        if (j == M)\n            result.push_back(i);\n    }\n    if (result.size() == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(result[0]);\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if(text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::regex regex(pattern);\n    std::smatch match;\n    std::regex_search(text, match, regex);\n    if (match.size() > 0) {\n        return Union_std_string_long(match.position());\n    } else {\n        return std::nullopt;\n    }",
    "    std::vector<int> lps = compute_lps(pattern);\n    int i = 0, j = 0;\n    int count = 0;\n    std::vector<int> positions;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            count++;\n            positions.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < text.size() && pattern[j] != text[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (count == 0) {\n        return {};\n    } else {\n        return Union_std_string_long(positions);\n    }",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos != std::string::npos) {\n        return Union_std_string_long(pos);\n    }\n    return {};",
    "    if(text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    } else {\n        return std::nullopt;\n    }",
    "    std::vector<int> lps = computeLPSArray(pattern);\n    int i = 0;\n    int j = 0;\n    while (i < text.length()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.length()) {\n            return Union_std_string_long(i - j);\n        }\n        else if (i < text.length() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            }\n            else {\n                i = i + 1;\n            }\n        }\n    }\n    return std::nullopt;",
    "    std::vector<int> lps = compute_lps(pattern);\n    int i = 0, j = 0;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            return Union_std_string_long(i - j);\n        }\n        else if (i < text.size() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            }\n            else {\n                i++;\n            }\n        }\n    }\n    return std::nullopt;",
    "    int count = 0;\n    int pos = 0;\n    for (int i = 0; i < text.length(); i++) {\n        if (text[i] == pattern[0]) {\n            int j = 0;\n            while (text[i + j] == pattern[j] && j < pattern.length()) {\n                j++;\n            }\n            if (j == pattern.length()) {\n                count++;\n                pos = i;\n            }\n        }\n    }\n    if (count == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(pos);\n    }",
    "    if(text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::vector<int> lps = compute_lps(pattern);\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            count++;\n            j = lps[j - 1];\n        }\n        else if (i < text.size() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            }\n            else {\n                i++;\n            }\n        }\n    }\n    if (count == 0) {\n        return std::nullopt;\n    }\n    else {\n        return Union_std_string_long(count);\n    }",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos != std::string::npos) {\n        return Union_std_string_long(pos);\n    }\n    return std::nullopt;",
    "    std::vector<int> lps = computeLPSArray(pattern);\n    int i = 0, j = 0;\n    while (i < text.length()) {\n        if (pattern[j] == text[i]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.length()) {\n            return Union_std_string_long(i - j);\n            j = lps[j - 1];\n        }\n        else if (i < text.length() && pattern[j] != text[i]) {\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i = i + 1;\n        }\n    }\n    return std::nullopt;",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(pos);\n    }",
    "    std::vector<int> lps(pattern.size(), 0);\n    int i = 1, j = 0;\n    while (i < pattern.size()) {\n        if (pattern[i] == pattern[j]) {\n            lps[i] = j + 1;\n            i++;\n            j++;\n        } else {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    i = 0;\n    j = 0;\n    int count = 0;\n    std::vector<int> indices;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            count++;\n            indices.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < text.size() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (count == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(indices);\n    }",
    "    std::vector<int> lps(pattern.size(), 0);\n    int i = 1;\n    int j = 0;\n    while (i < pattern.size()) {\n        if (pattern[i] == pattern[j]) {\n            lps[i] = j + 1;\n            i++;\n            j++;\n        } else {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    i = 0;\n    j = 0;\n    std::vector<int> positions;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            positions.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < text.size() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (positions.size() == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(positions.size());\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    } else {\n        return std::nullopt;\n    }",
    "    if(text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return {};",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    } else {\n        return std::nullopt;\n    }",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    std::vector<int> lps = computeLPSArray(pattern);\n    int i = 0;\n    int j = 0;\n    while (i < text.length()) {\n        if (pattern[j] == text[i]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.length()) {\n            return Union_std_string_long(i - j);\n        } else if (i < text.length() && pattern[j] != text[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return std::make_optional(Union_std_string_long(text.find(pattern)));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::size_t found = text.find(pattern);\n    if (found!=std::string::npos)\n        return Union_std_string_long(found);\n    return {};",
    "    int n = text.size();\n    int m = pattern.size();\n    if (m > n) {\n        return std::nullopt;\n    }\n    std::vector<int> lps(m);\n    int i = 1;\n    int len = 0;\n    lps[0] = 0;\n    while (i < m) {\n        if (pattern[i] == pattern[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    i = 0;\n    int j = 0;\n    std::vector<int> result;\n    while (i < n) {\n        if (pattern[j] == text[i]) {\n            i++;\n            j++;\n        }\n        if (j == m) {\n            result.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < n && pattern[j] != text[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (result.size() == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(result[0]);\n    }",
    "    int n = text.length();\n    int m = pattern.length();\n    for (int i = 0; i <= n - m; i++) {\n        int j;\n        for (j = 0; j < m; j++)\n            if (text[i + j] != pattern[j])\n                break;\n        if (j == m)\n            return Union_std_string_long(i);\n    }\n    return std::nullopt;",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(pos);\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return {};",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if(text.find(pattern) != std::string::npos)\n        return Union_std_string_long(text.find(pattern));\n    else\n        return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(pos);\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    } else {\n        return std::nullopt;\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return {};",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    if(text.find(pattern) == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(text.find(pattern));",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::vector<int> lps = computeLPSArray(pattern);\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    int pos = -1;\n    while (i < text.length()) {\n        if (pattern[j] == text[i]) {\n            j++;\n            i++;\n        }\n        if (j == pattern.length()) {\n            count++;\n            if (pos == -1) {\n                pos = i - j;\n            }\n            j = lps[j - 1];\n        } else if (i < text.length() && pattern[j] != text[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (count > 0) {\n        return Union_std_string_long(pos);\n    } else {\n        return std::nullopt;\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return {};",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    std::vector<int> result;\n    int M = pattern.length();\n    int N = text.length();\n    for (int i = 0; i <= N - M; i++) {\n        int j;\n        for (j = 0; j < M; j++)\n            if (text[i + j] != pattern[j])\n                break;\n        if (j == M)\n            result.push_back(i);\n    }\n    if (result.size() == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(result);\n    }",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    } else {\n        return std::nullopt;\n    }",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos != std::string::npos) {\n        return Union_std_string_long(pos);\n    }\n    return std::nullopt;",
    "    std::vector<int> lps = computeLPSArray(pattern);\n    int i = 0, j = 0;\n    while (i < text.length()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.length()) {\n            return Union_std_string_long(i - j);\n        }\n        else if (i < text.length() && pattern[j] != text[i]) {\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i = i + 1;\n        }\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::vector<int> lps = compute_lps(pattern);\n    int n = text.size();\n    int m = pattern.size();\n    int i = 0, j = 0;\n    int count = 0;\n    while (i < n) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == m) {\n            count++;\n            j = lps[j - 1];\n        } else if (i < n && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (count == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(count);\n    }",
    "    std::vector<int> lps = compute_lps(pattern);\n    int i = 0, j = 0;\n    int count = 0;\n    std::vector<int> positions;\n    while (i < text.length()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.length()) {\n            count++;\n            positions.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < text.length() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (count == 0) {\n        return {};\n    } else {\n        return {count};\n    }",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    std::vector<int> result;\n    int M = pattern.length();\n    int N = text.length();\n    for (int i = 0; i <= N - M; i++) {\n        int j;\n        for (j = 0; j < M; j++)\n            if (text[i + j] != pattern[j])\n                break;\n        if (j == M)\n            result.push_back(i);\n    }\n    if (result.size() == 0) {\n        return std::nullopt;\n    }\n    else {\n        return Union_std_string_long(result);\n    }",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    int n = text.length();\n    int m = pattern.length();\n    for (int i = 0; i <= n - m; i++) {\n        int j;\n        for (j = 0; j < m; j++)\n            if (text[i + j] != pattern[j])\n                break;\n        if (j == m)\n            return Union_std_string_long(i);\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::vector<int> lps = computeLPSArray(pattern);\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < text.length()) {\n        if (pattern[j] == text[i]) {\n            j++;\n            i++;\n        }\n        if (j == pattern.length()) {\n            count++;\n            j = lps[j - 1];\n        } else if (i < text.length() && pattern[j] != text[i]) {\n            if (j != 0)\n                j = lps[j - 1];\n            else\n                i = i + 1;\n        }\n    }\n    if (count == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(count);\n    }",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    std::vector<int> v;\n    int m = text.length();\n    int n = pattern.length();\n    for (int i = 0; i <= m - n; i++) {\n        int j;\n        for (j = 0; j < n; j++)\n            if (text[i + j] != pattern[j])\n                break;\n        if (j == n)\n            v.push_back(i);\n    }\n    if (v.size() == 0)\n        return std::nullopt;\n    else\n        return Union_std_string_long(v.size());",
    "    if(text.find(pattern) == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(text.find(pattern));",
    "    if (text.find(pattern) != std::string::npos)\n        return Union_std_string_long(text.find(pattern));\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    } else {\n        return std::nullopt;\n    }",
    "    std::vector<int> lps(pattern.size(), 0);\n    int i = 1;\n    int j = 0;\n    while (i < pattern.size()) {\n        if (pattern[i] == pattern[j]) {\n            lps[i] = j + 1;\n            i++;\n            j++;\n        } else {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    i = 0;\n    j = 0;\n    std::vector<int> positions;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            positions.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < text.size() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (positions.size() == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(positions.size());\n    }",
    "    std::vector<int> lps(pattern.length(), 0);\n    int i = 1;\n    int j = 0;\n    while (i < pattern.length()) {\n        if (pattern[i] == pattern[j]) {\n            lps[i] = j + 1;\n            i++;\n            j++;\n        } else {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    i = 0;\n    j = 0;\n    int count = 0;\n    std::vector<int> positions;\n    while (i < text.length()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.length()) {\n            count++;\n            positions.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < text.length() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (count == 0) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(positions);",
    "    std::vector<int> lps = compute_lps(pattern);\n    int i = 0, j = 0;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            return Union_std_string_long(i - j);\n        } else if (i < text.size() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    int n = text.length();\n    int m = pattern.length();\n    for (int i = 0; i <= n - m; i++) {\n        int j;\n        for (j = 0; j < m; j++)\n            if (text[i + j] != pattern[j])\n                break;\n        if (j == m)\n            return Union_std_string_long(i);\n    }\n    return std::nullopt;",
    "    if(text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(pos);\n    }",
    "    std::vector<int> lps = compute_lps(pattern);\n    int i = 0, j = 0;\n    int count = 0;\n    std::vector<int> positions;\n    while (i < text.length()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.length()) {\n            count++;\n            positions.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < text.length() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (count == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(count);\n    }",
    "    std::vector<int> lps(pattern.size(), 0);\n    int i = 1, j = 0;\n    while (i < pattern.size()) {\n        if (pattern[i] == pattern[j]) {\n            lps[i] = j + 1;\n            i++;\n            j++;\n        } else {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    i = 0;\n    j = 0;\n    int count = 0;\n    std::vector<int> positions;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            count++;\n            positions.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < text.size() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (count == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(positions);\n    }",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    std::string::size_type pos = text.find(pattern);\n    if (pos == std::string::npos) {\n        return std::nullopt;\n    }\n    return Union_std_string_long(pos);",
    "    std::vector<int> lps(pattern.size(), 0);\n    int i = 1, j = 0;\n    while (i < pattern.size()) {\n        if (pattern[i] == pattern[j]) {\n            lps[i] = j + 1;\n            i++;\n            j++;\n        } else {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                lps[i] = 0;\n                i++;\n            }\n        }\n    }\n    i = 0;\n    j = 0;\n    int count = 0;\n    std::vector<int> positions;\n    while (i < text.size()) {\n        if (text[i] == pattern[j]) {\n            i++;\n            j++;\n        }\n        if (j == pattern.size()) {\n            count++;\n            positions.push_back(i - j);\n            j = lps[j - 1];\n        } else if (i < text.size() && text[i] != pattern[j]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n    if (count == 0) {\n        return std::nullopt;\n    } else {\n        return Union_std_string_long(positions);\n    }",
    "    std::size_t found = text.find(pattern);\n    if (found != std::string::npos) {\n        return Union_std_string_long(found);\n    }\n    return std::nullopt;",
    "    if (text.find(pattern) != std::string::npos) {\n        return Union_std_string_long(text.find(pattern));\n    }\n    return std::nullopt;"
  ]
}