{
  "name": "mbpp_308_large_product",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "reworded",
  "tests": "}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpskd1pf0j: /tmp/tmpskd1pf0j.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto [product, pair] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = pair.first, j = pair.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpqq2tvn5x: /tmp/tmpqq2tvn5x.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long> temp;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            temp.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(temp.begin(), temp.end());\n    for(int i = 0; i < N; i++) {\n        result.push_back(temp[temp.size() - 1 - i]);\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        res.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpx_32iu9m: /tmp/tmpx_32iu9m.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); ++i) {\n        for (long j = 0; j < nums2.size(); ++j) {\n            pq.push(nums1[i] * nums2[j]);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpgpkxiz7y: /tmp/tmpgpkxiz7y.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    for (int i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (s.find({x, y + 1}) == s.end()) {\n            pq.push({nums1[x] * nums2[y + 1], {x, y + 1}});\n            s.insert({x, y + 1});\n        }\n        if (s.find({x + 1, y}) == s.end()) {\n            pq.push({nums1[x + 1] * nums2[y], {x + 1, y}});\n            s.insert({x + 1, y});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpp4tgvams: /tmp/tmpp4tgvams.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>, std::vector<std::pair<long, std::pair<int, int>>>, std::greater<std::pair<long, std::pair<int, int>>>> pq;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    std::unordered_set<int> visited;\n    visited.insert(0);\n    while(N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if(i + 1 < nums1.size() && visited.find((i + 1) * nums2.size() + j) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert((i + 1) * nums2.size() + j);\n        }\n        if(j + 1 < nums2.size() && visited.find(i * nums2.size() + j + 1) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert(i * nums2.size() + j + 1);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpsgf9a7wm: /tmp/tmpsgf9a7wm.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, idx] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = idx.first, j = idx.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpthvorw2q: /tmp/tmpthvorw2q.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n  std::vector<long> res;\n  std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n  std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n  std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n  pq.push({nums1[0] * nums2[0], {0, 0}});\n  std::set<std::pair<int, int>> visited;\n  visited.insert({0, 0});\n  while(N-- > 0 && pq.size() > 0) {\n    auto curr = pq.top();\n    pq.pop();\n    res.push_back(curr.first);\n    int i = curr.second.first, j = curr.second.second;\n    if(i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n      pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n      visited.insert({i + 1, j});\n    }\n    if(j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n      pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n      visited.insert({i, j + 1});\n    }\n  }\n  return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long>::iterator it1, it2;\n    std::vector<long>::iterator it1_end = nums1.end();\n    std::vector<long>::iterator it2_end = nums2.end();\n    std::vector<long>::iterator it1_begin = nums1.begin();\n    std::vector<long>::iterator it2_begin = nums2.begin();\n    std::vector<long>::iterator it1_max = nums1.begin();\n    std::vector<long>::iterator it2_max = nums2.begin();\n    long max_product = 0;\n    while(N > 0) {\n        max_product = 0;\n        for(it1 = it1_begin; it1 != it1_end; it1++) {\n            for(it2 = it2_begin; it2 != it2_end; it2++) {\n                if(*it1 * *it2 > max_product) {\n                    max_product = *it1 * *it2;\n                    it1_max = it1;\n                    it2_max = it2;\n                }\n            }\n        }\n        result.push_back(max_product);\n        it1_begin = it1_max + 1;\n        it2_begin = it2_max + 1;\n        N--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpoglz3tqh: /tmp/tmpoglz3tqh.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> max_heap;\n    std::set<std::pair<int, int>> visited;\n    max_heap.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    visited.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        long result_i = max_heap.top().first;\n        int idx1 = max_heap.top().second.first;\n        int idx2 = max_heap.top().second.second;\n        result.push_back(result_i);\n        max_heap.pop();\n        if (idx1 + 1 < nums1.size() && visited.find(std::make_pair(idx1 + 1, idx2)) == visited.end()) {\n            max_heap.push(std::make_pair(nums1[idx1 + 1] * nums2[idx2], std::make_pair(idx1 + 1, idx2)));\n            visited.insert(std::make_pair(idx1 + 1, idx2));\n        }\n        if (idx2 + 1 < nums2.size() && visited.find(std::make_pair(idx1, idx2 + 1)) == visited.end()) {\n            max_heap.push(std::make_pair(nums1[idx1] * nums2[idx2 + 1], std::make_pair(idx1, idx2 + 1)));\n            visited.insert(std::make_pair(idx1, idx2 + 1));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmp6u5lenap: /tmp/tmp6u5lenap.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    s.insert({nums1.size() - 1, nums2.size() - 1});\n    for (int i = 0; i < N; i++) {\n        auto a = pq.top();\n        pq.pop();\n        result.push_back(a.first);\n        int x = a.second.first;\n        int y = a.second.second;\n        if (s.find({x - 1, y}) == s.end()) {\n            pq.push({nums1[x - 1] * nums2[y], {x - 1, y}});\n            s.insert({x - 1, y});\n        }\n        if (s.find({x, y - 1}) == s.end()) {\n            pq.push({nums1[x] * nums2[y - 1], {x, y - 1}});\n            s.insert({x, y - 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long> nums1_sorted = nums1;\n    std::vector<long> nums2_sorted = nums2;\n    std::sort(nums1_sorted.begin(), nums1_sorted.end());\n    std::sort(nums2_sorted.begin(), nums2_sorted.end());\n    std::vector<long>::iterator it1 = nums1_sorted.begin();\n    std::vector<long>::iterator it2 = nums2_sorted.begin();\n    while(N--) {\n        if(*it1 > *it2) {\n            result.push_back(*it1);\n            it1++;\n        } else {\n            result.push_back(*it2);\n            it2++;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpryfw3n12: /tmp/tmpryfw3n12.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(long i = 0; i < nums1.size(); i++) {\n        for(long j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if(pq.size() < N) {\n                pq.push(product);\n            } else {\n                if(product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509971,
      "stdout": "",
      "stderr": "tmpyy8xihq8: /tmp/tmpyy8xihq8.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpygg_7t1d: /tmp/tmpygg_7t1d.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto a = pq.top();\n        pq.pop();\n        result.push_back(a.first);\n        int i = a.second.first, j = a.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpqzf64gws: /tmp/tmpqzf64gws.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n  std::vector<long> result;\n  std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n  std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n  std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n  pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n  std::set<std::pair<int, int>> visited;\n  visited.insert(std::make_pair(0, 0));\n  while (N--) {\n    auto top = pq.top();\n    pq.pop();\n    result.push_back(top.first);\n    int i = top.second.first;\n    int j = top.second.second;\n    if (i + 1 < nums1.size() && visited.find(std::make_pair(i + 1, j)) == visited.end()) {\n      pq.push(std::make_pair(nums1[i + 1] * nums2[j], std::make_pair(i + 1, j)));\n      visited.insert(std::make_pair(i + 1, j));\n    }\n    if (j + 1 < nums2.size() && visited.find(std::make_pair(i, j + 1)) == visited.end()) {\n      pq.push(std::make_pair(nums1[i] * nums2[j + 1], std::make_pair(i, j + 1)));\n      visited.insert(std::make_pair(i, j + 1));\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n\tstd::vector<long> result;\n\tstd::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n\tstd::set<std::pair<int, int>> visited;\n\tpq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n\tvisited.insert(std::make_pair(0, 0));\n\tfor (long i = 0; i < N; i++) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back(p.first);\n\t\tint left = p.second.first, right = p.second.second;\n\t\tif (visited.find(std::make_pair(left + 1, right)) == visited.end()) {\n\t\t\tpq.push(std::make_pair(nums1[left + 1] * nums2[right], std::make_pair(left + 1, right)));\n\t\t\tvisited.insert(std::make_pair(left + 1, right));\n\t\t}\n\t\tif (visited.find(std::make_pair(left, right + 1)) == visited.end()) {\n\t\t\tpq.push(std::make_pair(nums1[left] * nums2[right + 1], std::make_pair(left, right + 1)));\n\t\t\tvisited.insert(std::make_pair(left, right + 1));\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmp1mnjbyp0: /tmp/tmp1mnjbyp0.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (pq.top() < product) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpv1_h9awz: /tmp/tmpv1_h9awz.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n        N--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmpr0_i2fq3: /tmp/tmpr0_i2fq3.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while(N-- > 0 && pq.size() > 0) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first, j = top.second.second;\n        if(i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if(j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmpiq7fd2i_: /tmp/tmpiq7fd2i_.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else if (pq.top() < product) {\n                pq.pop();\n                pq.push(product);\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmp2g7gtr57: /tmp/tmp2g7gtr57.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(auto i:nums1) {\n        for(auto j:nums2) {\n            pq.push(i*j);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while (N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n        if (s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmp5mmc9jm7: /tmp/tmp5mmc9jm7.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmpylqg7_kf: /tmp/tmpylqg7_kf.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    visited.insert({nums1.size() - 1, nums2.size() - 1});\n    for (int i = 0; i < N; i++) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int r = top.second.first, c = top.second.second;\n        if (r > 0 && visited.find({r - 1, c}) == visited.end()) {\n            pq.push({nums1[r - 1] * nums2[c], {r - 1, c}});\n            visited.insert({r - 1, c});\n        }\n        if (c > 0 && visited.find({r, c - 1}) == visited.end()) {\n            pq.push({nums1[r] * nums2[c - 1], {r, c - 1}});\n            visited.insert({r, c - 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::multiset<long> products;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            products.insert(i * j);\n        }\n    }\n    for (auto i = products.rbegin(); i != products.rend(); i++) {\n        if (N == 0) {\n            break;\n        }\n        result.push_back(*i);\n        N--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmppkiqqgak: /tmp/tmppkiqqgak.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        res.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long> products;\n    for(int i=0;i<nums1.size();i++){\n        for(int j=0;j<nums2.size();j++){\n            products.push_back(nums1[i]*nums2[j]);\n        }\n    }\n    std::sort(products.begin(),products.end());\n    for(int i=0;i<N;i++){\n        result.push_back(products[products.size()-i-1]);\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    visited.insert({nums1.size() - 1, nums2.size() - 1});\n    while(N--) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first;\n        int j = top.second.second;\n        if(i > 0 && visited.find({i - 1, j}) == visited.end()) {\n            pq.push({nums1[i - 1] * nums2[j], {i - 1, j}});\n            visited.insert({i - 1, j});\n        }\n        if(j > 0 && visited.find({i, j - 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j - 1], {i, j - 1}});\n            visited.insert({i, j - 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long> nums1_sorted = nums1;\n    std::vector<long> nums2_sorted = nums2;\n    std::sort(nums1_sorted.begin(), nums1_sorted.end());\n    std::sort(nums2_sorted.begin(), nums2_sorted.end());\n    std::vector<long>::iterator it1 = nums1_sorted.end() - 1;\n    std::vector<long>::iterator it2 = nums2_sorted.end() - 1;\n    while (N > 0) {\n        if (*it1 > *it2) {\n            result.push_back(*it1 * *it2);\n            it2--;\n        } else {\n            result.push_back(*it1 * *it2);\n            it1--;\n        }\n        N--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmpk0_aqgve: /tmp/tmpk0_aqgve.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i=0; i<nums1.size(); i++) {\n        for(int j=0; j<nums2.size(); j++) {\n            pq.push(nums1[i]*nums2[j]);\n        }\n    }\n    for(int i=0; i<N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i=0;i<nums1.size();i++) {\n        for(int j=0;j<nums2.size();j++) {\n            pq.push(nums1[i]*nums2[j]);\n        }\n    }\n    for(int i=0;i<N;i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first, j = top.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmpc2kd0s7i: /tmp/tmpc2kd0s7i.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first, j = top.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmp7o4db_lv: /tmp/tmp7o4db_lv.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && pq.size() > 0) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmpmg8l0gtp: /tmp/tmpmg8l0gtp.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push(i*j);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::multiset<long> ms;\n    for (int i = 0; i < nums1.size(); ++i) {\n        for (int j = 0; j < nums2.size(); ++j) {\n            ms.insert(nums1[i] * nums2[j]);\n        }\n    }\n    auto it = ms.end();\n    while (N--) {\n        res.push_back(*(--it));\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long> product;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            product.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(product.begin(), product.end());\n    for (int i = 0; i < N; i++) {\n        result.push_back(product[product.size() - 1 - i]);\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (pq.top() < product) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmpouvbi4gs: /tmp/tmpouvbi4gs.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmpemvczxxx: /tmp/tmpemvczxxx.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else if (product > pq.top()) {\n                pq.pop();\n                pq.push(product);\n            }\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmp85je8b6_: /tmp/tmp85je8b6_.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::unordered_set<int> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert(0 * nums2.size() + 0);\n    for (int i = 0; i < N; i++) {\n        auto idx_pair = pq.top().second; pq.pop();\n        res.push_back(nums1[idx_pair.first] * nums2[idx_pair.second]);\n        if (idx_pair.first + 1 < nums1.size() && visited.find((idx_pair.first + 1) * nums2.size() + idx_pair.second) == visited.end()) {\n            pq.push({nums1[idx_pair.first + 1] * nums2[idx_pair.second], {idx_pair.first + 1, idx_pair.second}});\n            visited.insert((idx_pair.first + 1) * nums2.size() + idx_pair.second);\n        }\n        if (idx_pair.second + 1 < nums2.size() && visited.find(idx_pair.first * nums2.size() + idx_pair.second + 1) == visited.end()) {\n            pq.push({nums1[idx_pair.first] * nums2[idx_pair.second + 1], {idx_pair.first, idx_pair.second + 1}});\n            visited.insert(idx_pair.first * nums2.size() + idx_pair.second + 1);\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && pq.size()) {\n        auto t = pq.top();\n        pq.pop();\n        res.push_back(t.first);\n        int i = t.second.first, j = t.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmp0yzhoxt8: /tmp/tmp0yzhoxt8.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    for (int i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (x + 1 < nums1.size() && visited.find({x + 1, y}) == visited.end()) {\n            pq.push({nums1[x + 1] * nums2[y], {x + 1, y}});\n            visited.insert({x + 1, y});\n        }\n        if (y + 1 < nums2.size() && visited.find({x, y + 1}) == visited.end()) {\n            pq.push({nums1[x] * nums2[y + 1], {x, y + 1}});\n            visited.insert({x, y + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmpradjqyq3: /tmp/tmpradjqyq3.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n            if(pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmp8t2ava_9: /tmp/tmp8t2ava_9.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n\tstd::vector<long> res;\n\tstd::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n\tstd::set<std::pair<int, int>> visited;\n\tpq.push({nums1[0] * nums2[0], {0, 0}});\n\tvisited.insert({0, 0});\n\twhile(N--) {\n\t\tauto curr = pq.top();\n\t\tpq.pop();\n\t\tres.push_back(curr.first);\n\t\tint i = curr.second.first, j = curr.second.second;\n\t\tif(i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n\t\t\tpq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n\t\t\tvisited.insert({i + 1, j});\n\t\t}\n\t\tif(j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n\t\t\tpq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n\t\t\tvisited.insert({i, j + 1});\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmp7lczgdi1: /tmp/tmp7lczgdi1.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n  std::vector<long> result;\n  std::multimap<long, std::pair<long, long>> products;\n  for (auto it1 = nums1.begin(); it1 != nums1.end(); it1++) {\n    for (auto it2 = nums2.begin(); it2 != nums2.end(); it2++) {\n      products.insert(std::make_pair(*it1 * *it2, std::make_pair(*it1, *it2)));\n    }\n  }\n  auto it = products.rbegin();\n  for (long i = 0; i < N; i++) {\n    result.push_back(it->second.first);\n    result.push_back(it->second.second);\n    it++;\n  }\n  return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmpf5vo2abm: /tmp/tmpf5vo2abm.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    s.insert({nums1.size() - 1, nums2.size() - 1});\n    while (N--) {\n        auto temp = pq.top();\n        pq.pop();\n        result.push_back(temp.first);\n        int i = temp.second.first;\n        int j = temp.second.second;\n        if (s.find({i - 1, j}) == s.end()) {\n            pq.push({nums1[i - 1] * nums2[j], {i - 1, j}});\n            s.insert({i - 1, j});\n        }\n        if (s.find({i, j - 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j - 1], {i, j - 1}});\n            s.insert({i, j - 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n  std::vector<long> result;\n  std::multiset<long> products;\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      products.insert(nums1[i] * nums2[j]);\n    }\n  }\n  for (long i = 0; i < N; i++) {\n    result.push_back(*products.rbegin());\n    products.erase(--products.end());\n  }\n  return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n\tstd::vector<long> result;\n\tstd::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n\tstd::set<std::pair<int, int>> s;\n\tstd::sort(nums1.begin(), nums1.end());\n\tstd::sort(nums2.begin(), nums2.end());\n\tpq.push({ nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1} });\n\ts.insert({ nums1.size() - 1, nums2.size() - 1 });\n\twhile (N--) {\n\t\tauto a = pq.top();\n\t\tpq.pop();\n\t\tresult.push_back(a.first);\n\t\tint i = a.second.first;\n\t\tint j = a.second.second;\n\t\tif (s.find({ i - 1, j }) == s.end()) {\n\t\t\tpq.push({ nums1[i - 1] * nums2[j], { i - 1, j } });\n\t\t\ts.insert({ i - 1, j });\n\t\t}\n\t\tif (s.find({ i, j - 1 }) == s.end()) {\n\t\t\tpq.push({ nums1[i] * nums2[j - 1], { i, j - 1 } });\n\t\t\ts.insert({ i, j - 1 });\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto n1 : nums1) {\n        for (auto n2 : nums2) {\n            pq.push(n1 * n2);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        res.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first, j = top.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmpqg1kd6_p: /tmp/tmpqg1kd6_p.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    std::unordered_set<std::string> visited;\n    visited.insert(\"0,0\");\n    for (int i = 0; i < N; i++) {\n        auto t = pq.top();\n        pq.pop();\n        res.push_back(t.first);\n        int n = t.second.first, m = t.second.second;\n        if (visited.find(std::to_string(n + 1) + \",\" + std::to_string(m)) == visited.end()) {\n            pq.push({nums1[n + 1] * nums2[m], {n + 1, m}});\n            visited.insert(std::to_string(n + 1) + \",\" + std::to_string(m));\n        }\n        if (visited.find(std::to_string(n) + \",\" + std::to_string(m + 1)) == visited.end()) {\n            pq.push({nums1[n] * nums2[m + 1], {n, m + 1}});\n            visited.insert(std::to_string(n) + \",\" + std::to_string(m + 1));\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    visited.insert({nums1.size() - 1, nums2.size() - 1});\n    for (int i = 0; i < N; i++) {\n        auto curr = pq.top();\n        pq.pop();\n        result.push_back(curr.first);\n        int x = curr.second.first;\n        int y = curr.second.second;\n        if (x > 0 && visited.find({x - 1, y}) == visited.end()) {\n            pq.push({nums1[x - 1] * nums2[y], {x - 1, y}});\n            visited.insert({x - 1, y});\n        }\n        if (y > 0 && visited.find({x, y - 1}) == visited.end()) {\n            pq.push({nums1[x] * nums2[y - 1], {x, y - 1}});\n            visited.insert({x, y - 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n  std::vector<long> result;\n  std::vector<long> products;\n  for (int i = 0; i < nums1.size(); i++) {\n    for (int j = 0; j < nums2.size(); j++) {\n      products.push_back(nums1[i] * nums2[j]);\n    }\n  }\n  std::sort(products.begin(), products.end());\n  for (int i = products.size() - 1; i >= products.size() - N; i--) {\n    result.push_back(products[i]);\n  }\n  return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i=0;i<nums1.size();i++) {\n        for(int j=0;j<nums2.size();j++) {\n            pq.push(nums1[i]*nums2[j]);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > s;\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    s.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        long curr = pq.top().first;\n        int x = pq.top().second.first;\n        int y = pq.top().second.second;\n        pq.pop();\n        result.push_back(curr);\n        if (x + 1 < nums1.size() && s.find(std::make_pair(x + 1, y)) == s.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            s.insert(std::make_pair(x + 1, y));\n        }\n        if (y + 1 < nums2.size() && s.find(std::make_pair(x, y + 1)) == s.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            s.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmp_kf0z9iq: /tmp/tmp_kf0z9iq.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(auto i:nums1) {\n        for(auto j:nums2) {\n            pq.push(i*j);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            min_heap.push(num1 * num2);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        res.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmpr1a6m5z1: /tmp/tmpr1a6m5z1.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push({nums1.back() * nums2.back(), {(int)nums1.size() - 1, (int)nums2.size() - 1}});\n    visited.insert({(int)nums1.size() - 1, (int)nums2.size() - 1});\n    for (int i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (x > 0 && visited.find({x - 1, y}) == visited.end()) {\n            pq.push({nums1[x - 1] * nums2[y], {x - 1, y}});\n            visited.insert({x - 1, y});\n        }\n        if (y > 0 && visited.find({x, y - 1}) == visited.end()) {\n            pq.push({nums1[x] * nums2[y - 1], {x, y - 1}});\n            visited.insert({x, y - 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto t = pq.top();\n        pq.pop();\n        res.push_back(t.first);\n        int i = t.second.first, j = t.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmpk3tbdfg7: /tmp/tmpk3tbdfg7.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            pq.push(num1 * num2);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmpsqf9s6il: /tmp/tmpsqf9s6il.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    std::unordered_set<long> set;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(std::make_pair(product, std::make_pair(i, j)));\n                set.insert(product);\n            } else {\n                if (product > pq.top().first) {\n                    long old_product = pq.top().first;\n                    pq.pop();\n                    pq.push(std::make_pair(product, std::make_pair(i, j)));\n                    set.erase(old_product);\n                    set.insert(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top().first);\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmphwubixpp: /tmp/tmphwubixpp.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long> nums1_copy = nums1;\n    std::vector<long> nums2_copy = nums2;\n    std::sort(nums1_copy.begin(), nums1_copy.end());\n    std::sort(nums2_copy.begin(), nums2_copy.end());\n    std::vector<long>::iterator it1 = nums1_copy.end() - 1;\n    std::vector<long>::iterator it2 = nums2_copy.end() - 1;\n    while (N--) {\n        if (*it1 > *it2) {\n            result.push_back(*it1);\n            it1--;\n        } else {\n            result.push_back(*it2);\n            it2--;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmpmojch_ve: /tmp/tmpmojch_ve.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        result.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long>::iterator it1 = nums1.begin();\n    std::vector<long>::iterator it2 = nums2.begin();\n    std::vector<long>::iterator it3 = nums1.begin();\n    std::vector<long>::iterator it4 = nums2.begin();\n    std::vector<long>::iterator it5 = nums1.begin();\n    std::vector<long>::iterator it6 = nums2.begin();\n    std::vector<long>::iterator it7 = nums1.begin();\n    std::vector<long>::iterator it8 = nums2.begin();\n    std::vector<long>::iterator it9 = nums1.begin();\n    std::vector<long>::iterator it10 = nums2.begin();\n    std::vector<long>::iterator it11 = nums1.begin();\n    std::vector<long>::iterator it12 = nums2.begin();\n    std::vector<long>::iterator it13 = nums1.begin();\n    std::vector<long>::iterator it14 = nums2.begin();\n    std::vector<long>::iterator it15 = nums1.begin();\n    std::vector<long>::iterator it16 = nums2.begin();\n    std::vector<long>::iterator it17 = nums1.begin();\n    std::vector<long>::iterator it18 = nums2.begin();\n    std::vector<long>::iterator it19 = nums1.begin();\n    std::vector<long>::iterator it20 = nums2.begin();\n    std::vector<long>::iterator it21 = nums1.begin();\n    std::vector<long>::iterator it22 = nums2.begin();\n    std::vector<long>::iterator it23 = nums1.begin();\n    std::vector<long>::iterator it24 = nums2.begin();\n    std::vector<long>::iterator it25 = nums1.begin();\n    std::vector<long>::iterator it26 = nums2.begin();\n    std::vector<long>\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122834,
      "stdout": "",
      "stderr": "/tmp/tmpmg24b99o.cpp: In function \u2018std::vector<long int> large_product(std::vector<long int>, std::vector<long int>, long int)\u2019:\n/tmp/tmpmg24b99o.cpp:33:1: error: expected unqualified-id before \u2018}\u2019 token\n   33 | }\n      | ^\n/tmp/tmpmg24b99o.cpp:33:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        res.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpx_32iu9m: /tmp/tmpx_32iu9m.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n  std::vector<long> result;\n  std::priority_queue<long> pq;\n  for (long i = 0; i < nums1.size(); i++) {\n    for (long j = 0; j < nums2.size(); j++) {\n      pq.push(nums1[i] * nums2[j]);\n    }\n  }\n  for (long i = 0; i < N; i++) {\n    result.push_back(pq.top());\n    pq.pop();\n  }\n  return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::multimap<long, std::pair<long, long>> map;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            map.insert(std::make_pair(i * j, std::make_pair(i, j)));\n        }\n    }\n    auto it = map.rbegin();\n    while (N--) {\n        result.push_back(it->first);\n        it++;\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    std::set<std::pair<int, int>> visited;\n    visited.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; ++i) {\n        auto a = pq.top();\n        pq.pop();\n        res.push_back(a.first);\n        int x = a.second.first, y = a.second.second;\n        if (visited.find(std::make_pair(x + 1, y)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            visited.insert(std::make_pair(x + 1, y));\n        }\n        if (visited.find(std::make_pair(x, y + 1)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            visited.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        result.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmp1krwo5nj: /tmp/tmp1krwo5nj.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto [product, pair] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = pair.first, j = pair.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpqq2tvn5x: /tmp/tmpqq2tvn5x.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmpbgzzzmhh: /tmp/tmpbgzzzmhh.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmppkiqqgak: /tmp/tmppkiqqgak.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > visited;\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    visited.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        long val = pq.top().first;\n        int x = pq.top().second.first;\n        int y = pq.top().second.second;\n        pq.pop();\n        result.push_back(val);\n        if (x + 1 < nums1.size() && visited.find(std::make_pair(x + 1, y)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            visited.insert(std::make_pair(x + 1, y));\n        }\n        if (y + 1 < nums2.size() && visited.find(std::make_pair(x, y + 1)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            visited.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmpoqvw27ic: /tmp/tmpoqvw27ic.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    visited.insert(std::make_pair(0, 0));\n    for (long i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (x + 1 < nums1.size() && visited.find(std::make_pair(x + 1, y)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            visited.insert(std::make_pair(x + 1, y));\n        }\n        if (y + 1 < nums2.size() && visited.find(std::make_pair(x, y + 1)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            visited.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::multimap<long, std::pair<long, long>> products;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            products.insert(std::make_pair(num1 * num2, std::make_pair(num1, num2)));\n        }\n    }\n    auto it = products.rbegin();\n    while (N--) {\n        result.push_back(it->first);\n        it++;\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto n1 : nums1) {\n        for (auto n2 : nums2) {\n            pq.push(n1 * n2);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto t = pq.top();\n        pq.pop();\n        res.push_back(t.first);\n        int i = t.second.first, j = t.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmpk3tbdfg7: /tmp/tmpk3tbdfg7.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while (N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n        if (s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmp2xm8q8pj: /tmp/tmp2xm8q8pj.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmpqg1kd6_p: /tmp/tmpqg1kd6_p.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n\tstd::vector<long> res;\n\tstd::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n\tstd::set<std::pair<int, int>> s;\n\tpq.push({ nums1[0] * nums2[0], {0, 0} });\n\ts.insert({ 0, 0 });\n\tfor (int i = 0; i < N; i++) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tres.push_back(p.first);\n\t\tint x = p.second.first, y = p.second.second;\n\t\tif (s.find({ x + 1, y }) == s.end()) {\n\t\t\tpq.push({ nums1[x + 1] * nums2[y], { x + 1, y } });\n\t\t\ts.insert({ x + 1, y });\n\t\t}\n\t\tif (s.find({ x, y + 1 }) == s.end()) {\n\t\t\tpq.push({ nums1[x] * nums2[y + 1], { x, y + 1 } });\n\t\t\ts.insert({ x, y + 1 });\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmpm6ii4vyc: /tmp/tmpm6ii4vyc.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::unordered_set<int> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert(0 * nums2.size() + 0);\n    for (int i = 0; i < N; ++i) {\n        auto a = pq.top();\n        pq.pop();\n        res.push_back(a.first);\n        int x = a.second.first, y = a.second.second;\n        if (x + 1 < nums1.size() && visited.find((x + 1) * nums2.size() + y) == visited.end()) {\n            pq.push({nums1[x + 1] * nums2[y], {x + 1, y}});\n            visited.insert((x + 1) * nums2.size() + y);\n        }\n        if (y + 1 < nums2.size() && visited.find(x * nums2.size() + y + 1) == visited.end()) {\n            pq.push({nums1[x] * nums2[y + 1], {x, y + 1}});\n            visited.insert(x * nums2.size() + y + 1);\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmp1swpechz: /tmp/tmp1swpechz.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (pq.top() < product) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmpouvbi4gs: /tmp/tmpouvbi4gs.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long> products;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            products.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(products.begin(), products.end());\n    for (int i = products.size() - 1; i >= products.size() - N; i--) {\n        result.push_back(products[i]);\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long>::iterator it1, it2;\n    std::vector<long>::iterator it1_end = nums1.end();\n    std::vector<long>::iterator it2_end = nums2.end();\n    std::vector<long>::iterator it1_begin = nums1.begin();\n    std::vector<long>::iterator it2_begin = nums2.begin();\n    long product;\n    for(long i = 0; i < N; i++) {\n        product = 0;\n        for(it1 = it1_begin; it1 != it1_end; it1++) {\n            for(it2 = it2_begin; it2 != it2_end; it2++) {\n                if(*it1 * *it2 > product) {\n                    product = *it1 * *it2;\n                }\n            }\n        }\n        result.push_back(product);\n        it1_end--;\n        it2_end--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmpym56hxxv: /tmp/tmpym56hxxv.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            long prod = i * j;\n            if (pq.size() < N) {\n                pq.push(prod);\n            } else {\n                if (prod > pq.top()) {\n                    pq.pop();\n                    pq.push(prod);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmpgqvh5x02: /tmp/tmpgqvh5x02.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(auto i:nums1) {\n        for(auto j:nums2) {\n            pq.push(i*j);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmpbgzzzmhh: /tmp/tmpbgzzzmhh.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    for (int i = 0; i < N; i++) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int x = top.second.first, y = top.second.second;\n        if (x + 1 < nums1.size() && visited.find({x + 1, y}) == visited.end()) {\n            pq.push({nums1[x + 1] * nums2[y], {x + 1, y}});\n            visited.insert({x + 1, y});\n        }\n        if (y + 1 < nums2.size() && visited.find({x, y + 1}) == visited.end()) {\n            pq.push({nums1[x] * nums2[y + 1], {x, y + 1}});\n            visited.insert({x, y + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmpjzcc9ujb: /tmp/tmpjzcc9ujb.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::vector<long>::iterator it1 = nums1.begin();\n    std::vector<long>::iterator it2 = nums2.begin();\n    while(N--) {\n        if(*it1 < *it2) {\n            result.push_back(*it1 * *(nums2.end() - 1));\n            it1++;\n        }\n        else {\n            result.push_back(*it2 * *(nums1.end() - 1));\n            it2++;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmpk99cmfky: /tmp/tmpk99cmfky.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (min_heap.size() < N) {\n                min_heap.push(product);\n            } else {\n                if (product > min_heap.top()) {\n                    min_heap.pop();\n                    min_heap.push(product);\n                }\n            }\n        }\n    }\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122836,
      "stdout": "",
      "stderr": "tmpzdm32ej5: /tmp/tmpzdm32ej5.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first, j = top.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmp7o4db_lv: /tmp/tmp7o4db_lv.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmppkiqqgak: /tmp/tmppkiqqgak.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmpbgzzzmhh: /tmp/tmpbgzzzmhh.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long> products;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            products.push_back(i * j);\n        }\n    }\n    std::sort(products.begin(), products.end());\n    for (int i = products.size() - 1; i >= products.size() - N; i--) {\n        result.push_back(products[i]);\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long> product;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            product.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(product.begin(), product.end());\n    for(int i = product.size() - 1; i > product.size() - N - 1; i--) {\n        result.push_back(product[i]);\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    visited.insert({nums1.size() - 1, nums2.size() - 1});\n    for (long i = 0; i < N; i++) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int x = top.second.first, y = top.second.second;\n        if (x - 1 >= 0 && visited.find({x - 1, y}) == visited.end()) {\n            pq.push({nums1[x - 1] * nums2[y], {x - 1, y}});\n            visited.insert({x - 1, y});\n        }\n        if (y - 1 >= 0 && visited.find({x, y - 1}) == visited.end()) {\n            pq.push({nums1[x] * nums2[y - 1], {x, y - 1}});\n            visited.insert({x, y - 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long> nums1_copy = nums1;\n    std::vector<long> nums2_copy = nums2;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::vector<long>::iterator it1 = nums1.end() - 1;\n    std::vector<long>::iterator it2 = nums2.end() - 1;\n    while (N > 0) {\n        long product = (*it1) * (*it2);\n        result.push_back(product);\n        if (it1 != nums1.begin()) {\n            it1--;\n        } else {\n            it2--;\n        }\n        N--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "tmpbg6tf4f2: /tmp/tmpbg6tf4f2.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::multimap<long, std::pair<long, long>> map;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            map.insert(std::make_pair(nums1[i] * nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    auto it = map.end();\n    for(int i = 0; i < N; i++) {\n        it--;\n        result.push_back(it->first);\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > s;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push(std::make_pair(nums1[nums1.size() - 1] * nums2[nums2.size() - 1], std::make_pair(nums1.size() - 1, nums2.size() - 1)));\n    s.insert(std::make_pair(nums1.size() - 1, nums2.size() - 1));\n    for (int i = 0; i < N; i++) {\n        long product = pq.top().first;\n        int index1 = pq.top().second.first;\n        int index2 = pq.top().second.second;\n        pq.pop();\n        result.push_back(product);\n        if (index1 - 1 >= 0 && s.find(std::make_pair(index1 - 1, index2)) == s.end()) {\n            pq.push(std::make_pair(nums1[index1 - 1] * nums2[index2], std::make_pair(index1 - 1, index2)));\n            s.insert(std::make_pair(index1 - 1, index2));\n        }\n        if (index2 - 1 >= 0 && s.find(std::make_pair(index1, index2 - 1)) == s.end()) {\n            pq.push(std::make_pair(nums1[index1] * nums2[index2 - 1], std::make_pair(index1, index2 - 1)));\n            s.insert(std::make_pair(index1, index2 - 1));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > visited;\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    visited.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (x + 1 < nums1.size() && visited.find(std::make_pair(x + 1, y)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            visited.insert(std::make_pair(x + 1, y));\n        }\n        if (y + 1 < nums2.size() && visited.find(std::make_pair(x, y + 1)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            visited.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "tmpich4nkvw: /tmp/tmpich4nkvw.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::multimap<long, std::pair<long, long>> products;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            products.insert(std::make_pair(i * j, std::make_pair(i, j)));\n        }\n    }\n    auto it = products.rbegin();\n    while (N--) {\n        result.push_back(it->first);\n        it++;\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, pair] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = pair.first, j = pair.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "tmpuc77z74d: /tmp/tmpuc77z74d.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    int m = nums1.size(), n = nums2.size();\n    std::vector<std::vector<bool>> visited(m, std::vector<bool>(n, false));\n    pq.push({nums1[m - 1] * nums2[n - 1], {m - 1, n - 1}});\n    visited[m - 1][n - 1] = true;\n    while (N-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i > 0 && !visited[i - 1][j]) {\n            pq.push({nums1[i - 1] * nums2[j], {i - 1, j}});\n            visited[i - 1][j] = true;\n        }\n        if (j > 0 && !visited[i][j - 1]) {\n            pq.push({nums1[i] * nums2[j - 1], {i, j - 1}});\n            visited[i][j - 1] = true;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while (N--) {\n        auto [product, pair] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = pair.first, j = pair.second;\n        if (i + 1 < nums1.size() && s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "tmpg80sgjnr: /tmp/tmpg80sgjnr.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n            if (pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpygg_7t1d: /tmp/tmpygg_7t1d.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n  std::vector<long> result;\n  std::priority_queue<long> pq;\n  for (auto i : nums1) {\n    for (auto j : nums2) {\n      pq.push(i * j);\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    result.push_back(pq.top());\n    pq.pop();\n  }\n  return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int i = top.second.first, j = top.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmp7o4db_lv: /tmp/tmp7o4db_lv.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::multimap<long, std::pair<long, long>> map;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            map.insert(std::make_pair(nums1[i] * nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    for (auto it = map.rbegin(); it != map.rend(); it++) {\n        result.push_back(it->first);\n        if (result.size() == N) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (long i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long> > pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "tmpovq3hjvh: /tmp/tmpovq3hjvh.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    std::reverse(nums1.begin(), nums1.end());\n    std::reverse(nums2.begin(), nums2.end());\n    for (long i = 0; i < N; i++) {\n        result.push_back(nums1[i] * nums2[i]);\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "tmp6liwudar: /tmp/tmp6liwudar.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i=0;i<nums1.size();i++){\n        for(int j=0;j<nums2.size();j++){\n            pq.push(nums1[i]*nums2[j]);\n        }\n    }\n    for(int i=0;i<N;i++){\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while(N-- > 0 && !pq.empty()) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if(i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if(j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::unordered_set<int> visited;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(std::make_pair(nums1[i] * nums2[j], std::make_pair(i, j)));\n        }\n    }\n    while (N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        if (visited.find(p.second.first) == visited.end()) {\n            visited.insert(p.second.first);\n            for (int j = 0; j < nums2.size(); j++) {\n                pq.push(std::make_pair(nums1[p.second.first] * nums2[j], std::make_pair(p.second.first, j)));\n            }\n        }\n        if (visited.find(p.second.second) == visited.end()) {\n            visited.insert(p.second.second);\n            for (int i = 0; i < nums1.size(); i++) {\n                pq.push(std::make_pair(nums1[i] * nums2[p.second.second], std::make_pair(i, p.second.second)));\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "tmp83a1nqoc: /tmp/tmp83a1nqoc.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto a = pq.top();\n        pq.pop();\n        result.push_back(a.first);\n        int i = a.second.first, j = a.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpqzf64gws: /tmp/tmpqzf64gws.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    std::set<std::pair<long, long>> s;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while (N--) {\n        auto [product, [i, j]] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        if (i + 1 < nums1.size() && s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122838,
      "stdout": "",
      "stderr": "/tmp/tmpy124a0zs.cpp: In function \u2018std::vector<long int> large_product(std::vector<long int>, std::vector<long int>, long int)\u2019:\n/tmp/tmpy124a0zs.cpp:13:24: error: expected identifier before \u2018[\u2019 token\n   13 |         auto [product, [i, j]] = pq.top();\n      |                        ^\n/tmp/tmpy124a0zs.cpp:13:23: error: expected \u2018]\u2019 before \u2018[\u2019 token\n   13 |         auto [product, [i, j]] = pq.top();\n      |                       ^~\n      |                       ]\n/tmp/tmpy124a0zs.cpp:13:14: error: only 1 name provided for structured binding\n   13 |         auto [product, [i, j]] = pq.top();\n      |              ^\n/tmp/tmpy124a0zs.cpp:13:14: note: while \u2018std::pair<long int, std::pair<long int, long int> >\u2019 decomposes into 2 elements\n/tmp/tmpy124a0zs.cpp:16:13: error: \u2018i\u2019 was not declared in this scope\n   16 |         if (i + 1 < nums1.size() && s.find({i + 1, j}) == s.end()) {\n      |             ^\n/tmp/tmpy124a0zs.cpp:16:52: error: \u2018j\u2019 was not declared in this scope\n   16 |         if (i + 1 < nums1.size() && s.find({i + 1, j}) == s.end()) {\n      |                                                    ^\n/tmp/tmpy124a0zs.cpp:16:54: error: no matching function for call to \u2018std::set<std::pair<long int, long int> >::find(<brace-enclosed initializer list>)\u2019\n   16 |         if (i + 1 < nums1.size() && s.find({i + 1, j}) == s.end()) {\n      |                                                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/set:61,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:87,\n                 from /tmp/tmpy124a0zs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_set.h:794:7: note: candidate: \u2018std::set<_Key, _Compare, _Alloc>::iterator std::set<_Key, _Compare, _Alloc>::find(const key_type&) [with _Key = std::pair<long int, long int>; _Compare = std::less<std::pair<long int, long int> >; _Alloc = std::allocator<std::pair<long int, long int> >; std::set<_Key, _Com",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::multimap<long, std::pair<int, int>> map;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            map.insert(std::pair<long, std::pair<int, int>>(nums1[i] * nums2[j], std::pair<int, int>(i, j)));\n        }\n    }\n    auto it = map.rbegin();\n    while (it != map.rend() && N > 0) {\n        result.push_back(it->first);\n        it++;\n        N--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto [product, idx] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = idx.first, j = idx.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "tmpxcmn472_: /tmp/tmpxcmn472_.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            if (pq.size() < N) {\n                pq.push(nums1[i] * nums2[j]);\n            } else {\n                if (nums1[i] * nums2[j] > pq.top()) {\n                    pq.pop();\n                    pq.push(nums1[i] * nums2[j]);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "tmpox6nhv3g: /tmp/tmpox6nhv3g.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (product > pq.top()) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "tmp1wozt8lz: /tmp/tmp1wozt8lz.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "tmp0trn6vqg: /tmp/tmp0trn6vqg.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while(N--) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while (N--) {\n        auto [product, idx] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = idx.first, j = idx.second;\n        if (i + 1 < nums1.size() && s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "tmpdt1l1k2r: /tmp/tmpdt1l1k2r.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            long product = num1 * num2;\n            if (min_heap.size() < N) {\n                min_heap.push(product);\n            } else if (product > min_heap.top()) {\n                min_heap.pop();\n                min_heap.push(product);\n            }\n        }\n    }\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "tmph6ejz_oi: /tmp/tmph6ejz_oi.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> q;\n    std::set<std::pair<int, int>> s;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    q.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    s.insert({nums1.size() - 1, nums2.size() - 1});\n    while (N--) {\n        auto temp = q.top();\n        q.pop();\n        result.push_back(temp.first);\n        int i = temp.second.first;\n        int j = temp.second.second;\n        if (s.find({i - 1, j}) == s.end()) {\n            q.push({nums1[i - 1] * nums2[j], {i - 1, j}});\n            s.insert({i - 1, j});\n        }\n        if (s.find({i, j - 1}) == s.end()) {\n            q.push({nums1[i] * nums2[j - 1], {i, j - 1}});\n            s.insert({i, j - 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    while (N--) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i=0;i<nums1.size();i++)\n    {\n        for(int j=0;j<nums2.size();j++)\n        {\n            pq.push(nums1[i]*nums2[j]);\n            if(pq.size()>N)\n                pq.pop();\n        }\n    }\n    while(!pq.empty())\n    {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(result.begin(),result.end());\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "tmptogitqj0: /tmp/tmptogitqj0.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n    pq.push({nums1[nums1.size() - 1] * nums2[nums2.size() - 1], {nums1.size() - 1, nums2.size() - 1}});\n    visited.insert({nums1.size() - 1, nums2.size() - 1});\n    while (N--) {\n        auto [product, pair] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = pair.first, j = pair.second;\n        if (i > 0 && visited.find({i - 1, j}) == visited.end()) {\n            pq.push({nums1[i - 1] * nums2[j], {i - 1, j}});\n            visited.insert({i - 1, j});\n        }\n        if (j > 0 && visited.find({i, j - 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j - 1], {i, j - 1}});\n            visited.insert({i, j - 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push(i*j);\n            if(pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while(!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "tmp_58ypb0i: /tmp/tmp_58ypb0i.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > s;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    s.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        std::pair<long, std::pair<int, int> > curr = pq.top();\n        pq.pop();\n        result.push_back(curr.first);\n        int x = curr.second.first;\n        int y = curr.second.second;\n        if (s.find(std::make_pair(x + 1, y)) == s.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            s.insert(std::make_pair(x + 1, y));\n        }\n        if (s.find(std::make_pair(x, y + 1)) == s.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            s.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n\tstd::vector<long> result;\n\tstd::sort(nums1.begin(), nums1.end());\n\tstd::sort(nums2.begin(), nums2.end());\n\tlong i = 0, j = 0;\n\twhile (N--) {\n\t\tif (nums1[i] > nums2[j]) {\n\t\t\tresult.push_back(nums1[i] * nums2[j]);\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\tresult.push_back(nums1[i] * nums2[j]);\n\t\t\tj++;\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "tmpn0jz6rma: /tmp/tmpn0jz6rma.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    for (long i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmppkiqqgak: /tmp/tmppkiqqgak.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long> products;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            products.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(products.begin(), products.end());\n    for (long i = products.size() - 1; i >= products.size() - N; i--) {\n        result.push_back(products[i]);\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > s;\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    s.insert(std::make_pair(0, 0));\n    while (N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (i + 1 < nums1.size() && s.find(std::make_pair(i + 1, j)) == s.end()) {\n            pq.push(std::make_pair(nums1[i + 1] * nums2[j], std::make_pair(i + 1, j)));\n            s.insert(std::make_pair(i + 1, j));\n        }\n        if (j + 1 < nums2.size() && s.find(std::make_pair(i, j + 1)) == s.end()) {\n            pq.push(std::make_pair(nums1[i] * nums2[j + 1], std::make_pair(i, j + 1)));\n            s.insert(std::make_pair(i, j + 1));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "tmpycgpx0ld: /tmp/tmpycgpx0ld.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> ans;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while(N--) {\n        auto [product, idx] = pq.top();\n        pq.pop();\n        ans.push_back(product);\n        int i = idx.first, j = idx.second;\n        if(i + 1 < nums1.size() && s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n        if(j + 1 < nums2.size() && s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long> products;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            products.push_back(nums1[i] * nums2[j]);\n        }\n    }\n    std::sort(products.begin(), products.end());\n    for (long i = products.size() - 1; i >= products.size() - N; i--) {\n        result.push_back(products[i]);\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    std::set<std::pair<int, int>> visited;\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        res.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (long i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::unordered_set<int> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert(0 * nums2.size() + 0);\n    for (int i = 0; i < N; ++i) {\n        auto a = pq.top(); pq.pop();\n        res.push_back(a.first);\n        int x = a.second.first, y = a.second.second;\n        if (x + 1 < nums1.size() && visited.find((x + 1) * nums2.size() + y) == visited.end()) {\n            pq.push({nums1[x + 1] * nums2[y], {x + 1, y}});\n            visited.insert((x + 1) * nums2.size() + y);\n        }\n        if (y + 1 < nums2.size() && visited.find(x * nums2.size() + y + 1) == visited.end()) {\n            pq.push({nums1[x] * nums2[y + 1], {x, y + 1}});\n            visited.insert(x * nums2.size() + y + 1);\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122840,
      "stdout": "",
      "stderr": "tmpaptpcojo: /tmp/tmpaptpcojo.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto n1 : nums1) {\n        for (auto n2 : nums2) {\n            pq.push(n1 * n2);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(auto i:nums1) {\n        for(auto j:nums2) {\n            pq.push(i*j);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (auto i : nums1) {\n        for (auto j : nums2) {\n            pq.push(i * j);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> min_heap;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            long product = num1 * num2;\n            if (min_heap.size() < N) {\n                min_heap.push(product);\n            } else {\n                if (product > min_heap.top()) {\n                    min_heap.pop();\n                    min_heap.push(product);\n                }\n            }\n        }\n    }\n    while (!min_heap.empty()) {\n        result.push_back(min_heap.top());\n        min_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122840,
      "stdout": "",
      "stderr": "tmp58i8vuij: /tmp/tmp58i8vuij.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else if (pq.top() < product) {\n                pq.pop();\n                pq.push(product);\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "tmpbrv2hn1c: /tmp/tmpbrv2hn1c.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    for (int i = 0; i < N; i++) {\n        auto top = pq.top();\n        pq.pop();\n        result.push_back(top.first);\n        int row = top.second.first, col = top.second.second;\n        if (row + 1 < nums1.size() && visited.find({row + 1, col}) == visited.end()) {\n            pq.push({nums1[row + 1] * nums2[col], {row + 1, col}});\n            visited.insert({row + 1, col});\n        }\n        if (col + 1 < nums2.size() && visited.find({row, col + 1}) == visited.end()) {\n            pq.push({nums1[row] * nums2[col + 1], {row, col + 1}});\n            visited.insert({row, col + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "tmpuy69czum: /tmp/tmpuy69czum.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while (N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto [product, idx] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = idx.first, j = idx.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "tmpthvorw2q: /tmp/tmpthvorw2q.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    for (int i = 0; i < N; i++) {\n        auto [product, idx] = pq.top(); pq.pop();\n        result.push_back(product);\n        int i = idx.first, j = idx.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "/tmp/tmp04fdre1a.cpp: In function \u2018std::vector<long int> large_product(std::vector<long int>, std::vector<long int>, long int)\u2019:\n/tmp/tmp04fdre1a.cpp:15:13: error: redeclaration of \u2018int i\u2019\n   15 |         int i = idx.first, j = idx.second;\n      |             ^\n/tmp/tmp04fdre1a.cpp:12:14: note: \u2018int i\u2019 previously declared here\n   12 |     for (int i = 0; i < N; i++) {\n      |              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    visited.insert(std::make_pair(0, 0));\n    for (long i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first;\n        int y = p.second.second;\n        if (x + 1 < nums1.size() && visited.find(std::make_pair(x + 1, y)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            visited.insert(std::make_pair(x + 1, y));\n        }\n        if (y + 1 < nums2.size() && visited.find(std::make_pair(x, y + 1)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            visited.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long>::iterator it1, it2;\n    std::vector<long>::iterator it1_end = nums1.end();\n    std::vector<long>::iterator it2_end = nums2.end();\n    for (it1 = nums1.begin(); it1 != it1_end; ++it1) {\n        for (it2 = nums2.begin(); it2 != it2_end; ++it2) {\n            result.push_back(*it1 * *it2);\n        }\n    }\n    std::sort(result.begin(), result.end(), std::greater<long>());\n    result.resize(N);\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> s;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    s.insert({0, 0});\n    while (N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if (s.find({i, j + 1}) == s.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            s.insert({i, j + 1});\n        }\n        if (s.find({i + 1, j}) == s.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            s.insert({i + 1, j});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmp2xm8q8pj: /tmp/tmp2xm8q8pj.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1665509972,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            pq.push(i * j);\n            if(pq.size() > N) {\n                pq.pop();\n            }\n        }\n    }\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "tmpchcdh23s: /tmp/tmpchcdh23s.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && !pq.empty()) {\n        auto cur = pq.top();\n        pq.pop();\n        result.push_back(cur.first);\n        int i = cur.second.first, j = cur.second.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122835,
      "stdout": "",
      "stderr": "tmp1krwo5nj: /tmp/tmp1krwo5nj.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    visited.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (x + 1 < nums1.size() && visited.find(std::make_pair(x + 1, y)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            visited.insert(std::make_pair(x + 1, y));\n        }\n        if (y + 1 < nums2.size() && visited.find(std::make_pair(x, y + 1)) == visited.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            visited.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "tmpbqrr1cwd: /tmp/tmpbqrr1cwd.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::multimap<long, std::pair<long, long>> m;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            m.insert(std::make_pair(nums1[i] * nums2[j], std::make_pair(nums1[i], nums2[j])));\n        }\n    }\n    for (auto it = m.rbegin(); it != m.rend(); it++) {\n        if (N == 0) {\n            break;\n        }\n        result.push_back(it->first);\n        N--;\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    for (long i = 0; i < N; i++) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int> > > pq;\n    std::set<std::pair<int, int> > s;\n    pq.push(std::make_pair(nums1[0] * nums2[0], std::make_pair(0, 0)));\n    s.insert(std::make_pair(0, 0));\n    for (int i = 0; i < N; i++) {\n        std::pair<long, std::pair<int, int> > p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int x = p.second.first, y = p.second.second;\n        if (s.find(std::make_pair(x + 1, y)) == s.end()) {\n            pq.push(std::make_pair(nums1[x + 1] * nums2[y], std::make_pair(x + 1, y)));\n            s.insert(std::make_pair(x + 1, y));\n        }\n        if (s.find(std::make_pair(x, y + 1)) == s.end()) {\n            pq.push(std::make_pair(nums1[x] * nums2[y + 1], std::make_pair(x, y + 1)));\n            s.insert(std::make_pair(x, y + 1));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "tmp_38drggf: /tmp/tmp_38drggf.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while(N--) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122837,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<long> pq;\n    std::unordered_set<long> s;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n                s.insert(product);\n            } else {\n                if (product > pq.top() && s.find(product) == s.end()) {\n                    pq.pop();\n                    pq.push(product);\n                    s.insert(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "tmp20y7vbty: /tmp/tmp20y7vbty.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> max_heap;\n    for (auto num1 : nums1) {\n        for (auto num2 : nums2) {\n            max_heap.push(num1 * num2);\n            if (max_heap.size() > N)\n                max_heap.pop();\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "tmp2l8coult: /tmp/tmp2l8coult.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<long> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            pq.push(nums1[i] * nums2[j]);\n        }\n    }\n    while(N--) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122839,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N--) {\n        auto [product, indices] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = indices.first, j = indices.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122831,
      "stdout": "",
      "stderr": "tmpylqg7_kf: /tmp/tmpylqg7_kf.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while(N--) {\n        auto p = pq.top();\n        pq.pop();\n        result.push_back(p.first);\n        int i = p.second.first, j = p.second.second;\n        if(i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if(j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::vector<long> products;\n    for(auto i : nums1) {\n        for(auto j : nums2) {\n            products.push_back(i*j);\n        }\n    }\n    std::sort(products.begin(), products.end());\n    for(long i = products.size()-1; i >= products.size()-N; i--) {\n        result.push_back(products[i]);\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> max_heap;\n    std::unordered_set<std::pair<int, int>, pair_hash> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    max_heap.emplace(nums1[0] * nums2[0], std::make_pair(0, 0));\n    visited.emplace(0, 0);\n    for (int i = 0; i < N; ++i) {\n        long number = max_heap.top().first;\n        int row = max_heap.top().second.first, col = max_heap.top().second.second;\n        max_heap.pop();\n        result.emplace_back(number);\n        if (row + 1 < nums1.size() && visited.count(std::make_pair(row + 1, col)) == 0) {\n            max_heap.emplace(nums1[row + 1] * nums2[col], std::make_pair(row + 1, col));\n            visited.emplace(row + 1, col);\n        }\n        if (col + 1 < nums2.size() && visited.count(std::make_pair(row, col + 1)) == 0) {\n            max_heap.emplace(nums1[row] * nums2[col + 1], std::make_pair(row, col + 1));\n            visited.emplace(row, col + 1);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "/tmp/tmpi4y6z836.cpp: In function \u2018std::vector<long int> large_product(std::vector<long int>, std::vector<long int>, long int)\u2019:\n/tmp/tmpi4y6z836.cpp:7:45: error: \u2018pair_hash\u2019 was not declared in this scope\n    7 |     std::unordered_set<std::pair<int, int>, pair_hash> visited;\n      |                                             ^~~~~~~~~\n/tmp/tmpi4y6z836.cpp:7:54: error: template argument 2 is invalid\n    7 |     std::unordered_set<std::pair<int, int>, pair_hash> visited;\n      |                                                      ^\n/tmp/tmpi4y6z836.cpp:11:13: error: request for member \u2018emplace\u2019 in \u2018visited\u2019, which is of non-class type \u2018int\u2019\n   11 |     visited.emplace(0, 0);\n      |             ^~~~~~~\n/tmp/tmpi4y6z836.cpp:17:47: error: request for member \u2018count\u2019 in \u2018visited\u2019, which is of non-class type \u2018int\u2019\n   17 |         if (row + 1 < nums1.size() && visited.count(std::make_pair(row + 1, col)) == 0) {\n      |                                               ^~~~~\n/tmp/tmpi4y6z836.cpp:19:21: error: request for member \u2018emplace\u2019 in \u2018visited\u2019, which is of non-class type \u2018int\u2019\n   19 |             visited.emplace(row + 1, col);\n      |                     ^~~~~~~\n/tmp/tmpi4y6z836.cpp:21:47: error: request for member \u2018count\u2019 in \u2018visited\u2019, which is of non-class type \u2018int\u2019\n   21 |         if (col + 1 < nums2.size() && visited.count(std::make_pair(row, col + 1)) == 0) {\n      |                                               ^~~~~\n/tmp/tmpi4y6z836.cpp:23:21: error: request for member \u2018emplace\u2019 in \u2018visited\u2019, which is of non-class type \u2018int\u2019\n   23 |             visited.emplace(row, col + 1);\n      |                     ^~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    std::unordered_set<long> set;\n    for (long i = 0; i < nums1.size(); i++) {\n        for (long j = 0; j < nums2.size(); j++) {\n            if (set.find(i * nums2.size() + j) == set.end()) {\n                pq.push({nums1[i] * nums2[j], {i, j}});\n                set.insert(i * nums2.size() + j);\n            }\n        }\n    }\n    for (long i = 0; i < N; i++) {\n        result.push_back(pq.top().first);\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::set<std::pair<int, int>> visited;\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert({0, 0});\n    while (N-- > 0 && pq.size()) {\n        auto [product, pair] = pq.top();\n        pq.pop();\n        result.push_back(product);\n        int i = pair.first, j = pair.second;\n        if (i + 1 < nums1.size() && visited.find({i + 1, j}) == visited.end()) {\n            pq.push({nums1[i + 1] * nums2[j], {i + 1, j}});\n            visited.insert({i + 1, j});\n        }\n        if (j + 1 < nums2.size() && visited.find({i, j + 1}) == visited.end()) {\n            pq.push({nums1[i] * nums2[j + 1], {i, j + 1}});\n            visited.insert({i, j + 1});\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "tmpnkk1p453: /tmp/tmpnkk1p453.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> res;\n    std::priority_queue<std::pair<long, std::pair<int, int>>> pq;\n    std::unordered_set<int> visited;\n    std::sort(nums1.begin(), nums1.end(), std::greater<long>());\n    std::sort(nums2.begin(), nums2.end(), std::greater<long>());\n    pq.push({nums1[0] * nums2[0], {0, 0}});\n    visited.insert(0 * nums2.size() + 0);\n    for (int i = 0; i < N; i++) {\n        auto idx_pair = pq.top().second;\n        pq.pop();\n        res.push_back(nums1[idx_pair.first] * nums2[idx_pair.second]);\n        if (idx_pair.first + 1 < nums1.size() && visited.find((idx_pair.first + 1) * nums2.size() + idx_pair.second) == visited.end()) {\n            pq.push({nums1[idx_pair.first + 1] * nums2[idx_pair.second], {idx_pair.first + 1, idx_pair.second}});\n            visited.insert((idx_pair.first + 1) * nums2.size() + idx_pair.second);\n        }\n        if (idx_pair.second + 1 < nums2.size() && visited.find(idx_pair.first * nums2.size() + idx_pair.second + 1) == visited.end()) {\n            pq.push({nums1[idx_pair.first] * nums2[idx_pair.second + 1], {idx_pair.first, idx_pair.second + 1}});\n            visited.insert(idx_pair.first * nums2.size() + idx_pair.second + 1);\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the specified number of largest products from two given vectors, selecting one factor from each vector.\nstd::vector<long> large_product(std::vector<long> nums1, std::vector<long> nums2, long N) {\n    std::vector<long> result;\n    std::priority_queue<long> pq;\n    for (int i = 0; i < nums1.size(); i++) {\n        for (int j = 0; j < nums2.size(); j++) {\n            long product = nums1[i] * nums2[j];\n            if (pq.size() < N) {\n                pq.push(product);\n            } else {\n                if (pq.top() < product) {\n                    pq.pop();\n                    pq.push(product);\n                }\n            }\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = large_product;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (4)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (5)) == (std::vector<long>({(long)60, (long)54, (long)50, (long)48, (long)45})));\n}\n",
      "timestamp": 1666122833,
      "stdout": "",
      "stderr": "tmpouvbi4gs: /tmp/tmpouvbi4gs.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})), (std::vector<long>({(long)3, (long)6, (long)8, (long)9, (long)10, (long)6})), (3)) == (std::vector<long>({(long)60, (long)54, (long)50}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    }
  ]
}