{
  "name": "mbpp_262_split_two_parts",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes in a vector and an integer L and splits the given vector into two parts where the length of the first part of the vector is L, and returns the resulting vectors in a tuple.\nstd::any split_two_parts(std::any list1, long L) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_262_split_two_parts.py",
  "prompt_terminology": "reworded",
  "tests": "}\nint main() {\n    auto candidate = split_two_parts;\n    assert(candidate((std::any({(long)1, (long)1, (long)2, (long)3, (long)4, (long)4, (long)5, (long)1})), (3)) == std::make_tuple(std::vector<long>({(long)1, (long)1, (long)2}), std::vector<long>({(long)3, (long)4, (long)4, (long)5, (long)1})));\n    assert(candidate((std::any({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\", (std::string)\"d\"})), (2)) == std::make_tuple(std::vector<std::string>({(std::string)\"a\", (std::string)\"b\"}), std::vector<std::string>({(std::string)\"c\", (std::string)\"d\"})));\n    assert(candidate((std::any({(std::string)\"p\", (std::string)\"y\", (std::string)\"t\", (std::string)\"h\", (std::string)\"o\", (std::string)\"n\"})), (4)) == std::make_tuple(std::vector<std::string>({(std::string)\"p\", (std::string)\"y\", (std::string)\"t\", (std::string)\"h\"}), std::vector<std::string>({(std::string)\"o\", (std::string)\"n\"})));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    assert(L >= 0);\n    std::any list2 = std::any();\n    for (long i = 0; i < L; i++) {\n        list2.push_back(list1.front());\n        list1.pop_front();\n    }\n    return std::make_tuple(list1, list2);",
    "    std::any list2;\n    for (int i = 0; i < L; i++) {\n        list2.push_back(list1[i]);\n    }\n    list1.erase(list1.begin(), list1.begin() + L);\n    return std::make_tuple(list1, list2);",
    "    std::any list2;\n    std::any list3;\n    for (long i = 0; i < L; i++) {\n        list2.push_back(list1[i]);\n    }\n    for (long i = L; i < list1.size(); i++) {\n        list3.push_back(list1[i]);\n    }\n    return std::make_tuple(list2, list3);",
    "    std::any list2;\n    for (int i = L; i < list1.size(); i++) {\n        list2.push_back(list1[i]);\n    }\n    list1.resize(L);\n    return std::make_tuple(list1, list2);",
    "    std::any list2;\n    for (long i = 0; i < L; i++) {\n        list2.push_back(list1[i]);\n    }\n    for (long i = 0; i < L; i++) {\n        list1.erase(list1.begin());\n    }\n    return std::make_tuple(list1, list2);",
    "    std::any list2 = new std::any();\n    for (long i = 0; i < L; i++) {\n        list2.push_back(list1[i]);\n    }\n    return std::make_tuple(list2, list1);",
    "    assert(L >= 0);\n    std::any list2;\n    for (int i = 0; i < L; i++) {\n        list2.push_back(list1.front());\n        list1.pop_front();\n    }\n    return std::make_tuple(list1, list2);",
    "    std::any list2;\n    for (int i = L; i < list1.size(); i++) {\n        list2.push_back(list1[i]);\n    }\n    list1.erase(list1.begin() + L, list1.end());\n    return std::make_tuple(list1, list2);",
    "    assert(L >= 0);\n    std::any list2;\n    for (int i = 0; i < L; i++) {\n        list2.push_back(list1.front());\n        list1.pop_front();\n    }\n    return std::make_tuple(list1, list2);",
    "    if (L == 0) {\n        return std::make_tuple(std::vector<int>(), list1);\n    }\n    if (L == list1.size()) {\n        return std::make_tuple(list1, std::vector<int>());\n    }\n    std::vector<int> list2;\n    for (int i = 0; i < L; i++) {\n        list2.push_back(list1[i]);\n    }\n    std::vector<int> list3;\n    for (int i = L; i < list1.size(); i++) {\n        list3.push_back(list1[i]);\n    }\n    return std::make_tuple(list2, list3);",
    "    std::any list2;\n    for (int i = 0; i < L; i++) {\n        list2.push_back(list1[i]);\n    }\n    for (int i = 0; i < L; i++) {\n        list1.erase(list1.begin());\n    }\n    return std::make_tuple(list1, list2);",
    "    std::any list2;\n    for(int i=0;i<L;i++)\n    {\n        list2.push_back(list1[i]);\n    }\n    list1.erase(list1.begin(),list1.begin()+L);\n    return std::make_tuple(list1,list2);",
    "    std::any list2;\n    for (int i = 0; i < L; i++) {\n        list2.push_back(list1.front());\n        list1.pop_front();\n    }\n    return std::make_tuple(list1, list2);",
    "    std::any list2;\n    for (int i = 0; i < L; i++) {\n        list2.push_back(list1.front());\n        list1.pop_front();\n    }\n    return std::make_tuple(list1, list2);",
    "  std::any list2;\n  for (int i = 0; i < L; i++) {\n    list2.push_back(list1[i]);\n  }\n  list1.erase(list1.begin(), list1.begin() + L);\n  return std::make_tuple(list1, list2);",
    "    std::any list2;\n    for (int i = 0; i < L; i++) {\n        list2.push_back(list1.front());\n        list1.pop_front();\n    }\n    return std::make_tuple(list1, list2);",
    "    std::any list2;\n    std::any list3;\n    for (int i = 0; i < L; i++) {\n        list2.push_back(list1[i]);\n    }\n    for (int i = L; i < list1.size(); i++) {\n        list3.push_back(list1[i]);\n    }\n    return std::make_tuple(list2, list3);",
    "    assert(L >= 0);\n    std::any list2;\n    for (int i = 0; i < L; i++) {\n        list2.push_back(list1.front());\n        list1.pop_front();\n    }\n    return std::make_tuple(list1, list2);",
    "    std::any list2;\n    for (int i = 0; i < L; i++) {\n        list2.push_back(list1[i]);\n    }\n    for (int i = 0; i < L; i++) {\n        list1.erase(list1.begin());\n    }\n    return std::make_tuple(list1, list2);",
    "    std::any list2;\n    for (int i = 0; i < L; i++) {\n        list2.push_back(list1[i]);\n    }\n    list1.erase(list1.begin(), list1.begin() + L);\n    return std::make_tuple(list1, list2);"
  ]
}