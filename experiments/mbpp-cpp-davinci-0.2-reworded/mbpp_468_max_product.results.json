{
  "name": "mbpp_468_max_product",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_468_max_product.py",
  "prompt_terminology": "reworded",
  "tests": "}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if (curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if (curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmplrn0e9tt: /tmp/tmplrn0e9tt.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        max_product = std::max(max_product, curr_product);\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpfsgyefyx: /tmp/tmpfsgyefyx.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    // Write your code here\n    long max = 0;\n    long product = 1;\n    for(int i = 0; i < arr.size(); i++){\n        product = 1;\n        for(int j = i; j < arr.size(); j++){\n            if(arr[j] > arr[j-1]){\n                product *= arr[j];\n                if(product > max){\n                    max = product;\n                }\n            }\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpnuiae7g7: /tmp/tmpnuiae7g7.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        max_so_far = max_so_far*arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product,max_so_far);\n    }\n    max_so_far = 1;\n    for(int i=arr.size()-1;i>=0;i--){\n        max_so_far = max_so_far*arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product,max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmp5cs_qqjn: /tmp/tmp5cs_qqjn.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        max_product = std::max(max_product, curr_product);\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpfsgyefyx: /tmp/tmpfsgyefyx.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if (curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpaicxay8i: /tmp/tmpaicxay8i.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_prod(arr.size(), 0);\n    max_prod[0] = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        long max_val = arr[i];\n        for(int j = 0; j < i; j++) {\n            if(arr[i] > arr[j]) {\n                max_val = std::max(max_val, max_prod[j] * arr[i]);\n            }\n        }\n        max_prod[i] = max_val;\n    }\n    return *std::max_element(max_prod.begin(), max_prod.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpmd51kuzh: /tmp/tmpmd51kuzh.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            curr_product *= arr[i];\n        } else {\n            max_product = std::max(max_product, curr_product);\n            curr_product = 1;\n        }\n    }\n    return std::max(max_product, curr_product);\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpbqqxmcbv: /tmp/tmpbqqxmcbv.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    // Write your code here\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(int i = 0; i < arr.size(); i++){\n        max_product_so_far = max_product_so_far * arr[i];\n        if(max_product_so_far > max_product){\n            max_product = max_product_so_far;\n        }\n        if(max_product_so_far == 0){\n            max_product_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmp90bugj1u: /tmp/tmp90bugj1u.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpz12xqh_c: /tmp/tmpz12xqh_c.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpa2z3xn03: /tmp/tmpa2z3xn03.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if (curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if (curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmplrn0e9tt: /tmp/tmplrn0e9tt.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        long product = 1;\n        for (int j = i; j < arr.size(); j++) {\n            product *= arr[j];\n            if (product > max_product) {\n                max_product = product;\n            }\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmp9sjmjbic: /tmp/tmp9sjmjbic.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    int n = arr.size();\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpe3w7wg_v: /tmp/tmpe3w7wg_v.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            curr_prod *= arr[i];\n            max_prod = std::max(max_prod, curr_prod);\n        } else if(arr[i] == 0) {\n            curr_prod = 1;\n        } else {\n            curr_prod = std::max(curr_prod * arr[i], 1l);\n            max_prod = std::max(max_prod, curr_prod);\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpol5lzth4: /tmp/tmpol5lzth4.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i=0;i<arr.size();i++){\n        curr_prod *= arr[i];\n        max_prod = std::max(max_prod,curr_prod);\n        if(curr_prod == 0)\n            curr_prod = 1;\n    }\n    curr_prod = 1;\n    for(int i=arr.size()-1;i>=0;i--){\n        curr_prod *= arr[i];\n        max_prod = std::max(max_prod,curr_prod);\n        if(curr_prod == 0)\n            curr_prod = 1;\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmp_cz1uiup: /tmp/tmp_cz1uiup.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long prod = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        prod *= arr[i];\n        if (prod > max_prod) {\n            max_prod = prod;\n        }\n        if (prod == 0) {\n            prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmphtv4qvsh: /tmp/tmphtv4qvsh.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmp7aph69e5: /tmp/tmp7aph69e5.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpz12xqh_c: /tmp/tmpz12xqh_c.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i=0; i<arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpwad0b4br: /tmp/tmpwad0b4br.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long curr_product = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        curr_product = std::max(curr_product * arr[i], arr[i]);\n        max_product = std::max(max_product, curr_product);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmplwij0e_6: /tmp/tmplwij0e_6.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpa2z3xn03: /tmp/tmpa2z3xn03.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        product *= arr[i];\n        if(product > max_product) {\n            max_product = product;\n        }\n        if(product == 0) {\n            product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpo7clomk6: /tmp/tmpo7clomk6.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max = arr[0];\n    long min = arr[0];\n    long result = arr[0];\n    for(int i=1;i<arr.size();i++) {\n        if(arr[i]<0) {\n            long temp = max;\n            max = min;\n            min = temp;\n        }\n        max = std::max(arr[i],max*arr[i]);\n        min = std::min(arr[i],min*arr[i]);\n        result = std::max(result,max);\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmp_ppnm23a: /tmp/tmp_ppnm23a.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if(current_product > max_product) {\n            max_product = current_product;\n        }\n        if(current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpw39b0oo2: /tmp/tmpw39b0oo2.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        max_product_so_far *= arr[i];\n        if (max_product < max_product_so_far) {\n            max_product = max_product_so_far;\n        }\n        if (max_product_so_far == 0) {\n            max_product_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmp8955jers: /tmp/tmp8955jers.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            current_product *= arr[i];\n            max_product = std::max(max_product, current_product);\n        } else {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpr8q_5vds: /tmp/tmpr8q_5vds.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long curr_product = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      curr_product *= arr[i];\n      max_product = std::max(max_product, curr_product);\n    } else if (arr[i] == 0) {\n      curr_product = 1;\n    } else {\n      curr_product = 1;\n      for (int j = i; j < arr.size(); j++) {\n        curr_product *= arr[j];\n        max_product = std::max(max_product, curr_product);\n      }\n      break;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmp5ky_n_3n: /tmp/tmp5ky_n_3n.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpm311xkw7: /tmp/tmpm311xkw7.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpeg8vr5bq: /tmp/tmpeg8vr5bq.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  for (long i = 0; i < arr.size(); i++) {\n    max_product *= arr[i];\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmp1zbtchx4: /tmp/tmp1zbtchx4.cpp:13: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            curr_prod *= arr[i];\n            max_prod = std::max(max_prod, curr_prod);\n        } else {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpawonxc27: /tmp/tmpawonxc27.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if(current_product > max_product) {\n            max_product = current_product;\n        }\n        if(current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpw39b0oo2: /tmp/tmpw39b0oo2.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            curr_prod *= arr[i];\n            max_prod = std::max(max_prod, curr_prod);\n        } else {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpawonxc27: /tmp/tmpawonxc27.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n\tlong max_product = 1;\n\tlong curr_product = 1;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] > 0) {\n\t\t\tcurr_product *= arr[i];\n\t\t\tmax_product = std::max(max_product, curr_product);\n\t\t} else {\n\t\t\tcurr_product = 1;\n\t\t}\n\t}\n\treturn max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmp6ooenxrc: /tmp/tmp6ooenxrc.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if (current_product > max_product) {\n            max_product = current_product;\n        }\n        if (current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmp_db_7ngf: /tmp/tmp_db_7ngf.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        max_so_far = max_so_far*arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        if(max_so_far>max_product){\n            max_product = max_so_far;\n        }\n    }\n    max_so_far = 1;\n    for(int i=arr.size()-1;i>=0;i--){\n        max_so_far = max_so_far*arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        if(max_so_far>max_product){\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpcqj0zoyk: /tmp/tmpcqj0zoyk.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        max_product = std::max(max_product, curr_product);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmprb2agy1y: /tmp/tmprb2agy1y.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long curr_product = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    curr_product *= arr[i];\n    max_product = std::max(max_product, curr_product);\n    if (curr_product == 0) {\n      curr_product = 1;\n    }\n  }\n  curr_product = 1;\n  for (int i = arr.size() - 1; i >= 0; i--) {\n    curr_product *= arr[i];\n    max_product = std::max(max_product, curr_product);\n    if (curr_product == 0) {\n      curr_product = 1;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpk7fbhtuo: /tmp/tmpk7fbhtuo.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if (curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpaicxay8i: /tmp/tmpaicxay8i.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long max_so_far = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > max_so_far) {\n            max_so_far = arr[i];\n            max_product = max_so_far * max_product;\n        }\n        else {\n            max_product = max_product * arr[i];\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmp5j5d9ei_: /tmp/tmp5j5d9ei_.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far * arr[i], arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmp86yg3dkt: /tmp/tmp86yg3dkt.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far, max_so_far * arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmp06zcynxs: /tmp/tmp06zcynxs.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size()-1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpj711ofo1: /tmp/tmpj711ofo1.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far * arr[i], arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpe1jcejef: /tmp/tmpe1jcejef.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_prod)\n            max_prod = max_so_far;\n        if(max_so_far == 0)\n            max_so_far = 1;\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpbfh2unja: /tmp/tmpbfh2unja.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpz12xqh_c: /tmp/tmpz12xqh_c.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_product_so_far = std::max(max_product_so_far * arr[i], arr[i]);\n        max_product = std::max(max_product, max_product_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpe8n4g88x: /tmp/tmpe8n4g88x.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long current_product = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    current_product *= arr[i];\n    if (current_product > max_product) {\n      max_product = current_product;\n    }\n    if (current_product == 0) {\n      current_product = 1;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp0vf2he2l: /tmp/tmp0vf2he2l.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp3eiw70gd: /tmp/tmp3eiw70gd.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_product_so_far = std::max(max_product_so_far * arr[i], arr[i]);\n        max_product = std::max(max_product, max_product_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp6cbubkq6: /tmp/tmp6cbubkq6.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_product *= arr[i];\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpfca0bubc: /tmp/tmpfca0bubc.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long max_product_so_far = 0;\n    long max_element = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > max_element) {\n            max_element = arr[i];\n            max_product_so_far = max_product_so_far * arr[i];\n        } else {\n            max_product_so_far = max_product_so_far * arr[i];\n        }\n        if (max_product_so_far > max_product) {\n            max_product = max_product_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp6fap5ot9: /tmp/tmp6fap5ot9.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpxsnpm81p: /tmp/tmpxsnpm81p.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpm311xkw7: /tmp/tmpm311xkw7.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long max_so_far = 1;\n  long min_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_so_far = max_so_far * arr[i];\n      min_so_far = std::min(min_so_far * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_so_far = 1;\n      min_so_far = 1;\n    } else {\n      long temp = max_so_far;\n      max_so_far = std::max(min_so_far * arr[i], 1L);\n      min_so_far = temp * arr[i];\n    }\n    if (max_so_far > max_product) {\n      max_product = max_so_far;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpw28p316m: /tmp/tmpw28p316m.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long max_so_far = 0;\n    long min_so_far = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = std::max(max_so_far * arr[i], arr[i]);\n            min_so_far = std::min(min_so_far * arr[i], arr[i]);\n        } else if(arr[i] == 0) {\n            max_so_far = 0;\n            min_so_far = 0;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], arr[i]);\n            min_so_far = std::min(temp * arr[i], arr[i]);\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpsnwz9e0k: /tmp/tmpsnwz9e0k.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far *= arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_prod) {\n            max_prod = max_so_far;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpzlk23rt3: /tmp/tmpzlk23rt3.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long min_product = 1;\n  long max_product_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_product = max_product * arr[i];\n      min_product = std::min(min_product * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_product = 1;\n      min_product = 1;\n    } else {\n      long temp = max_product;\n      max_product = std::max(min_product * arr[i], 1L);\n      min_product = temp * arr[i];\n    }\n    if (max_product_so_far < max_product) {\n      max_product_so_far = max_product;\n    }\n  }\n  return max_product_so_far;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp1va1qhi8: /tmp/tmp1va1qhi8.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    long min_product_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_product_so_far = max_product_so_far * arr[i];\n            min_product_so_far = std::min(min_product_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_product_so_far = 1;\n            min_product_so_far = 1;\n        } else {\n            long temp = max_product_so_far;\n            max_product_so_far = std::max(min_product_so_far * arr[i], 1L);\n            min_product_so_far = temp * arr[i];\n        }\n        if(max_product_so_far > max_product) {\n            max_product = max_product_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpc6io0uyb: /tmp/tmpc6io0uyb.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long max_so_far = 0;\n    long min_so_far = 0;\n    long max_ending_here = 0;\n    long min_ending_here = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_ending_here = std::max(max_ending_here * arr[i], arr[i]);\n            min_ending_here = std::min(min_ending_here * arr[i], arr[i]);\n        }\n        else if(arr[i] == 0) {\n            max_ending_here = 0;\n            min_ending_here = 0;\n        }\n        else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * arr[i], arr[i]);\n            min_ending_here = std::min(temp * arr[i], arr[i]);\n        }\n        if(max_ending_here > max_so_far) {\n            max_so_far = max_ending_here;\n        }\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpmjbtiuc_: /tmp/tmpmjbtiuc_.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp9bce1fud: /tmp/tmp9bce1fud.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    max_so_far = 1;\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpr6a7u0_p: /tmp/tmpr6a7u0_p.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far * arr[i], arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmp86yg3dkt: /tmp/tmp86yg3dkt.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpxsnpm81p: /tmp/tmpxsnpm81p.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]>0){\n            max_so_far = max_so_far*arr[i];\n            min_so_far = std::min(min_so_far*arr[i],1L);\n        }\n        else if(arr[i]==0){\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else{\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far*arr[i],1L);\n            min_so_far = temp*arr[i];\n        }\n        if(max_so_far>max_product){\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpsjpnpbdh: /tmp/tmpsjpnpbdh.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        prod *= arr[i];\n        if(prod > max_prod) {\n            max_prod = prod;\n        }\n        if(prod == 0) {\n            prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpharkei1w: /tmp/tmpharkei1w.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(long i = 0; i < arr.size(); i++) {\n        max_product_so_far *= arr[i];\n        if(max_product_so_far > max_product) {\n            max_product = max_product_so_far;\n        }\n        if(max_product_so_far == 0) {\n            max_product_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp7mij278m: /tmp/tmp7mij278m.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        max_prod = std::max(max_prod, curr_prod);\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpd0t4zsc8: /tmp/tmpd0t4zsc8.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpz12xqh_c: /tmp/tmpz12xqh_c.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if (curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpaicxay8i: /tmp/tmpaicxay8i.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_product_so_far *= arr[i];\n        if(max_product_so_far > max_product) {\n            max_product = max_product_so_far;\n        }\n        if(max_product_so_far == 0) {\n            max_product_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpmc_6slet: /tmp/tmpmc_6slet.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpcjhwmrr3: /tmp/tmpcjhwmrr3.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    max_so_far = 1;\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpqdctnqqy: /tmp/tmpqdctnqqy.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    for(int i=1;i<arr.size();i++) {\n        if(arr[i]>0) {\n            max_so_far = std::max(arr[i], max_so_far*arr[i]);\n            min_so_far = std::min(arr[i], min_so_far*arr[i]);\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(arr[i], min_so_far*arr[i]);\n            min_so_far = std::min(arr[i], temp*arr[i]);\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpdn34a1la: /tmp/tmpdn34a1la.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        product *= arr[i];\n        if(product > max_product) {\n            max_product = product;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp7hb_p1ao: /tmp/tmp7hb_p1ao.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long max_so_far = 1;\n  long min_so_far = 1;\n  for(int i = 0; i < arr.size(); i++) {\n    if(arr[i] > 0) {\n      max_so_far = max_so_far * arr[i];\n      min_so_far = std::min(min_so_far * arr[i], 1L);\n    } else if(arr[i] == 0) {\n      max_so_far = 1;\n      min_so_far = 1;\n    } else {\n      long temp = max_so_far;\n      max_so_far = std::max(min_so_far * arr[i], 1L);\n      min_so_far = temp * arr[i];\n    }\n    if(max_so_far > max_product) {\n      max_product = max_so_far;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpk66p142v: /tmp/tmpk66p142v.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    int n = arr.size();\n    std::vector<long> dp(n, 0);\n    dp[0] = arr[0];\n    for(int i = 1; i < n; i++) {\n        dp[i] = arr[i];\n        for(int j = 0; j < i; j++) {\n            if(arr[i] > arr[j]) {\n                dp[i] = std::max(dp[i], dp[j] * arr[i]);\n            }\n        }\n    }\n    return *std::max_element(dp.begin(), dp.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpdxp5gg4_: /tmp/tmpdxp5gg4_.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    std::vector<long> max_product_arr(arr.size(), 0);\n    for (int i = 0; i < arr.size(); i++) {\n        max_product_arr[i] = arr[i];\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j]) {\n                max_product_arr[i] = std::max(max_product_arr[i], max_product_arr[j] * arr[i]);\n            }\n        }\n        max_product = std::max(max_product, max_product_arr[i]);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpa3jds0ai: /tmp/tmpa3jds0ai.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i=0;i<arr.size();i++) {\n        curr_product *= arr[i];\n        max_product = std::max(max_product, curr_product);\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpsbrpc8u7: /tmp/tmpsbrpc8u7.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long max_so_far = 0;\n    long min_so_far = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = std::max(max_so_far * arr[i], arr[i]);\n            min_so_far = std::min(min_so_far * arr[i], arr[i]);\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], arr[i]);\n            min_so_far = std::min(temp * arr[i], arr[i]);\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpssnqc54e: /tmp/tmpssnqc54e.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if (curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpfyoelz7b: /tmp/tmpfyoelz7b.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long product = 1;\n    for(int i=0;i<arr.size();i++) {\n        product *= arr[i];\n        if(product > max_product) {\n            max_product = product;\n        }\n        if(product == 0) {\n            product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpv7hroihx: /tmp/tmpv7hroihx.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    long product = 1;\n    for (int j = i; j < arr.size(); j++) {\n      product *= arr[j];\n      if (product > max_product) {\n        max_product = product;\n      }\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmp6j_sh_pv: /tmp/tmp6j_sh_pv.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        max_product = std::max(max_product, max_so_far);\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        max_product = std::max(max_product, max_so_far);\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpogskfg3g: /tmp/tmpogskfg3g.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long max_so_far = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > max_so_far) {\n            max_so_far = arr[i];\n            max_product = max_product * max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpalp2jmpu: /tmp/tmpalp2jmpu.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp3eiw70gd: /tmp/tmp3eiw70gd.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp9bce1fud: /tmp/tmp9bce1fud.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            curr_product *= arr[i];\n            max_product = std::max(max_product, curr_product);\n        }\n        else {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmp38dz5ndh: /tmp/tmp38dz5ndh.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long max_so_far = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > max_so_far) {\n            max_so_far = arr[i];\n            max_product = max_so_far;\n        }\n        else {\n            max_product *= arr[i];\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpm8d_m86j: /tmp/tmpm8d_m86j.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpz12xqh_c: /tmp/tmpz12xqh_c.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long max_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    max_so_far = std::max(max_so_far * arr[i], arr[i]);\n    max_product = std::max(max_so_far, max_product);\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpzxsl4k8w: /tmp/tmpzxsl4k8w.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpa2z3xn03: /tmp/tmpa2z3xn03.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_prod(arr.size());\n    max_prod[0] = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        max_prod[i] = arr[i];\n        for(int j = 0; j < i; j++) {\n            if(arr[i] > arr[j]) {\n                max_prod[i] = std::max(max_prod[i], max_prod[j] * arr[i]);\n            }\n        }\n    }\n    return *std::max_element(max_prod.begin(), max_prod.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpsrjixd8b: /tmp/tmpsrjixd8b.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1l);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1l);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpfohd66uw: /tmp/tmpfohd66uw.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    int n = arr.size();\n    std::vector<long> dp(n,1);\n    for(int i=1;i<n;i++){\n        for(int j=0;j<i;j++){\n            if(arr[i]>arr[j]){\n                dp[i] = std::max(dp[i],dp[j]*arr[i]);\n            }\n        }\n    }\n    return *std::max_element(dp.begin(),dp.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpee6j9288: /tmp/tmpee6j9288.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far*arr[i];\n            min_so_far = std::min(min_so_far*arr[i], 1);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far*arr[i], 1);\n            min_so_far = temp*arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "/tmp/tmpe1tqore1.cpp: In function \u2018long int max_product(std::vector<long int>)\u2019:\n/tmp/tmpe1tqore1.cpp:11:55: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_so_far = std::min(min_so_far*arr[i], 1);\n      |                                                       ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpe1tqore1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpe1tqore1.cpp:11:55: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_so_far = std::min(min_so_far*arr[i], 1);\n      |                                                       ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpe1tqore1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tmp/tmpe1tqore1.cpp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long prev_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > prev_product) {\n            max_product *= arr[i];\n            prev_product = arr[i];\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpmr1lsi8l: /tmp/tmpmr1lsi8l.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far, max_so_far * arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmp2ics5bkh: /tmp/tmp2ics5bkh.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]>0){\n            max_so_far = max_so_far*arr[i];\n            min_so_far = std::min(min_so_far*arr[i],1);\n        }\n        else if(arr[i]==0){\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else{\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far*arr[i],1);\n            min_so_far = temp*arr[i];\n        }\n        if(max_so_far>max_product){\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "/tmp/tmpuikknna0.cpp: In function \u2018long int max_product(std::vector<long int>)\u2019:\n/tmp/tmpuikknna0.cpp:11:54: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_so_far = std::min(min_so_far*arr[i],1);\n      |                                                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpuikknna0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpuikknna0.cpp:11:54: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_so_far = std::min(min_so_far*arr[i],1);\n      |                                                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpuikknna0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tmp/tmpuikknna0.cpp:11:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_product_so_far = max_product_so_far * arr[i];\n        if(max_product_so_far > max_product) {\n            max_product = max_product_so_far;\n        }\n        if(max_product_so_far == 0) {\n            max_product_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpfbjw6blr: /tmp/tmpfbjw6blr.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        max_product = std::max(max_product, current_product);\n        if(current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpocefem87: /tmp/tmpocefem87.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpm311xkw7: /tmp/tmpm311xkw7.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpm311xkw7: /tmp/tmpm311xkw7.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpm311xkw7: /tmp/tmpm311xkw7.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++){\n        if(arr[i] > 0){\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0){\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else{\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product){\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpq08fba2z: /tmp/tmpq08fba2z.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if (curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpfyoelz7b: /tmp/tmpfyoelz7b.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmp7u6ajtme: /tmp/tmp7u6ajtme.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if (curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpaicxay8i: /tmp/tmpaicxay8i.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmp7u6ajtme: /tmp/tmp7u6ajtme.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpa2z3xn03: /tmp/tmpa2z3xn03.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if (current_product > max_product) {\n            max_product = current_product;\n        }\n        if (current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmp_db_7ngf: /tmp/tmp_db_7ngf.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if (curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    curr_product = 1;\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        curr_product *= arr[i];\n        if (curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpqa_ztybp: /tmp/tmpqa_ztybp.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long current_product = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            current_product *= arr[i];\n            if (current_product > max_product) {\n                max_product = current_product;\n            }\n        } else {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpnds_xesi: /tmp/tmpnds_xesi.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        product *= arr[i];\n        if(product > max_product) {\n            max_product = product;\n        }\n        if(product == 0) {\n            product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpo7clomk6: /tmp/tmpo7clomk6.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmptrqmlqlh: /tmp/tmptrqmlqlh.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            curr_product *= arr[i];\n            max_product = std::max(max_product, curr_product);\n        } else {\n            curr_product = 1;\n        }\n    }\n    curr_product = 1;\n    for (long i = arr.size() - 1; i >= 0; i--) {\n        if (arr[i] > 0) {\n            curr_product *= arr[i];\n            max_product = std::max(max_product, curr_product);\n        } else {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpu8_e31wj: /tmp/tmpu8_e31wj.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp9bce1fud: /tmp/tmp9bce1fud.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpxsnpm81p: /tmp/tmpxsnpm81p.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far *= arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpgsk90y6y: /tmp/tmpgsk90y6y.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            current_product *= arr[i];\n            max_product = std::max(max_product, current_product);\n        } else {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpfxg3yqnd: /tmp/tmpfxg3yqnd.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        product *= arr[i];\n        if(product > max_product) {\n            max_product = product;\n        }\n        if(product == 0) {\n            product = 1;\n        }\n    }\n    product = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        product *= arr[i];\n        if(product > max_product) {\n            max_product = product;\n        }\n        if(product == 0) {\n            product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpdga8w1yy: /tmp/tmpdga8w1yy.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_product_so_far = max_product_so_far * arr[i];\n        if(max_product_so_far > max_product) {\n            max_product = max_product_so_far;\n        }\n        if(max_product_so_far == 0) {\n            max_product_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122478,
      "stdout": "",
      "stderr": "tmpfbjw6blr: /tmp/tmpfbjw6blr.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long curr_product = 1;\n  for (long i = 0; i < arr.size(); i++) {\n    curr_product *= arr[i];\n    if (curr_product > max_product) {\n      max_product = curr_product;\n    }\n    if (curr_product == 0) {\n      curr_product = 1;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpq2vx8qka: /tmp/tmpq2vx8qka.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    int n=arr.size();\n    std::vector<long> max_prod(n,0);\n    std::vector<long> min_prod(n,0);\n    max_prod[0]=arr[0];\n    min_prod[0]=arr[0];\n    for(int i=1;i<n;i++){\n        if(arr[i]>0){\n            max_prod[i]=std::max(arr[i],max_prod[i-1]*arr[i]);\n            min_prod[i]=std::min(arr[i],min_prod[i-1]*arr[i]);\n        }\n        else{\n            max_prod[i]=std::max(arr[i],min_prod[i-1]*arr[i]);\n            min_prod[i]=std::min(arr[i],max_prod[i-1]*arr[i]);\n        }\n    }\n    long max_val=max_prod[0];\n    for(int i=1;i<n;i++){\n        max_val=std::max(max_val,max_prod[i]);\n    }\n    return max_val;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmp8ft3zn7i: /tmp/tmp8ft3zn7i.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 0;\n  long max_so_far = 0;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > max_so_far) {\n      max_so_far = arr[i];\n      max_product = max_product * max_so_far;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpz74wlth9: /tmp/tmpz74wlth9.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long max_so_far = 0;\n    long min_so_far = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = std::max(max_so_far * arr[i], arr[i]);\n            min_so_far = std::min(min_so_far * arr[i], arr[i]);\n        } else if (arr[i] == 0) {\n            max_so_far = 0;\n            min_so_far = 0;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], arr[i]);\n            min_so_far = std::min(temp * arr[i], arr[i]);\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmp_u5_cnbq: /tmp/tmp_u5_cnbq.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmp7aph69e5: /tmp/tmp7aph69e5.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpa2z3xn03: /tmp/tmpa2z3xn03.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpxsnpm81p: /tmp/tmpxsnpm81p.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpz12xqh_c: /tmp/tmpz12xqh_c.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    int n = arr.size();\n    std::vector<long> dp(n,1);\n    for(int i=1;i<n;i++)\n    {\n        for(int j=0;j<i;j++)\n        {\n            if(arr[i]>arr[j])\n            {\n                dp[i] = std::max(dp[i],dp[j]*arr[i]);\n            }\n        }\n    }\n    return *std::max_element(dp.begin(),dp.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmplnvv0wtc: /tmp/tmplnvv0wtc.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    int n = arr.size();\n    std::vector<long> max_product(n, 0);\n    max_product[0] = arr[0];\n    for (int i = 1; i < n; i++) {\n        max_product[i] = arr[i];\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j]) {\n                max_product[i] = std::max(max_product[i], max_product[j] * arr[i]);\n            }\n        }\n    }\n    return *std::max_element(max_product.begin(), max_product.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpvkz0jpbc: /tmp/tmpvkz0jpbc.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if (max_so_far == 0) {\n            max_so_far = 1;\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpfkjx49qc: /tmp/tmpfkjx49qc.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for (long i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if (curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if (curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    curr_prod = 1;\n    for (long i = arr.size() - 1; i >= 0; i--) {\n        curr_prod *= arr[i];\n        if (curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if (curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpg35xh3_9: /tmp/tmpg35xh3_9.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_product_so_far = std::max(max_product_so_far, max_product_so_far * arr[i]);\n        max_product = std::max(max_product, max_product_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmp26xr6lt2: /tmp/tmp26xr6lt2.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpa2z3xn03: /tmp/tmpa2z3xn03.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long prev_product = 1;\n    long prev_num = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] > prev_num) {\n            max_product = std::max(max_product, prev_product * arr[i]);\n            prev_product = prev_product * arr[i];\n        } else {\n            prev_product = 1;\n        }\n        prev_num = arr[i];\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpe9aaab5b: /tmp/tmpe9aaab5b.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp9bce1fud: /tmp/tmp9bce1fud.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if (arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if (max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmp7aph69e5: /tmp/tmp7aph69e5.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpz12xqh_c: /tmp/tmpz12xqh_c.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpm311xkw7: /tmp/tmpm311xkw7.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        max_so_far *= arr[i];\n        if(max_so_far > max_product){\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i=arr.size()-1;i>=0;i--){\n        max_so_far *= arr[i];\n        if(max_so_far > max_product){\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpbjqgits6: /tmp/tmpbjqgits6.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpm311xkw7: /tmp/tmpm311xkw7.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if (current_product > max_product) {\n            max_product = current_product;\n        }\n        if (current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmp_db_7ngf: /tmp/tmp_db_7ngf.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long max_so_far = 1;\n  long min_so_far = 1;\n  int flag = 0;\n  for(int i = 0; i < arr.size(); i++) {\n    if(arr[i] > 0) {\n      max_so_far = max_so_far * arr[i];\n      min_so_far = std::min(min_so_far * arr[i], 1);\n      flag = 1;\n    }\n    else if(arr[i] == 0) {\n      max_so_far = 1;\n      min_so_far = 1;\n    }\n    else {\n      long temp = max_so_far;\n      max_so_far = std::max(min_so_far * arr[i], 1);\n      min_so_far = temp * arr[i];\n    }\n    if(max_so_far > max_product) {\n      max_product = max_so_far;\n    }\n  }\n  if(flag == 0 && max_product == 1) {\n    return 0;\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "/tmp/tmpl5v34_dd.cpp: In function \u2018long int max_product(std::vector<long int>)\u2019:\n/tmp/tmpl5v34_dd.cpp:12:51: error: no matching function for call to \u2018min(long int, int)\u2019\n   12 |       min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpl5v34_dd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpl5v34_dd.cpp:12:51: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   12 |       min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpl5v34_dd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tmp/tmpl5v34_dd.cpp:12:51: note:   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpvcun673w: /tmp/tmpvcun673w.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpa2z3xn03: /tmp/tmpa2z3xn03.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_prod(arr.size(), 0);\n    max_prod[0] = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        long max_val = arr[i];\n        for(int j = 0; j < i; j++) {\n            if(arr[j] < arr[i]) {\n                max_val = std::max(max_val, max_prod[j] * arr[i]);\n            }\n        }\n        max_prod[i] = max_val;\n    }\n    return *std::max_element(max_prod.begin(), max_prod.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmptjw_il31: /tmp/tmptjw_il31.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpvcun673w: /tmp/tmpvcun673w.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long prev = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] > prev) {\n            max_prod *= arr[i];\n        }\n        prev = arr[i];\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122480,
      "stdout": "",
      "stderr": "tmpqt12wpmi: /tmp/tmpqt12wpmi.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        max_so_far = max_so_far*arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product){\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpho_nrysj: /tmp/tmpho_nrysj.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long current_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        current_product *= arr[i];\n        if(current_product > max_product) {\n            max_product = current_product;\n        }\n        if(current_product == 0) {\n            current_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpw39b0oo2: /tmp/tmpw39b0oo2.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if (curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpaicxay8i: /tmp/tmpaicxay8i.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 0;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpr4yfka2s: /tmp/tmpr4yfka2s.cpp:17: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpa2z3xn03: /tmp/tmpa2z3xn03.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if (curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpaicxay8i: /tmp/tmpaicxay8i.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_product_so_far = std::max(max_product_so_far * arr[i], arr[i]);\n        max_product = std::max(max_product, max_product_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp6cbubkq6: /tmp/tmp6cbubkq6.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far *= arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1l);\n        }\n        else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1l);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpt6vi9pqa: /tmp/tmpt6vi9pqa.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpz12xqh_c: /tmp/tmpz12xqh_c.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++) {\n        max_so_far = max_so_far*arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    max_so_far = 1;\n    for(int i=arr.size()-1;i>=0;i--) {\n        max_so_far = max_so_far*arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpxkcmus0o: /tmp/tmpxkcmus0o.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            curr_product *= arr[i];\n            max_product = std::max(max_product, curr_product);\n        } else {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpo8zat8xv: /tmp/tmpo8zat8xv.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_ending_here = 1;\n    long min_ending_here = 1;\n    for (auto i : arr) {\n        if (i > 0) {\n            max_ending_here = max_ending_here * i;\n            min_ending_here = std::min(min_ending_here * i, 1L);\n        } else if (i == 0) {\n            max_ending_here = 1;\n            min_ending_here = 1;\n        } else {\n            long temp = max_ending_here;\n            max_ending_here = std::max(min_ending_here * i, 1L);\n            min_ending_here = temp * i;\n        }\n        if (max_product < max_ending_here) {\n            max_product = max_ending_here;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpl7rmxl1s: /tmp/tmpl7rmxl1s.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(long i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    max_so_far = 1;\n    for(long i = arr.size() - 1; i >= 0; i--) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmp3c0ctay_: /tmp/tmp3c0ctay_.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    std::vector<long> max_product_arr(arr.size(), 1);\n    for(int i = 0; i < arr.size(); i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[i] > arr[j]) {\n                max_product_arr[i] = std::max(max_product_arr[i], max_product_arr[j] * arr[i]);\n            }\n        }\n        max_product = std::max(max_product, max_product_arr[i]);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmp5eqvr_7k: /tmp/tmp5eqvr_7k.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_product_arr(arr.size(), 0);\n    max_product_arr[0] = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        long max_product = 0;\n        for(int j = 0; j < i; j++) {\n            if(arr[j] < arr[i]) {\n                max_product = std::max(max_product, max_product_arr[j]);\n            }\n        }\n        max_product_arr[i] = max_product + arr[i];\n    }\n    return *std::max_element(max_product_arr.begin(), max_product_arr.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpqwuox12p: /tmp/tmpqwuox12p.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> dp(arr.size(), 1);\n    long max_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[j] < arr[i]) {\n                dp[i] = std::max(dp[i], dp[j] * arr[i]);\n            }\n        }\n        max_product = std::max(max_product, dp[i]);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpjb1y9oeu: /tmp/tmpjb1y9oeu.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            curr_product *= arr[i];\n        } else {\n            max_product = std::max(max_product, curr_product);\n            curr_product = 1;\n        }\n    }\n    return std::max(max_product, curr_product);\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpzv0fwkd5: /tmp/tmpzv0fwkd5.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = arr[0];\n    long min_product = arr[0];\n    long max_so_far = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_product = std::max(max_product * arr[i], arr[i]);\n            min_product = std::min(min_product * arr[i], arr[i]);\n        } else {\n            long temp = max_product;\n            max_product = std::max(min_product * arr[i], arr[i]);\n            min_product = std::min(temp * arr[i], arr[i]);\n        }\n        max_so_far = std::max(max_so_far, max_product);\n    }\n    return max_so_far;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmp01n_ja42: /tmp/tmp01n_ja42.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod) {\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0) {\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpxsnpm81p: /tmp/tmpxsnpm81p.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n        if(max_product < max_so_far) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpvs57q3vi: /tmp/tmpvs57q3vi.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpcjhwmrr3: /tmp/tmpcjhwmrr3.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n\tlong max_product = 0;\n\tlong max_so_far = 0;\n\tlong min_so_far = 0;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] > 0) {\n\t\t\tmax_so_far = std::max(max_so_far * arr[i], arr[i]);\n\t\t\tmin_so_far = std::min(min_so_far * arr[i], arr[i]);\n\t\t} else if (arr[i] == 0) {\n\t\t\tmax_so_far = 0;\n\t\t\tmin_so_far = 0;\n\t\t} else {\n\t\t\tlong temp = max_so_far;\n\t\t\tmax_so_far = std::max(min_so_far * arr[i], arr[i]);\n\t\t\tmin_so_far = std::min(temp * arr[i], arr[i]);\n\t\t}\n\t\tif (max_so_far > max_product) {\n\t\t\tmax_product = max_so_far;\n\t\t}\n\t}\n\treturn max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmp9y1a6l0s: /tmp/tmp9y1a6l0s.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long max_so_far = 1;\n  long min_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_so_far = max_so_far * arr[i];\n      min_so_far = std::min(min_so_far * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_so_far = 1;\n      min_so_far = 1;\n    } else {\n      long temp = max_so_far;\n      max_so_far = std::max(min_so_far * arr[i], 1L);\n      min_so_far = temp * arr[i];\n    }\n    if (max_so_far > max_product) {\n      max_product = max_so_far;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpw28p316m: /tmp/tmpw28p316m.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  std::vector<long> max_product_ending_here(arr.size(), 0);\n  std::vector<long> min_product_ending_here(arr.size(), 0);\n  max_product_ending_here[0] = arr[0];\n  min_product_ending_here[0] = arr[0];\n  long max_product_so_far = arr[0];\n  for (int i = 1; i < arr.size(); i++) {\n    max_product_ending_here[i] = std::max(std::max(max_product_ending_here[i-1] * arr[i], min_product_ending_here[i-1] * arr[i]), arr[i]);\n    min_product_ending_here[i] = std::min(std::min(max_product_ending_here[i-1] * arr[i], min_product_ending_here[i-1] * arr[i]), arr[i]);\n    max_product_so_far = std::max(max_product_so_far, max_product_ending_here[i]);\n  }\n  return max_product_so_far;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpyiqptjvn: /tmp/tmpyiqptjvn.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        long product = 1;\n        for(int j = i; j < arr.size(); j++) {\n            product *= arr[j];\n            if(product > max_product) {\n                max_product = product;\n            }\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpj_zwadkg: /tmp/tmpj_zwadkg.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n\tlong max_product = 1;\n\tlong max_product_so_far = 1;\n\tfor(int i = 0; i < arr.size(); i++) {\n\t\tmax_product_so_far = max_product_so_far * arr[i];\n\t\tif(max_product_so_far > max_product) {\n\t\t\tmax_product = max_product_so_far;\n\t\t}\n\t\tif(max_product_so_far == 0) {\n\t\t\tmax_product_so_far = 1;\n\t\t}\n\t}\n\treturn max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmplrw61u17: /tmp/tmplrw61u17.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    std::vector<long> max_product_ending_here(arr.size(), 0);\n    std::vector<long> min_product_ending_here(arr.size(), 0);\n    max_product_ending_here[0] = arr[0];\n    min_product_ending_here[0] = arr[0];\n    long max_product = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        max_product_ending_here[i] = std::max(std::max(max_product_ending_here[i - 1] * arr[i], min_product_ending_here[i - 1] * arr[i]), arr[i]);\n        min_product_ending_here[i] = std::min(std::min(max_product_ending_here[i - 1] * arr[i], min_product_ending_here[i - 1] * arr[i]), arr[i]);\n        max_product = std::max(max_product, max_product_ending_here[i]);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpajl_ro_c: /tmp/tmpajl_ro_c.cpp:19: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]>0){\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far*arr[i],1);\n        }\n        else if(arr[i]==0){\n            max_so_far = 1;\n            min_so_far = 1;\n        }\n        else{\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far*arr[i],1);\n            min_so_far = temp*arr[i];\n        }\n        if(max_so_far>max_product){\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "/tmp/tmp606b0bvy.cpp: In function \u2018long int max_product(std::vector<long int>)\u2019:\n/tmp/tmp606b0bvy.cpp:11:54: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_so_far = std::min(min_so_far*arr[i],1);\n      |                                                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp606b0bvy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmp606b0bvy.cpp:11:54: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_so_far = std::min(min_so_far*arr[i],1);\n      |                                                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp606b0bvy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tmp/tmp606b0bvy.cpp:11:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i=0;i<arr.size();i++){\n        max_so_far = max_so_far*arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        if(max_so_far>max_product){\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmph11ar0mw: /tmp/tmph11ar0mw.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = max_so_far * arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1L);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1L);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpz12xqh_c: /tmp/tmpz12xqh_c.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n\tlong max_product = 1;\n\tlong max_so_far = 1;\n\tlong min_so_far = 1;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] > 0) {\n\t\t\tmax_so_far = max_so_far * arr[i];\n\t\t\tmin_so_far = std::min(min_so_far * arr[i], 1L);\n\t\t}\n\t\telse if (arr[i] == 0) {\n\t\t\tmax_so_far = 1;\n\t\t\tmin_so_far = 1;\n\t\t}\n\t\telse {\n\t\t\tlong temp = max_so_far;\n\t\t\tmax_so_far = std::max(min_so_far * arr[i], 1L);\n\t\t\tmin_so_far = temp * arr[i];\n\t\t}\n\t\tif (max_so_far > max_product) {\n\t\t\tmax_product = max_so_far;\n\t\t}\n\t}\n\treturn max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpw6yvku9l: /tmp/tmpw6yvku9l.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpm311xkw7: /tmp/tmpm311xkw7.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpm311xkw7: /tmp/tmpm311xkw7.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    long min_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far *= arr[i];\n            min_so_far = std::min(min_so_far * arr[i], 1);\n        } else if(arr[i] == 0) {\n            max_so_far = 1;\n            min_so_far = 1;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], 1);\n            min_so_far = temp * arr[i];\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "/tmp/tmpdm2ix88i.cpp: In function \u2018long int max_product(std::vector<long int>)\u2019:\n/tmp/tmpdm2ix88i.cpp:11:57: error: no matching function for call to \u2018min(long int, int)\u2019\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpdm2ix88i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5: note:   template argument deduction/substitution failed:\n/tmp/tmpdm2ix88i.cpp:11:57: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   11 |             min_so_far = std::min(min_so_far * arr[i], 1);\n      |                                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpdm2ix88i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:246:5: note:   template argument deduction/substitution failed:\n/tmp/tmpdm2i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far *= arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp9bce1fud: /tmp/tmp9bce1fud.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 0;\n    long max_so_far = 0;\n    long min_so_far = 0;\n    for(int i = 0; i < arr.size(); i++) {\n        if(arr[i] > 0) {\n            max_so_far = std::max(max_so_far * arr[i], arr[i]);\n            min_so_far = std::min(min_so_far * arr[i], arr[i]);\n        } else if(arr[i] == 0) {\n            max_so_far = 0;\n            min_so_far = 0;\n        } else {\n            long temp = max_so_far;\n            max_so_far = std::max(min_so_far * arr[i], arr[i]);\n            min_so_far = std::min(temp * arr[i], arr[i]);\n        }\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpsnwz9e0k: /tmp/tmpsnwz9e0k.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long curr_prod = 1;\n    for(int i=0;i<arr.size();i++){\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod){\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0){\n            curr_prod = 1;\n        }\n    }\n    curr_prod = 1;\n    for(int i=arr.size()-1;i>=0;i--){\n        curr_prod *= arr[i];\n        if(curr_prod > max_prod){\n            max_prod = curr_prod;\n        }\n        if(curr_prod == 0){\n            curr_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122482,
      "stdout": "",
      "stderr": "tmpezu9p4h6: /tmp/tmpezu9p4h6.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = std::max(max_so_far * arr[i], arr[i]);\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpe1jcejef: /tmp/tmpe1jcejef.cpp:15: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long max_so_far = 1;\n  long min_so_far = 1;\n  for (long i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_so_far = max_so_far * arr[i];\n      min_so_far = std::min(min_so_far * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_so_far = 1;\n      min_so_far = 1;\n    } else {\n      long temp = max_so_far;\n      max_so_far = std::max(min_so_far * arr[i], 1L);\n      min_so_far = temp * arr[i];\n    }\n    if (max_so_far > max_product) {\n      max_product = max_so_far;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122484,
      "stdout": "",
      "stderr": "tmp3k44n0he: /tmp/tmp3k44n0he.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_prod = 1;\n    long temp_prod = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        temp_prod *= arr[i];\n        if(temp_prod > max_prod) {\n            max_prod = temp_prod;\n        }\n        if(temp_prod == 0) {\n            temp_prod = 1;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122484,
      "stdout": "",
      "stderr": "tmpcxxg9nar: /tmp/tmpcxxg9nar.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n  long max_product = 1;\n  long max_so_far = 1;\n  long min_so_far = 1;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      max_so_far = max_so_far * arr[i];\n      min_so_far = std::min(min_so_far * arr[i], 1L);\n    } else if (arr[i] == 0) {\n      max_so_far = 1;\n      min_so_far = 1;\n    } else {\n      long temp = max_so_far;\n      max_so_far = std::max(min_so_far * arr[i], 1L);\n      min_so_far = temp * arr[i];\n    }\n    if (max_so_far > max_product) {\n      max_product = max_so_far;\n    }\n  }\n  return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpw28p316m: /tmp/tmpw28p316m.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for (int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if (curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if (curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1665509752,
      "stdout": "",
      "stderr": "tmpaicxay8i: /tmp/tmpaicxay8i.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122474,
      "stdout": "",
      "stderr": "tmpm311xkw7: /tmp/tmpm311xkw7.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_product_so_far = 1;\n    for(long i = 0; i < arr.size(); i++) {\n        max_product_so_far *= arr[i];\n        if(max_product_so_far > max_product) {\n            max_product = max_product_so_far;\n        }\n        if(max_product_so_far == 0) {\n            max_product_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmp7mij278m: /tmp/tmp7mij278m.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    // Write your code here\n    long max_prod = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++){\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        if(max_prod < max_so_far){\n            max_prod = max_so_far;\n        }\n    }\n    max_so_far = 1;\n    for(int i = arr.size() - 1; i >= 0; i--){\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far == 0){\n            max_so_far = 1;\n        }\n        if(max_prod < max_so_far){\n            max_prod = max_so_far;\n        }\n    }\n    return max_prod;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122484,
      "stdout": "",
      "stderr": "tmp05np302g: /tmp/tmp05np302g.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    int n = arr.size();\n    std::vector<long> dp(n, 1);\n    for(int i = 1; i < n; i++) {\n        for(int j = 0; j < i; j++) {\n            if(arr[i] > arr[j]) {\n                dp[i] = std::max(dp[i], dp[j] * arr[i]);\n            }\n        }\n    }\n    return *std::max_element(dp.begin(), dp.end());\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122484,
      "stdout": "",
      "stderr": "tmp6135dgk3: /tmp/tmp6135dgk3.cpp:18: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long curr_product = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    curr_product = 1;\n    for(int i = arr.size() - 1; i >= 0; i--) {\n        curr_product *= arr[i];\n        if(curr_product > max_product) {\n            max_product = curr_product;\n        }\n        if(curr_product == 0) {\n            curr_product = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122484,
      "stdout": "",
      "stderr": "tmp1myrg4ap: /tmp/tmp1myrg4ap.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    long max_product = 1;\n    long max_so_far = 1;\n    for(int i = 0; i < arr.size(); i++) {\n        max_so_far = max_so_far * arr[i];\n        if(max_so_far > max_product) {\n            max_product = max_so_far;\n        }\n        if(max_so_far == 0) {\n            max_so_far = 1;\n        }\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122476,
      "stdout": "",
      "stderr": "tmpcjhwmrr3: /tmp/tmpcjhwmrr3.cpp:20: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that vector.\nlong max_product(std::vector<long> arr) {\n    int n = arr.size();\n    long max_so_far = arr[0];\n    long min_so_far = arr[0];\n    long max_product = arr[0];\n    for(int i=1;i<n;i++) {\n        if(arr[i] > 0) {\n            max_so_far = std::max(arr[i], max_so_far*arr[i]);\n            min_so_far = std::min(arr[i], min_so_far*arr[i]);\n        }\n        else {\n            long temp = max_so_far;\n            max_so_far = std::max(arr[i], min_so_far*arr[i]);\n            min_so_far = std::min(arr[i], temp*arr[i]);\n        }\n        max_product = std::max(max_product, max_so_far);\n    }\n    return max_product;\n}\nint main() {\n    auto candidate = max_product;\n    assert(candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000));\n    assert(candidate((std::vector<long>({(long)4, (long)42, (long)55, (long)68, (long)80}))) == (50265600));\n    assert(candidate((std::vector<long>({(long)10, (long)22, (long)9, (long)33, (long)21, (long)50, (long)41, (long)60}))) == (2460));\n}\n",
      "timestamp": 1666122484,
      "stdout": "",
      "stderr": "tmpwt1497mi: /tmp/tmpwt1497mi.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)3, (long)100, (long)4, (long)5, (long)150, (long)6}))) == (3000)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    }
  ]
}