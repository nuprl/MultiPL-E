{
  "name": "mbpp_247_lps",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py",
  "prompt_terminology": "reworded",
  "tests": "}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i=0;i<n;i++){\n        dp[i][i] = 1;\n    }\n    for(int len=2;len<=n;len++){\n        for(int i=0;i<n-len+1;i++){\n            int j = i+len-1;\n            if(str[i] == str[j] && len == 2){\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]){\n                dp[i][j] = dp[i+1][j-1] + 2;\n            }\n            else{\n                dp[i][j] = std::max(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint dp[n][n];\n\tfor(int i = 0; i < n; i++) {\n\t\tdp[i][i] = 1;\n\t}\n\tfor(int l = 2; l <= n; l++) {\n\t\tfor(int i = 0; i < n - l + 1; i++) {\n\t\t\tint j = i + l - 1;\n\t\t\tif(str[i] == str[j] && l == 2) {\n\t\t\t\tdp[i][j] = 2;\n\t\t\t} else if(str[i] == str[j]) {\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t} else {\n\t\t\t\tdp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/\n    // cl is length of substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i+1][j-1];\n            } else {\n                dp[i][j] = std::max(dp[i+1][j], dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    long n = str.length();\n    long i, j, cl;\n    long L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of length 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n \n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n \n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n \n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i=0;i<n;i++)\n        dp[i][i] = 1;\n    for(int len=2;len<=n;len++) {\n        for(int i=0;i<n-len+1;i++) {\n            int j = i+len-1;\n            if(str[i] == str[j] && len == 2)\n                dp[i][j] = 2;\n            else if(str[i] == str[j])\n                dp[i][j] = 2 + dp[i+1][j-1];\n            else\n                dp[i][j] = std::max(dp[i+1][j], dp[i][j-1]);\n        }\n    }\n    return dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i=0;i<n;i++)\n        dp[i][i] = 1;\n    for(int len=2;len<=n;len++) {\n        for(int i=0;i<n-len+1;i++) {\n            int j = i+len-1;\n            if(str[i] == str[j] && len == 2)\n                dp[i][j] = 2;\n            else if(str[i] == str[j])\n                dp[i][j] = dp[i+1][j-1] + 2;\n            else\n                dp[i][j] = std::max(dp[i+1][j], dp[i][j-1]);\n        }\n    }\n    return dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i=0;i<n;i++)\n        dp[i][i] = 1;\n    for(int l=2;l<=n;l++){\n        for(int i=0;i<n-l+1;i++){\n            int j = i+l-1;\n            if(str[i] == str[j] && l==2)\n                dp[i][j] = 2;\n            else if(str[i] == str[j])\n                dp[i][j] = dp[i+1][j-1] + 2;\n            else\n                dp[i][j] = std::max(dp[i+1][j],dp[i][j-1]);\n        }\n    }\n    return dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++) {\n        for (i=0; i<n-cl+1; i++) {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i=0; i<n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l=2; l<=n; l++) {\n        for(int i=0; i<n-l+1; i++) {\n            int j = i+l-1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = dp[i+1][j-1] + 2;\n            } else {\n                dp[i][j] = std::max(dp[i+1][j], dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint dp[n][n];\n\tfor(int i = 0; i < n; i++) {\n\t\tdp[i][i] = 1;\n\t}\n\tfor(int len = 2; len <= n; len++) {\n\t\tfor(int i = 0; i < n - len + 1; i++) {\n\t\t\tint j = i + len - 1;\n\t\t\tif(str[i] == str[j] && len == 2) {\n\t\t\t\tdp[i][j] = 2;\n\t\t\t}\n\t\t\telse if(str[i] == str[j]) {\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint dp[n][n];\n\tfor(int i=0;i<n;i++)\n\t\tdp[i][i] = 1;\n\tfor(int l=2;l<=n;l++){\n\t\tfor(int i=0;i<n-l+1;i++){\n\t\t\tint j = i+l-1;\n\t\t\tif(str[i] == str[j] && l == 2)\n\t\t\t\tdp[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tdp[i][j] = dp[i+1][j-1] + 2;\n\t\t\telse\n\t\t\t\tdp[i][j] = std::max(dp[i+1][j],dp[i][j-1]);\n\t\t}\n\t}\n\treturn dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n=str.size();\n\tint dp[n][n];\n\tfor(int i=0;i<n;i++)\n\t\tdp[i][i]=1;\n\tfor(int l=2;l<=n;l++){\n\t\tfor(int i=0;i<=n-l;i++){\n\t\t\tint j=i+l-1;\n\t\t\tif(str[i]==str[j] && l==2)\n\t\t\t\tdp[i][j]=2;\n\t\t\telse if(str[i]==str[j])\n\t\t\t\tdp[i][j]=dp[i+1][j-1]+2;\n\t\t\telse\n\t\t\t\tdp[i][j]=std::max(dp[i+1][j],dp[i][j-1]);\n\t\t}\n\t}\n\treturn dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/\n    // cl is length of substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int i = n - 2; i >= 0; i--) {\n        for(int j = i + 1; j < n; j++) {\n            if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint i, j, cl;\n\tint L[n][n];  // Create a table to store results of subproblems\n\t// Strings of length 1 are palindrome of lentgh 1\n\tfor (i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\t// Build the table. Note that the lower diagonal values of table are\n\t// useless and not filled in the process. The values are filled in a\n\t// manner similar to Matrix Chain Multiplication DP solution (See\n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of\n\t// substring\n\tfor (cl=2; cl<=n; cl++)\n\t{\n\t\tfor (i=0; i<n-cl+1; i++)\n\t\t{\n\t\t\tj = i+cl-1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i+1][j-1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = std::max(L[i][j-1], L[i+1][j]);\n\t\t}\n\t}\n\treturn L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint i, j, cl;\n\tint L[n][n];\n\tfor (i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\tfor (cl = 2; cl <= n; cl++) {\n\t\tfor (i = 0; i < n - cl + 1; i++) {\n\t\t\tj = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = std::max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\treturn L[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n=str.length();\n\tint i,j,cl;\n\tint L[n][n];\n\tfor(i=0;i<n;i++)\n\t\tL[i][i]=1;\n\tfor(cl=2;cl<=n;cl++){\n\t\tfor(i=0;i<n-cl+1;i++){\n\t\t\tj=i+cl-1;\n\t\t\tif(str[i]==str[j] && cl==2)\n\t\t\t\tL[i][j]=2;\n\t\t\telse if(str[i]==str[j])\n\t\t\t\tL[i][j]=L[i+1][j-1]+2;\n\t\t\telse\n\t\t\t\tL[i][j]=std::max(L[i][j-1],L[i+1][j]);\n\t\t}\n\t}\n\treturn L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n=str.length();\n    int dp[n][n];\n    for(int i=0;i<n;i++)\n    {\n        dp[i][i]=1;\n    }\n    for(int l=2;l<=n;l++)\n    {\n        for(int i=0;i<n-l+1;i++)\n        {\n            int j=i+l-1;\n            if(str[i]==str[j]&&l==2)\n            {\n                dp[i][j]=2;\n            }\n            else if(str[i]==str[j])\n            {\n                dp[i][j]=dp[i+1][j-1]+2;\n            }\n            else\n            {\n                dp[i][j]=std::max(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n \n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n \n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n \n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++) {\n        for (i=0; i<n-cl+1; i++) {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    long n = str.length();\n    long L[n][n];\n    for(long i = 0; i < n; i++) {\n        L[i][i] = 1;\n    }\n    for(long cl = 2; cl <= n; cl++) {\n        for(long i = 0; i < n - cl + 1; i++) {\n            long j = i + cl - 1;\n            if(str[i] == str[j] && cl == 2) {\n                L[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                L[i][j] = L[i + 1][j - 1] + 2;\n            } else {\n                L[i][j] = std::max(L[i + 1][j], L[i][j - 1]);\n            }\n        }\n    }\n    return L[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  \n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int i = n - 1; i >= 0; i--) {\n        for(int j = i + 1; j < n; j++) {\n            if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i <= n - l; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124135,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/\n    // cl is length of substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n  int n = str.size();\n  int dp[n][n];\n  for(int i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n  for(int len = 2; len <= n; len++) {\n    for(int i = 0; i <= n - len; i++) {\n      int j = i + len - 1;\n      if(str[i] == str[j] && len == 2) {\n        dp[i][j] = 2;\n      }\n      else if(str[i] == str[j]) {\n        dp[i][j] = 2 + dp[i + 1][j - 1];\n      }\n      else {\n        dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n  return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl = 2; cl <= n; cl++) {\n        for (i = 0; i < n - cl + 1; i++) {\n            j = i + cl - 1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i + 1][j - 1] + 2;\n            else\n                L[i][j] = std::max(L[i][j - 1], L[i + 1][j]);\n        }\n    }\n    return L[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint dp[n][n];\n\tfor(int i = 0; i < n; i++) {\n\t\tdp[i][i] = 1;\n\t}\n\tfor(int len = 2; len <= n; len++) {\n\t\tfor(int i = 0; i < n - len + 1; i++) {\n\t\t\tint j = i + len - 1;\n\t\t\tif(str[i] == str[j] && len == 2) {\n\t\t\t\tdp[i][j] = 2;\n\t\t\t} else if(str[i] == str[j]) {\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t} else {\n\t\t\t\tdp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n \n    // Strings of length 1 are palindrome of length 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n \n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n \n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl = 2; cl <= n; cl++) {\n        for (i = 0; i < n - cl + 1; i++) {\n            j = i + cl - 1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i + 1][j - 1] + 2;\n            else\n                L[i][j] = std::max(L[i][j - 1], L[i + 1][j]);\n        }\n    }\n    return L[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i=0;i<n;i++)\n        dp[i][i] = 1;\n    for(int l=2;l<=n;l++){\n        for(int i=0;i<n-l+1;i++){\n            int j = i+l-1;\n            if(str[i] == str[j] && l==2)\n                dp[i][j] = 2;\n            else if(str[i] == str[j])\n                dp[i][j] = dp[i+1][j-1] + 2;\n            else\n                dp[i][j] = std::max(dp[i][j-1],dp[i+1][j]);\n        }\n    }\n    return dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint i, j, cl;\n\tint L[n][n];  // Create a table to store results of subproblems\n\t// Strings of length 1 are palindrome of lentgh 1\n\tfor (i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\t// Build the table. Note that the lower diagonal values of table are\n\t// useless and not filled in the process. The values are filled in a\n\t// manner similar to Matrix Chain Multiplication DP solution (See\n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of\n\t// substring\n\tfor (cl=2; cl<=n; cl++)\n\t{\n\t\tfor (i=0; i<n-cl+1; i++)\n\t\t{\n\t\t\tj = i+cl-1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i+1][j-1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = std::max(L[i][j-1], L[i+1][j]);\n\t\t}\n\t}\n\treturn L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint i, j, cl;\n\tint L[n][n];  // Create a table to store results of subproblems\n\t// Strings of length 1 are palindrome of lentgh 1\n\tfor (i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\t// Build the table. Note that the lower diagonal values of table are\n\t// useless and not filled in the process. The values are filled in a\n\t// manner similar to Matrix Chain Multiplication DP solution (See\n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of\n\t// substring\n\tfor (cl=2; cl<=n; cl++)\n\t{\n\t\tfor (i=0; i<n-cl+1; i++)\n\t\t{\n\t\t\tj = i+cl-1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i+1][j-1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = std::max(L[i][j-1], L[i+1][j]);\n\t\t}\n\t}\n\treturn L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint dp[n][n];\n\tfor(int i = 0; i < n; i++) {\n\t\tdp[i][i] = 1;\n\t}\n\tfor(int len = 2; len <= n; len++) {\n\t\tfor(int i = 0; i < n - len + 1; i++) {\n\t\t\tint j = i + len - 1;\n\t\t\tif(str[i] == str[j] && len == 2) {\n\t\t\t\tdp[i][j] = 2;\n\t\t\t} else if(str[i] == str[j]) {\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t} else {\n\t\t\t\tdp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n=str.length();\n    int dp[n][n];\n    for(int i=0;i<n;i++)\n    {\n        dp[i][i]=1;\n    }\n    for(int l=2;l<=n;l++)\n    {\n        for(int i=0;i<n-l+1;i++)\n        {\n            int j=i+l-1;\n            if(str[i]==str[j] && l==2)\n            {\n                dp[i][j]=2;\n            }\n            else if(str[i]==str[j])\n            {\n                dp[i][j]=dp[i+1][j-1]+2;\n            }\n            else\n            {\n                dp[i][j]=std::max(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of length 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i <= n - l; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::max(dp[i][j - 1], dp[i + 1][j]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++) {\n        for (i=0; i<n-cl+1; i++) {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint i, j, cl;\n\tint L[n][n];  // Create a table to store results of subproblems\n\n\t// Strings of length 1 are palindrome of lentgh 1\n\tfor (i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\n\t// Build the table. Note that the lower diagonal values of table are\n\t// useless and not filled in the process. The values are filled in a\n\t// manner similar to Matrix Chain Multiplication DP solution (See\n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of\n\t// substring\n\tfor (cl=2; cl<=n; cl++)\n\t{\n\t\tfor (i=0; i<n-cl+1; i++)\n\t\t{\n\t\t\tj = i+cl-1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i+1][j-1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = std::max(L[i][j-1], L[i+1][j]);\n\t\t}\n\t}\n\n\treturn L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124135,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint i, j, cl;\n\tint L[n][n];  // Create a table to store results of subproblems\n\t// Strings of length 1 are palindrome of lentgh 1\n\tfor (i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\t// Build the table. Note that the lower diagonal values of table are\n\t// useless and not filled in the process. The values are filled in a\n\t// manner similar to Matrix Chain Multiplication DP solution (See\n\t// http://www.geeksforgeeks.org/archives/15553). cl is length of\n\t// substring\n\tfor (cl=2; cl<=n; cl++)\n\t{\n\t\tfor (i=0; i<n-cl+1; i++)\n\t\t{\n\t\t\tj = i+cl-1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i+1][j-1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = std::max(L[i][j-1], L[i+1][j]);\n\t\t}\n\t}\n\treturn L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++) {\n        for (i=0; i<n-cl+1; i++) {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint dp[n][n];\n\tfor(int i=0;i<n;i++)\n\t\tdp[i][i] = 1;\n\tfor(int len=2;len<=n;len++) {\n\t\tfor(int i=0;i<n-len+1;i++) {\n\t\t\tint j = i+len-1;\n\t\t\tif(str[i] == str[j] && len == 2)\n\t\t\t\tdp[i][j] = 2;\n\t\t\telse if(str[i] == str[j])\n\t\t\t\tdp[i][j] = dp[i+1][j-1] + 2;\n\t\t\telse\n\t\t\t\tdp[i][j] = std::max(dp[i+1][j], dp[i][j-1]);\n\t\t}\n\t}\n\treturn dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/).\n    // cl is length of substring\n    for (cl=2; cl<=n; cl++) {\n        for (i=0; i<n-cl+1; i++) {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++) {\n        for (i=0; i<n-cl+1; i++) {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++) {\n        for (i=0; i<n-cl+1; i++) {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i=0;i<n;i++)\n        dp[i][i] = 1;\n    for(int len=2;len<=n;len++){\n        for(int i=0;i<n-len+1;i++){\n            int j = i+len-1;\n            if(str[i] == str[j] && len == 2)\n                dp[i][j] = 2;\n            else if(str[i] == str[j])\n                dp[i][j] = dp[i+1][j-1] + 2;\n            else\n                dp[i][j] = std::max(dp[i+1][j],dp[i][j-1]);\n        }\n    }\n    return dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n \n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n \n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n \n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n \n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n \n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n \n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i == j) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    for(int i = n - 2; i >= 0; i--) {\n        for(int j = i + 1; j < n; j++) {\n            if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tlong n = str.length();\n\tlong dp[n][n];\n\tfor(long i = 0; i < n; i++) {\n\t\tdp[i][i] = 1;\n\t}\n\tfor(long l = 2; l <= n; l++) {\n\t\tfor(long i = 0; i < n - l + 1; i++) {\n\t\t\tlong j = i + l - 1;\n\t\t\tif(str[i] == str[j] && l == 2) {\n\t\t\t\tdp[i][j] = 2;\n\t\t\t} else if(str[i] == str[j]) {\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t} else {\n\t\t\t\tdp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/\n    // cl is length of substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n=str.length();\n\tint dp[n][n];\n\tfor(int i=0;i<n;i++){\n\t\tdp[i][i]=1;\n\t}\n\tfor(int l=2;l<=n;l++){\n\t\tfor(int i=0;i<=n-l;i++){\n\t\t\tint j=i+l-1;\n\t\t\tif(str[i]==str[j] && l==2){\n\t\t\t\tdp[i][j]=2;\n\t\t\t}\n\t\t\telse if(str[i]==str[j]){\n\t\t\t\tdp[i][j]=2+dp[i+1][j-1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i][j]=std::max(dp[i+1][j],dp[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++) {\n        for (i=0; i<n-cl+1; i++) {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int L[n][n];\n    for(int i = 0; i < n; i++) {\n        L[i][i] = 1;\n    }\n    for(int cl = 2; cl <= n; cl++) {\n        for(int i = 0; i < n - cl + 1; i++) {\n            int j = i + cl - 1;\n            if(str[i] == str[j] && cl == 2) {\n                L[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                L[i][j] = L[i + 1][j - 1] + 2;\n            }\n            else {\n                L[i][j] = std::max(L[i][j - 1], L[i + 1][j]);\n            }\n        }\n    }\n    return L[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint i, j, cl;\n\tint L[n][n];\n\tfor (i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\tfor (cl = 2; cl <= n; cl++) {\n\t\tfor (i = 0; i < n - cl + 1; i++) {\n\t\t\tj = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = std::max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\treturn L[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n=str.length();\n    int dp[n][n];\n    for(int i=0;i<n;i++)\n    {\n        dp[i][i]=1;\n    }\n    for(int l=2;l<=n;l++)\n    {\n        for(int i=0;i<n-l+1;i++)\n        {\n            int j=i+l-1;\n            if(str[i]==str[j] && l==2)\n            {\n                dp[i][j]=2;\n            }\n            else if(str[i]==str[j])\n            {\n                dp[i][j]=dp[i+1][j-1]+2;\n            }\n            else\n            {\n                dp[i][j]=std::max(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++) {\n        for (i=0; i<n-cl+1; i++) {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint i, j, cl;\n\tint L[n][n];\n\tfor (i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\tfor (cl = 2; cl <= n; cl++) {\n\t\tfor (i = 0; i < n - cl + 1; i++) {\n\t\t\tj = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = std::max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\treturn L[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint dp[n][n];\n\tfor(int i = 0; i < n; i++) {\n\t\tdp[i][i] = 1;\n\t}\n\tfor(int l = 2; l <= n; l++) {\n\t\tfor(int i = 0; i < n - l + 1; i++) {\n\t\t\tint j = i + l - 1;\n\t\t\tif(str[i] == str[j] && l == 2) {\n\t\t\t\tdp[i][j] = 2;\n\t\t\t} else if(str[i] == str[j]) {\n\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t} else {\n\t\t\t\tdp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            } else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                dp[i][j] = std::max(dp[i][j - 1], dp[i + 1][j]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/\n    // cl is length of substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n \n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n \n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n               L[i][j] = 2;\n            else if (str[i] == str[j])\n               L[i][j] = L[i+1][j-1] + 2;\n            else\n               L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n \n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++) {\n        for (i=0; i<n-cl+1; i++) {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i=0;i<n;i++)\n        dp[i][i] = 1;\n    for(int len=2;len<=n;len++) {\n        for(int i=0;i<=n-len;i++) {\n            int j = i+len-1;\n            if(str[i] == str[j] && len == 2)\n                dp[i][j] = 2;\n            else if(str[i] == str[j])\n                dp[i][j] = dp[i+1][j-1] + 2;\n            else\n                dp[i][j] = std::max(dp[i+1][j], dp[i][j-1]);\n        }\n    }\n    return dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint i, j, cl;\n\tint L[n][n];\n\tfor (i = 0; i < n; i++)\n\t\tL[i][i] = 1;\n\tfor (cl = 2; cl <= n; cl++) {\n\t\tfor (i = 0; i < n - cl + 1; i++) {\n\t\t\tj = i + cl - 1;\n\t\t\tif (str[i] == str[j] && cl == 2)\n\t\t\t\tL[i][j] = 2;\n\t\t\telse if (str[i] == str[j])\n\t\t\t\tL[i][j] = L[i + 1][j - 1] + 2;\n\t\t\telse\n\t\t\t\tL[i][j] = std::max(L[i][j - 1], L[i + 1][j]);\n\t\t}\n\t}\n\treturn L[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124134,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for(int l = 2; l <= n; l++) {\n        for(int i = 0; i < n - l + 1; i++) {\n            int j = i + l - 1;\n            if(str[i] == str[j] && l == 2) {\n                dp[i][j] = 2;\n            }\n            else if(str[i] == str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            }\n            else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl = 2; cl <= n; cl++) {\n        for (i = 0; i < n - cl + 1; i++) {\n            j = i + cl - 1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i + 1][j - 1] + 2;\n            else\n                L[i][j] = std::max(L[i][j - 1], L[i + 1][j]);\n        }\n    }\n    return L[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++)\n        dp[i][i] = 1;\n    for(int len = 2; len <= n; len++) {\n        for(int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if(str[i] == str[j] && len == 2)\n                dp[i][j] = 2;\n            else if(str[i] == str[j])\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            else\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n=str.length();\n    int dp[n][n];\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            if(i==j)\n            {\n                dp[i][j]=1;\n            }\n            else\n            {\n                dp[i][j]=0;\n            }\n        }\n    }\n    for(int i=n-1;i>=0;i--)\n    {\n        for(int j=i+1;j<n;j++)\n        {\n            if(str[i]==str[j])\n            {\n                dp[i][j]=2+dp[i+1][j-1];\n            }\n            else\n            {\n                dp[i][j]=std::max(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n    }\n    return dp[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    // Strings of length 1 are palindrome of lentgh 1\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // http://www.geeksforgeeks.org/archives/15553). cl is length of\n    // substring\n    for (cl=2; cl<=n; cl++)\n    {\n        for (i=0; i<n-cl+1; i++)\n        {\n            j = i+cl-1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i+1][j-1] + 2;\n            else\n                L[i][j] = std::max(L[i][j-1], L[i+1][j]);\n        }\n    }\n    return L[0][n-1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1665509688,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n\tint n = str.length();\n\tint dp[n][n];\n\tfor(int i = 0; i < n; i++) {\n\t\tdp[i][i] = 1;\n\t}\n\tfor(int len = 2; len <= n; len++) {\n\t\tfor(int i = 0; i < n - len + 1; i++) {\n\t\t\tint j = i + len - 1;\n\t\t\tif(str[i] == str[j] && len == 2) {\n\t\t\t\tdp[i][j] = 2;\n\t\t\t} else if(str[i] == str[j]) {\n\t\t\t\tdp[i][j] = 2 + dp[i + 1][j - 1];\n\t\t\t} else {\n\t\t\t\tdp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.length();\n    int i, j, cl;\n    int L[n][n];  // Create a table to store results of subproblems\n    for (i = 0; i < n; i++)\n        L[i][i] = 1;\n    for (cl = 2; cl <= n; cl++) {\n        for (i = 0; i < n - cl + 1; i++) {\n            j = i + cl - 1;\n            if (str[i] == str[j] && cl == 2)\n                L[i][j] = 2;\n            else if (str[i] == str[j])\n                L[i][j] = L[i + 1][j - 1] + 2;\n            else\n                L[i][j] = std::max(L[i][j - 1], L[i + 1][j]);\n        }\n    }\n    return L[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124137,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function to find the length of the longest palindromic subsequence in the given string.\nlong lps(std::string str) {\n    int n = str.size();\n    int dp[n][n];\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i == j) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    for(int i = n - 2; i >= 0; i--) {\n        for(int j = i + 1; j < n; j++) {\n            if(str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\nint main() {\n    auto candidate = lps;\n    assert(candidate((\"TENS FOR TENS\")) == (5));\n    assert(candidate((\"CARDIO FOR CARDS\")) == (7));\n    assert(candidate((\"PART OF THE JOURNEY IS PART\")) == (9));\n}\n",
      "timestamp": 1666124136,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}