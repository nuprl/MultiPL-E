name: HumanEval_6_parse_nested_parens
language: rust
prompt: "/// Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n/// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\nfn parse_nested_parens(paren_string: String) -> Vec<isize>\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
  (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
  () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
  (()(())((())))\")), vec![4]);\n}\n"
completions: ["    let mut max_depth = 0;\n    let mut current_depth = 0;\n    let\
    \ mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                current_depth += 1;\n           \
    \     if current_depth > max_depth {\n                    max_depth = current_depth;\n\
    \                }\n            }\n            ')' => {\n                current_depth\
    \ -= 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    depths.push(max_depth);\n \
    \   depths", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                depths.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let mut\
    \ max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n \
    \   for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    depths.push(max_depth);\n    depths", "    let mut max_depth = 0;\n    let\
    \ mut depth = 0;\n    let mut depths = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              if depth > max_depth {\n                    max_depth = depth;\n\
    \                }\n            }\n            ')' => {\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut max_depths = Vec::new();\n\
    \n    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n                if depth == 0 {\n \
    \                   max_depths.push(max_depth);\n                    max_depth\
    \ = 0;\n                }\n            }\n            _ => {}\n        }\n   \
    \ }\n\n    max_depths", "    let mut max_depth = 0;\n    let mut depth = 0;\n\
    \    let mut max_depth_vec = Vec::new();\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            depth += 1;\n            if depth > max_depth\
    \ {\n                max_depth = depth;\n            }\n        } else if c ==\
    \ ')' {\n            depth -= 1;\n        } else if c == ' ' {\n            max_depth_vec.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    max_depth_vec.push(max_depth);\n\
    \    max_depth_vec", "    let mut paren_stack: Vec<char> = Vec::new();\n    let\
    \ mut max_depth: isize = 0;\n    let mut depth: isize = 0;\n    let mut max_depths:\
    \ Vec<isize> = Vec::new();\n\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            depth += 1;\n            if depth > max_depth {\n  \
    \              max_depth = depth;\n            }\n            paren_stack.push(c);\n\
    \        } else if c == ')' {\n            depth -= 1;\n            paren_stack.pop();\n\
    \        } else if c == ' ' {\n            max_depths.push(max_depth);\n     \
    \       max_depth = 0;\n            depth = 0;\n        }\n    }\n    max_depths.push(max_depth);\n\
    \    max_depths", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let\
    \ mut max_nesting_levels = Vec::new();\n    let mut current_nesting_level = 0;\n\
    \    let mut max_nesting_level = 0;\n    for c in paren_string.chars() {\n   \
    \     if c == '(' {\n            current_nesting_level += 1;\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level;\n\
    \            }\n        } else if c == ')' {\n            current_nesting_level\
    \ -= 1;\n        } else if c == ' ' {\n            max_nesting_levels.push(max_nesting_level);\n\
    \            max_nesting_level = 0;\n            current_nesting_level = 0;\n\
    \        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n    max_nesting_levels",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depths.push(depth);\n                depth -= 1;\n\
    \            }\n            _ => {}\n        }\n    }\n    depths", "    let mut\
    \ stack: Vec<isize> = Vec::new();\n    let mut max_depth: isize = 0;\n    let\
    \ mut depth: isize = 0;\n    let mut result: Vec<isize> = Vec::new();\n\n    for\
    \ c in paren_string.chars() {\n        if c == '(' {\n            depth += 1;\n\
    \            if depth > max_depth {\n                max_depth = depth;\n    \
    \        }\n        } else if c == ')' {\n            depth -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_depth);\n            max_depth =\
    \ 0;\n            depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result", "    let mut result = Vec::new();\n    let mut depth = 0;\n    let\
    \ mut max_depth = 0;\n    for c in paren_string.chars() {\n        if c == '('\
    \ {\n            depth += 1;\n            if depth > max_depth {\n           \
    \     max_depth = depth;\n            }\n        } else if c == ')' {\n      \
    \      depth -= 1;\n        } else if c == ' ' {\n            result.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result", "    let mut result = Vec::new();\n    let mut current_level = 0;\n\
    \    let mut max_level = 0;\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            current_level += 1;\n            if current_level > max_level\
    \ {\n                max_level = current_level;\n            }\n        } else\
    \ if c == ')' {\n            current_level -= 1;\n        } else if c == ' ' {\n\
    \            result.push(max_level);\n            max_level = 0;\n           \
    \ current_level = 0;\n        }\n    }\n    result.push(max_level);\n    result",
  "    let mut result = Vec::new();\n    let mut stack = Vec::new();\n    let mut\
    \ max_depth = 0;\n    let mut current_depth = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                stack.push(c);\n\
    \                current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       }\n            ')' => {\n                if stack.pop().is_none() {\n\
    \                    panic!(\"Unbalanced parentheses\");\n                }\n\
    \                current_depth -= 1;\n            }\n            ' ' => {\n  \
    \              if !stack.is_empty() {\n                    panic!(\"Unbalanced\
    \ parentheses\");\n                }\n                result.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => panic!(\"Invalid input\"),\n        }\n    }\n    if\
    \ !stack.is_empty() {\n        panic!(\"Unbalanced parentheses\");\n    }\n  \
    \  result.push(max_depth);\n    result", "    let mut max_nesting = 0;\n    let\
    \ mut current_nesting = 0;\n    let mut result = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting\
    \ += 1;\n                if current_nesting > max_nesting {\n                \
    \    max_nesting = current_nesting;\n                }\n            }\n      \
    \      ')' => {\n                current_nesting -= 1;\n            }\n      \
    \      ' ' => {\n                result.push(max_nesting);\n                max_nesting\
    \ = 0;\n                current_nesting = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    result.push(max_nesting);\n    result", "    let mut\
    \ max_depth = 0;\n    let mut current_depth = 0;\n    let mut depths = Vec::new();\n\
    \n    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       }\n            ')' => {\n                current_depth -= 1;\n       \
    \     }\n            ' ' => {\n                depths.push(max_depth);\n     \
    \           max_depth = 0;\n                current_depth = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_nesting = 0;\n    let mut current_nesting = 0;\n    let mut output\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            current_nesting += 1;\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting;\n            }\n        }\
    \ else if c == ')' {\n            current_nesting -= 1;\n        } else if c ==\
    \ ' ' {\n            output.push(max_nesting);\n            max_nesting = 0;\n\
    \            current_nesting = 0;\n        }\n    }\n\n    output.push(max_nesting);\n\
    \    output", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             current_depth -= 1;\n            }\n            ' ' => {\n     \
    \           depths.push(max_depth);\n                max_depth = 0;\n        \
    \        current_depth = 0;\n            }\n            _ => {}\n        }\n \
    \   }\n    depths.push(max_depth);\n    depths", "    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    let mut max_depths = Vec::new();\n\n    for c in\
    \ paren_string.chars() {\n        if c == '(' {\n            depth += 1;\n   \
    \         if depth > max_depth {\n                max_depth = depth;\n       \
    \     }\n        } else if c == ')' {\n            depth -= 1;\n        } else\
    \ if c == ' ' {\n            max_depths.push(max_depth);\n            max_depth\
    \ = 0;\n            depth = 0;\n        }\n    }\n    max_depths.push(max_depth);\n\
    \    max_depths", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let\
    \ mut paren_stack: Vec<isize> = Vec::new();\n    let mut max_depth: isize = 0;\n\
    \    let mut depth_vec: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                paren_stack.push(1);\n\
    \                max_depth += 1;\n            }\n            ')' => {\n      \
    \          paren_stack.pop();\n                max_depth -= 1;\n            }\n\
    \            ' ' => {\n                depth_vec.push(max_depth);\n          \
    \      max_depth = 0;\n            }\n            _ => {}\n        }\n    }\n\n\
    \    depth_vec.push(max_depth);\n    depth_vec", "    let mut max_depth = 0;\n\
    \    let mut current_depth = 0;\n    let mut depths = Vec::new();\n\n    for c\
    \ in paren_string.chars() {\n        match c {\n            '(' => {\n       \
    \         current_depth += 1;\n                if current_depth > max_depth {\n\
    \                    max_depth = current_depth;\n                }\n         \
    \   }\n            ')' => {\n                current_depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                current_depth = 0;\n            }\n  \
    \          _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut current_depth = 0;\n    let mut depths\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n  \
    \          '(' => {\n                current_depth += 1;\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth;\n            \
    \    }\n            }\n            ')' => {\n                current_depth -=\
    \ 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    depths.push(max_depth);\n \
    \   depths", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                depths.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let mut\
    \ max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n \
    \   for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    depths.push(max_depth);\n    depths", "    let mut max_nesting_levels = Vec::new();\n\
    \    let mut current_nesting_level = 0;\n    let mut max_nesting_level = 0;\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_nesting_level += 1;\n                if current_nesting_level\
    \ > max_nesting_level {\n                    max_nesting_level = current_nesting_level;\n\
    \                }\n            }\n            ')' => {\n                current_nesting_level\
    \ -= 1;\n            }\n            ' ' => {\n                max_nesting_levels.push(max_nesting_level);\n\
    \                max_nesting_level = 0;\n                current_nesting_level\
    \ = 0;\n            }\n            _ => {}\n        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n\
    \    max_nesting_levels", "    let mut max_nesting = 0;\n    let mut nesting_level\
    \ = 0;\n    let mut result = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                nesting_level +=\
    \ 1;\n                if nesting_level > max_nesting {\n                    max_nesting\
    \ = nesting_level;\n                }\n            }\n            ')' => {\n \
    \               nesting_level -= 1;\n            }\n            ' ' => {\n   \
    \             result.push(max_nesting);\n                max_nesting = 0;\n  \
    \              nesting_level = 0;\n            }\n            _ => {}\n      \
    \  }\n    }\n    result.push(max_nesting);\n    result", "    let mut max_depth\
    \ = 0;\n    let mut current_depth = 0;\n    let mut depths = Vec::new();\n\n \
    \   for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       }\n            ')' => {\n                current_depth -= 1;\n       \
    \     }\n            ' ' => {\n                depths.push(max_depth);\n     \
    \           max_depth = 0;\n                current_depth = 0;\n            }\n\
    \            _ => panic!(\"Invalid character in input string\"),\n        }\n\
    \    }\n    depths.push(max_depth);\n    depths", "    let mut max_depth = 0;\n\
    \    let mut current_depth = 0;\n    let mut depths = Vec::new();\n\n    for c\
    \ in paren_string.chars() {\n        match c {\n            '(' => {\n       \
    \         current_depth += 1;\n                if current_depth > max_depth {\n\
    \                    max_depth = current_depth;\n                }\n         \
    \   }\n            ')' => {\n                current_depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                current_depth = 0;\n            }\n  \
    \          _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_nesting = 0;\n    let mut current_nesting = 0;\n    let mut result\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n  \
    \          '(' => {\n                current_nesting += 1;\n                if\
    \ current_nesting > max_nesting {\n                    max_nesting = current_nesting;\n\
    \                }\n            }\n            ')' => {\n                current_nesting\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                current_nesting = 0;\n    \
    \        }\n            _ => {}\n        }\n    }\n    result.push(max_nesting);\n\
    \    result", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             if current_depth > 0 {\n                    current_depth -= 1;\n\
    \                }\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n\n    depths.push(max_depth);\n\
    \    depths", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             current_depth -= 1;\n            }\n            ' ' => {\n     \
    \           depths.push(max_depth);\n                max_depth = 0;\n        \
    \        current_depth = 0;\n            }\n            _ => panic!(\"Invalid\
    \ character in input string\"),\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut max_depths = Vec::new();\n\n    for c in paren_string.chars() {\n \
    \       if c == '(' {\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            current_depth -= 1;\n        } else\
    \ if c == ' ' {\n            max_depths.push(max_depth);\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n\n    max_depths.push(max_depth);\n\
    \    max_depths", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n\
    \    let mut result = Vec::new();\n\n    for c in paren_string.chars() {\n   \
    \     match c {\n            '(' => {\n                current_depth += 1;\n \
    \               if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               current_depth -= 1;\n            }\n            ' ' => {\n   \
    \             result.push(max_depth);\n                max_depth = 0;\n      \
    \          current_depth = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    result.push(max_depth);\n    result", "    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    let mut max_depth_vec = Vec::new();\n    for c in\
    \ paren_string.chars() {\n        match c {\n            '(' => {\n          \
    \      depth += 1;\n                if depth > max_depth {\n                 \
    \   max_depth = depth;\n                }\n            }\n            ')' => {\n\
    \                depth -= 1;\n            }\n            ' ' => {\n          \
    \      max_depth_vec.push(max_depth);\n                max_depth = 0;\n      \
    \          depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    max_depth_vec.push(max_depth);\n    max_depth_vec", "    let mut max_depth\
    \ = 0;\n    let mut current_depth = 0;\n    let mut depths = Vec::new();\n\n \
    \   for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       }\n            ')' => {\n                current_depth -= 1;\n       \
    \     }\n            ' ' => {\n                depths.push(max_depth);\n     \
    \           max_depth = 0;\n                current_depth = 0;\n            }\n\
    \            _ => {\n                panic!(\"Invalid character in input string\"\
    );\n            }\n        }\n    }\n\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut curr_depth = 0;\n    let mut depths = Vec::new();\n\
    \n    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                curr_depth += 1;\n                if curr_depth > max_depth {\n\
    \                    max_depth = curr_depth;\n                }\n            }\n\
    \            ')' => {\n                curr_depth -= 1;\n            }\n     \
    \       ' ' => {\n                depths.push(max_depth);\n                max_depth\
    \ = 0;\n                curr_depth = 0;\n            }\n            _ => {}\n\
    \        }\n    }\n    depths.push(max_depth);\n    depths", "    let mut max_depth\
    \ = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n    for c in\
    \ paren_string.chars() {\n        match c {\n            '(' => {\n          \
    \      depth += 1;\n                if depth > max_depth {\n                 \
    \   max_depth = depth;\n                }\n            }\n            ')' => {\n\
    \                depth -= 1;\n            }\n            ' ' => {\n          \
    \      depths.push(max_depth);\n                max_depth = 0;\n             \
    \   depth = 0;\n            }\n            _ => {}\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths", "    let mut result = Vec::new();\n    let mut current_level = 0;\n\
    \    let mut max_level = 0;\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            current_level += 1;\n            if current_level > max_level\
    \ {\n                max_level = current_level;\n            }\n        } else\
    \ if c == ')' {\n            current_level -= 1;\n        } else if c == ' ' {\n\
    \            result.push(max_level);\n            max_level = 0;\n           \
    \ current_level = 0;\n        }\n    }\n    result.push(max_level);\n    result",
  "    let mut result = Vec::new();\n    let mut current_level = 0;\n    let mut max_level\
    \ = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n         \
    \   current_level += 1;\n            if current_level > max_level {\n        \
    \        max_level = current_level;\n            }\n        } else if c == ')'\
    \ {\n            current_level -= 1;\n        } else if c == ' ' {\n         \
    \   result.push(max_level);\n            max_level = 0;\n            current_level\
    \ = 0;\n        }\n    }\n    result.push(max_level);\n    result", "    let mut\
    \ max_nesting = 0;\n    let mut current_nesting = 0;\n    let mut result = Vec::new();\n\
    \n    for c in paren_string.chars() {\n        if c == '(' {\n            current_nesting\
    \ += 1;\n            if current_nesting > max_nesting {\n                max_nesting\
    \ = current_nesting;\n            }\n        } else if c == ')' {\n          \
    \  current_nesting -= 1;\n        } else if c == ' ' {\n            result.push(max_nesting);\n\
    \            max_nesting = 0;\n            current_nesting = 0;\n        }\n \
    \   }\n\n    result.push(max_nesting);\n    result", "    let mut max_depth =\
    \ 0;\n    let mut current_depth = 0;\n    let mut depths = Vec::new();\n\n   \
    \ for c in paren_string.chars() {\n        match c {\n            '(' => {\n \
    \               current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       }\n            ')' => {\n                current_depth -= 1;\n       \
    \     }\n            ' ' => {\n                depths.push(max_depth);\n     \
    \           max_depth = 0;\n                current_depth = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut current_depth = 0;\n    let mut result\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n  \
    \          '(' => {\n                current_depth += 1;\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth;\n            \
    \    }\n            }\n            ')' => {\n                current_depth -=\
    \ 1;\n            }\n            ' ' => {\n                result.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    result.push(max_depth);\n \
    \   result", "    let mut stack: Vec<isize> = Vec::new();\n    let mut max_depth:\
    \ isize = 0;\n    let mut depth: isize = 0;\n    let mut max_depths: Vec<isize>\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            depth += 1;\n            if depth > max_depth {\n               \
    \ max_depth = depth;\n            }\n        } else if c == ')' {\n          \
    \  depth -= 1;\n        } else if c == ' ' {\n            max_depths.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    max_depths.push(max_depth);\n\
    \    max_depths", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut max_depths = Vec::new();\n\n    for c in paren_string.chars() {\n      \
    \  if c == '(' {\n            depth += 1;\n            if depth > max_depth {\n\
    \                max_depth = depth;\n            }\n        } else if c == ')'\
    \ {\n            depth -= 1;\n        } else if c == ' ' {\n            max_depths.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    max_depths.push(max_depth);\n\
    \    max_depths", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let\
    \ mut max_nesting = 0;\n    let mut current_nesting = 0;\n    let mut result =\
    \ Vec::new();\n\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            current_nesting += 1;\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting;\n            }\n        }\
    \ else if c == ')' {\n            current_nesting -= 1;\n        } else if c ==\
    \ ' ' {\n            result.push(max_nesting);\n            max_nesting = 0;\n\
    \            current_nesting = 0;\n        }\n    }\n    result.push(max_nesting);\n\
    \    result", "    let mut max_nesting = 0;\n    let mut current_nesting = 0;\n\
    \    let mut output = Vec::new();\n\n    for c in paren_string.chars() {\n   \
    \     if c == '(' {\n            current_nesting += 1;\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting;\n          \
    \  }\n        } else if c == ')' {\n            current_nesting -= 1;\n      \
    \  } else if c == ' ' {\n            output.push(max_nesting);\n            max_nesting\
    \ = 0;\n            current_nesting = 0;\n        }\n    }\n\n    output.push(max_nesting);\n\
    \    output", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             if current_depth > 0 {\n                    current_depth -= 1;\n\
    \                }\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n\n    depths.push(max_depth);\n\
    \    depths", "    let mut paren_stack: Vec<isize> = Vec::new();\n    let mut\
    \ max_nesting: isize = 0;\n    let mut max_nesting_vec: Vec<isize> = Vec::new();\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(1);\n\
    \            max_nesting += 1;\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            max_nesting -= 1;\n        } else if c == ' ' {\n            max_nesting_vec.push(max_nesting);\n\
    \            max_nesting = 0;\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n\
    \    max_nesting_vec", "    let mut paren_stack: Vec<isize> = Vec::new();\n  \
    \  let mut max_nesting: isize = 0;\n    let mut max_nesting_vec: Vec<isize> =\
    \ Vec::new();\n    for c in paren_string.chars() {\n        if c == '(' {\n  \
    \          paren_stack.push(max_nesting);\n            max_nesting += 1;\n   \
    \     } else if c == ')' {\n            max_nesting_vec.push(max_nesting);\n \
    \           max_nesting = paren_stack.pop().unwrap();\n        }\n    }\n    max_nesting_vec",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut result = Vec::new();\n\
    \n    for c in paren_string.chars() {\n        if c == '(' {\n            depth\
    \ += 1;\n            if depth > max_depth {\n                max_depth = depth;\n\
    \            }\n        } else if c == ')' {\n            depth -= 1;\n      \
    \  } else if c == ' ' {\n            result.push(max_depth);\n            max_depth\
    \ = 0;\n            depth = 0;\n        }\n    }\n\n    result.push(max_depth);\n\
    \    result", "    let mut max_nesting = 0;\n    let mut nesting_level = 0;\n\
    \    let mut result = Vec::new();\n\n    for c in paren_string.chars() {\n   \
    \     if c == '(' {\n            nesting_level += 1;\n            if nesting_level\
    \ > max_nesting {\n                max_nesting = nesting_level;\n            }\n\
    \        } else if c == ')' {\n            nesting_level -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_nesting);\n            max_nesting\
    \ = 0;\n            nesting_level = 0;\n        }\n    }\n\n    result.push(max_nesting);\n\
    \    result", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             current_depth -= 1;\n            }\n            ' ' => {\n     \
    \           depths.push(max_depth);\n                max_depth = 0;\n        \
    \        current_depth = 0;\n            }\n            _ => {}\n        }\n \
    \   }\n    depths.push(max_depth);\n    depths", "    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    let mut result = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              if depth > max_depth {\n                    max_depth = depth;\n\
    \                }\n            }\n            ')' => {\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    result.push(max_depth);\n    result",
  "    let mut max_depth = 0;\n    let mut current_depth = 0;\n    let mut depths\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n  \
    \          '(' => {\n                current_depth += 1;\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth;\n            \
    \    }\n            }\n            ')' => {\n                if current_depth\
    \ > 0 {\n                    current_depth -= 1;\n                }\n        \
    \    }\n            ' ' => {\n                depths.push(max_depth);\n      \
    \          max_depth = 0;\n                current_depth = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depths.push(depth);\n                depth -= 1;\n\
    \            }\n            _ => {}\n        }\n    }\n    depths", "    let mut\
    \ max_depth = 0;\n    let mut current_depth = 0;\n    let mut depths = Vec::new();\n\
    \n    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       }\n            ')' => {\n                current_depth -= 1;\n       \
    \     }\n            ' ' => {\n                depths.push(max_depth);\n     \
    \           max_depth = 0;\n                current_depth = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depths.push(depth);\n                depth -= 1;\n\
    \            }\n            _ => {}\n        }\n    }\n    depths", "    let mut\
    \ max_depth = 0;\n    let mut current_depth = 0;\n    let mut depths = Vec::new();\n\
    \n    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       }\n            ')' => {\n                current_depth -= 1;\n       \
    \     }\n            ' ' => {\n                depths.push(max_depth);\n     \
    \           max_depth = 0;\n                current_depth = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_nesting_levels = Vec::new();\n    let mut current_nesting_level\
    \ = 0;\n    let mut max_nesting_level = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting_level\
    \ += 1;\n                if current_nesting_level > max_nesting_level {\n    \
    \                max_nesting_level = current_nesting_level;\n                }\n\
    \            }\n            ')' => {\n                if current_nesting_level\
    \ > 0 {\n                    current_nesting_level -= 1;\n                }\n\
    \            }\n            ' ' => {\n                max_nesting_levels.push(max_nesting_level);\n\
    \                max_nesting_level = 0;\n                current_nesting_level\
    \ = 0;\n            }\n            _ => {}\n        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n\
    \    max_nesting_levels", "    let mut result = Vec::new();\n    let mut max_depth\
    \ = 0;\n    let mut current_depth = 0;\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_depth += 1;\n\
    \                if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               current_depth -= 1;\n            }\n            ' ' => {\n   \
    \             result.push(max_depth);\n                max_depth = 0;\n      \
    \          current_depth = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    result.push(max_depth);\n    result", "    let mut max_depth = 0;\n\
    \    let mut current_depth = 0;\n    let mut depths = Vec::new();\n\n    for c\
    \ in paren_string.chars() {\n        match c {\n            '(' => {\n       \
    \         current_depth += 1;\n                if current_depth > max_depth {\n\
    \                    max_depth = current_depth;\n                }\n         \
    \   }\n            ')' => {\n                current_depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                current_depth = 0;\n            }\n  \
    \          _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_nesting = 0;\n    let mut current_nesting = 0;\n    let mut max_nesting_vec\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            current_nesting += 1;\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting;\n            }\n        }\
    \ else if c == ')' {\n            current_nesting -= 1;\n        } else if c ==\
    \ ' ' {\n            max_nesting_vec.push(max_nesting);\n            max_nesting\
    \ = 0;\n            current_nesting = 0;\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n\
    \    max_nesting_vec", "    let mut max_depth = 0;\n    let mut current_depth\
    \ = 0;\n    let mut depths = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_depth +=\
    \ 1;\n                if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               if current_depth > 0 {\n                    current_depth -= 1;\n\
    \                }\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n\n    depths.push(max_depth);\n\
    \    depths", "    let mut paren_stack: Vec<char> = Vec::new();\n    let mut max_depth:\
    \ isize = 0;\n    let mut depth: isize = 0;\n    let mut result: Vec<isize> =\
    \ Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n    \
    \        '(' => {\n                depth += 1;\n                if depth > max_depth\
    \ {\n                    max_depth = depth;\n                }\n             \
    \   paren_stack.push(c);\n            }\n            ')' => {\n              \
    \  depth -= 1;\n                paren_stack.push(c);\n            }\n        \
    \    ' ' => {\n                if !paren_stack.is_empty() {\n                \
    \    result.push(max_depth);\n                    paren_stack.clear();\n     \
    \               max_depth = 0;\n                    depth = 0;\n             \
    \   }\n            }\n            _ => {}\n        }\n    }\n\n    if !paren_stack.is_empty()\
    \ {\n        result.push(max_depth);\n    }\n\n    result", "    let mut max_nesting\
    \ = 0;\n    let mut current_nesting = 0;\n    let mut result = Vec::new();\n\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            current_nesting\
    \ += 1;\n            if current_nesting > max_nesting {\n                max_nesting\
    \ = current_nesting;\n            }\n        } else if c == ')' {\n          \
    \  current_nesting -= 1;\n        } else if c == ' ' {\n            result.push(max_nesting);\n\
    \            max_nesting = 0;\n            current_nesting = 0;\n        }\n \
    \   }\n\n    result.push(max_nesting);\n    result", "    let mut paren_stack:\
    \ Vec<char> = Vec::new();\n    let mut max_nesting: isize = 0;\n    let mut max_nesting_vec:\
    \ Vec<isize> = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            paren_stack.push(c);\n            if paren_stack.len()\
    \ as isize > max_nesting {\n                max_nesting = paren_stack.len() as\
    \ isize;\n            }\n        } else if c == ')' {\n            if paren_stack.len()\
    \ > 0 {\n                paren_stack.pop();\n            } else {\n          \
    \      max_nesting_vec.push(-1);\n                max_nesting = 0;\n         \
    \       continue;\n            }\n        } else if c == ' ' {\n            max_nesting_vec.push(max_nesting);\n\
    \            max_nesting = 0;\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n\
    \    max_nesting_vec", "    let mut max_depth = 0;\n    let mut depth = 0;\n \
    \   let mut depths = Vec::new();\n    for c in paren_string.chars() {\n      \
    \  match c {\n            '(' => {\n                depth += 1;\n            \
    \    if depth > max_depth {\n                    max_depth = depth;\n        \
    \        }\n            }\n            ')' => {\n                depth -= 1;\n\
    \            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => panic!(\"Unexpected\
    \ character in input string\"),\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                depths.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let mut\
    \ max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n \
    \   for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    depths.push(max_depth);\n    depths", "    let mut max_nesting_levels = Vec::new();\n\
    \    let mut current_nesting_level = 0;\n    let mut max_nesting_level = 0;\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            current_nesting_level\
    \ += 1;\n            if current_nesting_level > max_nesting_level {\n        \
    \        max_nesting_level = current_nesting_level;\n            }\n        }\
    \ else if c == ')' {\n            current_nesting_level -= 1;\n        } else\
    \ if c == ' ' {\n            max_nesting_levels.push(max_nesting_level);\n   \
    \         max_nesting_level = 0;\n            current_nesting_level = 0;\n   \
    \     }\n    }\n    max_nesting_levels.push(max_nesting_level);\n    max_nesting_levels",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    depths.push(max_depth);\n    depths", "    let mut max_depth = 0;\n    let\
    \ mut current_depth = 0;\n    let mut depths = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_depth +=\
    \ 1;\n                if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               if current_depth > 0 {\n                    current_depth -= 1;\n\
    \                }\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n\n    depths.push(max_depth);\n\
    \    depths", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             if current_depth > 0 {\n                    current_depth -= 1;\n\
    \                }\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n\n    depths.push(max_depth);\n\
    \    depths", "    let mut max_nesting = vec![];\n    let mut current_nesting\
    \ = 0;\n    let mut max_nesting_so_far = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_nesting += 1;\n            if\
    \ current_nesting > max_nesting_so_far {\n                max_nesting_so_far =\
    \ current_nesting;\n            }\n        } else if c == ')' {\n            current_nesting\
    \ -= 1;\n        } else if c == ' ' {\n            max_nesting.push(max_nesting_so_far);\n\
    \            max_nesting_so_far = 0;\n            current_nesting = 0;\n     \
    \   }\n    }\n    max_nesting.push(max_nesting_so_far);\n    max_nesting", " \
    \   let mut max_nesting_levels = Vec::new();\n    let mut current_nesting_level\
    \ = 0;\n    let mut max_nesting_level = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_nesting_level += 1;\n        \
    \    if current_nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = current_nesting_level;\n            }\n        } else if c == ')' {\n    \
    \        current_nesting_level -= 1;\n        } else if c == ' ' {\n         \
    \   max_nesting_levels.push(max_nesting_level);\n            max_nesting_level\
    \ = 0;\n            current_nesting_level = 0;\n        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n\
    \    max_nesting_levels", "    let mut max_depth = 0;\n    let mut depth = 0;\n\
    \    let mut depths = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                depth += 1;\n           \
    \     if depth > max_depth {\n                    max_depth = depth;\n       \
    \         }\n            }\n            ')' => {\n                depth -= 1;\n\
    \            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut result: Vec<isize> = Vec::new();\n    let mut max_level: isize = 0;\n\
    \    let mut current_level: isize = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_level);\n            max_level =\
    \ 0;\n            current_level = 0;\n        }\n    }\n    result.push(max_level);\n\
    \    result", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             current_depth -= 1;\n            }\n            ' ' => {\n     \
    \           depths.push(max_depth);\n                max_depth = 0;\n        \
    \        current_depth = 0;\n            }\n            _ => {}\n        }\n \
    \   }\n    depths.push(max_depth);\n    depths", "    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    let mut depths = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              if depth > max_depth {\n                    max_depth = depth;\n\
    \                }\n            }\n            ')' => {\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    depths.push(max_depth);\n    depths", "    let mut paren_stack: Vec<char>\
    \ = Vec::new();\n    let mut max_depth: isize = 0;\n    let mut depth: isize =\
    \ 0;\n    let mut output: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            depth += 1;\n            if depth > max_depth\
    \ {\n                max_depth = depth;\n            }\n            paren_stack.push(c);\n\
    \        } else if c == ')' {\n            depth -= 1;\n            paren_stack.pop();\n\
    \        } else if c == ' ' {\n            output.push(max_depth);\n         \
    \   max_depth = 0;\n            depth = 0;\n        }\n    }\n    output.push(max_depth);\n\
    \    output", "    let mut paren_stack: Vec<char> = Vec::new();\n    let mut max_depth:\
    \ isize = 0;\n    let mut depths: Vec<isize> = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_stack.push(c);\n            max_depth\
    \ += 1;\n        } else if c == ')' {\n            paren_stack.pop();\n      \
    \      max_depth -= 1;\n        } else if c == ' ' {\n            depths.push(max_depth);\n\
    \            max_depth = 0;\n        }\n    }\n    depths.push(max_depth);\n \
    \   depths", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                depths.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let mut\
    \ max_nesting_levels = Vec::new();\n    let mut current_level = 0;\n    let mut\
    \ max_level = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            current_level += 1;\n            if current_level > max_level {\n\
    \                max_level = current_level;\n            }\n        } else if\
    \ c == ')' {\n            current_level -= 1;\n        } else if c == ' ' {\n\
    \            max_nesting_levels.push(max_level);\n            max_level = 0;\n\
    \            current_level = 0;\n        }\n    }\n    max_nesting_levels.push(max_level);\n\
    \    max_nesting_levels", "    let mut max_depth = 0;\n    let mut depth = 0;\n\
    \    let mut depths = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                depth += 1;\n           \
    \     if depth > max_depth {\n                    max_depth = depth;\n       \
    \         }\n            }\n            ')' => {\n                depth -= 1;\n\
    \            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    depths.push(max_depth);\n    depths", "    let mut max_depth = 0;\n    let\
    \ mut depth = 0;\n    let mut depths = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              if depth > max_depth {\n                    max_depth = depth;\n\
    \                }\n            }\n            ')' => {\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_nesting = 0;\n    let mut nesting_level = 0;\n    let mut max_nesting_vec\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            nesting_level += 1;\n            if nesting_level > max_nesting {\n\
    \                max_nesting = nesting_level;\n            }\n        } else if\
    \ c == ')' {\n            nesting_level -= 1;\n        } else if c == ' ' {\n\
    \            max_nesting_vec.push(max_nesting);\n            max_nesting = 0;\n\
    \            nesting_level = 0;\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n\
    \    max_nesting_vec", "    let mut max_nesting = 0;\n    let mut nesting_levels\
    \ = Vec::new();\n    let mut current_nesting = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting\
    \ += 1;\n                if current_nesting > max_nesting {\n                \
    \    max_nesting = current_nesting;\n                }\n            }\n      \
    \      ')' => {\n                nesting_levels.push(current_nesting);\n     \
    \           current_nesting -= 1;\n            }\n            _ => {}\n      \
    \  }\n    }\n    nesting_levels.iter().map(|x| *x as isize).collect()", "    let\
    \ mut max_nesting_levels = Vec::new();\n    let mut current_nesting_level = 0;\n\
    \    let mut max_nesting_level = 0;\n    for c in paren_string.chars() {\n   \
    \     if c == '(' {\n            current_nesting_level += 1;\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level;\n\
    \            }\n        } else if c == ')' {\n            current_nesting_level\
    \ -= 1;\n        } else if c == ' ' {\n            max_nesting_levels.push(max_nesting_level);\n\
    \            max_nesting_level = 0;\n            current_nesting_level = 0;\n\
    \        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n    max_nesting_levels",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    depths.push(max_depth);\n    depths", "    let mut max_depth = 0;\n    let\
    \ mut depth = 0;\n    let mut depths = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              if depth > max_depth {\n                    max_depth = depth;\n\
    \                }\n            }\n            ')' => {\n                depths.push(depth);\n\
    \                depth -= 1;\n            }\n            _ => {}\n        }\n\
    \    }\n    depths", "    let mut max_depth = 0;\n    let mut current_depth =\
    \ 0;\n    let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_depth += 1;\n\
    \                if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               current_depth -= 1;\n            }\n            ' ' => {\n   \
    \             depths.push(max_depth);\n                max_depth = 0;\n      \
    \          current_depth = 0;\n            }\n            _ => {}\n        }\n\
    \    }\n    depths.push(max_depth);\n    depths", "    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    let mut max_depths = Vec::new();\n\n    for c in\
    \ paren_string.chars() {\n        if c == '(' {\n            depth += 1;\n   \
    \         if depth > max_depth {\n                max_depth = depth;\n       \
    \     }\n        } else if c == ')' {\n            depth -= 1;\n        } else\
    \ if c == ' ' {\n            max_depths.push(max_depth);\n            max_depth\
    \ = 0;\n            depth = 0;\n        }\n    }\n    max_depths.push(max_depth);\n\
    \    max_depths", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut result = Vec::new();\n\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            depth += 1;\n            if depth > max_depth {\n  \
    \              max_depth = depth;\n            }\n        } else if c == ')' {\n\
    \            depth -= 1;\n        } else if c == ' ' {\n            result.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depths.push(depth);\n     \
    \           depth -= 1;\n            }\n            _ => {}\n        }\n    }\n\
    \    depths", "    let mut max_level = 0;\n    let mut current_level = 0;\n  \
    \  let mut output = Vec::new();\n\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_level += 1;\n   \
    \             if current_level > max_level {\n                    max_level =\
    \ current_level;\n                }\n            }\n            ')' => {\n   \
    \             current_level -= 1;\n            }\n            ' ' => {\n     \
    \           output.push(max_level);\n                max_level = 0;\n        \
    \        current_level = 0;\n            }\n            _ => {}\n        }\n \
    \   }\n    output.push(max_level);\n    output", "    let mut max_nesting = 0;\n\
    \    let mut current_nesting = 0;\n    let mut result = Vec::new();\n\n    for\
    \ c in paren_string.chars() {\n        match c {\n            '(' => {\n     \
    \           current_nesting += 1;\n                if current_nesting > max_nesting\
    \ {\n                    max_nesting = current_nesting;\n                }\n \
    \           }\n            ')' => {\n                current_nesting -= 1;\n \
    \           }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                current_nesting = 0;\n    \
    \        }\n            _ => {}\n        }\n    }\n    result.push(max_nesting);\n\
    \    result", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                depths.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let mut\
    \ max_nesting = 0;\n    let mut current_nesting = 0;\n    let mut output = Vec::new();\n\
    \n    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_nesting += 1;\n                if current_nesting > max_nesting\
    \ {\n                    max_nesting = current_nesting;\n                }\n \
    \           }\n            ')' => {\n                output.push(max_nesting);\n\
    \                max_nesting = 0;\n                current_nesting = 0;\n    \
    \        }\n            _ => (),\n        }\n    }\n\n    output", "    let mut\
    \ max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n \
    \   for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => panic!(\"Unexpected\
    \ character in input string!\"),\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths", "    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut max_level:\
    \ isize = 0;\n    let mut current_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            paren_vec.push(max_level);\n            max_level\
    \ = 0;\n            current_level = 0;\n        }\n    }\n    paren_vec.push(max_level);\n\
    \    paren_vec", "    let mut max_nesting_levels = Vec::new();\n    let mut current_nesting_level\
    \ = 0;\n    let mut max_nesting_level = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_nesting_level += 1;\n        \
    \    if current_nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = current_nesting_level;\n            }\n        } else if c == ')' {\n    \
    \        current_nesting_level -= 1;\n        } else if c == ' ' {\n         \
    \   max_nesting_levels.push(max_nesting_level);\n            max_nesting_level\
    \ = 0;\n            current_nesting_level = 0;\n        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n\
    \    max_nesting_levels", "    let mut max_depth = 0;\n    let mut depth = 0;\n\
    \    let mut depths = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                depth += 1;\n           \
    \     if depth > max_depth {\n                    max_depth = depth;\n       \
    \         }\n            }\n            ')' => {\n                depth -= 1;\n\
    \            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_nesting = 0;\n    let mut current_nesting = 0;\n    let mut output\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            current_nesting += 1;\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting;\n            }\n        }\
    \ else if c == ')' {\n            current_nesting -= 1;\n        } else if c ==\
    \ ' ' {\n            output.push(max_nesting);\n            max_nesting = 0;\n\
    \            current_nesting = 0;\n        }\n    }\n\n    output.push(max_nesting);\n\
    \    output", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             current_depth -= 1;\n            }\n            ' ' => {\n     \
    \           depths.push(max_depth);\n                max_depth = 0;\n        \
    \        current_depth = 0;\n            }\n            _ => {}\n        }\n \
    \   }\n    depths.push(max_depth);\n    depths", "    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    let mut max_depths = Vec::new();\n\n    for c in\
    \ paren_string.chars() {\n        if c == '(' {\n            depth += 1;\n   \
    \         if depth > max_depth {\n                max_depth = depth;\n       \
    \     }\n        } else if c == ')' {\n            depth -= 1;\n        } else\
    \ if c == ' ' {\n            max_depths.push(max_depth);\n            max_depth\
    \ = 0;\n            depth = 0;\n        }\n    }\n    max_depths.push(max_depth);\n\
    \    max_depths", "    let mut max_nesting = 0;\n    let mut current_nesting =\
    \ 0;\n    let mut result = Vec::new();\n\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting += 1;\n\
    \                if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result", "    let mut max_depth\
    \ = 0;\n    let mut current_depth = 0;\n    let mut depths = Vec::new();\n\n \
    \   for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       }\n            ')' => {\n                current_depth -= 1;\n       \
    \     }\n            ' ' => {\n                depths.push(max_depth);\n     \
    \           max_depth = 0;\n                current_depth = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut result = Vec::new();\n\
    \n    for c in paren_string.chars() {\n        if c == '(' {\n            depth\
    \ += 1;\n            if depth > max_depth {\n                max_depth = depth;\n\
    \            }\n        } else if c == ')' {\n            depth -= 1;\n      \
    \  } else if c == ' ' {\n            result.push(max_depth);\n            max_depth\
    \ = 0;\n            depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result", "    let mut max_nesting_levels = Vec::new();\n    let mut current_nesting_level\
    \ = 0;\n    let mut max_nesting_level = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_nesting_level += 1;\n        \
    \    if current_nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = current_nesting_level;\n            }\n        } else if c == ')' {\n    \
    \        current_nesting_level -= 1;\n        } else if c == ' ' {\n         \
    \   max_nesting_levels.push(max_nesting_level);\n            max_nesting_level\
    \ = 0;\n            current_nesting_level = 0;\n        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n\
    \    max_nesting_levels", "    let mut max_level = 0;\n    let mut level = 0;\n\
    \    let mut max_levels = Vec::new();\n    for c in paren_string.chars() {\n \
    \       if c == '(' {\n            level += 1;\n            if level > max_level\
    \ {\n                max_level = level;\n            }\n        } else if c ==\
    \ ')' {\n            level -= 1;\n        } else if c == ' ' {\n            max_levels.push(max_level);\n\
    \            max_level = 0;\n            level = 0;\n        }\n    }\n    max_levels.push(max_level);\n\
    \    max_levels", "    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ max_depth: isize = 0;\n    let mut depth: isize = 0;\n    let mut result: Vec<isize>\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            depth += 1;\n            if depth > max_depth {\n               \
    \ max_depth = depth;\n            }\n            paren_stack.push(c);\n      \
    \  } else if c == ')' {\n            paren_stack.pop();\n            depth -=\
    \ 1;\n        } else if c == ' ' {\n            result.push(max_depth);\n    \
    \        max_depth = 0;\n            depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result", "    let mut levels = Vec::new();\n    let mut level = 0;\n    for\
    \ c in paren_string.chars() {\n        match c {\n            '(' => level +=\
    \ 1,\n            ')' => level -= 1,\n            _ => (),\n        }\n      \
    \  levels.push(level);\n    }\n    levels", "    let mut max_depth = 0;\n    let\
    \ mut depth = 0;\n    let mut depths = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              if depth > max_depth {\n                    max_depth = depth;\n\
    \                }\n            }\n            ')' => {\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    depths.push(max_depth);\n    depths", "    let mut max_nesting_levels = Vec::new();\n\
    \    let mut current_nesting_level = 0;\n    let mut max_nesting_level = 0;\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            current_nesting_level\
    \ += 1;\n            if current_nesting_level > max_nesting_level {\n        \
    \        max_nesting_level = current_nesting_level;\n            }\n        }\
    \ else if c == ')' {\n            if current_nesting_level == 0 {\n          \
    \      max_nesting_levels.push(-1);\n                max_nesting_level = 0;\n\
    \                current_nesting_level = 0;\n            } else {\n          \
    \      current_nesting_level -= 1;\n            }\n        } else if c == ' '\
    \ {\n            max_nesting_levels.push(max_nesting_level);\n            max_nesting_level\
    \ = 0;\n            current_nesting_level = 0;\n        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n\
    \    max_nesting_levels", "    let mut max_nesting = 0;\n    let mut current_nesting\
    \ = 0;\n    let mut max_nesting_vec = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting\
    \ += 1;\n                if current_nesting > max_nesting {\n                \
    \    max_nesting = current_nesting;\n                }\n            }\n      \
    \      ')' => {\n                current_nesting -= 1;\n            }\n      \
    \      ' ' => {\n                max_nesting_vec.push(max_nesting);\n        \
    \        max_nesting = 0;\n                current_nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    max_nesting_vec.push(max_nesting);\n\
    \    max_nesting_vec", "    let mut max_depth = 0;\n    let mut depth = 0;\n \
    \   let mut depths = Vec::new();\n    for c in paren_string.chars() {\n      \
    \  match c {\n            '(' => {\n                depth += 1;\n            \
    \    if depth > max_depth {\n                    max_depth = depth;\n        \
    \        }\n            }\n            ')' => {\n                depth -= 1;\n\
    \            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut current_depth = 0;\n    let mut depths\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n  \
    \          '(' => {\n                current_depth += 1;\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth;\n            \
    \    }\n            }\n            ')' => {\n                current_depth -=\
    \ 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    depths.push(max_depth);\n \
    \   depths", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                depths.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let mut\
    \ paren_vec: Vec<isize> = Vec::new();\n    let mut current_level: isize = 0;\n\
    \    let mut max_level: isize = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            paren_vec.push(max_level);\n            max_level\
    \ = 0;\n            current_level = 0;\n        }\n    }\n    paren_vec.push(max_level);\n\
    \    paren_vec", "    let mut paren_stack: Vec<isize> = Vec::new();\n    let mut\
    \ max_depth: isize = 0;\n    let mut depth_list: Vec<isize> = Vec::new();\n\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                paren_stack.push(1);\n                max_depth += 1;\n     \
    \       }\n            ')' => {\n                paren_stack.pop();\n        \
    \        max_depth -= 1;\n            }\n            ' ' => {\n              \
    \  depth_list.push(max_depth);\n                max_depth = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n\n    depth_list.push(max_depth);\n  \
    \  depth_list", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n\
    \    let mut result = Vec::new();\n\n    for c in paren_string.chars() {\n   \
    \     match c {\n            '(' => {\n                current_depth += 1;\n \
    \               if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               current_depth -= 1;\n            }\n            ' ' => {\n   \
    \             result.push(max_depth);\n                max_depth = 0;\n      \
    \          current_depth = 0;\n            }\n            _ => panic!(\"Invalid\
    \ character in input string\"),\n        }\n    }\n    result.push(max_depth);\n\
    \    result", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                depths.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let mut\
    \ result: Vec<isize> = Vec::new();\n    let mut max_depth: isize = 0;\n    let\
    \ mut current_depth: isize = 0;\n    for c in paren_string.chars() {\n       \
    \ if c == '(' {\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            current_depth -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_depth);\n            max_depth =\
    \ 0;\n            current_depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             current_depth -= 1;\n            }\n            ' ' => {\n     \
    \           depths.push(max_depth);\n                max_depth = 0;\n        \
    \        current_depth = 0;\n            }\n            _ => {}\n        }\n \
    \   }\n    depths.push(max_depth);\n    depths", "    let mut result = Vec::new();\n\
    \    let mut max_depth = 0;\n    let mut curr_depth = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            curr_depth += 1;\n            if curr_depth\
    \ > max_depth {\n                max_depth = curr_depth;\n            }\n    \
    \    } else if c == ')' {\n            curr_depth -= 1;\n        } else if c ==\
    \ ' ' {\n            result.push(max_depth);\n            max_depth = 0;\n   \
    \         curr_depth = 0;\n        }\n    }\n    result.push(max_depth);\n   \
    \ result", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths\
    \ = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n    \
    \        '(' => {\n                depth += 1;\n                if depth > max_depth\
    \ {\n                    max_depth = depth;\n                }\n            }\n\
    \            ')' => {\n                depths.push(depth);\n                depth\
    \ -= 1;\n            }\n            _ => {}\n        }\n    }\n    depths", " \
    \   let mut max_level = 0;\n    let mut level = 0;\n    let mut max_levels = Vec::new();\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            level\
    \ += 1;\n            if level > max_level {\n                max_level = level;\n\
    \            }\n        } else if c == ')' {\n            level -= 1;\n      \
    \  } else if c == ' ' {\n            max_levels.push(max_level);\n           \
    \ max_level = 0;\n            level = 0;\n        }\n    }\n    max_levels.push(max_level);\n\
    \    max_levels", "    let mut result = Vec::new();\n    let mut current_level\
    \ = 0;\n    let mut max_level = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_level);\n            max_level =\
    \ 0;\n            current_level = 0;\n        }\n    }\n    result.push(max_level);\n\
    \    result", "    let mut result = Vec::new();\n    for group in paren_string.split(\"\
    \ \") {\n        let mut max_depth = 0;\n        let mut depth = 0;\n        for\
    \ paren in group.chars() {\n            if paren == '(' {\n                depth\
    \ += 1;\n            } else if paren == ')' {\n                depth -= 1;\n \
    \           }\n            if depth > max_depth {\n                max_depth =\
    \ depth;\n            }\n        }\n        result.push(max_depth);\n    }\n \
    \   result", "    let mut max_depth: isize = 0;\n    let mut depth: isize = 0;\n\
    \    let mut max_depths: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            depth += 1;\n            if depth > max_depth\
    \ {\n                max_depth = depth;\n            }\n        } else if c ==\
    \ ')' {\n            depth -= 1;\n        } else if c == ' ' {\n            max_depths.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    max_depths.push(max_depth);\n\
    \    max_depths", "    let mut stack: Vec<isize> = Vec::new();\n    let mut max_depth:\
    \ isize = 0;\n    let mut depth: isize = 0;\n    let mut output: Vec<isize> =\
    \ Vec::new();\n\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            depth += 1;\n            if depth > max_depth {\n               \
    \ max_depth = depth;\n            }\n        } else if c == ')' {\n          \
    \  depth -= 1;\n        } else if c == ' ' {\n            output.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    output.push(max_depth);\n\
    \    output", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                depths.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let mut\
    \ result: Vec<isize> = Vec::new();\n    let mut max_depth: isize = 0;\n    let\
    \ mut current_depth: isize = 0;\n    for c in paren_string.chars() {\n       \
    \ if c == '(' {\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            current_depth -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_depth);\n            max_depth =\
    \ 0;\n            current_depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             current_depth -= 1;\n            }\n            ' ' => {\n     \
    \           depths.push(max_depth);\n                max_depth = 0;\n        \
    \        current_depth = 0;\n            }\n            _ => {\n             \
    \   panic!(\"Invalid character in input string\");\n            }\n        }\n\
    \    }\n\n    depths.push(max_depth);\n    depths", "    let mut max_nesting =\
    \ 0;\n    let mut nesting_level = 0;\n    let mut result = Vec::new();\n\n   \
    \ for c in paren_string.chars() {\n        match c {\n            '(' => {\n \
    \               nesting_level += 1;\n                if nesting_level > max_nesting\
    \ {\n                    max_nesting = nesting_level;\n                }\n   \
    \         }\n            ')' => {\n                nesting_level -= 1;\n     \
    \       }\n            ' ' => {\n                result.push(max_nesting);\n \
    \               max_nesting = 0;\n                nesting_level = 0;\n       \
    \     }\n            _ => {}\n        }\n    }\n    result.push(max_nesting);\n\
    \    result", "    let mut max_nesting = 0;\n    let mut nesting_levels = Vec::new();\n\
    \    let mut current_nesting = 0;\n    for c in paren_string.chars() {\n     \
    \   if c == '(' {\n            current_nesting += 1;\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting;\n          \
    \  }\n        } else if c == ')' {\n            current_nesting -= 1;\n      \
    \  } else if c == ' ' {\n            nesting_levels.push(max_nesting);\n     \
    \       max_nesting = 0;\n            current_nesting = 0;\n        }\n    }\n\
    \    nesting_levels.push(max_nesting);\n    nesting_levels", "    let mut max_depth\
    \ = 0;\n    let mut curr_depth = 0;\n    let mut max_depths = Vec::new();\n\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            curr_depth\
    \ += 1;\n            if curr_depth > max_depth {\n                max_depth =\
    \ curr_depth;\n            }\n        } else if c == ')' {\n            curr_depth\
    \ -= 1;\n        } else if c == ' ' {\n            max_depths.push(max_depth);\n\
    \            max_depth = 0;\n            curr_depth = 0;\n        }\n    }\n \
    \   max_depths.push(max_depth);\n    max_depths", "    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    let mut depths = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              if depth > max_depth {\n                    max_depth = depth;\n\
    \                }\n            }\n            ')' => {\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut current_depth = 0;\n    let mut depths\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n  \
    \          '(' => {\n                current_depth += 1;\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth;\n            \
    \    }\n            }\n            ')' => {\n                if current_depth\
    \ > 0 {\n                    current_depth -= 1;\n                }\n        \
    \    }\n            ' ' => {\n                depths.push(max_depth);\n      \
    \          max_depth = 0;\n                current_depth = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n\n    depths.push(max_depth);\n    depths",
  "    let mut max_nesting = 0;\n    let mut nesting_level = 0;\n    let mut result\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n  \
    \          '(' => {\n                nesting_level += 1;\n                if nesting_level\
    \ > max_nesting {\n                    max_nesting = nesting_level;\n        \
    \        }\n            }\n            ')' => {\n                nesting_level\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting_level = 0;\n      \
    \      }\n            _ => {}\n        }\n    }\n    result.push(max_nesting);\n\
    \    result", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut depth_vec = Vec::new();\n\n    for c in paren_string.chars() {\n  \
    \      if c == '(' {\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            current_depth -= 1;\n        } else\
    \ if c == ' ' {\n            depth_vec.push(max_depth);\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    depth_vec.push(max_depth);\n\
    \    depth_vec", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut result = Vec::new();\n\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            depth += 1;\n            if depth > max_depth {\n  \
    \              max_depth = depth;\n            }\n        } else if c == ')' {\n\
    \            depth -= 1;\n        } else if c == ' ' {\n            result.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n\n    result.push(max_depth);\n\
    \    result", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                depths.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let mut\
    \ max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n \
    \   for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depths.push(depth);\n                depth -= 1;\n\
    \            }\n            _ => {}\n        }\n    }\n    depths", "    let mut\
    \ result: Vec<isize> = Vec::new();\n    let mut max_depth: isize = 0;\n    let\
    \ mut current_depth: isize = 0;\n    for c in paren_string.chars() {\n       \
    \ if c == '(' {\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            current_depth -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_depth);\n            max_depth =\
    \ 0;\n            current_depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             current_depth -= 1;\n            }\n            ' ' => {\n     \
    \           depths.push(max_depth);\n                max_depth = 0;\n        \
    \        current_depth = 0;\n            }\n            _ => {}\n        }\n \
    \   }\n    depths.push(max_depth);\n    depths", "    let mut max_depth = 0;\n\
    \    let mut current_depth = 0;\n    let mut depths = Vec::new();\n\n    for c\
    \ in paren_string.chars() {\n        match c {\n            '(' => {\n       \
    \         current_depth += 1;\n                if current_depth > max_depth {\n\
    \                    max_depth = current_depth;\n                }\n         \
    \   }\n            ')' => {\n                current_depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                current_depth = 0;\n            }\n  \
    \          _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut current_depth = 0;\n    let mut depths\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n  \
    \          '(' => {\n                current_depth += 1;\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth;\n            \
    \    }\n            }\n            ')' => {\n                current_depth -=\
    \ 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    depths.push(max_depth);\n \
    \   depths", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n   \
    \ let mut max_depths = Vec::new();\n\n    for c in paren_string.chars() {\n  \
    \      match c {\n            '(' => {\n                current_depth += 1;\n\
    \                if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               current_depth -= 1;\n            }\n            ' ' => {\n   \
    \             max_depths.push(max_depth);\n                max_depth = 0;\n  \
    \              current_depth = 0;\n            }\n            _ => {\n       \
    \         panic!(\"Invalid character in input string\");\n            }\n    \
    \    }\n    }\n    max_depths.push(max_depth);\n    max_depths", "    let mut\
    \ max_depth = 0;\n    let mut current_depth = 0;\n    let mut depths = Vec::new();\n\
    \n    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       }\n            ')' => {\n                current_depth -= 1;\n       \
    \     }\n            ' ' => {\n                depths.push(max_depth);\n     \
    \           max_depth = 0;\n                current_depth = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut current_depth = 0;\n    let mut depths\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n  \
    \          '(' => {\n                current_depth += 1;\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth;\n            \
    \    }\n            }\n            ')' => {\n                current_depth -=\
    \ 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => panic!(\"Invalid character in input string\"),\n    \
    \    }\n    }\n    depths.push(max_depth);\n    depths", "    let mut max_depth\
    \ = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n    for c in\
    \ paren_string.chars() {\n        match c {\n            '(' => {\n          \
    \      depth += 1;\n                if depth > max_depth {\n                 \
    \   max_depth = depth;\n                }\n            }\n            ')' => {\n\
    \                depths.push(depth);\n                depth -= 1;\n          \
    \  }\n            _ => (),\n        }\n    }\n    depths", "    let mut max_nesting\
    \ = 0;\n    let mut nesting_level = 0;\n    let mut result = Vec::new();\n\n \
    \   for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                nesting_level += 1;\n                if nesting_level > max_nesting\
    \ {\n                    max_nesting = nesting_level;\n                }\n   \
    \         }\n            ')' => {\n                nesting_level -= 1;\n     \
    \       }\n            ' ' => {\n                result.push(max_nesting);\n \
    \               max_nesting = 0;\n                nesting_level = 0;\n       \
    \     }\n            _ => {}\n        }\n    }\n    result.push(max_nesting);\n\
    \    result", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ result = Vec::new();\n\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                result.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    result.push(max_depth);\n    result", "    let\
    \ mut max_depth = 0;\n    let mut current_depth = 0;\n    let mut max_depths =\
    \ Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n    \
    \        '(' => {\n                current_depth += 1;\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth;\n            \
    \    }\n            }\n            ')' => {\n                current_depth -=\
    \ 1;\n            }\n            ' ' => {\n                max_depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => panic!(\"Invalid character in input string\"),\n    \
    \    }\n    }\n    max_depths.push(max_depth);\n    max_depths", "    let mut\
    \ max_nesting = 0;\n    let mut nesting_level = 0;\n    let mut max_nesting_levels\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            nesting_level += 1;\n            if nesting_level > max_nesting {\n\
    \                max_nesting = nesting_level;\n            }\n        } else if\
    \ c == ')' {\n            nesting_level -= 1;\n        } else if c == ' ' {\n\
    \            max_nesting_levels.push(max_nesting);\n            max_nesting =\
    \ 0;\n            nesting_level = 0;\n        }\n    }\n    max_nesting_levels.push(max_nesting);\n\
    \    max_nesting_levels", "    let mut result: Vec<isize> = Vec::new();\n    let\
    \ mut current_level = 0;\n    let mut max_level = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_level);\n            max_level =\
    \ 0;\n            current_level = 0;\n        }\n    }\n    result.push(max_level);\n\
    \    result", "    let mut max_nesting_level = 0;\n    let mut nesting_level =\
    \ 0;\n    let mut max_nesting_levels = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            nesting_level += 1;\n            if nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = nesting_level;\n\
    \            }\n        } else if c == ')' {\n            nesting_level -= 1;\n\
    \        } else if c == ' ' {\n            max_nesting_levels.push(max_nesting_level);\n\
    \            max_nesting_level = 0;\n            nesting_level = 0;\n        }\n\
    \    }\n    max_nesting_levels.push(max_nesting_level);\n    max_nesting_levels",
  "    let mut max_depth = 0;\n    let mut current_depth = 0;\n    let mut result\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n  \
    \          '(' => {\n                current_depth += 1;\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth;\n            \
    \    }\n            }\n            ')' => {\n                current_depth -=\
    \ 1;\n            }\n            ' ' => {\n                result.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    result.push(max_depth);\n \
    \   result", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n   \
    \ let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n      \
    \  match c {\n            '(' => {\n                current_depth += 1;\n    \
    \            if current_depth > max_depth {\n                    max_depth = current_depth;\n\
    \                }\n            }\n            ')' => {\n                current_depth\
    \ -= 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => panic!(\"Invalid character in input string\"),\n    \
    \    }\n    }\n    depths.push(max_depth);\n    depths", "    let mut paren_stack:\
    \ Vec<isize> = Vec::new();\n    let mut max_depth: isize = 0;\n    let mut max_depths:\
    \ Vec<isize> = Vec::new();\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            paren_stack.push(1);\n            max_depth += 1;\n  \
    \      } else if c == ')' {\n            paren_stack.pop();\n            max_depth\
    \ -= 1;\n        } else if c == ' ' {\n            max_depths.push(max_depth);\n\
    \            max_depth = 0;\n        }\n    }\n    max_depths.push(max_depth);\n\
    \    max_depths", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n\
    \    let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n   \
    \     match c {\n            '(' => {\n                current_depth += 1;\n \
    \               if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               if current_depth > 0 {\n                    current_depth -= 1;\n\
    \                }\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n\n    depths.push(max_depth);\n\
    \    depths", "    let mut result = Vec::new();\n    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    for c in paren_string.chars() {\n        if c ==\
    \ '(' {\n            depth += 1;\n            if depth > max_depth {\n       \
    \         max_depth = depth;\n            }\n        } else if c == ')' {\n  \
    \          depth -= 1;\n        } else if c == ' ' {\n            result.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                depths.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let mut\
    \ max_level = 0;\n    let mut level = 0;\n    let mut result = Vec::new();\n \
    \   for c in paren_string.chars() {\n        if c == '(' {\n            level\
    \ += 1;\n            if level > max_level {\n                max_level = level;\n\
    \            }\n        } else if c == ')' {\n            level -= 1;\n      \
    \  } else if c == ' ' {\n            result.push(max_level);\n            max_level\
    \ = 0;\n            level = 0;\n        }\n    }\n    result.push(max_level);\n\
    \    result", "    let mut max_nesting_levels = Vec::new();\n    let mut current_nesting_level\
    \ = 0;\n    let mut max_nesting_level = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting_level\
    \ += 1;\n                if current_nesting_level > max_nesting_level {\n    \
    \                max_nesting_level = current_nesting_level;\n                }\n\
    \            }\n            ')' => {\n                current_nesting_level -=\
    \ 1;\n            }\n            ' ' => {\n                max_nesting_levels.push(max_nesting_level);\n\
    \                max_nesting_level = 0;\n                current_nesting_level\
    \ = 0;\n            }\n            _ => {}\n        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n\
    \    max_nesting_levels", "    let mut max_nesting = 0;\n    let mut current_nesting\
    \ = 0;\n    let mut results = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting\
    \ += 1;\n                if current_nesting > max_nesting {\n                \
    \    max_nesting = current_nesting;\n                }\n            }\n      \
    \      ')' => {\n                if current_nesting > 0 {\n                  \
    \  current_nesting -= 1;\n                }\n            }\n            ' ' =>\
    \ {\n                results.push(max_nesting);\n                max_nesting =\
    \ 0;\n                current_nesting = 0;\n            }\n            _ => {}\n\
    \        }\n    }\n\n    results.push(max_nesting);\n    results", "    let mut\
    \ max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n \
    \   for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    depths.push(max_depth);\n    depths", "    let mut max_nesting = 0;\n   \
    \ let mut nesting_level = 0;\n    let mut result = Vec::new();\n\n    for c in\
    \ paren_string.chars() {\n        if c == '(' {\n            nesting_level +=\
    \ 1;\n            if nesting_level > max_nesting {\n                max_nesting\
    \ = nesting_level;\n            }\n        } else if c == ')' {\n            nesting_level\
    \ -= 1;\n        } else if c == ' ' {\n            result.push(max_nesting);\n\
    \            max_nesting = 0;\n            nesting_level = 0;\n        }\n   \
    \ }\n\n    result.push(max_nesting);\n    result", "    let mut paren_stack: Vec<isize>\
    \ = Vec::new();\n    let mut max_depth: isize = 0;\n    let mut result: Vec<isize>\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            paren_stack.push(max_depth);\n            max_depth += 1;\n     \
    \   } else if c == ')' {\n            result.push(max_depth);\n            max_depth\
    \ = paren_stack.pop().unwrap();\n        }\n    }\n\n    result", "    let mut\
    \ max_nesting_levels = Vec::new();\n    let mut current_nesting_level = 0;\n \
    \   let mut max_nesting_level = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            current_nesting_level += 1;\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level;\n\
    \            }\n        } else if c == ')' {\n            current_nesting_level\
    \ -= 1;\n        } else if c == ' ' {\n            max_nesting_levels.push(max_nesting_level);\n\
    \            max_nesting_level = 0;\n            current_nesting_level = 0;\n\
    \        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n    max_nesting_levels",
  "    let mut max_nesting = Vec::new();\n    let mut current_nesting = 0;\n    let\
    \ mut max_nesting_so_far = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            current_nesting += 1;\n            if current_nesting\
    \ > max_nesting_so_far {\n                max_nesting_so_far = current_nesting;\n\
    \            }\n        } else if c == ')' {\n            current_nesting -= 1;\n\
    \        } else if c == ' ' {\n            max_nesting.push(max_nesting_so_far);\n\
    \            max_nesting_so_far = 0;\n            current_nesting = 0;\n     \
    \   }\n    }\n    max_nesting.push(max_nesting_so_far);\n    max_nesting", " \
    \   let mut max_depth = 0;\n    let mut current_depth = 0;\n    let mut depths\
    \ = Vec::new();\n\n    for c in paren_string.chars() {\n        match c {\n  \
    \          '(' => {\n                current_depth += 1;\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth;\n            \
    \    }\n            }\n            ')' => {\n                current_depth -=\
    \ 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    depths.push(max_depth);\n \
    \   depths", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depths.push(depth);\n     \
    \           depth -= 1;\n            }\n            _ => {}\n        }\n    }\n\
    \    depths", "    let mut max_nesting_level = 0;\n    let mut nesting_level =\
    \ 0;\n    let mut max_nesting_levels = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            nesting_level += 1;\n            if nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = nesting_level;\n\
    \            }\n        } else if c == ')' {\n            nesting_level -= 1;\n\
    \        } else if c == ' ' {\n            max_nesting_levels.push(max_nesting_level);\n\
    \            max_nesting_level = 0;\n            nesting_level = 0;\n        }\n\
    \    }\n    max_nesting_levels.push(max_nesting_level);\n    max_nesting_levels",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => panic!(\"Invalid character\
    \ in input string\"),\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depths.push(depth);\n                depth -= 1;\n\
    \            }\n            _ => {}\n        }\n    }\n    depths", "    let mut\
    \ result = Vec::new();\n    let mut current_level = 0;\n    let mut max_level\
    \ = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n         \
    \   current_level += 1;\n            if current_level > max_level {\n        \
    \        max_level = current_level;\n            }\n        } else if c == ')'\
    \ {\n            current_level -= 1;\n        } else if c == ' ' {\n         \
    \   result.push(max_level);\n            max_level = 0;\n            current_level\
    \ = 0;\n        }\n    }\n    result.push(max_level);\n    result", "    let mut\
    \ max_depth = 0;\n    let mut current_depth = 0;\n    let mut result = Vec::new();\n\
    \n    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       }\n            ')' => {\n                current_depth -= 1;\n       \
    \     }\n            ' ' => {\n                result.push(max_depth);\n     \
    \           max_depth = 0;\n                current_depth = 0;\n            }\n\
    \            _ => panic!(\"Invalid character in input string\"),\n        }\n\
    \    }\n    result.push(max_depth);\n    result", "    let mut max_depth = 0;\n\
    \    let mut depth = 0;\n    let mut depths = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              if depth > max_depth {\n                    max_depth = depth;\n\
    \                }\n            }\n            ')' => {\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    depths.push(max_depth);\n    depths", "    let mut max_nesting = 0;\n   \
    \ let mut nesting_levels = Vec::new();\n    let mut current_nesting = 0;\n   \
    \ for c in paren_string.chars() {\n        match c {\n            '(' => {\n \
    \               current_nesting += 1;\n                if current_nesting > max_nesting\
    \ {\n                    max_nesting = current_nesting;\n                }\n \
    \           }\n            ')' => {\n                nesting_levels.push(current_nesting);\n\
    \                current_nesting -= 1;\n            }\n            _ => {}\n \
    \       }\n    }\n    nesting_levels.iter().map(|&x| x as isize).collect()", " \
    \   let mut max_nesting_level = 0;\n    let mut nesting_level = 0;\n    let mut\
    \ max_nesting_levels = Vec::new();\n\n    for c in paren_string.chars() {\n  \
    \      match c {\n            '(' => {\n                nesting_level += 1;\n\
    \                if nesting_level > max_nesting_level {\n                    max_nesting_level\
    \ = nesting_level;\n                }\n            }\n            ')' => {\n \
    \               nesting_level -= 1;\n            }\n            ' ' => {\n   \
    \             max_nesting_levels.push(max_nesting_level);\n                max_nesting_level\
    \ = 0;\n                nesting_level = 0;\n            }\n            _ => panic!(\"\
    Invalid character in input string\"),\n        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n\
    \    max_nesting_levels", "    let mut max_nesting_levels = Vec::new();\n    let\
    \ mut current_nesting_level = 0;\n    let mut max_nesting_level = 0;\n    for\
    \ c in paren_string.chars() {\n        if c == '(' {\n            current_nesting_level\
    \ += 1;\n            if current_nesting_level > max_nesting_level {\n        \
    \        max_nesting_level = current_nesting_level;\n            }\n        }\
    \ else if c == ')' {\n            current_nesting_level -= 1;\n        } else\
    \ if c == ' ' {\n            max_nesting_levels.push(max_nesting_level);\n   \
    \         max_nesting_level = 0;\n            current_nesting_level = 0;\n   \
    \     }\n    }\n    max_nesting_levels.push(max_nesting_level);\n    max_nesting_levels",
  "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                depths.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    depths.push(max_depth);\n    depths", "    let mut result = Vec::new();\n\
    \    let mut current_level = 0;\n    let mut max_level = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_level);\n            max_level =\
    \ 0;\n            current_level = 0;\n        }\n    }\n    result.push(max_level);\n\
    \    result", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                depths.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let mut\
    \ paren_stack: Vec<isize> = Vec::new();\n    let mut max_depth: isize = 0;\n \
    \   let mut result: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_stack.push(max_depth);\n       \
    \     max_depth += 1;\n        } else if c == ')' {\n            result.push(max_depth);\n\
    \            max_depth = paren_stack.pop().unwrap();\n        }\n    }\n\n   \
    \ result", "    let mut max_nesting = 0;\n    let mut current_nesting = 0;\n \
    \   let mut result = Vec::new();\n\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            current_nesting += 1;\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting;\n          \
    \  }\n        } else if c == ')' {\n            current_nesting -= 1;\n      \
    \  } else if c == ' ' {\n            result.push(max_nesting);\n            max_nesting\
    \ = 0;\n            current_nesting = 0;\n        }\n    }\n\n    result.push(max_nesting);\n\
    \    result", "    let mut max_nesting = 0;\n    let mut current_nesting = 0;\n\
    \    let mut result = Vec::new();\n\n    for c in paren_string.chars() {\n   \
    \     if c == '(' {\n            current_nesting += 1;\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting;\n          \
    \  }\n        } else if c == ')' {\n            current_nesting -= 1;\n      \
    \  } else if c == ' ' {\n            result.push(max_nesting);\n            max_nesting\
    \ = 0;\n            current_nesting = 0;\n        }\n    }\n\n    result.push(max_nesting);\n\
    \    result", "    let mut max_depth = 0;\n    let mut current_depth = 0;\n  \
    \  let mut depths = Vec::new();\n\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             current_depth -= 1;\n            }\n            ' ' => {\n     \
    \           depths.push(max_depth);\n                max_depth = 0;\n        \
    \        current_depth = 0;\n            }\n            _ => {}\n        }\n \
    \   }\n    depths.push(max_depth);\n    depths", "    let mut max_nesting_levels\
    \ = Vec::new();\n    let mut current_nesting_level = 0;\n    let mut max_nesting_level\
    \ = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n         \
    \   current_nesting_level += 1;\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level;\n            }\n\
    \        } else if c == ')' {\n            current_nesting_level -= 1;\n     \
    \   } else if c == ' ' {\n            max_nesting_levels.push(max_nesting_level);\n\
    \            max_nesting_level = 0;\n            current_nesting_level = 0;\n\
    \        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n    max_nesting_levels",
  "    let mut result: Vec<isize> = Vec::new();\n    let mut max_level: isize = 0;\n\
    \    let mut current_level: isize = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_level);\n            max_level =\
    \ 0;\n            current_level = 0;\n        }\n    }\n    result.push(max_level);\n\
    \    result", "    let mut paren_stack: Vec<isize> = Vec::new();\n    let mut\
    \ max_depth = 0;\n    let mut depth = 0;\n    let mut result: Vec<isize> = Vec::new();\n\
    \n    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                paren_stack.push(max_depth);\n                max_depth = 0;\n\
    \                depth = 0;\n            }\n            _ => {}\n        }\n \
    \   }\n    paren_stack.push(max_depth);\n\n    for i in paren_stack {\n      \
    \  result.push(i);\n    }\n\n    result"]
stop_tokens:
- "\n}"
