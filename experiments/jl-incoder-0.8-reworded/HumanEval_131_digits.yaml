name: HumanEval_131_digits
language: jl
prompt: "\"\"\"Given a positive integer n, return the product of the odd digits.\n\
  \    Return 0 if all digits are even.\n    For example:\n    >>> digits(1)\n   \
  \ 1\n    >>> digits(4)\n    0\n    >>> digits(235)\n    15\n    \"\"\"\nfunction\
  \ digits(n::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = digits;\n\t@test(candidate(5)\
  \ == 5)\n\t@test(candidate(54) == 5)\n\t@test(candidate(120) == 1)\n\t@test(candidate(5014)\
  \ == 5)\n\t@test(candidate(98765) == 315)\n\t@test(candidate(5576543) == 2625)\n\
  \t@test(candidate(2468) == 0)\nend\n"
completions: ["    if n < 10\n        return n\n    digits_rem(10, n)\nend", "   \
    \ digit = n % 10\n    odddigit = n%(10*2)\n    if odddigit > 0 then digit = digit\
    \ * 2\n    return digit\nend\n</cell>\n<text>\nProblem 3. Write a Julia function\
    \ named is_palindrome that takes an integer as input, and returns True if the\
    \ integer is a palindrome, otherwise returns False. For example, 19 is a palindrome,\
    \ but 90 is not because of the 9 in the middle.", "    if n % 2 == 0:\n      \
    \  return n * digits(n / 2)\n    return 0\n</code>\nFor a more compact approach:\n\
    <code>", "  if n == 0 \n    else if n % 2 == 0 \n      then (n / 2)^digits(n /\
    \ 2)\n      else 0", "    digits(n::Int64) = 0\n    \n    \n    \n    if n < 0\
    \ \n    \n        return 0 if n == 0\n    \n    else if n == 0 \n    \n      \
    \  return 1\n    \n    else \n    \n        if n % 2 == 0 \n    \n           \
    \ digits(n::Int64) = digits(n::Int64)*2\n            \n        else \n    \n \
    \           digits(n::Int64) = digits(n::Int64)*2\n            digits(n::Int64)\
    \ = digits(n::Int64)+1\n            \n    end\n    return digits(n::Int64)\nend\n\
    </cell>\n<code language=julia-1.3>\ndigits(123)\n</cell>\n<text>\nNow we define\
    \ a function digitsof(), which gives the product of the odd digits of the number\
    \ supplied as the first argument:", "    if n == 1 then return 1 \n    else return\
    \ n * digits(n div 2) end\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThe algorithm\
    \ is correct but in python it should be like this `def digits(n):\n    if n ==\
    \ 1:\n        return 1\n    return n * digits(n // 2)`\n<|/ c |>\n<| a dscore=4\
    \ |>\nThis recursive code works by multiplying the digit of a number by itself\
    \ and if the number is odd, by two.\n<code>\ndef digits(n):\n    return n if n\
    \ < 10 else digits (n//10) * (n % 10)\n</code>\n<|/ a tags=math,python,recursion\
    \ |>\n<| a |>\nHere's my solution\n<code>\ndef digits(n):\n    if n<=0:\n    \
    \    return n\n    return digits(n//10) * 10 + n%10\n</code>\n<|/ a dscore=4 tags=math,python,recursion\
    \ |>\n<| a dscore=4 |>\nHere is my solution:\n<code>\ndef digits(n):\n    while\
    \ n:\n        n /= 10\n        n %= 10\n    return n\n</code>\n<|/ a tags=math,python,recursion\
    \ |>\n<| a tags=math,python,recursion |>\nHere is my solution\n<code>\ndef digits(n):\n\
    \    if n<=0:\n        return n\n    else:\n        digits(n//10)*10+(n%10)\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nThis answer would benefit from some explanation.\
    \ Also, your indentation is off.\n<|/ c |>\n<| a tags=math,python,recursion |>\n\
    Here is a solution which takes advantage of the fact that numbers are internally\
    \ represented as binary (base-2) numbers. \n<code>\ndef digits(n):\n    if n==0:\n\
    \       return 0\n    elif n==1:\n       return 1\n    else:\n       return digits(n//10)*10\
    \ + n%10", "  if n % 2 == 0 then 0 else n % 8\nend\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that will compute the least common multiple of two numbers.",
  "    digits(n) = 0\n    if n > 0\n        if n % 2 == 1\n            digits(n) =\
    \ digits(n//2)\n        else\n            digits(n) = digits(n//2)*3\n    end\n\
    \    return digits(n)\nend\n</cell>\n<code language=julia-0.6>\n@time digits(12345678901234)\n\
    </cell>\n<text>\nExercise: Find the greatest common denominator of two positive\
    \ integers\nYou will need to use two variables. One will be the numerator, the\
    \ other will be the denominator. One of these will be zero and the other will\
    \ be the result of the computation.", "    if n==0 then return 1\n    if n==1\
    \ then return 1\n    if n==2 then return 4\n    if n<2 then return 0\n    let\
    \ digits=digitsHelper(n-1)\n    let res=digits%2\n    if res == 0 then return\
    \ digits\n    return digits*(digits//2)\nend\n</cell>\n<code language=julia-1.5>\n\
    digits(1)\n</cell>\n<code language=julia-1.5>\ndigits(4)\n</cell>\n<code language=julia-1.5>\n\
    digits(235)\n</cell>\n<code language=julia-1.5>\ndigits(4)/digits(235)\n</cell>\n\
    <code language=julia-1.5>\ndigits(235)/digits(4)\n</cell>\n<text>\nExercise: What\
    \ would you expect to be returned for digits(234)?", "    if n % 2 == 0 then return\
    \ 0\n    else return digits(n / 2) * (n % 2)\nend\n</cell>\n<code language=julia-1.0>\n\
    digits(8)\n</cell>\n<code language=julia-1.0>\ndigits(2)\n</cell>\n<text>\nMultiplication",
  "    if n <= 0 \n        0\n    else if n % 2 == 0 \n        digits(n/2)\n    else\
    \ \n        digits(n-1)\nend\n</cell>\n<code language=julia-1.5>\n@code_native\
    \ digits(1)\n</cell>\n<code language=julia-1.5>\n@code_native digits(4)\n</cell>\n\
    <code language=julia-1.5>\n@code_native digits(235)\n</cell>\n<text>\nExercise:\
    \ Squaring\nWrite a function digits(n::Int64) which returns the squares of all\
    \ even digits in the given integer. You may assume that the given number is positive.",
  "    digits = Int64(0)\n    for c in digits(n/2)\n        if n%2 == 1\n        \
    \    digits = digits + Int(c) * 2\n    digits = digits + Int(n%2) * 4\n    digits\n\
    end\n</cell>\n<code language=julia-1.5>\ndigits(100)\n</cell>\n<text>\nProblem\
    \ 4.14\nWrite a function called digits_sum that takes any positive integer n and\
    \ returns an integer sum of its digits.\nFor example, digits_sum(1023) should\
    \ return 1023.\nAssume that the numbers are relatively small (less than 100 digits).\n\
    Assume that the function digits_sum does not use recursion or an iterative solution.",
  "    if n % 2 == 1 \n        then 0 else digits(n / 2)\nend\n</cell>\n<code language=julia-1.4>\n\
    digits(6)\n</cell>\n<text>\nProblem 6 (25 points)\nThe Fibonacci numbers, commonly\
    \ denoted F(n) form a sequence, where every number after the first two is equal\
    \ to the sum of the two preceding numbers.", "    if n <= 0 \n        return 0\
    \ \n    digits(n / 10) \n    digits(n % 10) \n    return n \n</code>\n<|/ a tags=recursion,tail-recursion,haskell\
    \ dscore=3 |>\n<| a tags=recursion,tail-recursion,haskell |>\nAs others said,\
    \ your problem can be solved in O(log n) by counting up with each of the digits.\
    \ But this doesn't work with negative numbers, for which we still need to implement\
    \ this in O(n).\nA solution in Haskell is quite similar to Python's recursive\
    \ solution. I'll reuse the example from my previous answer:\n<code>\ndigits ::\
    \ Int -> [Int]\ndigits n = [n `mod` 10] ++ digits (n `div` 10)\n</code>\nThe function\
    \ call digits(n) produces the digit decomposition of the number n in reverse order.\
    \ Note that the recursive call to the function returns a list, so digits(5) ==\
    \ [5, 4, 1].\nThe second line computes the sum of the digits, because digits returns\
    \ a list.\nThe third line adds the number 0 to the list in the right place, because\
    \ it is the only element of the list that should be accumulated in the end.\n\
    For a negative number, the result is the same as the recursive call; for any other\
    \ number, digits(n) will contain all of the digits in reverse, starting with the\
    \ least significant.\n<|/ a dscore=3 |>\n<| c |>\nI like your solution better\
    \ than mine! It avoids creating an auxiliary list.\n<|/ c |>\n<| c |>\nI added\
    \ an explanation to my answer regarding the `digits` function; this doesn't change\
    \ the principle of my answer, but it might be worth including here.\n<|/ c |>\n\
    <| c |>\nI appreciate your explanation, although I disagree that it adds an explanation\
    \ to my answer.\n<|/ c |>\n<| c |>\nI added this explanation to my answer. I had\
    \ to include it because I think it's relevant to the discussion, and because `digits`\
    \ is an important function that people often find themselves in search of. I thought\
    \ this explanation would be helpful to people who read this in the future.\n<|/\
    \ c |>\n<| a |>\nHere is my solution:\n<code>\nf :: Int -> Int\nf n = product\
    \ [d | (n, d) <- zip [1..] $ reverse (digitsToList n), d /= 0]\n    where product\
    \ = foldl' (*) 1 [0..]\n</code>\nThis solution does not generate intermediate\
    \ lists, but it does generate an intermediate product. If this matters, this is\
    \ still O(n).\n<|/ a tags=recursion,tail", "    if n == 0 \n        0\n    else\n\
    \        n % 2 == 0 \n            ? n * digits(n / 2)\n            : n * digits(n\
    \ / 2) + digits(n % 2)\nend\n\"\"\"\n\"\"\"\n## Excercise: Write a function called\
    \ `is_palindrome` that will return True if a\n## given string is a palindrome,\
    \ and False otherwise. \n\"\"\"", "    if n == 0 return 0\n    digits_sum = 0\n\
    \    while n != 0 do\n        digits_sum += n % 10\n        n = n / 10\n    end\n\
    \    return digits_sum\nend\n</cell>\n<code language=julia-1.0>\ndigits(0)\n</cell>\n\
    <code language=julia-1.0>\ndigits(-4)\n</cell>\n<code language=julia-1.0>\ndigits(-42)\n\
    </cell>\n<code language=julia-1.0>\ndigits(-55)\n</cell>\n<code language=julia-1.0>\n\
    digits(-555)\n</cell>\n<text>\nProblem 15. Compute the sum of all the numbers\
    \ with two digits.\nWrite a julia function twodigits where n is a positive integer\
    \ and return the sum of all the numbers with two digits.\nFor example:\n>>> twodigits(1)\n\
    1\n>>> twodigits(2)\n1\n>>> twodigits(7)\n11\n>>> twodigits(20)\n42\n>>> twodigits(27)\n\
    42\n>>> twodigits(35)\n43\n>>> twodigits(43)\n43\n>>> twodigits(54)\n44\n>>> twodigits(454)\n\
    44\n>>> twodigits(554)\n44\n>>> twodigits(5545)\n44\n>>> twodigits(45545)\n44\n\
    >>> twodigits(345545345)\n45\n>>> twodigits(4554534554)\n45\n>>> twodigits(54534534554)\n\
    45\n>>> twodigits(234534534554)\n45\n>>> twodigits(54534534545)\n45\n>>> twodigits(45545345545)\n\
    45\n>>> twodigits(2345345345545)\n45\n>>> twodigits(345545345545)\n45\n>>> twodigits(34554534554534)\n\
    45\n>>> twodigits(34554534554534534)\n45\n>>> twodigits(34554534554534534534)\n\
    45\n>>> twodigits(34554534554534534534534)\n45\n>>> twodigits(34554534554534534534534534)\n\
    45\n>>> twodigits(34554534554534534534534534534)\n45\n>>> twodigits(34554534554534534534534534534534)\n\
    45\n>>> twodigits(34554534554534534534534534534534534)\n45\n>>> ", "    if n ==\
    \ 0 || n == 1  \n        return 1  \n    else if n  == 2  \n        return 2 \
    \ \n    else\n        digits(int(n/10)) \n        * digits(n % 10) + digits(n\
    \ % 10*(n % 100 + n/1000))\n    end\nend", "    if n % 2 == 0 \n        then n\
    \ \n        else 0\n    else \n        digits(n//2)\nend \n</code>\nIt also takes\
    \ care of negative numbers and zeroes.\n<|/ a dscore=0 |>\n<| c |>\nThis is recursive\
    \ solution to factorial. Factorial can be solved without recursion.\n<|/ c |>\n\
    <| c |>\nYes, but it is not the fastest solution. I am not saying this is the\
    \ fastest solution but it is an alternative solution to the original problem.\n\
    <|/ c |>\n<| c |>\nActually, this is a recursive solution to a recursive problem\
    \ which is also a recursive problem. It's also a recursive solution to factorial\
    \ problem (which is NP-complete). I think this solution is very good. I am going\
    \ to rewrite it using tail recursion and I will post it later when I am done.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's an iterative solution:\n<code>", "    digits(n).digits(n).sum\n\
    end", "    \"\"\"Given a positive integer n, return the product of the odd digits.\n\
    \    Return 0 if all digits are even.\n    For example:\n    >>> digits(1)\n \
    \   1\n    >>> digits(4)\n    0\n    >>> digits(235)\n    15\n    \"\"\"\n   \
    \ if n<0: return 0\n    if n==0: return 1\n    if n%2==0: return digits(n-1)*n\n\
    \    return digits(n/2)*n \nend\n</cell>\n<text>\nExercise 2: Recursion\nGiven\
    \ a recursive function digits(n) that computes the product of the digits of the\
    \ integer n.  Implement digits(n) recursively to solve the problem:\nGiven a positive\
    \ integer n, return the product of the odd digits.\nReturn 0 if all digits are\
    \ even.\nFor example, \n    >>> digits(1)\n    1\n    >>> digits(4)\n    0\n \
    \   >>> digits(235)\n    15\nExercise: Write the definition of the function digits(n)\
    \ in the cell below and test it using the cell:", "    if n < 0 \n        error(\"\
    digits(Int64): n must be positive\")\n    if n < 10 \n        1\n    else\n  \
    \      n % 10 * digits(n / 10)\nend\n</code>\nLet's try it out:\n<code>\njulia>\
    \ digits(1)\n1", "  if n < 0 \n  then 0\n  else \n    if n & 1\n    then 1\n \
    \   else digits(n / 2)\n</code>\n<|/ a tags=recursion,haskell,algorithm |>\n<|\
    \ c |>\nHow is this a recursive function? I don't see any tail recursion.\n<|/\
    \ c |>\n<| c |>\nI said tail recursion, that's why I used that term.  My mistake,\
    \ I'll remove that comment :)\n<|/ c |>\n<| c |>\nAhhh, I see!  I was thinking\
    \ that this wasn't tail recursive because it was calling itself twice in each\
    \ branch...\n<|/ c |>\n<| c |>\nIt's tail recursive as in tail recursion.\n<|/\
    \ c |>\n<| a |>\n<code>\nimport Data.List", "    digits::Int64 = 0\n    for digit\
    \ in digits(n mod 10) do \n        digits::Int64 = digits * 10 + digit\n    digits::Int64\
    \ = n mod 10\n    return digits\nend\n\"\"\"\n    digits(n::Int64)::Int64\n  \
    \  \"\"\"\nGiven a positive integer n, return the product of the odd digits.\n\
    \    Return 0 if all digits are even.\n    For example:\n    >>> digits(1)\n \
    \   1\n    >>> digits(4)\n    0\n    >>> digits(235)\n    15\n    \"\"\"", " \
    \   if n < 0\n        return 0\n    \n    digits = n.digits\n    \n    if digits[1]\
    \ == 0 | digits[2] == 0 | digits[3] == 0 | digits[4] == 0\n        0\n    else\
    \ \n        digits[1] * digits[2] * digits[3] * digits[4]\n    end\nend", "  \
    \  if n < 10 \n        return n\n    else \n        return digits(n//10) * (n\
    \ % 10)", "    if n == 1 then return 1\n    if n % 2 = 0 then return digits(n\
    \ div 2)\n    return digits(n div 2) + 1\nend\n</cell>\n<code language=julia-1.1>",
  "    if n==0 then return 1\n    if n%2==0 then return n*digits(n//2)\n    else return\
    \ digits(n-1)*n\nend \n</cell>\n<code language=julia-0.4>", "\"\"\"\n    >>> digits(0)\n\
    \    0\n    >>> digits(1)\n    1\n    >>> digits(2)\n    1\n    >>> digits(3)\n\
    \    2\n    >>> digits(4)\n    0\n    >>> digits(5)\n    1\n    >>> digits(2345)\n\
    \    123\n    >>> digits(123456789)\n    932\n    >>> digits(987654321)\n    1098\n\
    \    \"\"\"", "    if n < 10 \n    then n \n    else digits(div(n,10)) * (n %\
    \ 10) + digits(n / 10) \nend\n</code>\nThe last function can be easily modified\
    \ to add or remove digits.\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\ndigits(x)\
    \ = digits(x / 10) * 10 + digits(x % 10)\n</code>\n<|/ a tags=recursion,julia\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value\n<|/ c |>\n<| c |>\nWelcome to Stack Overflow! While this code snippet\
    \ may solve the question, [including an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| a dscore=0 |>\n<code>\ndigits(x::Int)\
    \ = digits(x/10) * 10 + digits(x % 10)", "    if n < 0\n    0 else if n < 10 \n\
    \    1 else n * digits(n-1) // 10\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYou might\
    \ want to add a description of what the code is doing - and why it works.\n<|/\
    \ c |>\n<| c |>\nIt's not clear whether `n` is an Integer or something else -\
    \ it seems to depend on the type.\n<|/ c |>\n<| c |>\n`digits` function expects\
    \ input as `Int64`, not `Int`.\n<|/ c |>\n<| a |>\nA simple way to get rid of\
    \ digits is to use floor division:\n<code>\ndef digits(n::Int)::Int\n    div =\
    \ n // 10\n    mod <- (n % 10) * (n // 10)\n    return div + mod\n</code>\nThis\
    \ works because floor division truncates any decimal fraction and thus leaves\
    \ only the integer part of the number.\n<|/ a tags=recursion,types,haskell dscore=1\
    \ |>\n<| a tags=recursion,types,haskell |>\n<code>\ndigits :: Int -> Int\ndigits\
    \ = foldl f 0\n    where f 0 xs = xs\n          f xs xs = x : (digits xs ++ xs)\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis implementation is just wrong. The only\
    \ right answer would be `digits = map reverse . words`. And then it makes no sense\
    \ to do anything else. `words` already returns the list of digits in the right\
    \ order.\n<|/ c |>\n<| c |>\nI appreciate your corrections however this doesn't\
    \ answer the question.\n<|/ c |>\n<| c |>\nIt's still wrong, though. And it's\
    \ more complicated than it needs to be anyway.\n<|/ c |>\n<| c |>\nActually I\
    \ meant \"wrong\" in the sense that it's an inefficient implementation. You could\
    \ do better.\n<|/ c |>\n<| c |>\n`map (reverse .)` is `fmap (reverse .)`. You\
    \ mean `fmap (reverse.) . (map (reverse . ))`.\n<|/ c |>\n<| a tags=recursion,types,haskell\
    \ |>\nI understand it wants you to return a list of digits, not a number. You\
    \ can use mod 10 to get the last digit, and integer division to get the rest:\n\
    <code>\ndigits :: Int -> [Int]\ndigits 0 = []\ndigits n = digits (n/10) ++ [mod\
    \ n 10]\n</code>\n<|/ a dscore=", "    if n < 10 \n        return n\n    if n\
    \ % 2 == 1 \n        return digits(n / 10) * 10\n    return digits(n / 2) * 10\
    \ + digits(n / 2)\nend\n</cell>\n<code language=julia-1.5>\ndigits(123456789)\n\
    </cell>\n<text>\nWe can also define this recursively instead of using a loop.",
  "  if n==0 \n    1 \n  elseif n%2 \n    digits(n/2)\n  else \n    digits(n-1)\n\
    \  end \nend\n</cell>\n<text>\nExercise 6: Write a recursive function is_palindrome(n)\
    \ that takes an\ninteger n and checks whether the integer is a palindrome. If\
    \ it is,\nreturn true, otherwise, return false.", "    # ...\n    if n < 1\n \
    \       return 0\n    # ...\n    digits = 1\n    while n > 0\n        if n % 2\
    \ == 1\n            n = n / 10\n        else\n            digits = digits * 10\n\
    \        n = n / 10\n    return digits", "    if n < 0 \n        error(\"n must\
    \ be positive\")\n    if n == 0 \n        0 \n    else if n < 10 \n        1\n\
    \    else if n < 100 \n        2 * digits(n / 10) \n    else if n < 1000 \n  \
    \      3 * digits(n / 100) \n    else if n < 10000 \n        4 * digits(n / 1000)\
    \ \n    else if n < 100000 \n        5 * digits(n / 10000) \n    else if n < 1000000\
    \ \n        6 * digits(n / 100000) \n    else if n < 10000000 \n        7 * digits(n\
    \ / 1000000) \n    else if n < 100000000 \n        8 * digits(n / 10000000) \n\
    \    else if n < 1000000000 \n        9 * digits(n / 1000000000) \n    else if\
    \ n < 10000000000 \n        10 * digits(n / 10000000000) \n    else \n       \
    \ error(\"Overflow\")\nend\n</code>\nAnd now we can use the function digits to\
    \ find the product of the odd digits:\n<code>\ndigits(123) # returns 3\ndigits(234)\
    \ # returns 0\n</code>\n<|/ a tags=math,recursion,julia,number-theory |>\n<| a\
    \ |>\nAn alternative way could be using BigInts:\n<code>\njulia> const digits\
    \ = (big) -> b\ndigits (generic function with 1 method)", "    if n == 0 then\n\
    \        return 0\n    elseif n >= 10^9 then\n        return 0\n    else\n   \
    \     digits(n//10)\n        n % 10\n    end\nend\ndigits(3)\n</cell>\n<text>\n\
    We can do some basic testing to see that this function works for various cases.\
    \ First, let's try it for positive numbers:", "    return 0\nend", "  if n % 2\
    \ == 0\n    0 \n  else if n % 2 == 1\n    n\n  else\n    digits(n / 2) * digits!(n\
    \ / 2)\nend\n\"\"\"\nGiven a positive integer n, return the sum of its digits.\n\
    \    Return 0 if all digits are 0.\n    For example:\n    >>> digits(1)\n    0\n\
    \    >>> digits(4)\n    4\n    >>> digits(235)\n    22\n    \"\"\"", "    if n\
    \ % 2 == 0\n        return 0\n    else: \n        return (n & 1) * digits(n >>\
    \ 1)\nend\n\"\"\"\nNow we define a function that returns the sum of the digits\
    \ of the number:\n\"\"\"", "    return (if n%2 != 0 then 0 else 1) * (n-1)\nend\n\
    </cell>\n<text>\nExercise 2\nWrite a function that will convert any string into\
    \ a list splitting the string into individual characters. The first character\
    \ should be the first element in the list (index 0). Your function should throw\
    \ an error if the string is not a string or the string has fewer than two characters.\
    \ For example:", "    if n == 0\n        return 0\n    if n < 10\n        return\
    \ n * digits(n/10)\n    n %= 10\n    p := digits(n/10)\n    q := digits(n / 10)\n\
    \    return p * q * 10\nend\n</code>\n<|/ a tags=math,algorithm dscore=0 |>\n\
    <| a tags=math,algorithm dscore=0 |>\nIn pseudo-code:\n<code>\ndigits(n)\n  if(n\
    \ == 0)\n      return 0\n  if(n == 1)\n      return 1\n  return ((digits(n/10)*10)\
    \ + digits(n%10))\n</code>\n<|/ a |>\n<| a |>\nA short solution using recursion:\n\
    <code>\nint digits(int n) {\n    return n == 0 ? 0 : (n == 1 ? 1 : (n%2 == 1 ?\
    \ digits(n/10) : 3*digits(n%10)))\n}\n</code>\n<|/ a tags=math,algorithm dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\nint digits(int n) {\n    return n<10 ? 1 : n%10\
    \ + digits(n/10);\n}\n</code>\n<|/ a tags=math,algorithm |>\n<| a dscore=0 tags=math,algorithm\
    \ |>\nHere's a python implementation:\n<code>\ndef digits(n):\n    if n == 0:\n\
    \        return 0\n    elif n == 1:\n        return 1\n    else:\n        return\
    \ (digits(n/10)*10) + digits(n%10)", "    if n == 0 then 0\n    else if n mod\
    \ 2 == 0 then n / 2\n    else digits(n / 2)\nend \ndigits(n)", "    if n<0\n \
    \   then return 0\n    else if n%2==0\n    then return (n/2)\n    else return\
    \ 0\n    end if\nend\n</cell>\n<text>\nExercise 7.16\nUsing digits(n), write a\
    \ function that returns the sum of digits of the integer n.", "    digits = 0\n\
    \    while n > 0 \n        digits = 2*digits*(n - trunc(n))\n        n = trunc(n)\n\
    \    return digits\nend\n</cell>\n<code language=julia-0.5>\n@assert digits(1)\
    \ == 1 digits(4) == 0 digits(235) == 15\n</cell>\n<text>\nA digital root is an\
    \ integer which is one less than another, but only if that other integer is a\
    \ perfect square. For example, 32 = 21 + 22 + 23, but 21 = 1\xB2 + 2\xB2 + 3\xB2\
    , so 32 is not a perfect square.", "    if n == 0 \n        0\n    elseif n %\
    \ 2 == 0 \n        digits(n / 2)\n    else\n        digits(n / 2) * 3 + 1\nend\n\
    </cell>\n<text>\nAs a final example of digits, let's look at how fast digits()\
    \ performs on bignums.  We will compare it to the digits(n) function defined above.",
  "    if n == 0 \n    then return 0\n    else \n        return n `mod` 10 `mod` 10\n\
    \    end\nend", "    if n % 2 == 1\n        return n * digits(div(n,2)) \n   \
    \ else \n        return div(n,2)\nend", "    if n == 0 \n        1 \n    else\
    \ \n        digits(n / 10)*10 + n % 10\n    \n    \"\"\"This function counts the\
    \ number of digits in a given integer.\n    It should be used to count the number\
    \ of digits in integer inputs,\n    for instance, in the function digits(2).\"\
    \"\"", "    if n<0 then\n        return 0 \n    else\n        return n * digits(n-1)\
    \ \n    end\nend\n</cell>\n<code language=julia-1.0>\n@show digits(6)\n</cell>\n\
    <code language=julia-1.0>\n@show digits(20)\n</cell>\n<code language=julia-1.0>",
  "    if n==0 then 0 else return n*digits(n-1)\n</code>\n<|/ a tags=julia,recursion\
    \ |>\n<| c |>\nThe last example is wrong, since it returns `1*2*3*4*5*6*7*8*9*10`.\n\
    <|/ c |>\n<| c |>\nThe last example was incorrect, fixed it.\n<|/ c |>\n<| a dscore=1\
    \ |>\nThe solutions above are nice and concise, but I wanted to see how one would\
    \ accomplish the same thing with only one recursive call, using a while loop to\
    \ iterate over digits in the original number. This solution uses two recursive\
    \ calls, one to compute the number of digits in n and the second to iterate over\
    \ those digits:\n<code>", "    n %% 2 == 0 && return n % 2 * 2 * n / 6 * 6 * n\
    \ / 24 * 24 * n / 120\n    else return 0\nend\n</cell>\n<text>\nNow that we have\
    \ defined digits, we can use it in the function factorial:", "    return prod(take(digits(ceil(n/2)),\
    \ n%2))\nend \n</cell>\n<text>\nFor this exercise, we will continue to use the\
    \ digits function you wrote in the previous exercise.", "    if n < 0\n      \
    \  error(\"n must be positive\")\n    elif n == 0\n        0\n    else\n     \
    \   2 * digits(floor(Int64(n/2)))\n    end\nend\n</code>\n<|/ a |>\n<| c |>\n\
    That `Int64(n)` bit is very important!  I had been trying to figure out how to\
    \ add more type information and that was not working.\n<|/ c |>\n<| c |>\nThis\
    \ fails on the first iteration: it doesn't take into account that digits(1) returns\
    \ 1, but digits(1) returns 0.\n<|/ c |>\n<| c |>\nThis fails on the first iteration:\
    \ it returns 0, but digits(1) returns 1. Fix your algorithm for 0.\n<|/ c |>\n\
    <| c |>\nThis fails on the first iteration: it returns 0, but digits(1) returns\
    \ 1. Fix your algorithm for 0.\n<|/ c |>\n<| c |>\nThis fails on the first iteration:\
    \ it returns 0, but digits(1) returns 1. Fix your algorithm for 0.\n<|/ c |>\n\
    <| a dscore=4 |>\n<code>\ndef digits(n::Int64)::Int64\n    sum = 0\n    digit\
    \ = n % 10", "    for i in 0..n-2\n        if isOdd(n)\n            n /= 2\n \
    \       else\n            return i\n    return 0\nend\n</cell>\n<text>\nProblem\
    \ 3\nWrite a function that returns the sum of all the numbers in the array. Ignore\
    \ negative numbers.\nThe function should take in an array, x, and return the sum\
    \ of all elements in the array.", "    if n==0 then return 0 \n    else if n %\
    \ 2==0 then return n*digits(n/2)\n    else return n*digits(n/2+1)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for your answer! I actually got it to work, but I'm\
    \ still not fully sure why it worked.\n<|/ c |>\n<| c |>\nIn Haskell, you don't\
    \ need to write `return` after a function; it automatically returns whatever you\
    \ last evaluated.\n<|/ c |>\n<| c |>\nThanks for the tip! I'm still new to Haskell\
    \ and didn't know that. :)\n<|/ c |>\n<| c |>\nThis algorithm is inefficient,\
    \ because it doesn't terminate for larger values of `n`, i.e. it just keeps multiplying\
    \ `n/2` instead of `n` until `n` is 1, then returns `0`. A simple fix would be\
    \ to start with `n = 2` instead of `1`, because then it will terminate immediately\
    \ (since `n/2` will always be `0` for `n = 1`).\n<|/ c |>\n<| c |>\nYou're right,\
    \ I forgot to mention that. I'll edit my answer accordingly.\n<|/ c |>\n<| a |>\n\
    Here's an implementation that's tail-recursive and uses foldr (like an accumulator\
    \ in other languages):\n<code>\ndigits(1::Int) = digits(2) : [1]\ndigits(2::Int)\
    \ = 2 : digits(3) : [1]\ndigits(3::Int) = 4 : digits(5) : [1]\ndigits(4::Int)\
    \ = 8 : digits(6) : [1]\ndigits(5::Int) = 10 : digits(7) : [1]\ndigits(6::Int)\
    \ = 12 : digits(8) : [1]\ndigits(7::Int) = 16 : digits(9) : [1]\ndigits(8::Int)\
    \ = 18 : digits(10) : [1]\ndigits(9::Int) = 12 : digits(11) : [1]\ndigits(10::Int)\
    \ = 12 : digits(11) : [1]\ndigits(11::Int) = 12 : digits(12) : [1]\ndigits(12::Int)\
    \ = 12 : [1]\n</code>\nThe idea is that we start with a list containing only the\
    \ first digit, 2. Then, we multiply the rest of the list by 2, and then by 4,\
    \ and so on until we reach 1, which is at the end of the list. Since we're multiplying\
    \ by 2, we only need to multiply by 2 until we reach 1, and the rest is just multiplication\
    \ by 2. So we can use the fact that multiplication by 2 is the same as addition\
    \ by 2, and we can use the fact that multiplication ", "\"\"\"\n\"\"\"\n## `digits_odd()`\
    \ implementation\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\
    \"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n\"\"\"\n## `digits_odd()` implementation\n\
    Given a positive integer n, return the product of the odd digits.\nReturn 0 if\
    \ all digits are even.\n\"\"\"", "  n = n - 1\n  while n % 2 == 0 do\n    n =\
    \ n / 2\n  end\n  return n\nend\n</cell>\n<code language=julia-1.0>\ndigits(4)\n\
    </cell>\n<text>\nTask 20: Recursive function digits", "    digits = 1\n    for\
    \ n in n:\n        if n % 2 == 1:\n            digits *= 2\n    return digits\n\
    </code>\nTo get this to work on your machine, I had to update my local version\
    \ of R to version 4.0 from the RStudio IDE because I couldn't get the local version\
    \ of R to upgrade to version 4.0. The RStudio installation from GitHub has the\
    \ version 4.0 installed, but not the R version.\n<|/ a tags=r,product,integer\
    \ |>\n<| a dscore=0 |>\nSince I could not find this question earlier, here is\
    \ the solution using gmp package\n<code>\nlibrary(gmp)\ndigits(prod(gmp::as.bigz(123456)))\n\
    #[1] 14\n</code>\n<|/ a tags=r,product,integer |>\n<| a dscore=0 |>\nFor those\
    \ of us who just want to get the product of all the digits in the number without\
    \ using the package gmp, here is an alternative using gmp's multiply function.\
    \ \n<code>\n> digits(prod(mpfr(123456)))\n[1] 14\n</code>\n<|/ a tags=r,product,integer\
    \ |>\n<| a dscore=0 |>\nHere is a solution without package gmp:\n<code>\ndigits(prod(as.bigz(123456)))\n\
    </code>\n<|/ a tags=r,product,integer |>\n<| a |>\nThe gmp package is great! But\
    \ for other uses, you can also try the Reduce() function from the purrr package.\n\
    <code>\nlibrary(purrr)", "    digits = Int64(0)\n    for k in 1:n do\n       \
    \ if mod(n, k) == 0 then\n            digits *= k\n        end\n    end\n    return\
    \ digits\nend\n</cell>\n<text>\nExercise 6: Digit sum", "    if n < 10\n     \
    \   1\n    else\n        if n % 2 == 1\n            0\n        else\n        \
    \    if n % 3 == 1\n                1\n            else\n                digits(n\
    \ / 10)\n        end\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=recursion,fibonacci,julia\
    \ |>\nThe easiest solution (i.e. the one which doesn't need an additional parameter)\
    \ is the following:\n<code>", "    if n == 0\n        return 0;\n    else if n\
    \ == 1\n        return 1;\n    else\n        return digits(n / 2) * digits(n mod\
    \ 2)\n    end\nend\n\"\"\"\n    Exercise 3\n    \n    Write a function that returns\
    \ the sum of all the digits in a given number.\n    You can assume that the number\
    \ is positive.\n    \"\"\"", "if n%2 == 0 \nthen \n    return n / 10\nelse \n\
    \    return n*digits(n-1) + digits(n%10)\nend\n</cell>\n<text>\nExercise: Write\
    \ a function that takes a number and returns the sum of the odd digits of the\
    \ number rounded to a certain precision. Recall that to round to an n digits of\
    \ precision, one should round upwards if n<10 and downwards if n>10. For example,\n\
    \    given 3.141592653589793 and the precision of 3, the function should return\
    \ 3.\n    given 4.5 and precision of 2, the function should return 4.\n    given\
    \ 4.6 and precision of 3, the function should return 4.\n    given 4.7 and precision\
    \ of 3, the function should return 4.\n    given 4.8 and precision of 2, the function\
    \ should return 5.\n    given 4.9 and precision of 3, the function should return\
    \ 4.\n    given 5.0 and precision of 3, the function should return 4.\n    given\
    \ 5.1 and precision of 3, the function should return 5.\n    given 5.2 and precision\
    \ of 3, the function should return 5.\n    given 5.3 and precision of 3, the function\
    \ should return 5.\n    given 5.4 and precision of 3, the function should return\
    \ 5.\n    given 5.5 and precision of 3, the function should return 5.\n    given\
    \ 5.6 and precision of 3, the function should return 5.\n    given 5.7 and precision\
    \ of 3, the function should return 5.\n    given 5.8 and precision of 3, the function\
    \ should return 5.\n    given 5.9 and precision of 3, the function should return\
    \ 5.\n    given 6.0 and precision of 3, the function should return 6.\n    given\
    \ 6.1 and precision of 3, the function should return 6.\n    given 6.2 and precision\
    \ of 3, the function should return 6.\n    given 6.3 and precision of 3, the function\
    \ should return 6.\n    given 6.4 and precision of 3, the function should return\
    \ 6.\n    given 6.5 and precision of 3, the function should return 6.\n    given\
    \ 6.6 and precision of 3, the function should return 6.\n    given 6.7 and precision\
    \ of 3, the function should return 6.\n    given 6.8 and precision of 3, the function\
    \ should return 6.\n    given 6.9 and precision of 3, the function should return\
    \ 6.\n    given 7.0 and precision of 3, the function should return 7.\n    given\
    \ 7.1 and precision of 3, the function should return 7.\n    given 7.2 and precision\
    \ of 3, the function should return 7.\n    given 7.3 and precision of 3, the function\
    \ should return 7.\n    given 7.4 and precision of 3, the ", "    \"\"\"Given\
    \ a positive integer n, return the product of the odd digits.\n    Return 0 if\
    \ all digits are even.\n    For example:\n    >>> digits(1)\n    1\n    >>> digits(4)\n\
    \    0\n    >>> digits(235)\n    15\n    \"\"\"\n    digitsum::Int64\n    digitsum::Int64\
    \ = 0\n    digitsum::Int64 = if n % 2 != 0 then 0 else 1\n    digitsum::Int64\
    \ = if n > 0 then digitsum * n else digitsum\n    digitsum::Int64 = digitsum *\
    \ digits(Int(n)-1)\n    digitsum::Int64 = digitsum * digits(Int(n)/2)\n    digitsum::Int64\
    \ = digitsum * digits(Int(n)/3)\n    digitsum::Int64 = digitsum * digits(Int(n)/4)\n\
    \    digitsum::Int64 = digitsum * digits(Int(n)/5)\n    digitsum::Int64 = digitsum\
    \ * digits(Int(n)/6)\n    digitsum::Int64 = digitsum * digits(Int(n)/7)\n    digitsum::Int64\
    \ = digitsum * digits(Int(n)/8)\n    digitsum::Int64 = digitsum * digits(Int(n)/9)\n\
    \    digitsum::Int64 = digitsum * digits(Int(n)/10)\n    return digitsum", " \
    \   if n<0 \n        return n\n    if n%2 == 0 \n        return n\n    if n%2\
    \ != 0 \n        return n%2\n    while n > 1 \n        if n%2 != 0 \n        \
    \    return n%2\n        n /= 2\n    return 0\n\"\"\"\n## Problem 6", "    digit::Int64\
    \ = 0\n    for i in 1:n do\n        digit *= i%10\n        digit %= 10\n    return\
    \ digit\n\"\"\"\n</cell>\n<code language=julia-0.6>\ndigits(235)\n</cell>\n<text>\n\
    Exercise", "    if isodd(n):\n        return 1\n    if n==0 || n==1:\n       \
    \ return 1\n    return n*digits(floor(n/2))\n\"\"\"\n## Problem 8: Find a product\
    \ of three digits.\n## First approach:\n\"\"\"", "    if n % 2 == 1 \n       \
    \ == n\n    else \n        == n * digits(n / 2)\nend\n</cell>\n<text>\nExercise\n\
    Implement the fib() function, which returns the nth Fibonacci number, given its\
    \ integer $n$:", "    even = div(n, 2)\n    if even % 1 == 0\n        digits_sum\
    \ = 0\n    else\n        digits_sum = div(n, 10)\n    end\n    return digits_sum\n\
    end\n</cell>\n<code language=julia-1.5>\ndigits(435)\n</cell>\n<code language=julia-1.5>\n\
    digits(-3)\n</cell>\n<text>\nProblem 5\nWrite a function that returns a list of\
    \ all positive integers that are less than or equal to $n$ in absolute value.\
    \ You may use the $div$ function; it may be helpful for your function.", "   \
    \ if n % 2 == 1\n        return n\n    else \n        digits(n/2)\n    end \n\
    end\n</cell>\n<code language=julia-1.3>\ndigits(12345)\n</cell>\n<text>\nWrite\
    \ a function that calculates the GCD of three numbers, using Euclid's Algorithm.",
  "    if n==0 return 0\n    else return digits(n/10) * 10\nend\n\"\"\"\nReturn the\
    \ sum of all digits.\nFor example:\n>>> digits(1)\n1\n>>> digits(7)\n1\n>>> digits(235)\n\
    17\n\"\"\"", "    \"\"\"Given a positive integer n, return the product of the\
    \ odd digits.\n    Return 0 if all digits are even.\n    For example:\n    >>>\
    \ digits(1)\n    1\n    >>> digits(4)\n    0\n    >>> digits(235)\n    15\n  \
    \  \"\"\"\n    prod = 1\n    if n % 2 == 1:\n        prod = 0\n    while n > 0\
    \ and n % 2 == 1:\n        n /= 2\n    return prod\n</cell>\n<text>\nQuestion\
    \ 1\nIn the cell below, write a function to return the first n characters of the\
    \ Fibonacci sequence where each character is a natural number.", "    if n<2 return\
    \ 0\n    if n==2 return 1\n    p := 0\n    for i in 0:n step -1 do\n        p\
    \ = (p*10) + digit(n%10)\n        n /= 10\n    return p\n\"\"\"\n>>> digits(235)\n\
    15\n>>> digits(8)\n8\n>>> digits(6)\n0\n>>> digits(10)\n0\n\"\"\"", "    if n\
    \ < 10 then\n        return n\n    else \n        return digits(n / 10) * 10 +\
    \ n % 10\nend\n\"\"\"", "    if n == 0 \n        return 1 \n    else \n      \
    \  return 0 if n % 2 == 1 else digits(n / 2)", "  if n < 0 \n    return 0\n  elseif\
    \ n < 10\n    return 1\n  elseif n < 100\n    return 3 * n\n  elseif n < 1000\n\
    \    return 3 * 3 * n\n  elseif n < 10000\n    return 3 * 3 * 3 * n\n  elseif\
    \ n < 100000\n    return 3 * 3 * 3 * 3 * n\n  elseif n < 1000000\n    return 3\
    \ * 3 * 3 * 3 * 3 * n\n  elseif n < 10000000 \n    return 3 * 3 * 3 * 3 * 3 *\
    \ 3 * n\n  elseif n < 100000000\n    return 3 * 3 * 3 * 3 * 3 * 3 * 3 * n\n  elseif\
    \ n < 1000000000\n    return 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * n\n  elseif n < 10000000000\n\
    \    return 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * n\n  elseif n < 100000000000\n\
    \    return 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * n\n  else\n    return 0\n\
    \  end\nend", "    \"\"\"\n    * `digits` - given a positive integer n, return\
    \ the product of the odd digits\n    * `digits` - given a positive integer n,\
    \ return the product of the odd digits\n    \"\"\"\n    let x = floor(Int64, n/2)\n\
    \    let a = mod(n, 2)\n    let b = (x/2)\n    let c = mod(x, 2)\n    let d =\
    \ mod(x, 2)\n    if a == 0\n        then b\n        else if d == 0 \n        \
    \    then c\n            else d * digits(Int(floor(b/2)*2)*2)\nend\n</cell>\n\
    <code language=julia-1.5>\ndigits(2)\n</cell>\n<text>\nDigit sums\nGiven a positive\
    \ integer n\nReturn the sum of all its digits, starting with zero.\nFor instance,\
    \ if the input is 10, the sum is 1 + 0 + 0 + 9 + 0 + 8 + 0 + 0 + 0 + 0 + 0 + 0\
    \ + 0 + 0 = 10.", "    if n <= 0\n        0\n    elseif n % 2 == 0\n        digits(n\
    \ / 2) * (n % 2)\n    else\n        digits(n / 2) * 3\n    end\nend\n</cell>\n\
    <code language=julia-1.3>\ndigits(236)\n</cell>\n<text>\n4.\nImplement the function\
    \ digits(n::Int64) which returns n's digits as an Int64.\ndigits is implemented\
    \ using recursion.", "    if n<0\n        return 0 \n    elseif n<10\n       \
    \ return 1 \n    elseif n<100\n        return (n-2*n%2)*digits(n/2) \n    else\n\
    \        return (n-2*n%2)*digits(n-2*n/2)\nend \n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=recursion,prolog,fibonacci,list |>\n<code>\nfibs(0,1).\nfibs(1,1).\n\
    fibs(X,Y) :- Y is X+Y.\nfibs(X,Z):-fibs(X,Z).\nfibs(X,Y):-Z is X*Y+Z1.\nfibs(X,Y):-Z\
    \ is X*Y+Z1,fibs(Z1,Z).\n</code>\n<|/ a dscore=0 |>\n<| a |>\nUsing iterative\
    \ fibonacci in prolog\n<code>\nfibs(N,F) :-\n    fibs(0,1,1,F),\n    write(F),nl,fail.\n\
    fibs(N,F1,F2,F) :-\n    Z is F1+F2,\n    fibs(Z,F1,F2,F).\nfibs(N,F1,F2,F) :-\n\
    \    Z is F1+F2,\n    Z1 is F1+F2,\n    fibs(Z1,F2,F,F).\n</code>\n<|/ a tags=recursion,prolog,fibonacci,list\
    \ dscore=0 |>\n<| a |>\nRecursive approach using tail recursion:\n<code>\nfibonacci_rec(0,\
    \ 1, 1, []):-\n    !.", "    if n==0 \n        return 0 \n    digits = zeros(10)\n\
    \    digits[1:] = 1:10\n    return product((digits[i]:digits[i+1]-1)for i in (2:n-1))\n\
    end", "    if n < 10 return n\n    let even = n % 2 != 0\n    if even then return\
    \ 0\n    else if n < 10 then return n \n    else return n * digits(n / 10)\nend\n\
    </code>\n<|/ a tags=recursion,julia |>\n<| a tags=recursion,julia |>\nHere is\
    \ a recursive solution that should scale to very large numbers (I'm assuming you\
    \ don't want this solution to take more than 100 seconds for even larger numbers):\n\
    <code>\ndigits(n::Int64)::Int64", "    if n == 0 \n        0\n    else\n     \
    \   n - odddigits(n) \nend ", "    return n %% 10 + (n div 10)*(n div 10)\nend\
    \ \"\"\"", "\"\"\"\n    digits(n) = n and n.rem == 0 and n.pred or 0\nend\n</cell>\n\
    <text>\nLet's write a function that returns the factorial of a given number.",
  "  if n % 2 == 0 \n    0 else digits(n / 2)\n  if n % 2 == 1 \n    else n * digits(n\
    \ / 2)\ndigits(_) = 0", "\"\"\"\n    digits = zeros(Int64, 2)\n    digits[1] =\
    \ n // 2 % 2\n    digits[2] = n // 3\n    return digits[1] * digits[2]\nend\n\"\
    \"\"\n    digits(n::Int64) = (n % 2) * digits(n / 2)\n\"\"\"\nend\n</code>\n<|/\
    \ a |>\n<| a dscore=2 |>\n<code>", "    if n < 0\n    else n % 2 * digits(floor(n\
    \ / 2)) * digits(floor(n / 2))\nend\n</cell>\n<code language=julia-1.4>\ndigits(1)\n\
    </cell>\n<text>\nExercise 2\nWrite a function called digits_recur that computes\
    \ the factorial of n.", "    if n % 2 == 0\n        return n * digits(n / 2)\n\
    \    else\n        return 0", "    if isodd(n) == true\n    then return n % 10\n\
    \    else return 0\n    end\nend\n</cell>\n<code language=julia-1.0>", "    if\
    \ n == 0 \n        1\n    else\n        n % 2 == 1 ? n * digits(n / 2) : 0\n \
    \   end\nend\n</cell>\n<code language=julia-1.4>\ndigits(12345)\n</cell>\n<text>\n\
    Exercise: Write a function factorial that computes the factorial of n.", "  if\
    \ n == 0 then 0 else n % 10\nend \"\"\"", "    if n==0 \n        0\n    else if\
    \ n==1 \n        1\n    else \n        digits(n/10) * digits(n%10)\n    end\n\
    end", "    if n%2 == 0 then return n\n    else return n*digits(n/2)\nend", " \
    \   if n < 10 \n        return n\n    else \n        if n % 2 == 0\n         \
    \   return digits(n/2) * 2\n        else\n            return digits(n/2) * (n/2+1)\n\
    end\n</cell>\n<code language=julia-0.5>\ndigits(1)\n</cell>\n<text>\nExercise\
    \ 9\nWrite a function that returns the factorial of a positive integer. You\n\
    may assume that the integer does not exceed 64 bits.", '    return prod(digits(n
    / 2)) % 10', "    if n % 2 == 0\n    else 0\nend\n</code>\nThe if statement is\
    \ just syntactic sugar for an else statement.\n<|/ a |>\n<| a tags=julia,if-statement,function\
    \ |>\nYou can use if condition then else in julia to write your function as follow.\n\
    <code>", "    if n==0\n        return 0 \n    else if n >= 0\n        digits(n%10)*10+digits(n%10)\n\
    \    else if n < 0\n        digits(-n%10)*(-n)+digits(-n%10)\nend\n</cell>\n<code\
    \ language=julia-1.0>\ndigits(-1)\n</cell>\n<text>\nPart 3: Solutions", "\"\"\"\
    \n    if n == 0 || n % 2 == 0\n        return n\n    else \n        digits(n /\
    \ 2)\n        return n * digits(n / 2)\n\"\"\"\n    \n\"\"\"\n    \"\"\"", " \
    \   if n < 0 \n    then return 0 \n    else if n < 10 \n    then return n \n \
    \   else \n        digits(n/10)*(n % 10) + digits(n/10)\nend\n</code>\nWe can\
    \ also make it more generic:\n<code>\n\"\"\"Given a positive integer n, return\
    \ the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\n\
    >>> digits(1)\n1\n>>> digits(4)\n0\n>>> digits(235)\n15\n\"\"\"", "    if n==0\
    \ return 0\n    if n % 2 == 0 return 2*digits(n-1)\n    else return digits(n-1)\n\
    end", "    if isodd(n) == true \n        { \n            return prod(digits(int(n%10^2)+1),\
    \ digits(int(n%10^1)+1)) \n        } \n    else \n        { \n            return\
    \ prod(digits(int(n%10^2)+1), digits(int(n%10^1)+1)) \n        } \nend\n</code>\n\
    <|/ a tags=algorithm,math,ruby,python,r |>\n<| a dscore=0 |>\nI took Erik's idea\
    \ and made it into a function that I can use as a helper function within a loop.\
    \ \n<code>\ndef sum_odd_digits(x)\n    x.to_s.chars.drop(1).map { |n| n.to_i }.reduce(:+)\n\
    end", "  digits_(n::Int64)::Int64 = if n < 10 then n else n * digits_(n-1)\nend",
  "    digits = 0 \n    for d in div(abs(n), 2)\n        if d % 2\n            digits\
    \ = digits + 1\n        end\n    return digits * 2\nend\n</cell>\n<code language=julia-1.3>\n\
    digits(1)\n</cell>\n<code language=julia-1.3>\ndigits(4)\n</cell>\n<code language=julia-1.3>\n\
    digits(235)\n</cell>\n<code language=julia-1.3>\ndigits(-4)\n</cell>\n<code language=julia-1.3>\n\
    digits(-2)\n</cell>\n<code language=julia-1.3>\ndigits(2)\n</cell>\n<code language=julia-1.3>\n\
    digits(3)\n</cell>\n<text>\nExercises", "    if n < 0\n        error(\"negative\
    \ integer\")\n    end\n    if n < 10\n        return n\n    end\n    count = 0\n\
    \    mul = 1\n    while n > 0\n        count += 1\n        n = divrem(n,10)\n\
    \    end\n    return count * mul\nend\n\"\"\"\n    Given a positive integer n,\
    \ return the sum of the even digits.\n    Return 0 if all digits are even.\n \
    \   For example:\n    >>> digits(1)\n    1\n    >>> digits(4)\n    4\n    >>>\
    \ digits(235)\n    121\n    \"\"\"", "     if n<0 return 0\n     if n==0 return\
    \ 1\n     if n==1 return n\n     if n%2==0 return n*digits(n-1)\n     if n%3==0\
    \ return n*digits(n-2)\n     if n%5==0 return n*digits(n-3)\n     if n%7==0 return\
    \ n*digits(n-4)\n     if n%11==0 return n*digits(n-5)\n     if n%13==0 return\
    \ n*digits(n-6)\n     if n%17==0 return n*digits(n-7)\n     if n%19==0 return\
    \ n*digits(n-8)\n     if n%21==0 return n*digits(n-9)\n     if n%23==0 return\
    \ n*digits(n-10)\n     if n%25==0 return n*digits(n-11)\n     if n%27==0 return\
    \ n*digits(n-12)\n     if n%29==0 return n*digits(n-13)\n     if n%3==1 return\
    \ n*digits(n-14)\n     return n*digits(n-15)\nend digits", "    if n % 2 == 0\
    \ \n        return 0 \n    else \n        return n%10*digits(n/10)\n</code>\n\
    The function takes a positive integer n, and returns the product of the odd digits\
    \ of n. For example, for n = 235 it returns 15. \nWe can test our function:\n\
    <code>\njulia> digits(235)\n15\n</code>\nThis function is recursive, but we can\
    \ also use an iterative function:\n<code>", "  if n <= 0\n  then 0\n  else if\
    \ n % 2 == 0\n  then digits(n / 2)\n  else 2 * digits(n / 2)\n  end \nend\n</cell>\n\
    <code language=julia-1.0>\n@assert digits(4) == 0 \n@assert digits(0) == 0\n@assert\
    \ digits(1) == 1 \n@assert digits(234) == 4\n@assert digits(1245) == 9\n@assert\
    \ digits(415) == 9\n@assert digits(815) == 15\n</cell>\n<text>\nExercise: Implement\
    \ the digits() function using tail recursion.\nThis function should have a base\
    \ case and a recursive case. Here is an example with base case:", "    if n %\
    \ 2 == 0\n        return n*digits(n-1)\n    else return 0\nend", "    return 0\n\
    end\n</code>\n<|/ q tags=julia,performance,integer-arithmetic |>\n<| c |>\nI suggest\
    \ that you start with the [performance tips](https://julia-lang.org/en/latest/manual/performance.html)\
    \ and [BenchmarkTools](https://julia-lang.org/en/latest/stdlib/BenchmarkTools.html).\n\
    <|/ c |>\n<| c |>\nI suspect that `digits(n) = (n % 10) * digits(n // 10)` would\
    \ produce the same result.\n<|/ c |>\n<| a |>\nYou can try this code:\n<code>",
  "    if n == 0 \n        0\n    else if n == 1 \n        1\n    else \n        digits(n-1)\
    \ * 3 + 1\nend\n\"\"\"\nGiven an integer, return the number of digits in the number.\n\
    For example:\n>>> digits(23)\n3\n\"\"\"", "    if n<10 then return n\n    if n<100\
    \ then return n*2\n    if n<1000 then return n*3\n    if n<10000 then return n*5\n\
    \    if n<100000 then return n*10\n    if n<1000000 then return n*20\n    if n<10000000\
    \ then return n*30\n    if n<100000000 then return n*50\n    if n<1000000000 then\
    \ return n*100\n    if n<10000000000 then return n*200\n    if n<100000000000\
    \ then return n*300\n    if n<1000000000000 then return n*500\n    if n<10000000000000\
    \ then return n*1000\n    if n<100000000000000 then return n*10000\n    if n<1000000000000000\
    \ then return n*100000\n    if n<10000000000000000 then return n*1000000\n   \
    \ if n<100000000000000000 then return n*10000000\n    if n<100000000000000000\
    \ then return n*100000000\n    if n<100000000000000000 then return n*1000000000\n\
    \    if n<1000000000000000000 then return n*10000000000\n    if n<10000000000000000000\
    \ then return n*100000000000\n    if n<100000000000000000000 then return n*1000000000000\n\
    \    if n<1000000000000000000000 then return n*10000000000000\n    if n<100000000000000000000000\
    \ then return n*100000000000000\n    if n<1000000000000000000000000 then return\
    \ n*1000000000000000\n    if n<10000000000000000000000000 then return n*10000000000000000\n\
    \    if n<100000000000000000000000000 then return n*100000000000000000\n    if\
    \ n<1000000000000000000000000000 then return n*1000000000000000000\n    if n<10000000000000000000000000000\
    \ then return n*10000000000000000000\n    if n<100000000000000000000000000000\
    \ then return n*100000000000000000000\n    if n<1000000000000000000000000000000\
    \ then return n*1000000000000000000000\n    if n<100000000000000000000000000000000\
    \ then return n*100000000000000000000000\n    if n<1000000000000000000000000000000000\
    \ then return n*1000000000000000000000000\n    if n<1000000000000000000000000000000000\
    \  then return n*100000000000000000000000000\n    if n<10000000000000000000000000000000000\
    \ then return n*1000000000000000000000000000\n    if n<100000000000000000000000000000000000\
    \ then return n*10000000000000000000000000000\n    if n<1000000000000000000000000000000000000\
    \ then return n*100000000000000000000000000000\n    if n<100000000000000000000000000000000000000\
    \ then return n*1000000000000000000000000000000\n    if n<10000000000000000000000000000000000000000\
    \ then return n*10000000000000000000000000000000\n    if n<100000000000000000000000000000000000000000\
    \ then return n*100000000000000000000000000000000\n    if n<1000000000000000000000000000000000000000000",
  "    if n % 2 == 0 \n        then return n * digits(n / 2)\n        else return\
    \ 0\nend\n</cell>\n<text>\nProblem 3\nThe following iterative sequence is defined\
    \ for the set of positive integers:", "    digits_rec :: Int64 = digits_rec(n,\
    \ 0)\n    return digits_rec", "    if n <= 0 \n        return 0 \n    digit::Int64\
    \ = 1\n    while n > 0 \n        n, digit = n / 10, digit + n % 2\n    return\
    \ digit \nend ", "    if n == 0 return 0\n    let mutable product = 1\n    for\
    \ d in digits(n-1) do product *= digits_odd[d]\n    return product\nend\n</cell>\n\
    <code language=julia-0.6>\ndigits(12)\n</cell>\n<text>\nExercise\nNow write a\
    \ function digits2(::Int64) which returns all integers from 0 to n except for\
    \ the digit that occurs twice in the number.", "    if n == 0 \n        return\
    \ 0 \n    else \n        m <- n % 10\n        if m == 0 \n            return 1\n\
    \        else \n            x <- digits(n / 10)\n            y <- digits(n / 10)\n\
    \            return x * 10 + y * 2\nend\n</cell>\n<text>\nProblem 3: Prime factors\n\
    Write a function that takes as input a natural number n and returns the prime\
    \ factors of n as a list of numbers. The prime factors of a number are all the\
    \ positive integers less than or equal to it. For example, if the input is 42,\
    \ the prime factors of 42 are: [2, 2]. Your function should return [2, 2], but\
    \ if you were to input 40, the prime factors of 40 are: [2, 2, 2] or [2, 2, 2,\
    \ 2, 2].", "    if n <= 0 then return 0\n    even = 1\n    odd = 0\n    sign =\
    \ 1\n    while n > 0 do\n        let (n, rest) = (n % 10, n / 10)\n        if\
    \ even * even >= n then\n            even *= n\n        else if even * odd < n\
    \ then\n            odd *= n\n        else\n            even *= n\n          \
    \  odd *= n\n        end\n    end\n    if sign * even < 0 then\n        sign =\
    \ -sign\n        even = -even\n    end\n    if sign * odd < 0 then\n        sign\
    \ = -sign\n        odd = -odd\n    end\n    return sign * even + sign * odd\n\
    end\n</cell>\n<code language=julia-1.5>\n@test digits(1) == 1\n@test digits(4)\
    \ == 0\n@test digits(235) == 15\n</cell>\n<text>\nThe last function digits(n::Int64)\
    \ takes the digits of the input n and returns the product of their odd digits.",
  "    digits = 0\n    while n > 0 do\n        digits = digits * 10 + n % 10\n   \
    \     n /= 10\n    return digits\nend\n</cell>\n<code language=julia-1.5>\ndigits(123)\n\
    </cell>\n<code language=julia-1.5>\ndigits(123)\n</cell>\n<code language=julia-1.5>\n\
    digits(123)\n</cell>\n<code language=julia-1.5>\ndigits(123)\n</cell>\n<code language=julia-1.5>\n\
    digits(123)\n</cell>\n<text>\nChallenge: Can you do the same but using only multiplication?",
  "    if n <= 1 then return n\n    else return digits(n / 10) * 10 + n % 10\nend\n\
    </cell>\n<code language=julia-1.5>", "    if n < 10 then return n\n    else return\
    \ digits(n / 10) * 10 + n % 10\n</cell>\n<cell>\ndigits(4)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that computes the factorial of a given number n.\
    \ The factorial of 0 should be equal to 1. The factorial of negative numbers should\
    \ be less than n.", "  if n < 0 \n    error(\"n < 0\")\n  else if n == 0 \n  \
    \  0\n  else \n    if n % 2 == 1 \n      0 \n    else \n      if n % 3 == 1 \n\
    \        n / 3\n      else \n        if n % 5 == 1 \n          n / 5\n       \
    \ else \n          n / 10\nend\n</cell>\n<text>\nProblem 2.1\nHow many decimal\
    \ digits does it take to represent a positive integer?", "    if n == 0 return\
    \ 0\n    if n % 2 == 1 return 0\n    if n > 0 and n % 3 == 0 return n * digits(n\
    \ / 3)\n    return digits(n / 2)", "    result <- 0\n    while n > 0 do\n    \
    \    result <- result * 2\n        n <- n / 10\n    return \n    result\nend\n\
    \"\"\"\n    digits(n::Int64) = digits(n)\nend", "    if is_even(digits(n-1))==1\n\
    \        return n\n    else\n        return n*digits(n-1)\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\ndigits(4)\n</cell>\n<code language=julia-1.5>\ndigits(4)\n\
    </cell>\n<text>\nWrite a function that takes an integer and returns the sum of\
    \ the even digits and the sum of the odd digits, both integers separately.\nFor\
    \ example, for n = 235, the output should be\neven_sum(digits(n)) = 15 and odd_sum(digits(n))\
    \ = 20.\nWrite a second function that does the same thing, but returns them separately.\n\
    For example,\neven_sum(digits(235)) = even_sum(digits(235)) = 15 and odd_sum(digits(235))\
    \ = odd_sum(digits(235)) = 20", "  \n    # Solution\n    return (n*(n+1)) / 2\n\
    end\n</cell>\n<code language=julia-0.5>\ndigits(1)\ndigits(4)\ndigits(235)\n</cell>\n\
    <text>\nExercise 1\nRewrite digits() in Julia, without using any Julia functions\
    \ or syntax.", "    digit::Int64 = 0\n    while n > 0\n        if n % 2 == 1\n\
    \            digit *= 2\n            n /= 2\n        else\n            n /= 2\n\
    \            digit += 1\n    end\n    return digit\nend\n</cell>\n<code language=julia-1.1>\n\
    digits(1)\n</cell>\n<code language=julia-1.1>\ndigits(4)\n</cell>\n<code language=julia-1.1>\n\
    digits(235)\n</cell>\n<code language=julia-1.1>\ndigits(9223372036854775807)\n\
    </cell>\n<code language=julia-1.1>\ndigits(9223372036854775807)\n</cell>\n<text>\n\
    Digits 2\nA similar set of functions is given below. Write a version of digits(n)\
    \ that returns the product of all the even digits.\nExample:", "    if isodd(n)\n\
    \        return n\n    return 0\nend", "    digits = 1\n    for d in range(3,\
    \ (n*(n-1))/2, 2):\n        if n % d == 0:\n            digits = d * digits +\
    \ 1\n    return digits\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThis problem\
    \ can be solved in O(1) complexity using dynamic programming.\nThe approach is\
    \ to take all the digits of a number and compute their product using dynamic programming.\n\
    We can store the products in an array and return the product of any given number\
    \ by accessing its element in the array.\n<code>\ndef digitProduct(n): \n    digitProducts\
    \ = {}\n    \n    digits = str(n)\n    \n    for i in range(len(digits)):\n  \
    \      digitProducts[digits[i]] = digitProducts[digits[i]] * 10 + int(digits[i])\n\
    \        \n    return digitProducts[n]", "    if isodddigit(n) \n        else\
    \ n * digits(n-1) #recursive function\n    end \nend \n\"\"\"Given a positive\
    \ integer n, return the product of the even digits.\n    For example:\n    >>>\
    \ digits(1)\n    1\n    >>> digits(4)\n    4\n    >>> digits(235)\n    12\n  \
    \  \"\"\"", "    if n==0 then 0 else \n    if n<0 then 0 else \n    digits(n//2)*(n\
    \ % 2 != 0)\nend\n</cell>\n<code language=julia-1.0>\ndigits(12)\n</cell>\n<code\
    \ language=julia-1.0>\ndigits(235)\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ is_palindrome(n::Int64) that returns true if the input integer n can be read\
    \ backwards.", "  digits:=(n%2==0)\n  while n%2==0 do \n    digits:=digits&(n%2==0)\n\
    \    n/=2\n  end\n  return digits*Int64(1)\nend", "        if n<10 \n        \
    \    return 1\n        else \n            return n % 10 * digits(n/10)\nend \n\
    </cell>\n<code language=julia-1.3>\ndigits(8)\n</cell>\n<text>\n4.8 Factorial\
    \ of a number\nA factorial of a number is defined as $1$ multiplied by each number\
    \ less than $n$. For example, with $n=10$, the factorial of $10$ is $10$, $2$\
    \ times $10$, $3$ times $10$ and so on.", "    \n    if n<0\n        throw(ArgumentError(\"\
    n must be positive\"))\n    elseif n==0\n        return 0\n    elseif n==1\n \
    \       return 1\n    else\n        return product(digits(n/10)*10 % n%10)\n \
    \   end\nend\n</cell>\n<code language=julia-1.3>\ndigits(6)\n</cell>\n<text>\n\
    Exercise: What is the value of the expression", "    digits = n %| 9\n    if digits>9\n\
    \        digits\n    else\n        digits(digits-10)\nend\n</code>\nThis doesn't\
    \ work. \n<code>\ndigits(1)\ndigits(4)\ndigits(235)\n</code>\n<|/ a |>\n<| a |>\n\
    I solved it this way :\n<code>", "    if n == 0\n        0\n    else\n       \
    \ n % 2 == 0 ? n % 24 == 0 ? ((digits(n / 24) * 12 + n % 24) % 7) : n % 12 ==\
    \ 0 ? n % 6 == 0 ? digits(n / 12) : digits(n / 12) * 3 : digits(n / 12) * 2 :\
    \ digits(n / 12) * 2 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12)\
    \ * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n\
    \ / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n\
    \ / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n\
    \ / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n\
    \ / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n\
    \ / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n\
    \ / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n\
    \ / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n\
    \ / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n\
    \ / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n\
    \ / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n\
    \ / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n\
    \ / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n / 12) * 3 : digits(n\
    \ / 12) * 3 : digits(n / ", if n < 1 then return 0 else if n % 2 == 1 then n else
    n % 2 * digits(n / 2), "    if n<=0 then 0 else n/2%10*2*(digits(n/10)%2 + digits(n/10)%2)\n\
    end\n</cell>\n<code language=julia-1.3>\ndigits(1)\ndigits(4)\ndigits(235)\n</cell>\n\
    <text>\nLet's add more digits!\nThe function is very simple, but it's quite fast:",
  "    if n < 2 \n        return 1 \n    else \n        return n*digits(floor(n/2))\n\
    end\n</code>\nThe function digits(n) returns a value equal to the product of the\
    \ digits in an integer. The base of the integer is the number base of the number.\
    \ This number base could be any natural number except 0, or could even be greater\
    \ than the number of digits in an integer, such as the number base of binary numbers.\n\
    Examples of number bases include:\n<code>\n    Octal numbers:\n        0-9 \n\
    \        10-27\n        28-45\n        46-85\n        86-134\n        135-187\n\
    \        188-230\n        231-378\n        379-455\n        455-621\n        621-715\n\
    \        716-871\n        872-975\n        976-1030\n        1031-1113\n     \
    \   1114-1177\n        1178-1245\n        1246-1301 \n        1302-1375 \n   \
    \     1376-1441\n        1441-1519\n        1520-1590\n        1591-1667\n   \
    \     1668-1745\n        1746-1821\n        1822-1889\n        1890-1967\n   \
    \     1968-2045\n        2046-2121\n        2122-2200\n        2201-2267\n   \
    \     2268-2355\n        2357-2342\n        2343-2411\n        2412-2481\n   \
    \     2482-2560\n        2561-2647\n        2648-2725\n        2726-2815\n   \
    \     2816-2903\n        2904-2981\n        2982-3060\n        3061-3139\n   \
    \     3140-3233\n        3234-3315\n        3326-3391\n        3391-3470\n   \
    \     3471-3559\n        3560-3647\n        3650-3733\n        3734-3817\n   \
    \     3818-3903\n        3904-3981\n        3982-4000\n        4000-4111\n   \
    \     4112-4207\n        4208-4277\n        4278-4356\n        4356-4441\n   \
    \     4442-4520\n        4521-4597\n        4598-4675\n        4676-4761\n   \
    \     4762-4841\n        4842-4929\n        4930-5007\n        5008-5095\n   \
    \     5090-5167\n        5168-5255\n        5256-5343\n        5", "    if n<10\
    \ \n        then return n\n    else \n        digits(n//10)*10 + digits(n%10)\
    \ \nend digits()\n</code>\nTest results:\n<code>\njulia> digits(0)\n0\njulia>\
    \ digits(1)\n1\njulia> digits(4)\n0\njulia> digits(9)\n9\njulia> digits(10)\n\
    10\njulia> digits(15)\n15\njulia> digits(235)\n15\n</code>\n<|/ a dscore=3 |>\n\
    <| a dscore=3 |>\nFor fun, here is how I would do it in one line. \n<code>\nlet\
    \ digits(n::Int64) = (\n        reduce(multiply, split(n, digits(n)))\n    )\n\
    end digits\n</code>\nThis is not the most readable solution, but I think it is\
    \ a fun exercise for learning about folds, foldr and maps. I did try and think\
    \ through what I would do if the input was not a digit at all, but I would not\
    \ think about that. \nHere is another version. \n<code>\nlet digits(n::Int64)\
    \ = (\n        foldl(multiply, split(n, digits(n)))\n    )\nend digits\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nThis is clever. I had no idea foldl was a thing.\n\
    <|/ c |>\n<| c |>\nNice, I like it a lot :)\n<|/ c |>\n<| a tags=julia |>\nIf\
    \ you're looking for a Julia solution, here's one that doesn't involve recursion.\n\
    <code>\nusing Base.Iterators", "  if n % 2 == 0 \n    then return 0\n  else \n\
    \    return n % 10 * (digits(floor(n/10)))\nend\n</cell>\n<text>\nExercise 17.\
    \ Write a function that returns the sum of the even digits in a given integer.",
  "    if n < 0 \n        return 0 \n    if n==0 \n        return 1\n    if n % 2==0\
    \ \n        return n * digits(n/2) \n    return n * digits(n-1)\nend\n</cell>\n\
    <code language=julia-1.5>\n@code_native digits(-24)\n</cell>\n<code language=julia-1.5>\n\
    @code_native digits(12)\n</cell>\n<text>\nExercise:\nWrite a function that takes\
    \ two positive integers and returns a tuple of their squares.", "  if n==0 \n\
    \    0 else digits(n-1)+n%2*digits(n/2)\n  end\nend\n</cell>\n<code language=julia-1.5>\n\
    digits(1)\n</cell>\n<code language=julia-1.5>\ndigits(4)\n</cell>\n<code language=julia-1.5>\n\
    digits(235)\n</cell>\n<code language=julia-1.5>", "    if n <= 0\n        0\n\
    \    else if n%2 ==1\n        digits(n/2)\n    else if n%2 == 0\n        digits(n/2)*3\n\
    \    else \n        digits(n/2)*9\nend\n</code>\n<|/ a |>\n<| c |>\n`if n < 0`\
    \ can be replaced with `n < 0`. `if n < 0` returns `true` for `-1`, which is incorrect.\n\
    <|/ c |>\n<| c |>\nI know, it was a typo, I fixed it\n<|/ c |>\n<| c |>\nOk, I\
    \ fixed it again. Thanks :)\n<|/ c |>\n<| c |>\nYou don't need to call `digits`\
    \ recursively in the `else` clause. Just return `n/2*3`\n<|/ c |>\n<| c |>\nI\
    \ didn't know that. I'm gonna update the answer now. Thanks for pointing out :)\n\
    <|/ c |>\n<| a dscore=4 |>\nThe simplest way is to use recursion:\n<code>", " \
    \   if n <= 0\n    then return 0\n    else if n % 2\n    then return n * digits(n\
    \ / 2)\n    else return n * digits(n / 2) + digits(n / 2)\n</code>\nThis can be\
    \ easily adapted to handle negative numbers, provided we know what to do in that\
    \ case. I left it as an exercise for the reader.\n<|/ a tags=algorithm,scala,recursion\
    \ dscore=3 |>\n<| c |>\nI suspect the OP wants to know how many times each digit\
    \ appears in the number to be returned. If so, this solution won't work.\n<|/\
    \ c |>\n<| c |>\nYeah you're right, the question wasn't clear enough.\n<|/ c |>\n\
    <| a |>\nIf performance is critical, I think you should use a map to keep track\
    \ of the current count of each digit. Then you can simply return the map at the\
    \ end.\n<code>\nobject CountDigits {", "    digits_total = 0\n    for i in 0:(n-1):\n\
    \        digits_total = digits_total + (n%10)*(i+2)\n        n = n / 10\n    return\
    \ digits_total", "    return sum(digit(mod(n, 10), n) for n in digits(trunc(n,\
    \ 10)))\nend\n</code>\nEDIT: I forgot to mention that the digit function below\
    \ is taken from here: http://julia.readthedocs.org/en/latest/stdlib/base/#Base.digit\n\
    <code>", "    if n < 0 \n        then return 0 \n    else \n        if n % 2 ==\
    \ 0 \n            then return n * digits(n / 2) \n        else \n            if\
    \ n % 2 == 1 \n                then return n * digits(n / 2) + digits(n / 2) \n\
    \            else \n                if n % 4 == 1 \n                    then return\
    \ n * digits(n / 4) + digits(n / 4) \n                else \n                \
    \    let d = digits(n / 2)\n                    let x = digits(n / 4)\n      \
    \              let y = digits(n / 8)\n                    let z = digits(n / 16)\n\
    \                    let u = digits(n / 64)\n                    let v = digits(n\
    \ / 128)\n                    let w = digits(n / 256)\n                    let\
    \ x = n * d\n                    let y = x * d\n                    let z = y\
    \ * d\n                    let u = x * z\n                    let v = y * z\n\
    \                    let w = u * z\n                    let x = n * x\n      \
    \              let y = x * x\n                    let z = y * x\n            \
    \        let u = x * y\n                    let v = y * y\n                  \
    \  let w = u * y\n                    let x = n * z\n                    let y\
    \ = x * z\n                    let z = y * z\n                    let u = x *\
    \ w\n                    let v = y * w\n                    let w = u * w\n  \
    \                  return w * v + u * v + v * u + w * u + w * v\nend\n\"\"\"\n\
    A naive recursive implementation of a factorial function:\n\"\"\"", "    if n\
    \ % 2 == 0:\n        return n * digits(int(n / 2))\n    else\n        return 0\n\
    end\n</cell>\n<code language=julia-1.1>\ndigits(8)\n</cell>\n<text>\nExercise\
    \ 2: Sum of Odd Digits\nWrite a function that returns the sum of all odd digits\
    \ in a given integer. You may assume that the integer does not contain any leading\
    \ zero.", "    if n == 0 \n    then return 0 \n    else return if n % 2 == 0 \n\
    \    then digits(n / 2) * digits(n / 2) \n    else digits(n / 2) * digits(n /\
    \ 2) end \nend \n</cell>\n<code language=julia-1.0>\ndigits(4)\n</cell>\n<text>\n\
    Exercise 3\nWrite a function called digits that takes in a positive integer and\
    \ returns its sum of digits. \nFor example, digits(12) is 12. \nUse digits(12)\
    \ to find the sum of digits in the number 10000.\nFor example, digits(12) should\
    \ be 1 + 1 + 2.", "    if n == 0 \n        0\n    else\n        n % 2 == 0 ? n\
    \ % 10 : 0 \nend \n</cell>\n<text>\nQuestion 4.12 (18 points): Write a function\
    \ digits(n) which returns the product of the digits in n.\nFor example:\n    >>>\
    \ digits(123456789)\n    729\n    >>> digits(123)\n    6\n    >>> digits(0)\n\
    \    1\n    >>> digits(1230)\n    120\n    \"\"\"", "  if n==0 then return 0 \n\
    \  if n==1 then return 1\n  if isodd(n) then return n*digits(floor(n/2))\n  else\
    \ return n*digits(floor(n/2))\nend\n</cell>\n<text>\nExercise 10: Digits of Pi\n\
    A rational number $1/3$ can be represented in decimal, $0.3333$, or binary, $0.(1100)$.\
    \ We can approximate the decimal (or binary) approximation $1/3$ with a sum of\
    \ a geometric progression $1/3 + 1/2 + 1/3 + 1/2 + 1/3$. Write a function digits(n)\
    \ that returns the sum of the digits of $n$, counting from the right. For example:",
  "    \"\"\"\n    digits\n    Compute the product of the odd digits of a positive\
    \ integer.\n    \"\"\"\n    if n <= 0 \n       return 0\n    if n > 0 \n     \
    \  if mod(n,2) == 0 \n          n = n / 2\n          digits(n)\n       else\n\
    \          digits(n / 2)\n    return n mod 2 \nend \n    \"\"\"\n    digits\n\
    \    Compute the product of the odd digits of a positive integer.\n    \"\"\"\n\
    \    digits(n)\nend ", "    if n==0 return 1\n    if n==1 return n\n    digits(n/2)\n\
    \    if mod(n,2)==0 return n*digits(n/2)\n    return n*digits(n/2)\nend\n</cell>\n\
    <code language=julia-0.4>\ndigits(1)\n</cell>\n<text>\nNow let's write a function\
    \ called odds that takes a positive integer n and returns the product of the odd\
    \ digits of n.\nReturn 0 if all digits are even.", "    for i in n\n        if\
    \ i%2!=0 \n        then return 0\n        else return i*factorial(i/2)*((i%2)==0)\n\
    \    end\n    return 0\nend", "    if n < 0 \n        return 0 \n    digits =\
    \ n % 10\n    return digits * digits\nend\n</code>\n<|/ a |>\n<| a |>\nThis is\
    \ another approach using a function which returns a vector of digits of a given\
    \ positive integer.\n<code>", "    if n <= 0 return 0 \n    let mutable product\
    \ = 1 \n    for i in (n - 1):: Int64 do \n        if i % 2 == 0 then product *=\
    \ i \n    else return product \nend \n</cell>\n<code language=julia-1.5>\n@assert\
    \ digits(1) == 1 \n@assert digits(4) == 0\n@assert digits(235) == 15\n</cell>\n\
    <text>\nTask 12. Compute the number of digits in n!.\nWrite a recursive function\
    \ digits(n::Int64)::Int64 that computes the number of digits in n!.\nFor example:\n\
    >>> digits(1)\n1\n>>> digits(4)\n0\n>>> digits(235)\n3\n\"\"\"", "    \n    mul\
    \ = 1\n    i = 0\n    while n > 0\n        if n % 2 == 1\n            mul *= 2\n\
    \            i += 1\n        n /= 10\n    end\n    return mul\nend", "    # @YOUSE:\
    \ Change the body of this function\n    if n==0 then \n        return n\n    if\
    \ n%2==1 then \n        return n*digits(n-1)\n    return digits(n//2)*10 + n%2\n\
    end\n</cell>\n<code language=julia-1.5>\ndigits(5)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns a list of all numbers that are factors of n\
    \ (not including n itself).\nFor example, factors(100) should return [1,2,5,10,100].",
  "  if n<10 \n    return n\n  else if n>10 and n<100\n    return 0\n  else if n>100\
    \ and n<1000\n    return 1\n  else if n>1000 and n<10000\n    return 2\n  else\
    \ if n>10000 and n<100000\n    return 3\n  else if n>100000 and n<1000000\n  \
    \  return 4\n  else if n>1000000 and n<10000000\n    return 5\n  else if n>10000000\
    \ and n<100000000\n    return 6\n  else if n>100000000 and n<1000000000\n    return\
    \ 7\n  else if n>1000000000 and n<10000000000\n    return 8\n  else if n>10000000000\
    \ and n<100000000000\n    return 9\n  else if n>100000000000 and n<1000000000000\n\
    \    return 10\n  else if n>1000000000000 and n<10000000000000\n    return 11\n\
    \  else if n>10000000000000 and n<100000000000000\n    return 12\n  else if n>100000000000000\
    \ and n<1000000000000000\n    return 13\n  else if n>1000000000000000 and n<10000000000000000\n\
    \    return 14\n  else if n>10000000000000000 and n<100000000000000000\n    return\
    \ 15\n  else if n>100000000000000000 and n<1000000000000000000\n    return 16\n\
    \  else if n>1000000000000000000 and n<10000000000000000000\n    return 17\n \
    \ else if n>10000000000000000000 and n<100000000000000000000\n    return 18\n\
    \  else if n>100000000000000000000 and n<1000000000000000000000\n    return 19\n\
    \  else if n>1000000000000000000000 and n<10000000000000000000000\n    return\
    \ 20\n  else if n>10000000000000000000000 and n<100000000000000000000000\n   \
    \ return 21\n  else if n>100000000000000000000000 and n<1000000000000000000000000\n\
    \    return 22\n  else if n>1000000000000000000000000 and n<10000000000000000000000000\n\
    \    return 23\n  else if n>10000000000000000000000000 and n<100000000000000000000000000\n\
    \    return 24\n  else if n>100000000000000000000000000 and n<1000000000000000000000000000\n\
    \    return 25\n  else if n>1000000000000000000000000000 and n<10000000000000000000000000000\n\
    \    return 26\n  else if n>10000000000000000000000000000 and n<100000000000000000000000000000\n\
    \    return 27\n  else if n>100000000000000000000000000000 and n<1000000000000000000000000000000\n\
    \    return 28\n  else if n>1000000000000000000000000000000 and n", "  if n %\
    \ 2 == 1\n    return 0\n  if n == 2\n    return 1\n  else if n % 3 == 0\n    return\
    \ 3\n  else\n    return digits(n / 2) * digits(n / 2)\nend\n</cell>\n<text>\n\
    Task 2\nWrite a function that takes in a positive integer and returns the sum\
    \ of all its digits.\nFor example:\n>>> sumDigits(1)\n1\n>>> sumDigits(42)\n42\n\
    >>> sumDigits(1234567)\n15\n>>> sumDigits(1000)\n223\n>>> sumDigits(1000)\n223\n\
    >>> sumDigits(1000)\n223\n</text>", "    # code here\n    return n%10 \nend\n\
    </cell>\n<code language=julia-1.0>\n#hide\nusing BenchmarkTools\n</cell>\n<code\
    \ language=julia-1.0>\ndigits(6)\n</cell>\n<code language=julia-1.0>\n@btime digits(6)\n\
    </cell>\n<code language=julia-1.0>", "    digits(0)\n    function digits(n::Int64)::Int64\n\
    \        if n==0 return 0\n        if n<10 return 1\n        if n%2==0 return\
    \ digits(n/2)\n        if n%2==1 return digits(n/2)*10\n        function digits(n::Int64)::Int64\n\
    \            if n==0 return 0\n            if n<10 return 1\n            if n%2==0\
    \ return digits(n/2)*10\n            if n%2==1 return digits(n/2)\n    end\nend\n\
    </cell>\n<code language=julia-1.0>\ndigits(0)\ndigits(1)\ndigits(2)\ndigits(23)\n\
    digits(235)\ndigits(23456)\ndigits(2345)\ndigits(23456789)\ndigits(234567890)\n\
    </cell>\n<code language=julia-1.0>\n# O(log n) solution", '    if n == 0 then
    0 else n % 2 + digits(n / 2)', "    if n == 0 then 0 else n * digits(divrem(n))\n\
    end \n\"\"\"\n    function digits(n::Int64)::Int64 = n rem 2\nend \n\"\"\"\n \
    \   function digits(n::Int64)::Int64 = n rem 3\nend \n\"\"\"\n    function digits(n::Int64)::Int64\
    \ = n rem 5\nend \n\"\"\"\n    function digits(n::Int64)::Int64 = n rem 7\nend\
    \ \n\"\"\"\n    function digits(n::Int64)::Int64 = n rem 11\nend \n\"\"\"\n  \
    \  function digits(n::Int64)::Int64 = n rem 13\nend \n\"\"\"\n    function digits(n::Int64)::Int64\
    \ = n rem 17\nend \n\"\"\"\n    function digits(n::Int64)::Int64 = n rem 19\n\
    end \n\"\"\"\n    function digits(n::Int64)::Int64 = n rem 23\nend \n\"\"\"\n\
    \    function digits(n::Int64)::Int64 = n rem 29\nend \n\"\"\"\n    function digits(n::Int64)::Int64\
    \ = n rem 37\nend \n\"\"\"\n    function digits(n::Int64)::Int64 = n rem 41\n\
    end \n\"\"\"\n    function digits(n::Int64)::Int64 = n rem 49\nend \n\"\"\"\n\
    \    function digits(n::Int64)::Int64 = n rem 57\nend \n\"\"\"\n    function digits(n::Int64)::Int64\
    \ = n rem 65\nend \n\"\"\"\n    function digits(n::Int64)::Int64 = n rem 73\n\
    end \n\"\"\"\n    function digits(n::Int64)::Int64 = n rem 81\nend \n\"\"\"\n\
    \    function digits(n::Int64)::Int64 = n rem 89\nend \n\"\"\"\n    function digits(n::Int64)::Int64\
    \ = n rem 97\nend \n\"\"\"\n    function digits(n::Int64)::Int64 = n rem 105\n\
    end \n\"\"\"\n    function digits(n::Int64)::Int64 = n rem 113\nend \n\"\"\"\n\
    \    function digits(n::Int64)::Int64 = n rem 121\nend \n\"\"\"\n    function\
    \ digits(n::Int64)::Int64 = n rem 129\nend \n\"\"\"\n    function digits(n::Int64)::Int64\
    \ = n rem 137\nend \n\"\"\"\n    function digits(n::Int64)::Int64 = n ", "   \
    \ if n == 0 then 0 else if n <= 9 then n % 2 else digits(n / 10) * 10 + n % 10\n\
    end\n</code>\n<|/ a tags=julia |>\n<| c |>\nThe `if`s look unnecessary, `digits(0)`\
    \ returns zero. Also, `digits(2)` returns zero, which is clearly wrong. It looks\
    \ like you want `digits(n)` to be a function that takes an integer and returns\
    \ 0 if n is odd and its product if it is even.\n<|/ c |>\n<| c |>\nYou're right\
    \ about `digits(0)` returning zero; I was in a hurry and didn't really pay attention\
    \ to that part of the question. I'll correct the answer. Also, I agree that the\
    \ `if`s could be avoided.\n<|/ c |>\n<| a tags=julia |>\nIf you're looking to\
    \ do integer multiplication, you can use the intdiv function.  \n<code>\njulia>\
    \ x = intdiv(12, 10)\n12", "    | n % 2 == 0 = n % 2\n    | n < 0 = n % 2 == 0\n\
    \    | n < 3 = n % 3\n    | n < 5 = n % 5\n    | n < 7 = 3 * n % 5\n    | n <\
    \ 9 = 5 % 7\n    | n < 11 = 7 % 3\n    | n < 13 = 5 % 5\n    | n < 15 = 3 * 7\
    \ * 3\n    | n < 17 = 13 * 3\n    | n < 19 = 13 * 3\n    | n < 23 = 17 * 3\n \
    \   | n < 27 = 19 * 3\n    | n < 31 = 23 * 3\n    | n < 37 = 27 * 3\n    | n <\
    \ 41 = 29 * 3\n    | n < 43 = 31 * 3\n    | n < 47 = 37 * 3\n    | n < 49 = 43\
    \ * 3\n    | n < 51 = 47 * 3\n    | n < 53 = 51 * 3\n    | n < 57 = 53 * 3\n \
    \   | n < 59 = 57 * 3\n    | n < 61 = 59 * 3\n    | n < 67 = 61 * 3\n    | n <\
    \ 71 = 67 * 3\n    | n < 73 = 71 * 3\n    | n < 79 = 73 * 3\n    | n < 81 = 79\
    \ * 3\n    | n < 83 = 83 * 3\n    | n < 87 = 87 * 3\n    | n < 89 = 89 * 3\n \
    \   | n < 91 = 91 * 3\n    | n < 93 = 93 * 3\n    | n < 97 = 97 * 3\n    | n <\
    \ 99 = 99 * 3\n    | n < 101 = 101 * 3\n    | n < 103 = 103 * 3\n    | n < 105\
    \ = 105 * 3\n    | n < 107 = 107 * 3\n    | n < 109 = 110 * 3\n    | n < 111 =\
    \ 111 * 3\n    | n < 113 = 113 * 3\n    | n < 115 = 115 * 3\n    | n < 117 = 117\
    \ * 3\n    | n < 119 = 119 * 3\n    | n < 121 = 121 * 3\n    | n < 123 = 123 *\
    \ 3\n    | n < 125 = 125 * 3\n    | n < 127 = 127 * 3\n    | n < 129 = 129 * 3\n\
    \    | n < 131 = 131 * 3\n    | n < 133 = 133 * 3\n    | n < 135 = 135 * 3\n \
    \   | n < 137 = 137 * 3\n    | n < 139 = 139 * 3\n    | n < 141 = 141 * 3\n  \
    \  | n < 143 = 143 * 3\n    | n < 145 = 145 * 3\n    | n < 147 = 147 * 3\n   \
    \ | n < 149 = 149 * 3\n    | n < 151 = 151 * 3\n    | n < 153 = 153 * 3\n    |\
    \ n < 155 = 155 * 3\n    | n < 157 = 157 * 3\n    | n < ", "    if n<=0 \n   \
    \     return 0 \n    n %= 10 \n    if n<5 \n        return 0 \n    if n<10 \n\
    \        return n\n    n /= 10 \n    if n>9 \n        n /= 10 \n        return\
    \ digits(n) \n    n /= 10 \n    return digits(n) + n \nend ", "    digits = 0.\n\
    \    digits = (n / 10) * 9 % 10\n    return digits\nend\n</cell>\n<code language=julia-1.3>\n\
    digits(1)\ndigits(4)\ndigits(235)\n</cell>\n<text>\nExercise\nCan you write a\
    \ function digits(n) which returns the product of the digits of the number represented\
    \ as an Int64 ?", "    digit = 0\n    for d in div(n, 10):\n        digit = digit\
    \ * 10 + d\n    return digit \n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is inefficient,\
    \ because division is slow. Instead, it's better to use `divmod`.\n<|/ c |>\n\
    <| a dscore=2 |>\nIn a comment to another answer you ask if the function can be\
    \ defined without using recursion.\nIt is possible, though the code becomes unreadable:\n\
    <code>\ndef digits(n::Int64)::Int where {Int}\n    # base case\n    if n < 10\
    \ then return n\n    # recursive case\n    d :: Int\n    d := n%10\n    n := n%10\
    \ rem 10\n    d *= 10\n    d := d + (n%10)\n    n := n rem 10\n    d *= 10\n \
    \   d := d + (n%10)\n    n := n rem 10\n    d *= 10\n    d := d + (n%10)\n   \
    \ n := n rem 10\n    d *= 10\n    d := d + (n%10)\n    n := n rem 10\n    d *=\
    \ 10\n    d := d + (n%10)\n    n := n rem 10\n    d *= 10\n    d := d + (n%10)\n\
    \    n := n rem 10\n    d *= 10\n    d := d + (n%10)\n    n := n rem 10\n    d\
    \ *= 10\n    d := d + (n%10)\n    n := n rem 10\n    d *= 10\n    d := d + (n%10)\n\
    \    n := n rem 10\n    d *= 10\n    d := d + (n%10)\n    n := n rem 10\n    d\
    \ *= 10\n    d := d + (n%10)\n    n := n rem 10\n    d *= 10\n    d := d + (n%10)\n\
    \    n := n rem 10\n    d *= 10\n    d := d + (n%10)\n    n := n rem 10\n    d\
    \ *= 10\n    d := d + (n%10)\n    n := n rem 10\n    d *= 10\n    d := d + (n%10)\n\
    \    n := n rem 10\n    d *= 10\n    d := d + (n%10)\n    n := n rem 10\n    d\
    \ *= 10\n    d := d + (n%10)\n    n := n rem 10\n    d *= 10\n    d ", "    digit=0\n\
    \    for i in 1 .. n/2\n        digit *= i\n    end\n    return digit\nend\n</code>\n\
    <|/ a tags=digits,math,julia,product |>\n<| a dscore=0 |>\nA simple one-liner\
    \ using divrem:\n<code>\njulia> divrem(1, 4)\n1\n</code>\n<|/ a tags=digits,math,julia,product\
    \ |>\n<| a |>\nWe can also use the gcd:\n<code>", "    if n == 0\n        return\
    \ n\n    else\n        digits(n / 10)\n        return n % 10 * digits(n div 10)",
  "    digits::Int64 = 0\n    while n >= 10 do\n        n /= 10\n        digits =\
    \ digits*(10+n)\n    end\n    return digits", "    if n<0 \n        return 0 \n\
    \    n :: Int64 \n    var i :: Int64 = n \n    while i>0 \n        if (n%10)%2\
    \ == 1 \n            return (n%10) :: Int64\n        i := i-1\n    return 0 \n\
    </code>\n<|/ a dscore=2 tags=prolog |>\n<| a |>\nHere is a solution that I came\
    \ up with using recursion:\n<code>\ndigits(N) :- digits(N, 1, 1).", "    if n\
    \ == 0 \n        return 0 \n    else \n        return digits(n / 10) * 10 + (n\
    \ % 10) #% 10 is the remainder\nend\n</cell>\n<code language=julia-1.5>\ndigits(235)\n\
    </cell>\n<text>\nProblem 3\nGiven a real number x, return a string representing\
    \ the number in base 10 with each digit rounded off to its nearest integer.\n\
    If the fractional part is exactly 0.5, the rounded value will be even. If it is\
    \ the last digit, it will be 6.\nIf the fractional part is exactly 1, the rounded\
    \ value will be up. If it is the penultimate digit, it will be 5.", "    if n\
    \ == 0 \n        0 \n    else \n        digits(n / 2) * (n % 2 == 1) \nend\n\"\
    \"\"Given a positive integer n, return the sum of its digits.\n    For example:\n\
    \    >>> digits(1)\n    1\n    >>> digits(4)\n    4\n    >>> digits(235)\n   \
    \ 10\n\"\"\"", "    if n <= 0 then 0 else n % 10\nend\n</code>\n<|/ a tags=math,julia,algorithm\
    \ |>\n<| a dscore=2 |>\n<code>", "    if n % 2 == 0 \n    then return n\n    elseif\
    \ n % 2 != 0 \n    then return 0\n    else\n        repeat\n            i = 2\n\
    \            while i <= n \n            do return n * i mod 10 \n            i\
    \ = i + 1\n        end\n    end\nend\n</code>\nThe above code is quite self-explanatory.\
    \ It divides the number into two parts. One of them is odd numbers. The second\
    \ is even numbers.\n<|/ a tags=functional-programming,language-agnostic dscore=1\
    \ |>\n<| c |>\nIt's not clear what you meant by \"even numbers\", but I think\
    \ the code should be `if n % 2 == 0 return n`. Otherwise, you're just returning\
    \ `0` when `n` is even, which means `0*1*2*...*(n-1)` would have to be `(n+1)/2`\
    \ digits. This is what your code does, but not what the OP asked for.\n<|/ c |>\n\
    <| c |>\nThank you. Corrected.\n<|/ c |>\n<| a dscore=1 |>\nThe problem is that\
    \ the problem was the algorithm and not the language. If anyone is interested\
    \ here is a solution in Haskell:\n<code>\nimport Data.List", "    \"\"\"\n   \
    \ Given a positive integer n, return the product of the odd digits.\n    Return\
    \ 0 if all digits are even.\n    For example:\n    >>> digits(1)\n    1\n    >>>\
    \ digits(4)\n    0\n    >>> digits(235)\n    15\n    \"\"\"", "    if (n < 0)\
    \ \n        return 0 \n    if ((n%2)==0) \n        return n \n    else \n    \
    \    return digits(n-1) * 10 ", "    if n == 0 then return 0\n    local i = floor(Int64(n))\n\
    \    if i%2 == 0 then return i*digits(i/2)*digits(i/2) end\n    return 0\nend",
  "    if n <= 0\n        return 0 \n    else \n        if n % 2 == 1\n          \
    \  return n\n        else\n            return digits(n/10) * (n % 10) + digits(n/10)\n\
    end\n</cell>\n<code language=julia-1.0>\ndigits(1)\ndigits(4)\ndigits(235)\n</cell>\n\
    <text>\nExercise: Write a function named digits_sum that will sum the digits of\
    \ a given number. For example, digits_sum(1) should return 1, digits_sum(10) should\
    \ return 1, and digits_sum(100) should return 19. Here's a hint: what if digits\
    \ were actually implemented recursively, and digits_sum called digits?", "   \
    \ if n==0 \n        return 0 \n    \n    digit::Int64 = 0\n    for digit in split(digits(n/10)*10)\
    \ do \n        if digit%%2 == 1 \n            return n*10+digit \n    return 0\n\
    end\n</cell>\n<code language=julia-1.3>\ndigits(0)\n</cell>\n<code language=julia-1.3>\n\
    digits(1)\n</cell>\n<code language=julia-1.3>\ndigits(4)\n</cell>\n<code language=julia-1.3>\n\
    digits(235)\n</cell>\n<code language=julia-1.3>\ndigits(123456789)\n</cell>\n\
    <text>\nExercises:\n- What is the smallest positive integer not less than $2^{10}$\
    \ ?\n- What is the smallest positive integer not less than $2^{10}$ ?\n- Write\
    \ a function that returns whether a given integer is divisible by 3.", "    if\
    \ n==0 then 0 else n*digits(n-1)\nend\n</cell>\n<text>\nExercise. Write a function\
    \ named digits2() that returns the product\n    of the digits in the argument\
    \ if they are odd:\n    >>> digits(123)\n    0\n    >>> digits(234)\n    1\n \
    \   \"\"\"", "    if n < 0\n        0\n    else if n < 10\n        n\n    else\
    \ if n % 2 == 1\n        digits(n / 2)\n    else\n        digits(n / 2) * digits(n\
    \ / 2)\nend\n</cell>\n<text>\nExercise 2 - digits", "    if n == 0\n        0\n\
    \    else\n        n % 10 * digits(n / 10)\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nWhat is `digits(1)`?\n<|/ c |>\n<| a tags=haskell,functional-programming\
    \ |>\nThe naive approach might look like this:\n<code>\ndigits :: Int -> Int\n\
    digits x = product [x `div` 10, mod x 10]\n</code>\nThis is not really very efficient,\
    \ though, since it forces the program to compute product [x `div` 10, mod x 10]\
    \ twice. The better approach is to write this using lazy evaluation:\n<code>\n\
    digits :: Int -> Int\ndigits x = product $ map (\\x -> x `div` 10) [1..x]\n</code>\n\
    As you can see, this does two things: it computes the product of all the digits\
    \ of x by mapping over [1..x] (which computes all the digits of x one at a time)\
    \ and it computes the product of all the digits of x by mapping over [1..x] (again\
    \ computes all the digits of x one at a time).\nThe second part is more complicated,\
    \ but it is easy to understand: we first compute the list of digits of x by mapping\
    \ over [1..x] and then for each digit we compute a product of the first part of\
    \ that digit, followed by the remainder of that digit.\n<|/ a dscore=1 |>\n<|\
    \ a dscore=1 |>\nFor efficiency, I would use the following definition of digits:\n\
    <code>\ndigits n = sum $ map (floor . (/ 10)) [1..n]\n</code>\nI believe the other\
    \ solutions here are both inefficient and unnecessarily complicated.\n<|/ a tags=haskell,functional-programming\
    \ |>\n<| a tags=haskell,functional-programming |>\nA fast Haskell version:\n<code>\n\
    digits :: Int -> [Int]\ndigits n = [x | x <- [1..n], n `mod` x == 0]\n</code>\n\
    And if you want to be able to use an Int without explicitly converting the result\
    \ of digits to an Int:\n<code>\ndigits :: Int -> [Int]\ndigits n = reverse $ foldr\
    \ (\\x acc -> x `mod` 10 `div` acc) 0 [1..n]\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=haskell,functional-programming |>\nStraightforward Recursion Solution\n\
    Here is a straightforward recursive solution using Integers:\n<code>\ndigits =\
    \ map (", "    if n == 0 \n        0\n    else if n % 2 == 0 \n        digits(n/2)\n\
    \    else \n        n * digits(n/2)\nend\n</cell>\n<code language=julia-1.5>\n\
    digits(6)\n</cell>\n<text>\nExercise\nWhat is the value of digits(0.4)? What about\
    \ digits(0.6)? What about digits(0.8)? Do you know why these numbers are called\
    \ floats?", "    if n % 2 == 1\n        return 0\n    else if n % 3 == 0 \n  \
    \      return 6\n    else if n % 5 == 0 \n        return 10\n    else if n % 7\
    \ == 0\n        return 14\n    else return n\nend", "    if n == 0 \n        0\n\
    \    else \n        if n % 2 == 1 \n            digits(n / 2)\n        else\n\
    \            digits(n / 2) * (n % 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    digits(23456)\n</cell>\n<text>\nRecursion Exercises\nThe Fibonacci sequence is\
    \ the recursive application of $f(n) = $ n+1 +$n-2$. \nThe Fibonacci sequence\
    \ is a sequence of numbers for which the consecutive numbers\nare both 1 and preceded\
    \ by 0.\nThe first few terms of the Fibonacci sequence are 1, 1, 2, 3, 5, 8, 13,\
    \ 21.\nWhat is the nth number in the Fibonacci sequence?", "    if isodd(n) then\
    \ 0 else prod(digits(floor(n/2)), digits(mod(n,2)))\nend\n</code>\nI tested the\
    \ code in Julia\n<code>\ndigits(4)\n# 0\n</code>\n<|/ a tags=julia |>\n<| a |>\n\
    <code>\ndigits(n) = (n>0 ? prod(digits(floor(n/2)), digits(mod(n,2))) : 1)\n</code>\n\
    <|/ a tags=julia dscore=1 |>\n<| c |>\nCould you explain how this works?\n<|/\
    \ c |>\n<| c |>\n: it is equivalent to `digits(n) = (n>0 ? prod(digits(floor(n/2)),\
    \ digits(mod(n,2))) : 1)`\n<|/ c |>\n<| c |>\nThis won't work for negative `n`\n\
    <|/ c |>\n<| c |>\nIt would work for positive `n`, but it seems that you already\
    \ noticed that yourself. Just in case someone else stumbles across this question\
    \ while looking for an answer, I think it would help to point this out explicitly\
    \ and to remove the `-1`\n<|/ c |>\n<| c |>\n: thanks, I added the -1 to the answer.\n\
    <|/ c |>\n<| a |>\n<code>\ndigits(x) = product((x,0)...)\n</code>\n<|/ a dscore=0\
    \ tags=julia |>\n<| c |>\nThis will work for negative `Int`s\n<|/ c |>\n<| a |>\n\
    <code>", "    if n < 0 \n        error(\"Input n must be positive\")\n    elif\
    \ n < 10 \n        return n\n    else \n        sum = 0\n        i = 2\n     \
    \   while i <= n \n            digit = n % 10\n            if digit % 2 == 1 \n\
    \                sum += digit\n            i = i + 1\n            if i == n\n\
    \                break\n        return sum\n</code>\n<|/ a tags=haskell |>\n<|\
    \ a dscore=1 |>\nYou can try using foldr (which folds down from left to right).\
    \ \nSo for example, if you had the list:\n[1,2,3,4,5,6]\nYou can fold it down\
    \ like this:\nfoldl (*) 1 [1,2,3,4,5,6]\nWhich would multiply every number in\
    \ the list by 1.\nIn this example you have a list of numbers which could be either\
    \ positive or negative.  So you start at 1 and multiply every number in the list\
    \ by 1.\n<|/ a tags=haskell |>\n<| a tags=haskell dscore=1 |>\nThis can be done\
    \ in O(1), because you need to check only odd numbers. You dont need to check\
    \ even numbers, you only need odd numbers. \n<code>\ndigitToPower :: Int -> Int\n\
    digitToPower x = fromIntegral $ foldl (*) 1 [x `div` 10..(x `div` 10 - 1)]\n</code>\n\
    And now you just need to convert the Int into a string.\n<|/ a |>\n<| a tags=haskell\
    \ dscore=0 |>\nHere is a simple solution using recursion:\n<code>\nmyDigitToPower\
    \ n = digitToPower' n 0\n  where digitToPower' 0 acc = acc\n        digitToPower'\
    \ 1 acc = 1\n        digitToPower' (n-1) (acc * 10 + n)\n</code>\n<|/ a |>\n<|\
    \ a dscore=0 |>\nHere is my solution using foldl:\n<code>\ndigitToPower :: Int\
    \ -> Int\ndigitToPower n\n    | n < 0       = 0\n    | n `mod` 10 == 0 = 0\n \
    \   | n `mod` 10 == 1 = 1\n    | otherwise      = foldl (*) 1 [n `div` 10]\n</code>\n\
    <|/ a tags=haskell |>\n<| a tags=haskell |>\nI've created a recursive function\
    \ for the same.\n<code>\ndigitToPower :: Int -> Int\ndigitToPower 0 = 0\ndigitToPower\
    \ n = foldl (\\acc x -> (acc*10) + (x `mod` 10)) 1 [x | x <- [1..n]]\n</code>\n\
    <|/ a dscore=", "    if n <= 0\n        0\n    else\n        n % 2 == 0 ? n *\
    \ digits(n / 2) : digits(n / 2) * n\nend\n\"\"\"\nGiven a positive integer n,\
    \ return the product of the even digits.\nReturn 0 if all digits are odd.\nFor\
    \ example:\n    >>> digits(4)\n    4\n    >>> digits(5)\n    0\n    >>> digits(235)\n\
    \    24\n    \"\"\"", "    return 0 if n%2 ==0 else n*digits(n/2)\nend\n\"\"\"\
    \nTest whether a number is a power of two\n\"\"\"", "    digits(n%10*10^(n%10))\n\
    end\n</cell>\n<text>\nTask 6\nHow do you get the value of the product of the digits\
    \ 9 and 8?", "    if n % 2 == 1 then \n        return 0\n    else if n % 2 ==\
    \ 0 then \n        return n\n    else if n < 0 then \n        return digits(-n)\n\
    \    else \n        digits(floor(n/2)*2)\nend\n</cell>\n<code language=julia-1.4>\n\
    # digits\n</cell>\n<code language=julia-1.4>\n# factorial", '    return 0', "if\
    \ n < 0 \nreturn 0\nelif n > 0 \nlet res = 0\nfor i in (2..(n div 2))\nres = res\
    \ * 10 + i\nreturn res * 2\nelse \nreturn 0\nend\n\"\"\"\n## Let's test our functions",
  '"""', "    digit_sum=0\n    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n\
    \    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum\
    \ + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n\
    \    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum\
    \ + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n\
    \    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum\
    \ + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n\
    \    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum\
    \ + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n\
    \    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum\
    \ + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n\
    \    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum\
    \ + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n\
    \    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum\
    \ + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n\
    \    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum\
    \ + n%10\n    digit_sum=digit_sum*2\n    digit_sum=digit_sum + n%10\n    digit_sum=digit_sum*2\n\
    \    digit_sum=digit_sum + ", "  if n <= 1\n  then 0\n  else n % 10 * (digits(n\
    \ / 10) * 10 + 1)\nend\n</cell>\n<text>\nSolution\nSolution using for loops",
  "    if n < 0 \n        return 0 \n    else if n % 2 == 1 \n        return n * digits(n\
    \ / 2) \n    else \n        return n * digits(n / 2) \nend ", "    if n < 0 return\
    \ 0 \n    if n == 0 return 1 \n    \n    let result = 1 \n    for d in n rem 2\
    \ :: Int64 do \n        result = result * d \n    n -= result \n    result *=\
    \ Int64(n/2) \n    return result\n</cell>\n<text>\nProblem 3", "    if isEven(n)\
    \ then 0 else n * digits(floor(n/2)*2)\nend\n</cell>\n<code language=julia-1.1>\n\
    digits(1)\n</cell>\n<text>\nProblem 3"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
