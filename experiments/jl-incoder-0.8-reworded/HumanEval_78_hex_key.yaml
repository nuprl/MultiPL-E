name: HumanEval_78_hex_key
language: jl
prompt: "\"\"\"You have been tasked to write a function that receives \n    a hexadecimal\
  \ number as a string and counts the number of hexadecimal \n    digits that are\
  \ primes (prime number, or a prime, is a natural number \n    greater than 1 that\
  \ is not a product of two smaller natural numbers).\n    Hexadecimal digits are\
  \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5,\
  \ 7, 11, 13, 17,...\n    So you have to determine a number of the following digits:\
  \ 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume\
  \ the input is always correct or empty string, \n    and symbols A,B,C,D,E,F are\
  \ always uppercase.\n    Examples:\n    >>> hex_key(\"AB\")\n    1\n    >>> hex_key(\"\
  1077E\")\n    2\n    >>> hex_key(\"ABED1A33\")\n    4\n    >>> hex_key(\"123456789ABCDEF0\"\
  )\n    6\n    >>> hex_key(\"2020\")\n    2\n    \"\"\"\nfunction hex_key(num::String)::Int64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = hex_key;\n\t@test(candidate(\"\
  AB\") == 1)\n\t@test(candidate(\"1077E\") == 2)\n\t@test(candidate(\"ABED1A33\"\
  ) == 4)\n\t@test(candidate(\"2020\") == 2)\n\t@test(candidate(\"123456789ABCDEF0\"\
  ) == 6)\n\t@test(candidate(\"112233445566778899AABBCCDDEEFF00\") == 12)\nend\n"
completions: ["    count = 0\n    for c in num\n        if c in \"0123456789ABCDEF\"\
    \n            count += 1\n        elseif c == \"A\" or c == \"B\" or c == \"C\"\
    \ or c == \"D\" or c == \"E\" or c == \"F\"\n            count += 1\n        else\n\
    \            return 0\n    end\n    return count\nend\n</cell>\n<code language=julia-1.0>\n\
    hex_key(\"AB\")\n</cell>\n<text>\nExercise: Write a function prime(digits::Int64)\
    \ which returns the number of primes\nthat have n digits. \nHint: Use a loop and\
    \ a range starting from 2 to sqrt(digits). \nUse a variable flag = false and set\
    \ flag to true if i is a prime number.\nUse this flag to increment the number\
    \ of primes that have a digit larger than or equal to n\nHint: You can use a loop\
    \ to do this.", "    if is_prime(hex_key(num))\n        prime_count\n    else\n\
    \        not_prime_count\n    end\nend\n</cell>\n<code language=julia-0.5>", " \
    \   if num == \"\"\n        error(\"The input string is empty.\")\n    else\n\
    \        len_num = length(num)\n        digits_num = length(split(num,\"0\"))\n\
    \        primes_num = 0\n        for i in 1:(digits_num-1)\n            for j\
    \ in i+1:(digits_num-1)\n                if mod(to_integer(char((num[i]))),to_integer(char((num[j])))\
    \ == 0 \n                    primes_num = primes_num+1\n                    num\
    \ = \"\"\n                    break\n            end\n        end\n        return\
    \ primes_num\n    end\nend\n</code>\n<|/ a dscore=0 tags=primes,haskell,hex,string\
    \ |>\n<| c |>\n`mod x y` doesn't work for negative numbers, as `mod` works for\
    \ positive numbers only. The `digit` function does return negative values for\
    \ digits in the range, however, see e.g. `digits \"abc\" == [-1,0,1,0,1,1]`.\n\
    <|/ c |>\n<| c |>\nThe `digit` function does return negative values for digits\
    \ in the range, however, see e.g. `digits \"abc\" == [-1,0,1,0,1,1]`.\n<|/ c |>\n\
    <| c |>\nThanks Andreas, I've updated the answer.\n<|/ c |>\n<| a |>\nHere is\
    \ a simple solution using Data.Char, Data.List and Data.Map. It uses lazy lists,\
    \ foldl and Data.Map.!.\n<code>\nhexKey :: String -> Int\nhexKey = length . foldl\
    \ (\\x -> if x == 0 || isOdd x then \"1\" : x `mod` x else x `mod` x*2)\n    \
    \         [head \"00\" ++ toUpper \"ABCD\" ++ toUpper \"0\" ++ toUpper \"123456789ABCDEF\"\
    ]\n  where toUpper \"0\" = \"0\"\n        toUpper \"1\" = \"1\"\n        toUpper\
    \ \"2\" = \"2\"\n        toUpper \"3\" = \"3\"\n        toUpper \"4\" = \"4\"\n\
    \        toUpper \"5\" = \"5\"\n        toUpper \"6\" = \"6\"\n        toUpper\
    \ \"7\" = \"7\"\n        toUpper \"8\" = \"8\"\n        toUpper \"9\" = \"9\"\n\
    \        isOdd 0 = False\n        isOdd x = x `mod` x == 0\n</code>\n<|/ a tags=primes,haskell,hex,string\
    \ dscore=0 |>\n<| c |>\nThanks Oleg, this is quite elegant! I think you meant\
    \ `if x == 0 ...`\n<|/ c |>\n<| c |>\nYes, I missed that ", "    if num == \"\"\
    \ \n        error(\"Hexadecimal number cannot be empty\")\n    else if hex_value(ch::Char)\
    \ = num \n        return 1 \n    else \n        error(\"Hexadecimal number does\
    \ not contain correct digits 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F\")\n    end \nend\
    \ \n</cell>\n<text>\nExercise 2\nWrite a function that checks if a number is palindrome.\
    \ Palindrome is a word or phrase that is written the same forward as backward,\
    \ i.e. \"kayak\" is a palindrome, \"racecar\" is not palindrome. Also known as\
    \ \"mirrored\".", "    if num.isEmpty || num == \"0\" || num == \"00\" || num\
    \ == \"000\"\n        0\n    else\n        for i in num\n            if i.isDigit()\n\
    \                if i.isUpper()\n                    (i == \"A\" || i == \"B\"\
    \ || i == \"C\" || i == \"D\" || i == \"E\" || i == \"F\")\n                else\n\
    \                    (i == \"0\" || i == \"1\" || i == \"2\" || i == \"3\" ||\
    \ i == \"4\" || i == \"5\" || i == \"6\" || i == \"7\" || i == \"8\" || i == \"\
    9\")\n            else\n                false\n    end\nend\n</code>\nMy first\
    \ try failed because of the \"true\" statement. I had to find another way to detect\
    \ if the function returned true. Instead of using the \"true\" statement I used\
    \ the return keyword, which returns the number of primes found.\n<code>", "  \
    \  let\n        hex_list = strsplit(num,\"ABCD\")\n        hex_list_size = length(hex_list)\n\
    \        prime_num_list = get_prime_num_list(hex_list_size)\n        hex_list\
    \ = map(x->to_binary(x), hex_list)\n    in \n        sum(filter(x -> x in prime_num_list,\
    \ hex_list))\n    end\nend\n\"\"\"\nExercise 6: Write a function that receives\
    \ a decimal number as a string \n    and counts the number of decimal digits that\
    \ are primes (prime number, \n    or a prime, is a natural number greater than\
    \ 1 that is not a product of two \n    natural numbers).\n    Decimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17, 19...\n    So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may\
    \ assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F\
    \ are always uppercase.\n    Examples:\n    >>> decimal_key(\"AB\")\n    1\n \
    \   >>> decimal_key(\"1077E\")\n    2\n    >>> decimal_key(\"ABED1A33\")\n   \
    \ 4\n    >>> decimal_key(\"123456789ABCDEF0\")\n    6\n    >>> decimal_key(\"\
    2020\")\n    2\n    \"\"\"", "    digit_count = length(num) -1\n    hex_digits\
    \ = \"\"\n    for ch in num\n        if isalpha(ch) || ch =='0'\n            hex_digits\
    \ += ch\n        else\n            break\n    hex_digits = hex_digits |> hex_to_int\n\
    \    hex_digits = hex_digits[digit_count]\n    if hex_digits in primes\n     \
    \   return primes[hex_digits]\n    else \n        prime_number = 1\n        for\
    \ p in primes\n            if p > hex_digits\n                break\n        \
    \    else\n                prime_number *= primes[p]\n            if prime_number\
    \ == hex_digits\n                return prime_number\n            end\n      \
    \  end\n    end\n    return 0\nend\n</cell>\n<text>\nExercise 4.5\nWrite a function\
    \ that checks if a number is pandigital. It should return true if the number is\
    \ pan digital, and false otherwise.\nExamples:\n>>> isPandigital(8)\ntrue\n>>>\
    \ isPandigital(9)\nfalse\n>>> isPandigital(12321)\nfalse\n>>> isPandigital(1232123)\n\
    true\n\"\"\"", "    if num==\"\" or num==\"null\"\n        return 0\n    if num==\"\
    \"\n        return 0\n    if any([d in hexdigits for d in num]) # if number is\
    \ in hexdigits \n        return 1\n    return 0\nend\n</cell>\n<code language=julia-1.2>",
  "    if num == \"\"\n        return 0\n    prime_digits = [2, 3, 5, 7, 11, 13, 17,\
    \ 19]\n    num_to_check = num.chars()\n    for digit in num_to_check\n       \
    \ prime_digit = prime_digits[digit.to_i(16)]\n        if prime_digit == 0\n  \
    \          num_to_check -= digit\n        else \n            prime_digits += prime_digit\n\
    \    return num_to_check.count()\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n\
    This was a fun question! This isn't the best solution but it might be helpful\
    \ to you. The function below will go through the string and add every odd number\
    \ to an array. Then it goes through the array, and compares each number to the\
    \ sum of the odd numbers. If the sum of the odd numbers is a prime number then\
    \ it adds them to the prime array. \n<code>", "    if num == \"\"\n        1\n\
    \    else\n        let\n            hex_digits = map(char,num)\n            primes\
    \ = filter(x->x==3, filter(x ->x%2==0, [x | x<<1 for x in hex_digits]))\n    \
    \        count_of_digits = filter(x->x>0, map(x -> x%10, primes))\n          \
    \  count_of_digits = map(x -> x+2, count_of_digits)\n        end\n        count_of_digits[count]\n\
    \    end\nend\n</cell>\n<code language=julia-1.0>\nhex_key(\"AB\")\n</cell>\n\
    <code language=julia-1.0>\nhex_key(\"1077E\")\n</cell>\n<code language=julia-1.0>\n\
    hex_key(\"ABED1A33\")\n</cell>\n<code language=julia-1.0>\nhex_key(\"123456789ABCDEF0\"\
    )\n</cell>\n<code language=julia-1.0>\nhex_key(\"2020\")\n</cell>\n<text>\nExercise\
    \ 2", "    lenn = length(num)\n    \n    count::Int64 = 0\n    \n    for i in\
    \ 0:lenn-1\n        digit = num[i]\n        if digit == \"A\" or digit == \"B\"\
    \ or digit == \"C\" or digit == \"D\" or digit == \"E\" or digit == \"F\"\n  \
    \          count += 1\n        end\n    end\n    \n    return count\nend\n</cell>\n\
    <text>\nExercise 8", "    if (length(num) == 0)\n        return 0\n    if num\
    \ ~~ \"A\"\n        return 2\n    if num ~~ \"B\"\n        return 3\n    if num\
    \ ~~ \"C\"\n        return 5\n    if num ~~ \"D\"\n        return 7\n    if num\
    \ ~~ \"E\"\n        return 11\n    if num ~~ \"F\"\n        return 13\n    if\
    \ num ~~ \"0\"\n        return 0\n    if num ~~ \"1\"\n        return 2\n    if\
    \ num ~~ \"2\"\n        return 3\n    if num ~~ \"3\"\n        return 5\n    if\
    \ num ~~ \"4\"\n        return 7\n    if num ~~ \"5\"\n        return 11\n   \
    \ if num ~~ \"6\"\n        return 13\n    if num ~~ \"7\"\n        return 17\n\
    \    if num ~~ \"8\"\n        return 19\n    if num ~~ \"9\"\n        return 21\n\
    end\n</cell>\n<code language=julia-1.4>", "    prime_digits = Set(\"0123456789ABCDEF\"\
    )\n    function is_prime(n::Int64)::Bool\n        is_prime = (n == 2 || n == 3)\n\
    \    end\n    function is_composite(n::Int64)::Bool\n        is_composite = (n\
    \ % 2) == 0 && (n % 3) == 0\n    end\n    function is_hex(n::Int64)::Bool\n  \
    \      is_hex = ((n % 16) == 0)\n    end\n    \n    for i = 1:length(num)\n  \
    \      if is_hex(i)\n            num_int = i\n        else\n            num_int\
    \ = tostring(num[i])\n        end\n        if is_prime(num_int)\n            if\
    \ is_composite(num_int)\n                num_int = num_int * 2\n            else\n\
    \                num_int = num_int + 2\n            end\n        else\n      \
    \      if num_int in prime_digits\n                num_int = (num_int + 2)/2\n\
    \            else\n                num_int = (num_int + 3)/2\n            end\n\
    \        end\n    end\n    return num_int\nend\n</cell>\n<code language=julia-0.4>",
  "    if num==\"\"\n        return -1\n    else\n        return sum(num.chars().filter(|x|x.is_ascii()).filter(|x|x.is_upper()).take_while(|_|\
    \ x == x).count())\n    end\nend\n</cell>\n<text>\nExercise 2: Write a function\
    \ that receives another function f and a number as its arguments. That function\
    \ should compute g(x) = f(g(x)). For example:", "    if num.length == 0 then return\
    \ 0\n    if num.head == hexdig('A') || num.head == hexdig('B') || num.head ==\
    \ hexdig('C') or num.head == hexdig('D') or num.head == hexdig('E') or num.head\
    \ == hexdig('F') then return 0\n    else return prime_count(num)\nend\n</cell>\n\
    <cell>", "    \"\"\"\n    hex_key(num::String)", "    digits=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]\n\
    \    for i in digits\n        if (num[i] >= 'A' and num[i] <= 'F')\n         \
    \   || num[i] >= 'a' and num[i] <= 'f'\n            || num[i] >= '0' and num[i]\
    \ <= '9'\n        then\n            hex_count = hex_count + 1\n        end\n \
    \   end\n    return hex_count\nend\n\"\"\"", "    if num==\"\" || num==\"NULL\"\
    \ || num==\"NULL\" \n        then return 0\n    else if is_hex(num)\n        then\
    \ let a=num[1]\n            let b=num[2]\n            let c=num[3]\n         \
    \   let d=num[4]\n            let e=num[5]\n            let f=num[6]\n       \
    \     let g=num[7]\n            let h=num[8]\n            let i=num[9]\n     \
    \       let j=num[10]\n            let k=num[11]\n            let l=num[12]\n\
    \            let m=num[13]\n            let n=num[14]\n            let o=num[15]\n\
    \            let p=num[16]\n            let q=num[17]\n            let r=num[18]\n\
    \            let s=num[19]\n            let t=num[20]\n            let u=num[21]\n\
    \            let v=num[22]\n            let w=num[23]\n            let x=num[24]\n\
    \            let y=num[25]\n            let z=num[26]\n            let A=num[27]\n\
    \            let B=num[28]\n            let C=num[29]\n            let D=num[30]\n\
    \            let E=num[31]\n            let F=num[32]\n            if a==0 &&\
    \ b==0 && c==0 && d==0 && e==0 && f==0 && g==0 && h==0 && i==0 && j==0 && k==0\
    \ && l==0 && m==0 && n==0 && o==0 && p==0 && q==0 && r==0 && s==0 && t==0 && u==0\
    \ && v==0 && w==0 && x==0 && y==0 && z==0 \n                then return 0\n  \
    \          else if a==0 || b==0 || c==0 || d==0 || e==0 || f==0 || g==0 || h==0\
    \ || i==0 || j==0 || k==0 || l==0 || m==0 || n==0 || o==0 || p==0 || q==0 || r==0\
    \ || s==0 || t==0 || u==0 || v==0 || w==0 || x==0 || y==0 || z==0 \n         \
    \       then return 0\n            else if a==1 \n                then return\
    \ 1\n            else if a==2 \n                then return 2\n            else\
    \ if a==3 \n                then return 3\n            else if a==4 \n       \
    \         then return 4\n            else if a==5 \n                then return\
    \ 5\n            else if a==6 \n                then return 6\n            else\
    \ if a==7 \n                then return 7\n            else if a==8 \n       \
    \         then return 8\n            else if a==9 \n", "    # Your code here\n\
    \    return count_digits(num)\nend\n</cell>\n<code language=julia-1.5>\nhex_key(\"\
    AB\")\n</cell>\n<text>\nExercise", "    hex_digits=\"0123456789ABCDEF\"\n    hex_count\
    \ = \n        let\n            let \n                str_num = num\n         \
    \       hex_digits_arr = str_num.split(\"\")\n                hex_digits_len =\
    \ hex_digits_arr.length\n            in \n                if hex_digits_len ==\
    \ 0 \n                    then 0\n                else \n                    let\
    \ \n                        hex_digits_arr_2d = \n                           \
    \ hex_digits_arr.map(|x| x.to_i64())\n                    in \n              \
    \          if hex_digits_arr_2d.len == hex_digits_len\n                      \
    \      then hex_digits_arr_2d.reduce(|&,|)\n                        else 0 \n\
    \            end\n        in \n            hex_count\n        end\n</code>\n<|/\
    \ a dscore=1 tags=ocaml,functional-programming,ocaml-batteries |>\n<| c |>\nHow\
    \ about `hex_count(\"ABCD\")`?\n<|/ c |>\n<| c |>\nThanks for the answer! But\
    \ I already know that. I have my own solution, posted as an answer below. Do you\
    \ think your solution is more elegant and faster?\n<|/ c |>\n<| c |>\n, your solution\
    \ is way too inefficient (O(n^2) for a counting problem), I wrote a solution that\
    \ is O(n) without using batteries, and posted it as an answer.\n<|/ c |>\n<| c\
    \ |>\nThe `count` function you posted is inefficient. That's why I posted my own\
    \ solution in the first place. But thanks for your answer anyway, it does make\
    \ sense and will probably be useful for future readers!\n<|/ c |>\n<| a tags=ocaml,functional-programming,ocaml-batteries\
    \ |>\nMy solution below, based on Svetlin's answer and some more experimenting:\n\
    <code>\n(* Count primes within a given string *)\nlet count =\n  let hex_keys\
    \ = \n    Hex_digits_of_string in \n      List.fold_left\n        (fun (acc, curr)\
    \ \n           (hex_key, hex_digits) ->\n          if hex_key mod 2 = 0 then \n\
    \              acc + hex_digits; \n              hex_digits else hex_digits)\n\
    \        0\n        hex_keys\n  in\n      hex_keys \n    |> List.length\n    |>\
    \ int\n    |> string_of_int\n    |> String.length\n    |> String.length\n    |>\
    \ string_of_int \n    |> string_of_int\n    |> String.length\n    |> string_of_int ",
  "    return sum(i==j for i,j in zip(list(num),list(hex_decode(num))[2:]))\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThank you! I am working through this right\
    \ now, but I get an incorrect value if I put in \"AB\" instead of \"A\". I am\
    \ not sure how to get around this. Thanks again.\n<|/ c |>\n<| c |>\nYou can add\
    \ a test for empty string. `if num == \"\" return 0 else return 1`\n<|/ c |>\n\
    <| c |>\nIt works when I input \"AB\". But the function should still work for\
    \ any valid hex number (so \"0AB\", \"1077E\", \"ABED1A33\", and \"123456789ABCDEF0\"\
    ) It doesn't work when I put in \"AB\" for the input. Any ideas? Thanks again.\n\
    <|/ c |>\n<| c |>\nI updated the answer. Now it should work even for empty strings.\n\
    <|/ c |>\n<| a |>\nHere is a function that will count the number of digits that\
    \ represent prime numbers. \n<code>", "    if is_valid_hex_key(num)\n    else\
    \ \n        error(\"Invalid input\")\nend", "    num::Int64 \n    \n    num::Int64\
    \ = replace(num, num == \"\", \"0\"::Int64)\n    \n    if isPrime(num)\n     \
    \   return num\n    \n    num::Int64 = replace(num, num mod 2 == 0, \"1\"::Int64)\n\
    \    num::Int64 = replace(num, num mod 3 == 0, \"2\"::Int64)\n    num::Int64 =\
    \ replace(num, num mod 5 == 0, \"3\"::Int64)\n    num::Int64 = replace(num, num\
    \ mod 7 == 0, \"4\"::Int64)\n    num::Int64 = replace(num, num mod 11 == 0, \"\
    5\"::Int64)\n    num::Int64 = replace(num, num mod 13 == 0, \"6\"::Int64)\n  \
    \  num::Int64 = replace(num, num mod 17 == 0, \"7\"::Int64)\n    num::Int64 =\
    \ replace(num, num mod 19 == 0, \"8\"::Int64)\n    num::Int64 = replace(num, num\
    \ mod 23 == 0, \"9\"::Int64)\n    num::Int64 = replace(num, num mod 29 == 0, \"\
    A\"::Int64)\n    num::Int64 = replace(num, num mod 39 == 0, \"B\"::Int64)\n  \
    \  num::Int64 = replace(num, num mod 49 == 0, \"C\"::Int64)\n    num::Int64 =\
    \ replace(num, num mod 59 == 0, \"D\"::Int64)\n    num::Int64 = replace(num, num\
    \ mod 69 == 0, \"E\"::Int64)\n    num::Int64 = replace(num, num mod 79 == 0, \"\
    F\"::Int64)\n    num::Int64 = replace(num, num mod 89 == 0, \"G\"::Int64)\n  \
    \  num::Int64 = replace(num, num mod 109 == 0, \"H\"::Int64)\n    num::Int64 =\
    \ replace(num, num mod 119 == 0, \"I\"::Int64)\n    num::Int64 = replace(num,\
    \ num mod 139 == 0, \"J\"::Int64)\n    num::Int64 = replace(num, num mod 159 ==\
    \ 0, \"K\"::Int64)\n    num::Int64 = replace(num, num mod 179 == 0, \"L\"::Int64)\n\
    \    num::Int64 = replace(num, num mod 197 == 0, \"M\"::Int64)\n    num::Int64\
    \ = replace(num, num mod 229 == 0, \"N\"::Int64)\n    num::Int64 = replace(num,\
    \ num mod 239 == 0, \"O\"::Int64)\n    num::Int64 = replace(num, num mod 259 ==\
    \ 0, \"P\"::Int64)\n    num::Int64 = replace(num, num mod 269 == 0, \"Q\"::Int64)\n\
    \    num::Int64 = replace(num, num mod 279 == 0, \"R", "    \"\"\"count the prime\
    \ numbers of the hexadecimal number\"\"\"\n    if num ==\"\"\n        return 0\n\
    \    \n    digit_to_check = map(x->(String.toUpper(x)),num) \n    digit_to_check.map(x->(x\
    \ !=String.toUpper(x)))\n    \n    let digit_to_check = map(x->(String.toUpper(x)),num)\
    \ \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check\
    \ = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num)\
    \ \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check\
    \ = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num)\
    \ \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check\
    \ = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num)\
    \ \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check\
    \ = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num)\
    \ \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check\
    \ = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num)\
    \ \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check\
    \ = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num)\
    \ \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check\
    \ = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num)\
    \ \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check\
    \ = map(x->(x !=String.toUpper(x)),num) \n    let digit_to_check = map(x->(x !=String.toUpper(x)),num)\
    \ \n    let digit_to_check = map(x->(x !=", "    if num == \"\"\n        return\
    \ 0\n    for i in num\n        if i != AtoF[i] && i != AtoF[AtoF[i]]\n       \
    \     count = 1\n            while AtoF[i * count] != AtoF[AtoF[i * count]]\n\
    \                count += 1\n            count += 1\n            if count > num.length\n\
    \                count += 1\n            hex_num += count * i\n    end\n    return\
    \ hex_num\nend\n</code>\n<|/ a tags=string,julia,function,arrays |>\n<| c |>\n\
    Oops I forgot to include that, thank you! I just added that to the original post\n\
    <|/ c |>\n<| c |>\nThank you for your help. Your solution worked perfectly. I\
    \ would upvote if I had the reputation to do so, but I'm new to Stack Overflow.\
    \ Thanks again\n<|/ c |>\n<| a dscore=0 |>\nHere is a solution with minimal code\
    \ change:\n<code>", "    if num==\"\"\n        return 0\n    for c in num\n  \
    \      d <- to_digit(c.upper())\n        if d < 10\n            d <- 10\n    \
    \    if d < 16\n            d <- 16\n        if d < 26\n            d <- 26\n\
    \        if d < 34\n            d <- 34\n        if d < 42\n            d <- 42\n\
    \        if d < 52\n            d <- 52\n        if d < 62\n            d <- 62\n\
    \        if d < 72\n            d <- 72\n        if d < 82\n            d <- 82\n\
    \        if d < 93\n            d <- 93\n        if d < 94\n            d <- 94\n\
    \        if d < 96\n            d <- 96\n        if d < 97\n            d <- 97\n\
    \        if d < 98\n            d <- 98\n        if d < 99\n            d <- 99\n\
    \        if d < 100\n            d <- 100\n        if d < 101\n            d <-\
    \ 101\n        if d < 102\n            d <- 102\n        if d < 103\n        \
    \    d <- 103\n        if d < 104\n            d <- 104\n        if d < 105\n\
    \            d <- 105\n        if d < 106\n            d <- 106\n        if d\
    \ < 107\n            d <- 107\n        if d < 108\n            d <- 108\n    \
    \    if d < 109\n            d <- 109\n        if d < 110\n            d <- 110\n\
    \        if d < 111\n            d <- 111\n        if d < 112\n            d <-\
    \ 112\n        if d < 113\n            d <- 113\n        if d < 114\n        \
    \    d <- 114\n        if d < 115\n            d <- 115\n        if d < 116\n\
    \            d <- 116\n        if d < 117\n            d <- 117\n        if d\
    \ < 118\n            d <- 118\n        if d < 119\n            d <- 119\n    \
    \    if d < 120\n            d <- 120\n        if d < 121\n            d <- 121\n\
    \        if d < 122\n            d <- 122\n        if d < 123\n            d <-\
    \ 123\n        if d < 124\n            d <- 124\n        if d < 125\n        \
    \    d <- 125\n        if d < 126\n            d <- 126\n        if d < 127\n\
    \            d <- 127\n        if d < 128\n            d <- 128\n        if d\
    \ < 129\n            d <- 129\n        if d < 130\n            d <- 130\n    \
    \    if d < 131\n            d <- 131\n        if d < 132\n            d <- 132\n\
    \        if d < ", "    \n    len = length(num)\n    \n    if len == 0 \n    \
    \    return 0\n    \n    digits = []\n    for i in 1:len-1\n        push!(digits,\
    \ strsplit(num[i], \"\")[2])\n    end\n    \n    digits[9] += 1\n    digits[12]\
    \ += 1\n    \n    for i in 1:11\n        push!(digits, 0)\n    end\n    \n   \
    \ for d in digits\n        if d == 2 || d == 3 || d == 5 || d == 7 || d == 11\
    \ || d == 13\n            digits[d] += 1\n        end\n    end\n    \n    for\
    \ i in 1:16\n        push!(digits, 0)\n    end\n    \n    for d in digits\n  \
    \      if d == 2 || d == 3 || d == 5 || d == 7 || d == 11 || d == 13\n       \
    \     digits[d] += 1\n        end\n    end\n    \n    for i in 1:16\n        push!(digits,\
    \ 0)\n    end\n    \n    for d in digits\n        if d == 2 || d == 3 || d ==\
    \ 5 || d == 7 || d == 11 || d == 13\n            digits[d] += 1\n        end\n\
    \    end\n    \n    for i in 1:16\n        push!(digits, 0)\n    end\n    \n \
    \   for d in digits\n        if d == 2 || d == 3 || d == 5 || d == 7 || d == 11\
    \ || d == 13\n            digits[d] += 1\n        end\n    end\n    \n    for\
    \ i in 1:16\n        push!(digits, 0)\n    end\n    \n    for d in digits\n  \
    \      if d == 2 || d == 3 || d == 5 || d == 7 || d == 11 || d == 13\n       \
    \     digits[d] += 1\n        end\n    end\n    \n    for i in 1:16\n        push!(digits,\
    \ 0)\n    end\n    \n    for d in digits\n        if d == 2 || d == 3 || d ==\
    \ 5 || d == 7 || d == 11 || d == 13\n            digits[d] += 1\n        end\n\
    \    end\n    \n    for i in 1:16\n        push!(digits, 0)\n    end\n    \n \
    \   for d in digits\n        if d == 2 || d == 3 || d == 5 || d == 7 || d == 11\
    \ || d == 13\n            digits[d] += 1\n        end\n    end\n    \n    for\
    \ i in 1:16\n        push!(digits, 0)\n    end\n    \n    for d in digits\n  \
    \      if d == 2 || d == 3 || d == 5 || d == 7 || d == 11 || d == 13\n       \
    \     digits[d] += 1\n        end\n    end\n    \n    for i in 1:16\n        push!(digits,\
    \ 0)\n    end\n    \n    for d in digits\n        if d == 2 || d == 3 || d ==\
    \ 5 || d == 7 || d == 11 || d == 13\n            digits[d] += 1\n        end\n\
    \    end\n    \n    for i in 1:16\n        ", "    if num == \"\" then return\
    \ 0\n    \n    digits = split(num, \"ABCDEF\")\n    \n    for i in digits\n  \
    \      num = replace(i, toupper(i), \"\")\n    \n    for digit in digits\n   \
    \     if length(digits) == 0 then return 0\n    end\n    \n    digits[1] == \"\
    A\" || digits[1] == \"B\"\n    digits[2] == \"C\" || digits[2] == \"D\"\n    digits[3]\
    \ == \"E\" || digits[3] == \"F\"\n    return length(digits)\nend", "    if hex(num).length\
    \ != 8 then return 0 \n    else if hex_key(hex(num)).n == 1 then return 1 \n \
    \   else return hex_key(hex(num)).n * hex_key(hex(num+hex(num))) end\nend\nhex_key(\"\
    \")", "    # Return number of digits which are prime numbers\n    if length(num)<=0\
    \ return 0\n    res::Int64 = 0\n    for i in 2..length(num) do \n        if ((num[i/2]==num[i])\
    \ && (i%2==0))\n            res = res + 1 \n    return res\nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function primes which  receives an array of integers and returns\
    \ an array containing the prime numbers of the array.\nUse a for loop for iteration:",
  "    if num == \"\"\n        return 0\n    str = num\n    len::Int = str.len()\n\
    \    digit::Int64 = 0\n    hex_digit::Int64 = 0\n    while hex_digit < 16\n  \
    \      if len > hex_digit\n            digit += 1\n            hex_digit += 1\n\
    \            str[hex_digit] = digit\n            len -= 1\n        end\n    end\n\
    \    return digit\nend", "    nums = split(num, \"\")\n    let primes = prime_digits(0)\n\
    \    for i in nums\n        primes = prime_digits(primes)\n    primes = prime_digits(primes)\n\
    \    return sum(i not in primes for i in nums)\nend", "    \n    \n    \"\"\"\n\
    \    Function takes in hexadecimal number and returns number of hexadecimal \n\
    \    digits primes\n    \"\"\"\n    \n    # get the string length of the input\
    \ number\n    string_length = length(num)\n    \n    \n    # initialize empty\
    \ list to store prime numbers\n    list_primes = []\n    \n    # loop through\
    \ all the digits\n    for i in (string_length - 1 downto 0)\n        \n      \
    \  # initialize a counter to keep track of prime numbers\n        prime_counter\
    \ = 1\n        \n        # loop through all the digits\n        for j in (string_length\
    \ downto 0)\n            \n            # initialize a boolean to determine if\
    \ we have a factor\n            is_prime = True\n            \n            # loop\
    \ through all the possible factors of j from i\n            for k in (string_length)\
    \ do\n            \n                # if the current digit is equal to 0 or the\
    \ digit is not \n                # a factor\n                if ((j % k) == 0)\
    \ || ((j % k) != 0)\n                    is_prime = false\n                  \
    \  break\n                end\n            end\n            \n            # if\
    \ the current digit is prime\n            if is_prime\n            \n        \
    \        # increment the counter\n                prime_counter += 1 \n      \
    \      end\n            \n        end\n        \n        # append the prime number\
    \ to the list\n        list_primes.append(prime_counter)\n        \n        #\
    \ increase i to skip the current digit\n        i -= 1\n    end\n    \n    # return\
    \ the length of the list\n    return length(list_primes)\nend\n</cell>\n<text>\n\
    Problem 8 (Optional)\nThe following problem is optional and can be solved using\
    \ the functions you learned above. If you feel confident enough you can solve\
    \ this problem using both functions or a combination of both.", "    count = 0\n\
    \    i = 2\n    while i <= length(num)\n        while i + i + i + 1 >= length(num)\n\
    \            i += 2\n        count += 1 if is_prime(bin(ord(num)[i])::Int64 +\
    \ bin(ord(num)[i + i])::Int64 + bin(ord(num)[i + i + i])::Int64 + bin(ord(num)[i\
    \ + i + i + i])::Int64)\n        i += 2\n    return count\nend function hex_key\n\
    </cell>\n<code language=julia-1.0>\n@assert hex_key(\"AB\") == 1 \n@assert hex_key(\"\
    1077E\") == 2 \n@assert hex_key(\"ABED1A33\") == 4 \n@assert hex_key(\"123456789ABCDEF0\"\
    ) == 6 \n@assert hex_key(\"2020\") == 2\n</cell>\n<text>\nExercise 2.10\nWrite\
    \ a function that receives a hexadecimal number (a string) of a person name and\
    \ returns the number of times the letter \u201Cm\u201D appears in the string in\
    \ the first name, and the number of times the letter \u201Ca\u201D appears in\
    \ the string in the last name.", "    \n    hex_list::Vector{String} = [hexdigit(c)\
    \ for c in num]\n    count_hex::Int64 = 0\n    \n    for hex in hex_list\n   \
    \     if hex.upper() == \"A\" \n            count_hex += 1\n        elif hex.upper()\
    \ == \"B\"\n            count_hex += 1\n        elif hex.upper() == \"C\"\n  \
    \          count_hex += 1\n        elif hex.upper() == \"D\"\n            count_hex\
    \ += 1\n        elif hex.upper() == \"E\"\n            count_hex += 1\n      \
    \  elif hex.upper() == \"F\"\n            count_hex += 1\n        else\n     \
    \       break\n    end\n    \n    return count_hex\nend\n</cell>\n<code language=julia-0.6>\n\
    ?hex_key\n</cell>\n<text>\nProblem 1\nWrite a function that receives an integer\
    \ (in the form of a string) and returns an integer.\nFor example, if the input\
    \ value is \"11\", your function should return 3. \nIf the input value is \"100\"\
    , your function should return 3.\nIf the input value is \"0000\", your function\
    \ should return 0.\nIf the input value is \"01\", your function should return\
    \ 1.\nIf the input value is \"1000\", your function should return 3.", "    if\
    \ hex_key(num) == None \n        error(\"Not a valid hexadecimal number\") \n\
    \    else \n        return hex_key(num) \nend", "    if num == \"\"\n        return\
    \ 0\n    num = num.upper()\n    var res::Int64 = 0\n    primes::Vector[Int64]\
    \ = prime_digits(num)\n    for i in primes\n        res::Int64 = i\n        primes::Vector[Int64]\
    \ = prime_digits(res)\n    return res\nend\n</cell>\n<code language=julia-1.5>\n\
    hex_key(\"1077E\")\n</cell>\n<text>\nThe function prime_digits function can be\
    \ defined using the following algorithm:", "    count = 0\n    for x in num\n\
    \        if x>='A'&&x<='F'\n            count++\n        end\n    end\n    return\
    \ count\nend\n</cell>\n<text>\nExercise\n(6 pts): Implement your hexadecimal key\
    \ function.\n(15 pts): Use map function and filter to find all primes below 1000.\n\
    (20 pts): Use reduce function and filter to find all prime numbers below 1000.\n\
    (25 pts): Write a function that receives two numbers and returns the sum of the\
    \ squares of the first two numbers.\n(30 pts): Write a function that receives\
    \ two numbers and returns the sum of the squares of the first two numbers, that\
    \ also has a parameter for the number of times to repeat the square.\n(35 pts):\
    \ Write a function that receives a binary number and returns its reverse number.\n\
    (40 pts): Write a function that receives a string and returns a list of strings\
    \ from that string with spaces between each character.\n(45 pts): Write a function\
    \ that receives an array and returns the sum of the elements in the array.\n(50\
    \ pts): Write a function that receives an array and returns its sum.\n(55 pts):\
    \ Write a function that receives a list with numbers and returns the sum of all\
    \ the elements in the list.\n(60 pts): Write a function that receives an array\
    \ with numbers and returns a list of strings from that array with spaces between\
    \ each element.\n(65 pts): Write a function that receives an array of strings,\
    \ returns a dictionary with keys from string and values from array of strings.\n\
    (70 pts): Write a function that receives an array of integers, and returns an\
    \ array with values between 0 and 9.\n(75 pts): Write a function that receives\
    \ an array of strings, and returns an array with strings in reverse.\n(80 pts):\
    \ Write a function that receives an array of numbers, and returns an array with\
    \ strings converted to their corresponding hexadecimal digits.\n(85 pts): Write\
    \ a function that receives an array of strings, and returns a dictionary with\
    \ keys from string and values from array of strings.\n(90 pts): Write a function\
    \ that receives an array of integers, and returns a dictionary with keys from\
    \ string and values from array of integers.", "    number = to_string(num) \n\
    \    \n    if number.length==0\n        error(\"The input is empty.\")\n    end\n\
    \    \n    base = hextobin(number[1]) \n    \n    if hextobin(number[2])!=10\n\
    \        error(\"The second character of the hex string is not an uppercase letter.\"\
    )\n    end\n    \n    primes = prime_digits(base)\n    \n    if primes.length==0\n\
    \        error(\"The prime digit count is zero.\")\n    end\n    \n    return\
    \ primes[primes.length-1]\nend", "    # Write your solution here\n    hex_digits=\"\
    0123456789ABCDEF\"\n    num=num.upper()\n    digits_count=countdigits(num)\n \
    \   count_primes=count_primes(num)\n    if digits_count==1 and count_primes>0:\n\
    \        \n        \n        return(count_primes)\n    else:\n        \n     \
    \   return(-1)\n    \n\"\"\"\n## Exercise 2.2\nWrite a function to check whether\
    \ a number is prime (is a natural number greater than 1 that is not a product\
    \ of two smaller natural numbers).\nHint: you may assume input is always correct\
    \ or empty string, and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n\
    \    >>> prime_check(5)\n    True\n    >>> prime_check(\"5\")\n    False\n   \
    \ >>> prime_check(\"AB\")\n    False\n    >>> prime_check(\"\")\n    False\n \
    \   >>> prime_check(\"12345\")\n    False\n    >>> prime_check(\"ABED1A33\")\n\
    \    True\n    >>> prime_check(\"123456789ABCDEF0\")\n    True\n    >>> prime_check(\"\
    2020\")\n    True\n    \"\"\"", "    primes :: Array[Int64] =  Array[Int64](2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97)\n\
    \    inc :: Int64 = 0\n    for digit in num\n        i :: Int64 = digit::Int64\n\
    \        inc += primes[i]\n    end\n    return inc\nend\n</cell>\n<code language=julia-0.5>\n\
    ?hex_key\n</cell>\n<code language=julia-0.5>\nhex_key(\"AB\") # 1\n</cell>\n<code\
    \ language=julia-0.5>\nhex_key(\"1077E\") # 2\n</cell>\n<code language=julia-0.5>\n\
    hex_key(\"ABED1A33\") # 4\n</cell>\n<code language=julia-0.5>\nhex_key(\"123456789ABCDEF0\"\
    ) # 6\n</cell>\n<code language=julia-0.5>\nhex_key(\"2020\") # 2\n</cell>\n<text>\n\
    4.2 Hexagons\nThe hexagonal tiling scheme was proposed in the 1976 paper \"Hexagonal\
    \ tiling in computer graphics\" by Jeffrey Shipton and Nicola Leroti. \nThe hexagonal\
    \ tiling scheme is very similar to the classic hexagonal tiling scheme.\nThe hexagonal\
    \ tiling scheme is based on a hexagon of side length 6 that has side lengths 1,\
    \ 2, 3 or 4. \nThe hexagonal tiling scheme has 6 hexagons with side length 1,\
    \ 2, 3 or 4 that form a hexagon.\nThe hexagonal tiling scheme is made of hexagons\
    \ that can rotate clockwise or counterclockwise.\nHexagons move around clockwise\
    \ and counterclockwise until they touch the ground or the edge of the hexagon.\
    \ \nThe hexagonal tiling scheme is called \"hexagonal\" because the tiling pattern\
    \ is symmetrical.\nThe hexagonal tiling scheme is commonly used on paper to represent\
    \ a 3D object such as a sphere or a cube.", "    let digit_list = num.characters\n\
    \    let digit_count = (digit_list.count) :: 0\n    let digits = (0..digit_count-1).collect{\
    \ \n        digit_list[$0]\n    }\n    let digit_to_int = digits |> Array.map\
    \ UInt32\n    let odd_digits = digits[0..digit_count-1]\n    let evens_digits\
    \ = digits[digit_count..]\n    let hexdigits_to_int = hexdigits_to_int digit_to_int\n\
    \    let odd_digits_to_int = odd_digits_to_int hexdigits_to_int\n    let evens_digits_to_int\
    \ = evens_digits_to_int odd_digits_to_int\n    let hexdigits_length = hexdigits_to_int.length\n\
    \    let odd_digits_length = odd_digits_to_int.length\n    let evens_digits_length\
    \ = evens_digits_to_int.length\n    let total_digits = hexdigits_length + odd_digits_length\
    \ + evens_digits_length\n    hexdigits_to_int.filter(is_prime).length\nend", " \
    \   \"\"\"\n    hex_key(\"AB\")\n    1\n    >>> hex_key(\"1077E\")\n    2\n  \
    \  >>> hex_key(\"ABED1A33\")\n    4\n    >>> hex_key(\"123456789ABCDEF0\")\n \
    \   6\n    >>> hex_key(\"2020\")\n    2\n    \"\"\"\n    if num == \"\"\n    \
    \    return 0\n    primes = filter_primes(num.to_digits())\n    if primes == []\n\
    \        return 0\n    primes = primes[1..]\n    hex = num.chars().collect{|c|\
    \ to_hex(c)}\n    return hex_digits(primes).intersect(hex).count\nend\n</cell>\n\
    <code language=julia-1.1>\n\"\"\"\n    primes\n    \n    Get all the primes numbers\
    \ in the given range (inclusive)", "    hex_list = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F']\n\
    \    int_list = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]\n  \
    \  hex_char_list = ['A','B','C','D','E','F']\n    key = -1\n    total = 0\n  \
    \  for c in num\n        total += int_list[hex_list.index(c)]\n    return total\n\
    end", "# returns prime number\n    if length(num) <= 2\n        2\n    else if\
    \ isPrime(num)\n        2\n    else\n        for n in (2..length(num)-1)\n   \
    \         n = next_digit(num, n)\n            n = hex_key(n) == 0 ? n : hex_key(n-1)\
    \ + 1\n        end\n    end\nend\n</code>\n<|/ a tags=algorithm,haskell |>\n<|\
    \ c |>\nThank you for your reply. I will give it a shot later today.\n<|/ c |>\n\
    <| c |>\nThis code doesn't work with `hex_key(\"012\")` because `next_digit` only\
    \ works with `hex_key(\"0\")`.\n<|/ c |>\n<| a tags=algorithm,haskell dscore=0\
    \ |>\nThis is my first ever haskell project. I think that my solution works and\
    \ can be usefull.\n<code>\nimport Data.List (foldl', elemIndex)\nimport Data.Maybe\
    \ (fromJust)", "    \n    \"\"\"\n    Complete this function\n    \"\"\"\n   \
    \ \n    return 0\nend\n</cell>\n<text>\nExercise 5\nWrite a function called count_primes.",
  "    int_num::Int64 = int64(num)\n    function prime_check(p::Int64)::Bool \n  \
    \      if p < 2 || p%2 == 1 || p < int_num\n            return false\n       \
    \ else\n            return true\n    end\n    digit_count(digits::Int64)::Int64\
    \ = digits(int_num)\n    prime_count = 0\n    while prime_count < digit_count(int_num)\n\
    \        for p in prime_candidates(int_num)\n            if prime_check(p)\n \
    \               prime_count += 1\n                break\n        end\n    end\n\
    \    return prime_count\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"A prime\
    \ number is a natural number greater than 1 that is not a \nproduct of two smaller\
    \ natural numbers\"\"\"", "    \"\"\"count number of hexadecimal digits that are\
    \ primes (prime number, \n    or a prime, is a natural number greater than 1 that\
    \ is not a product of two \n    smaller natural numbers).\n    Hexadecimal digits\
    \ are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2,\
    \ 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may\
    \ assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F\
    \ are always uppercase.\n    Examples:\n    >>> hex_key(\"AB\")\n    1\n    >>>\
    \ hex_key(\"1077E\")\n    2\n    >>> hex_key(\"ABED1A33\")\n    4\n    >>> hex_key(\"\
    123456789ABCDEF0\")\n    6\n    >>> hex_key(\"2020\")\n    2\n    \"\"\"\n   \
    \ function hex_key(num::String)::Int64 \n        if num == \"\"\n            0\n\
    \        elseif num.contains(\"A\") && num.contains(\"B\") && num.contains(\"\
    C\") && num.contains(\"D\") && num.contains(\"E\") && num.contains(\"F\")\n  \
    \          4\n        elseif num.contains(\"0\") && num.contains(\"1\")\n    \
    \        2\n        elseif num.contains(\"2\") && num.contains(\"3\")\n      \
    \      2\n        elseif num.contains(\"4\") && num.contains(\"5\") && num.contains(\"\
    6\") && num.contains(\"7\") && num.contains(\"8\") && num.contains(\"9\")\n  \
    \          2\n        elseif num.contains(\"A\") && num.contains(\"B\") && num.contains(\"\
    C\") && num.contains(\"D\") && num.contains(\"E\") && num.contains(\"F\")\n  \
    \          2\n        elseif num.contains(\"10\") && num.contains(\"11\") && num.contains(\"\
    12\") && num.contains(\"13\") && num.contains(\"14\") && num.contains(\"15\")\
    \ && num.contains(\"16\") && num.contains(\"17\") && num.contains(\"18\") && num.contains(\"\
    19\") && num.contains(\"20\") && num.contains(\"21\") && num.contains(\"22\")\
    \ && num.contains(\"23\") && num.contains(\"24\") && num.contains(\"25\") && num.contains(\"\
    26\") && num.contains(\"27\") && num.contains(\"28\") && num.contains(\"29\")\
    \ && num.", "    primes = primes_upto(none,7)\n    digit_counts = prime_digits(num,\"\
    abcdef\",7)\n    primes = primes_upto(digit_counts,7)\n    digit_counts = digit_counts_without_prime(digit_counts,primes)\n\
    \    digit_counts[2] = digit_counts[2] + (digit_counts[1] * digit_counts[2])\n\
    \    digit_counts[3] = digit_counts[3] + (digit_counts[1] * digit_counts[3])\n\
    \    digit_counts[4] = digit_counts[4] + (digit_counts[1] * digit_counts[4])\n\
    \    digit_counts[5] = digit_counts[5] + (digit_counts[1] * digit_counts[5])\n\
    \    digit_counts[6] = digit_counts[6] + (digit_counts[1] * digit_counts[6])\n\
    \    digit_counts[7] = digit_counts[7] + (digit_counts[1] * digit_counts[7])\n\
    \    return digit_counts[2] + digit_counts[3] + digit_counts[4] + digit_counts[5]\
    \ + digit_counts[6] + digit_counts[7]\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thanks, your solution is perfect. I was trying to use the same code but I think\
    \ I was complicating myself.\n<|/ c |>\n<| a tags=julia,primes |>\nI think your\
    \ code might be doing too much work. For example, once you've got digit_counts,\
    \ you only need to check if the element at position i is odd.\nAnd your prime\
    \ checker function is redundant. You've already got primes_upto and prime_digits,\
    \ so just use those.\n<code>", "    let digits = \"0123456789ABCDEF\"\n    let\
    \ digits_int = digits.to_int()\n    let result = digits_int\n    for digit in\
    \ num\n        if digit in digits\n            result+=digits_int[digit]\n   \
    \ else \n        if digit in \"ABCDEF\"\n            result+=digits_int[\"A\"\
    ]\n        else\n            result+=1\n    result\nend\n</cell>\n<text>\nProblem\
    \ 2\nA hexadecimal number is represented by a string with digits ranging from\
    \ 0 to 9 and letters A, B, C, D, E, F (uppercase only). \nThe letters indicate\
    \ the hexadecimal number system:", "    let\n        digits = num.digits \n  \
    \      primes = \n            [\n                2\n            ] ++ \n      \
    \      3::Int \n                (\n                    digits \n             \
    \       |> Array.filter (fun x -> x % 2 != 0) \n                    |> Array.filter\
    \ (fun x -> x % 3 != 0)\n                )\n    return \n        sum(\n      \
    \      primes \n            |> Array.filter (fun x -> digits.is_prime_of_length\
    \ (x + 1))\n        )", "    local n=0\n    for c in num:\n        power = math.pow(16,\
    \ n)\n        if c == hexchars.A..hexchars.F and n >= hexchars.A..hexchars.F\n\
    \            n = n - (hexchars.F-hexchars.A+1)\n        else if c == hexchars.A..hexchars.F\
    \ and n < hexchars.A..hexchars.F\n            n = n + hexchars.A-hexchars.F+1\n\
    \        else if c == hexchars.A..hexchars.F and n < hexchars.A..hexchars.F \n\
    \            n = n + hexchars.A-hexchars.F+1\n        else if c == hexchars.A..hexchars.F\
    \ and n > hexchars.A..hexchars.F\n            n = n + hexchars.A-hexchars.F+1\n\
    \        else if c == hexchars.A..hexchars.F and n > hexchars.A..hexchars.F\n\
    \            n = n + hexchars.A-hexchars.F+1\n        else if c == hexchars.A..hexchars.F\
    \ and n > hexchars.A..hexchars.F\n            n = n + hexchars.A-hexchars.F+1\n\
    \        else if c == hexchars.A..hexchars.F and n > hexchars.A..hexchars.F\n\
    \            n = n + hexchars.A-hexchars.F+1\n        else if c == hexchars.A..hexchars.F\
    \ and n > hexchars.A..hexchars.F\n            n = n + hexchars.A-hexchars.F+1\n\
    \        else if c == hexchars.A..hexchars.F and n > hexchars.A..hexchars.F\n\
    \            n = n + hexchars.A-hexchars.F+1\n        else if c == hexchars.A..hexchars.F\
    \ and n > hexchars.A..hexchars.F\n            n = n + hexchars.A-hexchars.F+1\n\
    \        else if c == hexchars.A..hexchars.F and n > hexchars.A..hexchars.F\n\
    \            n = n + hexchars.A-hexchars.F+1\n        else if c == hexchars.A..hexchars.F\
    \ and n > hexchars.A..hexchars.F\n            n = n + hexchars.A-hexchars.F+1\n\
    \        else if c == hexchars.A..hexchars.F and n > hexchars.A..hexchars.F\n\
    \            n = n + hexchars.A-hexchars.F+1\n        else if c == hexchars.A..hexchar",
  "    if is_empty(num) == true\n        0\n    else\n        if is_composite(num)\
    \ == true\n            0\n        else\n            if is_natural(num) == true\n\
    \                count_digits(num)\n            else\n                0\n    \
    \        end\n        end\n    end\nend\n</cell>\n<code language=julia-1.0>\n\"\
    \"\"\n    hex_to_char", "    count_digit_primes(num)\nend \n</cell>\n<code language=julia-1.0>",
  "    if num == \"\" return 0\n    nums = num.digits\n    if nums[1] != nums[2]\n\
    \        return 0\n    if nums[1] > 7 || nums[1] < 2 || nums[2] > 7 || nums[2]\
    \ < 2\n        return 0\n    \n    if nums[1] == 3 || nums[1] == 7 || nums[1]\
    \ == 11 || nums[1] == 13\n        \n        for d in [3,4,7,11,13]:\n        \
    \    if nums[d] == nums[1] or nums[d] == nums[2]\n                return d\n \
    \       return 0\n    \n    if nums[1] == 7 or nums[1] == 11\n        return nums[1]\n\
    \        \n    return 0", "    if num == \"\" \n        error(\"The given string\
    \ must be non-empty!\") \n    else \n        sum(isPrime(int(n)) for n in num)\
    \ \nend\n</cell>\n<code language=julia-0.6>\n\"\"\"isPrime checks if a number\
    \ is a prime.\nIf number is prime, returns true, otherwise returns false.\n\"\"\
    \"", "</code>\nA simple loop could look like this:\n<code>\nfor v in hex_keys:\n\
    \    if hex_key(val) == prime_hex_key:\n        primes_found += 1\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThank you for your help. I am trying to understand this\
    \ code and am still a novice at programming in general. Can you clarify how I\
    \ would incorporate the code into my original code? I have included my code in\
    \ the original question.\n<|/ c |>\n<| c |>\nI'm pretty sure my code is incomplete.\
    \ I don't know what to put in the \"hex_keys\" section or where I should put it.\
    \ I really appreciate your help.\n<|/ c |>\n<| c |>\nI realised that the input\
    \ should have been a string and the output should be an int so I added that to\
    \ the code. Now I'm getting a type error that reads: \n\"type 'tuple' does not\
    \ have a field 'hex_key'\"\n<|/ c |>\n<| c |>\nOkay, I think I figured it out.\
    \ Thanks for your help!\n<|/ c |>\n<| c |>\nI updated my answer, I hope it will\
    \ help you out. Feel free to ask any question you might have.\n<|/ c |>\n<| a\
    \ tags=recursion,string,python |>\nHere is my implementation. It takes in input\
    \ the string and returns a list of tuples containing the primes and non-primes\
    \ of the input string. It also checks for any missing characters in the input.\
    \ I am sure you could improve on this. \n<code>\ndef is_prime(x):\n    if x >\
    \ 0:\n        if x%2 == 0:\n            return False\n        for i in range(3,int(math.sqrt(x)+1),2):\n\
    \            if x%i == 0:\n                return False\n    return True", " \
    \   if num == \"\" \n        return 0 \n    \n    # Count number of decimal digits.\
    \ \n    num_digits <- length(num) ", "    # Your code here\n    res = 0\n    for\
    \ char in num:\n        char_to_int = ord(char)\n        if char_to_int >= 48\
    \ and char_to_int <= 57:\n            res += char_to_int\n        elif char_to_int\
    \ >= 65 and char_to_int <= 70:\n            res += char_to_int - 48\n        elif\
    \ char_to_int >= 97 and char_to_int <= 102:\n            res += char_to_int -\
    \ 55\n    return res\nend\n</cell>\n<text>\nExercise 10: Counting Primes Using\
    \ a Recursive Algorithm\nWe have seen that you can write a function using for\
    \ loops in Julia to count the number of digits in your number. Recursive functions\
    \ are functions that have calls inside them. For example, if we want to count\
    \ the number of digits of 12345, we can do so with the following code:", "   \
    \ count = 0\n    for i in num\n        count += char2digit(i)\n    return count\n\
    end", "    if length(num) < 2\n        return -1\n    return count_divisibility_divisors(to_base10(num))\
    \ == 2 ? 1 : -1", "    \n    if num == \"\" then return 0 \n    num::Int64::Set\
    \ = hex2num(num)\n    \n    let m = num.length()\n    for i in 0 .. m-1 do\n \
    \       let a = num.substring(i, i+1)\n        let b = hex2num(a + \"0\")\n  \
    \      if b.is_prime() == false then return 0 \n    end\n    return num.length()\n\
    end\n</cell>\n<code language=julia-1.4>", "    \n    let  rec find_divisors(x::Int,\
    \ y::Int, z::Int, prime::Int64)::Int64 \n        \n        if prime==0 then\n\
    \            0\n        else\n            (x*y)>z ? find_divisors(x,y,z,prime-1)\
    \ :\n                find_divisors(x,y,z//prime,prime)\n        end\n    end\n\
    \    \n    let  prime::Int64 = find_divisors(hex_to_dec(\"0\"),hex_to_dec(\"9\"\
    ),hex_to_dec(\"A\"),hex_to_dec(\"F\"))\n    \n    let  digit::Int64 = hex_to_dec(num)\n\
    \    \n    let  res::Int64 = digit %prime\n    \n    return res\nend\n</cell>\n\
    <code language=julia-1.6>\nhex_key(\"AB\")\n</cell>\n<code language=julia-1.6>\n\
    hex_key(\"1077E\")\n</cell>\n<code language=julia-1.6>\nhex_key(\"ABED1A33\")\n\
    </cell>\n<code language=julia-1.6>\nhex_key(\"123456789ABCDEF0\")\n</cell>\n<code\
    \ language=julia-1.6>\nhex_key(\"2020\")\n</cell>\n<code language=julia-1.6>",
  "    digits = \"ABCDEF\"\n    \n    len = length(num)\n    primes = collect(2:(len\
    \ - 2))\n    \n    hex_count = 0\n    \n    for i in num\n        hex_count =\
    \ hex_count*16 + digits[digittoint(i)]\n        if i != \"A\"\n            primes\
    \ = filter(elem -> elem < hex_count, primes)\n        end\n    end\n    \n   \
    \ sum = 0\n    for i in primes\n        sum = sum + i\n    end\n    \n    return\
    \ sum\nend\n</cell>\n<code language=julia-0.6>\n\"\"\"\nExercise 5\nWrite a function\
    \ named prime_count(num::String) that takes a number in \nhexadecimal notation\
    \ and returns the number of prime numbers that are \nless than or equal to the\
    \ given number. Do not worry about hexadecimal \nnumbers outside the range of\
    \ 0 - FFFF.\nExamples:\n>>> prime_count(0xFFFF)\n4\n>>> prime_count(0xFF)\n1\n\
    >>> prime_count(0x1234)\n6\n\"\"\"", "    num = num.upper()\n    hex = num.split(\"\
    \")\n    hex = hex.filter(x -> x in \"ABCDEF0123456789\")\n    hex = hex.map((x)\
    \ -> x.to_i(16))\n    hex = hex.filter(x -> x mod 2 != 0)\n    hex = hex.filter(x\
    \ -> x % 3 != 0)\n    hex = hex.filter(x -> x % 5 != 0)\n    hex = hex.filter(x\
    \ -> x % 7 != 0)\n    return hex.length\nend\n</code>\n<|/ a tags=julia dscore=1\
    \ |>\n<| c |>\nI guess you meant hex = hex.filter(x -> x mod 3 != 0)\n<|/ c |>\n\
    <| c |>\nThanks for your inputs. I guess my original intention was to find the\
    \ count of unique prime numbers smaller than the hex input length. I've edited\
    \ the question to reflect the intention.\n<|/ c |>\n<| c |>\nYeah, I misread the\
    \ original question. I'll look into this and get back to you. Thanks!\n<|/ c |>\n\
    <| c |>\nI edited the answer with a solution that returns the count. Hope it helps.\n\
    <|/ c |>\n<| c |>\nThanks! I've updated the answer with a solution returning the\
    \ count.\n<|/ c |>\n<| a dscore=1 |>\nThis should do it:\n<code>", "    \n   \
    \ if num == \"\" then return 0\n    let \n        hex_digits = num.to_chars().map(&hex\
    \ |> Char)\n        if any(hex_digits.contains(&i) && hex_digits.contains(&i +\
    \ 2) && hex_digits.contains(&i + 4) for i in [2,3,5,7,11,13]) then return 2\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,11]) then return 3\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,13]) then return 4\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,17]) then return 5\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,19]) then return 6\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,23]) then return 7\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,29]) then return 8\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,31]) then return 9\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,37]) then return 10\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,41]) then return 11\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,47]) then return 12\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,53]) then return 13\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,59]) then return 14\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,61]) then return 15\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,67]) then return 16\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,71]) then return 17\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,77]) then return 18\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,83]) then return 19\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,89]) then return 20\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,97]) then return 21\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,101]) then return 22\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,107]) then return 23\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,113]) then return 24\n\
    \        if any(hex_digits.contains(&i) for i in [2,3,5,7,119]) then return 25\n\
    \        if any(hex_digits.contains(&i", "    if num.isEmpty()\n        return\
    \ 0\n    \n    digits = num.toCharArray()\n    digits = Array{Char,1}(digits)\n\
    \    \n    for i in 0:length(digits)-1\n        if digits[i] <: digits[i+1]\n\
    \            return length(digits) - i - 1\n        end\n    end\n    \n    for\
    \ i in 0:length(digits)-1\n        if digits[i] == digits[i+1]\n            return\
    \ length(digits) - i - 1\n        end\n    end\n    \n    for i in 0:length(digits)-1\n\
    \        if digits[i] == digits[i+1] &&\n            digits[i] <: digits[i+2]\n\
    \            return length(digits) - i - 1\n        end\n    end\n    \n    return\
    \ 0\nend", "    if num == \"\"\n        return 0\n    \n    \n    ", "    digits=0\n\
    \    digits=0\n    digits=0 \n    for num in num\n        for digit in num\n \
    \           if digit=='A' or digit=='B' or digit=='C' or digit=='D' or digit=='E'\
    \ or digit=='F'\n                digits=digits+1\n    end\n    return digits\n\
    end\n</cell>\n<code language=julia-1.0>\nhex_key(\"AB\")\n</cell>\n<code language=julia-1.0>\n\
    hex_key(\"1077E\")\n</cell>\n<code language=julia-1.0>\nhex_key(\"ABED1A33\")\n\
    </cell>\n<code language=julia-1.0>\nhex_key(\"123456789ABCDEF0\")\n</cell>\n<code\
    \ language=julia-1.0>\nhex_key(\"2020\")\n</cell>\n<text>\nProblem 10\nA palindrome\
    \ is a word, phrase, or other sequence of characters that \nreads the same backward\
    \ as forward.\nA string is said to be a palindrome if the reverse of that string\
    \ \nequals the original string.\nA palindrome is a string that reads the same\
    \ backward as forward, \nand is spelled the same way backward as forward.\nExamples:\n\
    \u201Cracecar\u201D is a palindrome.\n\u201Chello\u201D is a palindrome.\n\u201C\
    Ramanujan is a palindrome.\n\u201CA man, a plan, a canal: Panama\u201D is a palindrome.\n\
    \u201CThe rain in Spain\u201D is a palindrome.\n\u201CIs He a palindrome?\u201D\
    \ is a palindrome.\n\u201CA man, a plan, a canal: Panama\u201D is not a palindrome.\n\
    \u201CThe rain in Spain\u201D is not a palindrome.\n\u201CIs He a palindrome?\u201D\
    \ is not a palindrome.\nThe function palindrome should return the first string\
    \ that is a palindrome, \nor return false if there is no such string.\nA palindrome\
    \ is a string that reads the same backward as forward, \nand is spelled the same\
    \ way backward as forward.\nExamples\npalindrome(\"racecar\")\n\"racecar\"\npalindrome(\"\
    hello\")\n\"hello\"\npalindrome(\"Ramanujan is a palindrome.\")\n\"Ramanujan is\
    \ a palindrome.\"\npalindrome(\"A man, a plan, a canal: Panama\")\n\"A man, a\
    \ plan, a canal: Panama\"\npalindrome(\"The ", "    num \u2208 string(\"\") ?\
    \ 0 : string \"ABED1A33\" \u2208 string(num) ? 0 : \n        string \"123456789ABCDEF0\"\
    \ \u2208 string(num) ? 0 : \n        string \"2020\" \u2208 string(num) ? 0 :\
    \ \u221E \n    \u2227 2::Int \u2208 string(num) ? 0 :\n        3::Int \u2208 string(num)\
    \ ? 0 : 5::Int \u2208 string(num) ? 0 : 7::Int \u2208 \n        string(num) ?\
    \ 0 : 11::Int \u2208 string(num) ? 0 : 13::Int \u2208 string(num) ? \n       \
    \     0 : 17::Int \u2208 string(num) ? 0 : 19::Int \u2208 string(num) ? 0 : \n\
    \            21::Int \u2208 string(num) ? 0 : 25::Int \u2208 string(num) ? 0 :\
    \ \n            29::Int \u2208 string(num) ? 0 : 33::Int \u2208 string(num) ?\
    \ 0 : \n            37::Int \u2208 string(num) ? 0 : 41::Int \u2208 string(num)\
    \ ? 0 : \n            45::Int \u2208 string(num) ? 0 : 49::Int \u2208 string(num)\
    \ ? 0 : \n            53::Int \u2208 string(num) ? 0 : 57::Int \u2208 string(num)\
    \ ? 0 : \n            61::Int \u2208 string(num) ? 0 : 67::Int \u2208 string(num)\
    \ ? 0 : \n            71::Int \u2208 string(num) ? 0 : 75::Int \u2208 string(num)\
    \ ? 0 : \n            79::Int \u2208 string(num) ? 0 : 83::Int \u2208 string(num)\
    \ ? 0 : \n            87::Int \u2208 string(num) ? 0 : 91::Int \u2208 string(num)\
    \ ? 0 : \n            97::Int \u2208 string(num) ? 0 : 101::Int \u2208 string(num)\
    \ ? 0 : \n            103::Int \u2208 string(num) ? 0 : 105::Int \u2208 string(num)\
    \ ? 0 : \n            107::Int \u2208 string(num) ? 0 : 109::Int \u2208 string(num)\
    \ ? 0 : \n            111::Int \u2208 string(num) ? 0 : 113::Int \u2208 string(num)\
    \ ? 0 : \n            115::Int \u2208 string(num) ? 0 : 117::Int \u2208 string(num)\
    \ ? 0 : \n            119::Int \u2208 string(num) ? 0 : 121::Int \u2208 string(num)\
    \ ? 0 : \n            123::Int \u2208 string(num) ? 0 : 127::Int \u2208 string(num)\
    \ ? 0 : \n            129::Int \u2208 string(num) ? 0 : 13", "    local res=0\n\
    \    for _ in hexdigits(num) do\n        if mod(_,BASE)==2 || mod(_,BASE+1)==2\
    \ then\n            res+=1 \n        end\n    end\n    return res\nend\n\"\"\"\
    \n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n    count-primes-by-hex-keys\n\
    \    count-primes-by-hex-keys\n    count-prime", "    \n    \n    \"\"\"\n   \
    \ Implement a function that receives a hexadecimal number as a string \n    and\
    \ counts the number of hexadecimal digits that are primes (prime \n    number,\
    \ or a prime, is a natural number greater than 1 that is not a \n    product of\
    \ two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n\
    \    So you have to determine a number of the following digits: 2, 3, 5, 7, \n\
    \    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is\
    \ always correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.\n\
    \    Examples:\n    >>> hex_key(\"AB\")\n    1\n    >>> hex_key(\"1077E\")\n \
    \   2\n    >>> hex_key(\"ABED1A33\")\n    4\n    >>> hex_key(\"123456789ABCDEF0\"\
    )\n    6\n    >>> hex_key(\"2020\")\n    2\n    \"\"\"\n    return 0", "    if\
    \ num == \"\"\n        return 0\n    let digits = [0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, A, B, C, D, E, F]\n    let hex = digits(num.uppercase())\n    let hex = hex.filter(x\
    \ -> x != 0)\n    let hex = hex.filter(x -> x % 2 != 0)\n    let hex = hex.filter(x\
    \ -> x % 3 == 0)\n    let hex = hex.filter(x -> x % 5 == 0)\n    let hex = hex.filter(x\
    \ -> x % 7 == 0)\n    let hex = hex.filter(x -> x % 11 == 0)\n    let hex = hex.filter(x\
    \ -> x % 13 == 0)\n    let hex = hex.filter(x -> x % 17 == 0)\n    let hex = hex.filter(x\
    \ -> x % 19 == 0)\n    let hex = hex.filter(x -> x % 23 == 0)\n    let hex = hex.filter(x\
    \ -> x % 29 == 0)\n    let hex = hex.filter(x -> x % 31 == 0)\n    let hex = hex.filter(x\
    \ -> x % 37 == 0)\n    let hex = hex.filter(x -> x % 41 == 0)\n    let hex = hex.filter(x\
    \ -> x % 43 == 0)\n    let hex = hex.filter(x -> x % 47 == 0)\n    let hex = hex.filter(x\
    \ -> x % 51 == 0)\n    let hex = hex.filter(x -> x % 53 == 0)\n    let hex = hex.filter(x\
    \ -> x % 57 == 0)\n    let hex = hex.filter(x -> x % 61 == 0)\n    let hex = hex.filter(x\
    \ -> x % 67 == 0)\n    let hex = hex.filter(x -> x % 71 == 0)\n    let hex = hex.filter(x\
    \ -> x % 73 == 0)\n    let hex = hex.filter(x -> x % 79 == 0)\n    let hex = hex.filter(x\
    \ -> x % 83 == 0)\n    let hex = hex.filter(x -> x % 89 == 0)\n    let hex = hex.filter(x\
    \ -> x % 97 == 0)\n    let hex = hex.filter(x -> x % 101 == 0)\n    let hex =\
    \ hex.filter(x -> x % 103 == 0)\n    let hex = hex.filter(x -> x % 107 == 0)\n\
    \    let hex = hex.filter(x -> x % 111 == 0)\n    let hex = hex.filter(x -> x\
    \ % 113 == 0)\n    let hex = hex.filter(x -> x % 115 == 0)\n    let hex = hex.filter(x\
    \ -> x % 117 == 0)\n    let hex = hex.filter(x -> ", "    if is_prime(num)\n \
    \       return num.to_i\n    else\n        return hex_key(num.to_upper).to_i\n\
    \    end\nend\n</cell>\n<code language=julia-1.4>\n\"\"\"\nis_prime (num::String)::Bool",
  "    \n    return 0\nend\n</cell>\n<code language=julia-1.4>\nhex_key(\"\")\n</cell>\n\
    <code language=julia-1.4>", "    if is_hex(num) == true\n        else is_hex(num)\
    \ == false \n            return -1\n    end\n    if is_hex(num) == false\n   \
    \     error(\"The input is not a hexadecimal number\")\n    end\n    \n    function\
    \ is_hex(num::String)\n        length(num) == length(hexdigits) && \n        all(x\
    \ -> x in hexdigits, num) && \n        all(x -> x < hexdigits, num) && \n    \
    \    all(x -> x not in hexdigits, num)\n    end\n    if is_hex(num) == true\n\
    \        count(num) == length(num)\n    end\nend\n</code>\n<|/ a tags=julia,hex,primes\
    \ dscore=1 |>\n<| c |>\n\"You may assume the input is always correct or empty\
    \ string, \" you can't, otherwise you'd need to check for each digit.\n<|/ c |>\n\
    <| c |>\nyes, but it can be also the case when input is correct hexadecimal number.\
    \ I'll add it to my answer.\n<|/ c |>\n<| c |>\nIt is not very clear how you expect\
    \ to check for each digit. Do you expect a more efficient solution?\n<|/ c |>\n\
    <| c |>\nThe solution I have posted is simple and straightforward. I believe that\
    \ most of us are experienced in programming so I believe that most of us would\
    \ have seen this solution earlier or later. Your solution is very close to the\
    \ solution I posted earlier.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "\"\"\"\nCount\
    \ Hexadecimal Digit Prime\n\"\"\"\nif num == \"\" return 0\nlet hex = num.upcase()\n\
    let mut cnt = 0\nfor i in 0..(hex.length()-1) {\n    cnt += hex.chars().any(|c|\
    \ c in \"0123456789ABCDEF\")\n}\nreturn cnt\nend\n\"\"\"\nCount Hexadecimal Digit\
    \ Prime\n\"\"\"", "    \"\"\"returns number of primes starting from 10\"\"\"\n\
    \    return count(num, hexdigits)\nend\n</code>\nEDIT: Fixed a bug in hex_key\n\
    <|/ a tags=julia,primes dscore=2 |>\n<| a tags=julia,primes dscore=1 |>\n<code>",
  "    count = 0\n    for c in num:\n        if isHexDigit(c):\n            count\
    \ = count + 1\n            if isPrime(count):\n                return count\n\
    \    return count\n</code>\n<|/ a tags=string,haskell,recursion dscore=0 |>\n\
    <| c |>\n`isHexDigit` can be rewritten as `ord c >= 48 andalso ord c <= 57` since\
    \ all non-decimal digits are in range 48 - 57\n<|/ c |>\n<| c |>\nAhh I see, I\
    \ used isHexDigit because I had some bad code on my computer that used isCharInHexDigit\
    \ which for some reason wasn't working so I just replaced that line with the one\
    \ you posted.\n<|/ c |>\n<| c |>\nI changed it to use the ord function and I edited\
    \ my original post with the updated code but it keeps returning 0 for all inputs.\
    \ I've added the isPrime function to the original post.\n<|/ c |>\n<| c |>\nHmm,\
    \ that works for me. Are you sure you're using your `isHexDigit` function and\
    \ not the original `isCharInHexDigit`? Try printing the value of `count` each\
    \ time you call the function to see how it changes.\n<|/ c |>\n<| c |>\nI think\
    \ I see what is happening now, I'll update the original post with what I see now\
    \ and what it returned for my other inputs.\n<|/ c |>\n<| a dscore=0 tags=string,haskell,recursion\
    \ |>\nI think what you need to use is isDigit. isCharInHexDigit isn't going to\
    \ help you much here, because it's only ever going to return False if c is not\
    \ in 0-9 and thus never match isDigit.\nisDigit takes in an integer and checks\
    \ if it's in the set 0-9. isHexDigit looks for the first hex digit.\nIf you look\
    \ carefully at your code, isHexDigit uses isCharInHexDigit which means you need\
    \ to change it to isDigit instead.\nAlso, you only need to check up to isZero\
    \ when you're checking for the first hex digit, and up to isOne when you're checking\
    \ for the second, since those are the only ones you need to check with isPrime.\n\
    Here's what I came up with:\n<code>\nisHexDigit :: Char -> Bool\nisHexDigit =\
    \ ord >= 48 andalso ord <= 57", "    num = num.upper\n    if num == \"\"\n   \
    \     return 0\n    num::String\n    if num !~ /^[0-F]$/\n        return 0\n \
    \   num::Int64\n    return count(num) - count(num.upper)\nend\n</cell>\n<text>\n\
    Exercise 9 - Sieve of Eratosthenes", "    if num == \"\"\n        return -1\n\
    \    if num == \"A\" || num == \"B\"\n        return -1\n    if num == \"C\" ||\
    \ num == \"D\"\n        return -1\n    if num == \"E\" || num == \"F\"\n     \
    \   return -1\n    if num == \"0\"\n        return 1\n    if num == \"1\"\n  \
    \      return 1\n    if num == \"2\"\n        return 2\n    if num == \"3\"\n\
    \        return 3\n    if num == \"4\"\n        return 4\n    if num == \"5\"\n\
    \        return 5\n    if num == \"6\"\n        return 6\n    if num == \"7\"\n\
    \        return 7\n    if num == \"8\"\n        return 8\n    if num == \"9\"\n\
    \        return 9\n    if num == \"10\"\n        return 10\n    if num == \"11\"\
    \n        return 11\n    if num == \"12\"\n        return 12\n    if num == \"\
    13\"\n        return 13\n    if num == \"14\"\n        return 14\n    if num ==\
    \ \"15\"\n        return 15\n    if num == \"16\"\n        return 16\n    if num\
    \ == \"17\"\n        return 17\n    if num == \"18\"\n        return 18\n    if\
    \ num == \"19\"\n        return 19\n    if num == \"20\"\n        return 20\n\
    \    if num == \"21\"\n        return 21\n    if num == \"22\"\n        return\
    \ 22\n    if num == \"23\"\n        return 23\n    if num == \"24\"\n        return\
    \ 24\n    if num == \"25\"\n        return 25\n    if num == \"26\"\n        return\
    \ 26\n    if num == \"27\"\n        return 27\n    if num == \"28\"\n        return\
    \ 28\n    if num == \"29\"\n        return 29\n    if num == \"30\"\n        return\
    \ 30\n    if num == \"31\"\n        return 31\n    if num == \"32\"\n        return\
    \ 32\n    if num == \"33\"\n        return 33\n    if num == \"34\"\n        return\
    \ 34\n    if num == \"35\"\n        return 35\n    if num == \"36\"\n        return\
    \ 36\n    if num == \"37\"\n        return 37\n    if num == \"38\"\n        return\
    \ 38\n    if num == \"39\"\n        return 39\n    if num == \"40\"\n        return\
    \ 40\n    if num == \"41\"\n        return 41\n    if num == \"42\"\n        return\
    \ 42\n    if num == \"43\"\n        return 43\n    if num == \"44\"\n        return\
    \ 44\n    if num == \"45\"\n        return 45\n    if num == \"46\"\n        return\
    \ 46\n    if num == \"47\"\n        return 47\n    if num == \"48\"\n        return\
    \ 48\n    if num == \"49\"\n        return 49\n    if num == \"50\"\n        return\
    \ 50\n    if num == \"51\"\n        return 51\n    if num == \"52\"\n        return ",
  "    if num == \"\"\n        return 0\n    else\n        prime_count = 0\n     \
    \   \n        for ch in num\n            \n            hex_digit = ch\n      \
    \      \n            if isDigit(ch)\n                \n                hex_digit::Int64\
    \ = parse(Char.digit(ch))\n            else\n                if hex_digit == hex(\"\
    A\")\n                    hex_digit::Int64 = 26\n                else\n      \
    \              if hex_digit == hex(\"B\")\n                        hex_digit::Int64\
    \ = 27\n                    else\n                        if hex_digit == hex(\"\
    C\")\n                            hex_digit::Int64 = 28\n                    \
    \    else\n                            if hex_digit == hex(\"D\")\n          \
    \                      hex_digit::Int64 = 29\n                            else\n\
    \                                if hex_digit == hex(\"E\")\n                \
    \                    hex_digit::Int64 = 30\n                                else\n\
    \                                    if hex_digit == hex(\"F\")\n            \
    \                            hex_digit::Int64 = 31\n                         \
    \           else\n                                        if hex_digit == hex(\"\
    0\")\n                                            hex_digit::Int64 = 48\n    \
    \                                    else\n                                  \
    \          if hex_digit == hex(\"1\")\n                                      \
    \          hex_digit::Int64 = 49\n                                           \
    \ else\n                                                if hex_digit == hex(\"\
    2\")\n                                                    hex_digit::Int64 = 50\n\
    \                                                else\n                      \
    \                              if hex_digit == hex(\"3\")\n                  \
    \                                      hex_digit::Int64 = 51\n               \
    \                                     else\n                                 \
    \                       if hex_digit == hex(\"4\")\n                         \
    \                                   hex_digit::Int64 = 52\n                  \
    \                                      else\n                                \
    \                            if hex_digit == hex(\"5\")\n                    \
    \                                            hex_digit::Int64 = 53\n         \
    \                                                   else\n                   \
    \                                             if hex_digit == hex(\"6\")\n   \
    \                                                                 hex_digit::Int64\
    \ = 54\n                                                                else\n\
    \                                                                    if hex_digit\
    \ == hex(\"7\")\n                                                            \
    \            hex_digit::Int64 = 55\n                                         \
    \                           else\n                                           \
    \                         if hex_digit == hex(\"8\")\n                       \
    \                                                 hex_digit::Int64 = 56\n    \
    \                                                                else\n      \
    \                                                              if hex_digit ==\
    \ hex(\"9\")\n                                                               \
    \         hex_digit::Int64 = 57\n                                            \
    \                        else\n                                              \
    \                      if hex_digit == hex(\"a\")\n                          \
    \                                              hex_digit::Int64 = 97\n       \
    \                                                             else\n         \
    \                                                           if hex_digit == hex(\"\
    b\")\n                                                                       \
    \ hex_digit::Int64 = 98\n                                                    \
    \                else\n                                                      \
    \              if hex_digit == hex(\"c\")\n                                  \
    \                                      hex_digit::Int64 = 99\n               \
    \                                                     else\n                 \
    \                                                   if hex_digit == hex(\"d\"\
    )\n                                                                        hex_digit::Int64\
    \ = 100\n                                                                    else\n\
    \                                                                    if hex_digit\
    \ == hex(\"e\")\n", "    # your code here\n    \n    digits = num.chars.collect{|d|\
    \ d.to_i}\n    \n    primes = (0..64).filter{|x| x.odd?}.filter{|x| digits.include?(x)}\n\
    \    \n    primes.count{|x| hex_key(x)}\nend", "    for i in num\n        if hexdigits[i]\
    \ in hexdigits2primes\n            prime_count += hexdigits2primes[hexdigits[i]]\n\
    \    end\n    return prime_count\nend\n</cell>\n<code language=julia-1.4>", " \
    \   \"\"\"\n    Input: \n        num: a string representing the hexadecimal number\n\
    \    Output:\n        an integer representing the number of prime numbers in the\
    \ hexadecimal number\n    \"\"\"\n    num = tolower(num)\n    \n    primes = \n\
    \    if num =~ \"^[0-9A-F]+$\"\n        error(\"input must be hexadecimal string\"\
    )\n    end\n    \n    prime_digits = \"\"\n    for i in num\n        if i != \"\
    A\" and i != \"B\" and i != \"C\" and i != \"D\" and i != \"E\" and i != \"F\"\
    \n            error(\"input must be hexadecimal string\")\n        end\n     \
    \   prime_digits += i\n    end\n    \n    prime_digits = prime_digits[1..end]\n\
    \    \n    return length(prime_digits)\nend", "    if num == \"\" || is_hex(num)\n\
    \        return 0\n    digits = split(num, \"\")\n    for a in digits[2:5]\n \
    \       if is_hex(tostring(a))\n            count += 1\n    return count\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nUsing Mathematica for the primality check:\n<code>\n\
    CheckPrime[n_] := Module[{q, n0, n1, d, b, p, n2, n3, x, j, i, a, f},\n  If[n\
    \ < 2 || n > 31, \n   False,\n   If[n < 4, \n    True,\n    If[n == 2,\n     True]\n\
    \    ];\n   n0 = Floor[n];\n   n1 = n - n0;\n   If[n1 == 2, \n    False\n   ];\n\
    \   d = Floor[Sqrt[(n0 - 1) ^ 2]];\n   b = Floor[Floor[n0 / 2]];\n   For[i = 1,\
    \ i <= b, i++,\n    n2 = i*i + n1;\n    n3 = n2 + n0;\n    If[n3 > n1,\n     If[n3\
    \ != n2,\n      If[n0 == 1,\n       If[n3 != 2,\n        False\n       ],\n  \
    \    If[n0 == 2,\n       True\n       ]\n     ],\n     If[n0 != 1,\n      If[n3\
    \ != 2,\n       If[n0 == 1,\n        If[n3 != 2,\n         False\n        ],\n\
    \       False\n      ]\n     ],\n     n2 == n3,\n     False\n    ]\n   ]\n   ]\n\
    \   ]\n</code>\nThe function below returns True if and only if the input number\
    \ is a prime number:\n<code>\nIsPrime[n_] := Module[{q},\n  If[n < 2 || n > 31,\
    \ \n   False,\n   If[n < 4, \n    True,\n    If[n == 2,\n     True]\n   ]\n  \
    \ ];\n   q = Floor[Sqrt[(n-1)^2]];\n   If[n == 2,\n    True\n   ];\n   For[j =\
    \ 1, j <= q, j++,\n    n = j*j;\n    If[n*n > n,\n     If[n*n < n,\n      If[n*n\
    \ != j,\n       True\n      ]\n     ]\n    ]\n   ]\n   ]\n</code>\nThen:\n<code>\n\
    TestPrime[n_] := If[\n  n < 2, \n  True,\n  CheckPrime[n],\n  False\n]\n</code>\n\
    and:\n<code>\nTestPrime[2^15]\n", "    len_hex = length(num)\n    if num == \"\
    \" || len_hex <= 0\n        return 0\n    hex_digit::Int64 = 0\n    digit::Int64\
    \ = 1\n    prev_digit::Int64 = 0\n    prime::Int64 = 0\n    while digit < len_hex\n\
    \        hex_digit = digit - prev_digit\n        prime = digit == 11 || digit\
    \ == 13\n        if isPrime(hex_digit) || prime\n            prime = 1\n     \
    \       prev_digit = digit\n        else\n            prime = 0\n        hex_digit\
    \ += 1\n        digit += 1\n    end\n    return prime\nend", "    digits = split(num,\
    \ '').map(x => hex(x))\n    digits = filter((x)-> x%2 == 0, digits)\n    digits\
    \ = filter((x)-> x%2 == 1, digits)\n    digits = filter((x)-> x%2 != 0, digits)\n\
    \    digits = filter((x)-> x%2 != 1, digits)\n    digits = filter((x)-> x%3 !=\
    \ 0, digits)\n    digits = filter((x)-> x%3 != 1, digits)\n    digits = filter((x)->\
    \ x%5 != 0, digits)\n    digits = filter((x)-> x%5 != 1, digits)\n    digits =\
    \ filter((x)-> x%7 != 0, digits)\n    digits = filter((x)-> x%7 != 1, digits)\n\
    \    digits = filter((x)-> x%11 != 0, digits)\n    digits = filter((x)-> x%11\
    \ != 1, digits)\n    digits = filter((x)-> x%13 != 0, digits)\n    digits = filter((x)->\
    \ x%13 != 1, digits)\n    digits = filter((x)-> x%17 != 0, digits)\n    digits\
    \ = filter((x)-> x%17 != 1, digits)\n    digits = filter((x)-> x%23 != 0, digits)\n\
    \    digits = filter((x)-> x%23 != 1, digits)\n    digits = filter((x)-> x%29\
    \ != 0, digits)\n    digits = filter((x)-> x%29 != 1, digits)\n    digits = filter((x)->\
    \ x%31 != 0, digits)\n    digits = filter((x)-> x%31 != 1, digits)\n    digits\
    \ = filter((x)-> x%31 != 0, digits)\n    digits = filter((x)-> x%31 != 1, digits)\n\
    \    digits = filter((x)-> x%31 != 2, digits)\n    digits = filter((x)-> x%31\
    \ != 3, digits)\n    digits = filter((x)-> x%31 != 5, digits)\n    digits = filter((x)->\
    \ x%31 != 7, digits)\n    digits = filter((x)-> x%31 != 11, digits)\n    digits\
    \ = filter((x)-> x%31 != 13, digits)\n    digits = filter((x)-> x%31 != 17, digits)\n\
    \    digits = filter((x)-> x%31 != 19, digits)\n    digits = filter((x)-> x%31\
    \ != 23, digits)\n    digits = filter((x)-> x%31 != 29, digits)\n    digits = ",
  "    # Your code here\n    # return count of number with 2 decimal\n    digit_count=0\n\
    \    if num == \"\"\n        return digit_count\n    for i in num\n        if\
    \ ('A' <= i) && (i <= 'F')\n            digit_count+=12\n        elseif ('B' <=\
    \ i) && (i <= 'F')\n            digit_count+=8\n        elseif ('0' <= i) && (i\
    \ <= '9')\n            digit_count+=1\n        elseif ('E' <= i) && (i <= 'F')\n\
    \            digit_count+=10\n        else\n            digit_count+=int(i)\n\
    \        \n    return digit_count", "    num=num.upper()\n    \n    let digit_count=countDigits(num)\n\
    \    \n    if digit_count>1\n    then \n        prime_digits=count_prime_digits(num)\n\
    \        let prime_digit_count=digit_count-prime_digits+1 \n        let digits_per_prime=digits_in_bases(prime_digits)\n\
    \        let digits=hexDigits(num)\n        let digit_count_prime=countDigits(digits)\n\
    \        let prime_digits_prime=digits_in_bases(prime_digits)-prime_digits_prime+1\n\
    \        let digits_to_check=(digits_per_prime*digits_prime)//digit_count_prime\n\
    \        return digit_count_prime-digits_to_check\n    else\n        return digit_count\n\
    end\n</cell>\n<text>\nProblem 9\nThe hexadecimal numbers, 167, 9, 102, 109, 107,\
    \ and 1103 are all prime.\nFind how many hexadecimal digits are there in the number\
    \ 16746972.\nHint: use the function hex_key from the previous problem.\nExamples:\n\
    >>> hex_key(\"167\")\n5\n>>> hex_key(\"9\")\n2\n>>> hex_key(\"102\")\n3\n>>> hex_key(\"\
    109\")\n3\n>>> hex_key(\"107\")\n3\n>>> hex_key(\"1103\")\n3\n\"\"\"", "    \n\
    \    \n    primes = prime_list \n    \n    prime_digits = filter(x->(x>=2), primes)\n\
    \    \n    # counting number of possible primes with less than 16 digits\n   \
    \ prime_digit_count = length(prime_digits)\n    \n    # counting number of possible\
    \ primes with more than 16 digits\n    prime_digit_count_more = prime_digit_count\
    \ + 16\n    \n    # counting number of possible primes with more than 16 digits\n\
    \    digit_digit_count = length(num) - prime_digit_count + prime_digit_count_more\n\
    \    \n    # counting number of possible primes with more than 16 digits\n   \
    \ digit_digit_count_more = digit_digit_count + 16\n    \n    # counting number\
    \ of possible primes with more than 16 digits\n    digit_digit_count_more = digit_digit_count_more\
    \ + 16\n    \n    # counting number of possible primes with more than 16 digits\n\
    \    digit_digit_count_more = digit_digit_count_more + 16\n    \n    # counting\
    \ number of possible primes with more than 16 digits\n    digit_digit_count_more\
    \ = digit_digit_count_more + 16\n    \n    # counting number of possible primes\
    \ with more than 16 digits\n    digit_digit_count_more = digit_digit_count_more\
    \ + 16\n    \n    # counting number of possible primes with more than 16 digits\n\
    \    digit_digit_count_more = digit_digit_count_more + 16\n    \n    # counting\
    \ number of possible primes with more than 16 digits\n    digit_digit_count_more\
    \ = digit_digit_count_more + 16\n    \n    # counting number of possible primes\
    \ with more than 16 digits\n    digit_digit_count_more = digit_digit_count_more\
    \ + 16\n    \n    # counting number of possible primes with more than 16 digits\n\
    \    digit_digit_count_more = digit_digit_count_more + 16\n    \n    # counting\
    \ number of possible primes with more than 16 digits\n    digit_digit_count_more\
    \ = digit_digit_count_more + 16\n    \n    # counting number of possible primes\
    \ with more than 16 digits\n    digit_digit_count_more = digit_digit_count_more\
    \ + 16\n    \n    # counting number of possible primes with more than 16 digits\n\
    \    digit_digit_count_more = digit_digit_count_more + 16\n    \n    # counting\
    \ number of possible primes with more than 16 digits\n    digit_digit_count_more\
    \ = digit_digit_count_more + 16\n    \n    # counting number of possible primes\
    \ with more than 16 digits\n    digit_digit_count_more = digit_digit_count_more\
    \ + 16\n    \n    # counting number of possible primes with more than 16 digits\n\
    \    digit_digit_count_more = digit_digit_count_more + 16\n    \n    # counting\
    \ number of possible primes with more than 16 digits\n    ", "    if num.length\
    \ != 6\n        return 0\n    elif num == \"0\"\n        return 1\n    else if\
    \ num.includes(\"A\"..\"F\")\n        return 2\n    else if num.includes(\"B\"\
    ..\"F\")\n        return 2\n    else if num.includes(\"0\"..\"9\")\n        return\
    \ 2\n    else if num.includes(\"2\"..\"9\")\n        return 2\n    else if num.includes(\"\
    3\"..\"9\")\n        return 2\n    else if num.includes(\"5\"..\"9\")\n      \
    \  return 2\n    else if num.includes(\"7\"..\"9\")\n        return 2\n    else\
    \ if num.includes(\"B\"..\"F\")\n        return 2\n    else if num.includes(\"\
    D\"..\"F\")\n        return 2\n    else if num.includes(\"0\"..\"9\")\n      \
    \  return 2\n    else if num.includes(\"2\"..\"9\")\n        return 2\n    else\
    \ if num.includes(\"3\"..\"9\")\n        return 2\n    else if num.includes(\"\
    5\"..\"9\")\n        return 2\n    else if num.includes(\"7\"..\"9\")\n      \
    \  return 2\n    else if num.includes(\"B\"..\"F\")\n        return 2\n    else\
    \ if num.includes(\"D\"..\"F\")\n        return 2\n    else if num.includes(\"\
    0\"..\"9\")\n        return 2\n    else if num.includes(\"2\"..\"9\")\n      \
    \  return 2\n    else if num.includes(\"3\"..\"9\")\n        return 2\n    else\
    \ if num.includes(\"5\"..\"9\")\n        return 2\n    else if num.includes(\"\
    7\"..\"9\")\n        return 2\n    else if num.includes(\"B\"..\"F\")\n      \
    \  return 2\n    else if num.includes(\"D\"..\"F\")\n        return 2\n    else\
    \ if num.includes(\"0\"..\"9\")\n        return 2\n    else if num.includes(\"\
    2\"..\"9\")\n        return 2\n    else if num.includes(\"3\"..\"9\")\n      \
    \  return 2\n    else if num.includes(\"5\"..\"9\")\n        return 2\n    else\
    \ if num.includes(\"7\"..\"9\")\n        return 2\n    else if num.includes(\"\
    B\"..\"F\")\n        return 2\n    else if num.includes(\"D\"..\"F\")\n      \
    \  return 2\n    else if ", "    \n    \"\"\" \n    Your task is to implement\
    \ this function.\n    Do not use the built in python function len, instead implement\
    \ your own \n    version of it.\n    \"\"\"\n    \n    hexnum::String = \"\"\n\
    \    \n    \"\"\"\n    Convert input to a string and strip all characters that\
    \ are not hex digits\n    \"\"\"\n    for c in num:\n        if c not in \"0123456789ABCDEF\"\
    \n            hexnum +=c\n    \"\"\"\n    Count the number of characters that\
    \ are either hexadecimal or \n    characters in \"0123456789ABCDEF\"\n    \"\"\
    \"\n    count = 0\n    for c in hexnum:\n        if c in \"0123456789ABCDEF\"\
    :\n            count +=1\n    return count", "    \n    # write your solution\
    \ here\n    count::Int64 = 0\n    for digit in num\n        count += 1\n    return\
    \ count\n    \n\"\"\"\n## Solution\n\"\"\"", "    local count = 0\n    for digit\
    \ in num\n        count = count + (digit == \"A\" or digit == \"B\" or digit ==\
    \ \"C\" or digit == \"D\" or digit == \"E\" or digit == \"F\" or digit == \"0\"\
    \ or digit == \"1\")\n    end\n    return count\nend", "    if num == \"\"\n \
    \       0\n    elseif num == \"A\" || num == \"B\" || num == \"C\" || num == \"\
    D\" || num == \"E\" || num == \"F\"\n        1\n    else\n        2\n    end\n\
    end\n</cell>\n<text>\nProblem 4\nWrite a function that returns True iff the given\
    \ string is a valid phone number.", "    \n    primes = Set([2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])",
  "    # Your code goes here\n    return sum(x in '0123456789ABCDEF' for x in num) ",
  "    count_digs(num) == 2 || count_digs(num) == 3 || count_digs(num) == 5\n    \
    \    || count_digs(num) == 7 || count_digs(num) == 11 || count_digs(num) == 13\n\
    \            || count_digs(num) == 17\n            || count_digs(num) == 19 ||\
    \ count_digs(num) == 23 || count_digs(num) == 29\n                || count_digs(num)\
    \ == 31\n                || count_digs(num) == 37\n                || count_digs(num)\
    \ == 41\n                || count_digs(num) == 43\n                || count_digs(num)\
    \ == 47\n                || count_digs(num) == 53\n                || count_digs(num)\
    \ == 59\n                || count_digs(num) == 61\n                || count_digs(num)\
    \ == 67\n                || count_digs(num) == 71\n                || count_digs(num)\
    \ == 73\n                || count_digs(num) == 79\n                || count_digs(num)\
    \ == 83\n                || count_digs(num) == 89\n                || count_digs(num)\
    \ == 91\n                || count_digs(num) == 97\n                || count_digs(num)\
    \ == 103 || count_digs(num) == 107\n                || count_digs(num) == 109\n\
    \                || count_digs(num) == 113\n                || count_digs(num)\
    \ == 127\n                || count_digs(num) == 131\n                || count_digs(num)\
    \ == 137\n                || count_digs(num) == 139\n                || count_digs(num)\
    \ == 149\n                || count_digs(num) == 151\n                || count_digs(num)\
    \ == 157\n                || count_digs(num) == 163\n                || count_digs(num)\
    \ == 167\n                || count_digs(num) == 173\n                || count_digs(num)\
    \ == 179\n                || count_digs(num) == 181\n                || count_digs(num)\
    \ == 191\n                || count_digs(num) == 193\n                || count_digs(num)\
    \ == 193\n                || count_digs(num) == 193\n                || count_digs(num)\
    \ == 193\n                || count_digs(num) == 193\n                || count_digs(num)\
    \ == 193\n                || count_digs(num) == 193\n                || count_digs(num)\
    \ == 193\n                || count_digs(num) == 193\n                || count_digs(num)\
    \ == 193\n                || count_digs(num) == 193\n                || count_digs(num)\
    \ == 193\n                || count_digs(num) == 193\n                || count_",
  "    let \n        num = num.trim()\n        hexDigits = if num.length > 10 \n \
    \           \"0123456789ABCDEF\"\n            else \n            \"0123456789ABCDEF0123456789ABCDEF\"\
    \n        prime_digits = if num.length > 10 \n            \"5555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555",
  "   if num islower\n      num_hex = num\n   else\n      num_hex = num_hex.uppercase\n\
    \   end\n   num_digits = count(num_hex)\n   return num_digits % 2 != 0 \nend \n\
    \"\"\"", "    sum = 0\n    for i in num:\n        if (i in \"ABCDEF\") or (i ==\
    \ \"0\"):\n            sum += digit(i)\n    return sum\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nI needed this kind of thing too. Since I'm a novice programmer\
    \ I coded it up myself. Here's what I came up with:\n<code>", "    num = num\n\
    \    for n in num:\n        if n == 'A' or n == 'B' or n == 'C' or n == 'D' or\
    \ n == 'E' or n == 'F':\n            return 1\n    return 0\nend\nhex_key(\"\"\
    )\n</cell>\n<code language=julia-1.2>", "    hex_digits = \"0123456789ABCDEF\"\
    \n    num_prime = 0\n    for digit in num\n        if digit in hex_digits and\
    \ digit.isupper() and digit.islower()\n            num_prime += 1\n        end\n\
    \    end\n    return num_prime\nend", "    hex_vals = split(num, \"\")\n    hex_chars\
    \ = split(num, \"AaBbCcDdEeFf\")\n    primes = prime_list()\n    primes_hex =\
    \ split(primes, \"AaBbCcDdEeFf\")\n    primes_hex = map(toupper, primes_hex)\n\
    \    return sum(primes_hex.count(char) for char in hex_chars)\nend", "    if isa(num,\"\
    String\")\n        str = num\n    elseif isa(num,\"Int64\")\n        return num\n\
    \    elseif num == \"\"\n        return 0\n    else\n        error(\"Cannot parse\
    \ string/int into Int64\")\n    end\n    count = 0\n    for x in str:\n      \
    \  if x in \"0123456789ABCDEF\"\n            count += 1\n        end\n    end\n\
    \    return count\nend\n</code>\nThe next task is to write a function that will\
    \ identify prime numbers that are divisible by one and also divisible by two,\
    \ 3, and 4.\nThe function is supposed to be as efficient as possible. It will\
    \ take one argument that is either a number or an empty string.\nThe function\
    \ will return a list of prime numbers that are divisible by one and also divisible\
    \ by two, 3, and 4.\nIf the number passed in is blank, the function will return\
    \ the empty list.\nIf the number passed in is not an Int64 or a String, it will\
    \ throw an error.\nExample:\n<code>\n>>> primes(20)\n[]\n>>> primes(10)\n[2]\n\
    >>> primes(8)\n[2, 3, 5]\n>>> primes(\"20\")\n[]\n>>> primes(\"10\")\n[2]\n>>>\
    \ primes(\"8\")\n[2, 3, 5]\n>>> primes(\"1234567\")\n[2, 3, 5, 7, 11]\n>>> primes(\"\
    \")\n[]\n>>> primes(2)\n[2]\n</code>\nWrite a function that will accept a list\
    \ of numbers and returns the sum of the even numbers in that list. Your function\
    \ must return the correct sum, even if the list is empty or contains a single\
    \ value.\nThe sum of the even numbers in an empty list should be 0. The sum of\
    \ the even numbers in a list containing just one number should be that number\
    \ multiplied by the number of the even numbers.\nThe function should ignore zero\
    \ values or empty lists. The function will throw an error if the list contains\
    \ more than one element.\nExample:\n<code>\n>>> sum_of_even([])\n0\n>>> sum_of_even([5])\n\
    5\n>>> sum_of_even([4])\n4\n>>> sum_of_even([2, 6, 5])\n28\n>>> sum_of_even([2,\
    \ 4, 6, 8, 10])\n28\n>>> sum_of_even([7, 2, 2])\n40\n>>> sum_of_even([1])\n1\n\
    </code>\nThe next task is to write a function that can find the sum of all numbers\
    \ in a list that are divisible by 9. \nThe function should ignore zero values\
    \ and empty lists.\nThe function should throw an error if the list contains more\
    \ than one element, or if the list contains a single element.\nExample:\n<code>\n\
    >>> sum_of_nines([10, 20, 30])\n45\n>>> sum_of_nines([1])\n0\n>>> sum_of_nines([])\n\
    0\n>>> sum_of_nines([2])\n2\n>>> sum_of_", "    if num == \"\" then return 0\n\
    \    if num == \"0\" then return 0\n    if num contains \"A\" then return hex_num(num)\n\
    \    if num contains \"B\" then return hex_num(num)\n    if num contains \"C\"\
    \ then return hex_num(num)\n    if num contains \"D\" then return hex_num(num)\n\
    \    if num contains \"E\" then return hex_num(num)\n    if num contains \"F\"\
    \ then return hex_num(num)\n    return hex_num(num)\nend\n\"\"\"\n    Problem\
    \ 8: Counting digits\n\"\"\"", "    local hex_digits = \"01234567\"\n    local\
    \ hex_prime_numbers = [2,3,5,7,11,13,17,19]\n    local result = num:len()\n  \
    \  for i = 1, result do \n        if isPrime(hex_prime_numbers[hex_digits:len()],\
    \ hex_digits, i) do \n            hex_key[i] = i\n        end\n    end\n    return\
    \ result\nend", "    \"\"\"This function counts the number of hexadecimal digits\
    \ that are \n    primes (prime number, or a prime, is a natural number greater\
    \ than 1 that \n    is not a product of two smaller natural numbers).\n    Hexadecimal\
    \ digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers\
    \ are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the\
    \ following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note:\
    \ you may assume the input is always correct or empty string, \n    and symbols\
    \ A,B,C,D,E,F are always uppercase.\n    Examples:\n    >>> hex_key(\"AB\")\n\
    \    1\n    >>> hex_key(\"1077E\")\n    2\n    >>> hex_key(\"ABED1A33\")\n   \
    \ 4\n    >>> hex_key(\"123456789ABCDEF0\")\n    6\n    >>> hex_key(\"2020\")\n\
    \    2\n    \"\"\"\n    count = 0\n    for n in hex_to_int(num):\n        if n\
    \ % 2 != 0 or n % 5 == 3:\n            count += 1\n    return count\nend \n</code>\n\
    For your case\n<code>\njulia> hex_key(\"ABED1A33\")\n4\n</code>\nFor a large number\
    \ you should use a vectorized solution\n<code>\njulia> hex_key(\"123456789ABCDEF0\"\
    )\n30\n</code>\n<|/ a dscore=3 |>\n<| a tags=julia |>\nOne more vectorized solution:\n\
    <code>", "    count = 0\n    \n    for i in num\n        if i == \"A\" or i ==\
    \ \"B\" or i == \"C\" or i == \"D\" or i == \"E\" or i == \"F\"\n            count\
    \ += 1\n        end\n    end\n    return count\nend\n</cell>\n<cell>\nhex_key(\"\
    AB\")\n</cell>\n<cell>\nhex_key(\"1077E\")\n</cell>\n<cell>\nhex_key(\"ABED1A33\"\
    )\n</cell>\n<cell>\nhex_key(\"123456789ABCDEF0\")\n</cell>\n<cell>\nhex_key(\"\
    2020\")\n</cell>\n<text>\nProblem 9\nCreate a function prime_number_test that\
    \ takes one string as an argument, \nand returns the number of times the string\
    \ is a prime number. You may assume \nthat the string contains only natural numbers.\n\
    For example:\n>>> prime_number_test(\"1077E\")\n1\n>>> prime_number_test(\"2020\"\
    )\n1\n>>> prime_number_test(\"ABED1A33\")\n0", "    num := to_string(num)\n  \
    \  count := 0\n    \n    hex_str := \"\"\n    hex_str := to_string(num:to_lowercase())\n\
    \    \n    hex_str := replace(hex_str,\"A\",\"0A\")\n    hex_str := replace(hex_str,\"\
    B\",\"0B\")\n    hex_str := replace(hex_str,\"C\",\"0C\")\n    hex_str := replace(hex_str,\"\
    D\",\"0D\")\n    hex_str := replace(hex_str,\"E\",\"0E\")\n    hex_str := replace(hex_str,\"\
    F\",\"0F\")\n    \n    for x in hex_str\n        incr count\n        if x == \"\
    A\"\n            count += 1\n        else if x == \"B\"\n            count +=\
    \ 1\n        else if x == \"C\"\n            count += 1\n        else if x ==\
    \ \"D\"\n            count += 1\n        else if x == \"E\"\n            count\
    \ += 1\n        else if x == \"F\"\n            count += 1\n    end\n    \n  \
    \  count\nend\n</code>\n<|/ a |>\n<| c |>\nThe code you posted has a syntax error:\
    \ missing `end` before `incr count`. And your code doesn't work because it counts\
    \ spaces as hex digits, not letters.\n<|/ c |>\n<| a tags=julia,primes |>\nThe\
    \ following Julia code counts the number of hexadecimal digits that are prime\
    \ numbers. You can adapt it to count the number of primes you want.\n<code>",
  "    return count(find(num,\"ABCDEF\"))\nend\n</cell>\n<code language=julia-0.6>\n\
    hex_key(\"AB\")\n</cell>\n<text>\nWrite a function that counts the number of hexadecimal\
    \ digits that are primes (prime number, or a prime, is a natural number greater\
    \ than 1 that is not a product of two smaller natural numbers).\nHexadecimal digits\
    \ are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\nSo you have to determine a number of the following digits:\
    \ 2, 3, 5, 7, \nB (=decimal 11), D (=decimal 13).\nNotes: you may assume the input\
    \ is always correct or empty string, and symbols A,B,C,D,E,F are always uppercase.\n\
    Examples:\nhex_key(\"AB\")\n1\nhex_key(\"1077E\")\n2\nhex_key(\"ABED1A33\")\n\
    4\nhex_key(\"123456789ABCDEF0\")\n6\nhex_key(\"2020\")\n2", "if is_hex(num) ==\
    \ false\n    return 0\nend\n\"\"\"\n    \"\"\"", "    if length(num) == 1 && isupper(num)\n\
    \        return 2\n    \n    # check whether the hexadecimal number contains at\
    \ least two hexadecimal digits\n    if num.length() == 1\n        return 0\n \
    \   \n    # check whether the hexadecimal number contains at least three hexadecimal\
    \ digits\n    if num.length() == 2\n        return 0\n    \n    # check whether\
    \ the hexadecimal number contains at least five hexadecimal digits\n    if num.length()\
    \ == 3\n        return 0\n    \n    # check whether the hexadecimal number contains\
    \ at least 7 hexadecimal digits\n    if num.length() == 4\n        return 0\n\
    \    \n    # check whether the hexadecimal number contains at least 9 hexadecimal\
    \ digits\n    if num.length() == 5\n        return 0\n    \n    # check whether\
    \ the hexadecimal number contains at least 10 hexadecimal digits\n    if num.length()\
    \ == 6\n        return 0\n    \n    # check the first two hexadecimal digits\n\
    \    if islower(num[0])\n        return 0\n    \n    # check the first three hexadecimal\
    \ digits\n    if islower(num[0]) && islower(num[1])\n        return 0\n    \n\
    \    # check the first five hexadecimal digits\n    if islower(num[0]) && islower(num[1])\
    \ && islower(num[2])\n        return 0\n    \n    # check the first seven hexadecimal\
    \ digits\n    if islower(num[0]) && islower(num[1]) && islower(num[2]) && \n \
    \       islower(num[3]) && islower(num[4]) && islower(num[5])\n        return\
    \ 0\n    \n    # check the first nine hexadecimal digits\n    if islower(num[0])\
    \ && islower(num[1]) && islower(num[2]) && \n        islower(num[3]) && islower(num[4])\
    \ && islower(num[5]) && \n        islower(num[6]) && islower(num[7]) && islower(num[8])\
    \ && \n        islower(num[9]) && islower(num[10]) && islower(num[11])\n     \
    \   return 0\n    \n    # check the first ten hexadecimal digits\n    if islower(num[0])\
    \ && islower(num[1]) && islower(num[2]) && \n        islower(num[3]) && islower(num[4])\
    \ && islower(num[5]) && \n        islower(num[6]) && islower(num[7]) && islower(num[8])\
    \ && \n        islower(num[9]) && islower(num[10]) && islower(num[11]) && \n \
    \       islower(num[12]) && islower(num[13]) && islower(num[14]) && \n       \
    \ islower(num[15]) && islower(num[16]) && islower(num[17]) && \n        islower(num[18])\
    \ && islower(num[19]) && islower(", "     \"\"\"\n     \"\"\"\n     \"\"\"\n \
    \    \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n\
    \     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"\n     \"\"\"",
  "    \n    return 0\nend", "    for i in num.chars:\n        if hexdigit(i) == i\
    \ // 2:\n            count += 1\n            \n    return count\nend", "    if\
    \ num == \"\"\n        return -1\n    if num == \"A\" ||  num == \"B\" || num\
    \ == \"C\" || num == \"D\" || num == \"E\" || num == \"F\"\n        return -1\n\
    \    else if num == \"0\" || num == \"1\"\n        return 1\n    else if num ==\
    \ \"2\"\n        return 2\n    else if num == \"3\"\n        return 3\n    else\
    \ if num == \"4\"\n        return 4\n    else if num == \"5\"\n        return\
    \ 5\n    else if num == \"6\"\n        return 6\n    else if num == \"7\"\n  \
    \      return 7\n    else if num == \"8\"\n        return 8\n    else if num ==\
    \ \"9\"\n        return 9\n    else if num == \"a\"\n        return 10\n    else\
    \ if num == \"b\"\n        return 11\n    else if num == \"c\"\n        return\
    \ 12\n    else if num == \"d\"\n        return 13\n    else if num == \"e\"\n\
    \        return 14\n    else if num == \"f\"\n        return 15\n    else if num\
    \ == \"0\"\n        return 16\n    else if num == \"1\"\n        return 17\n \
    \   else if num == \"2\"\n        return 18\n    else if num == \"3\"\n      \
    \  return 19\n    else if num == \"4\"\n        return 20\n    else if num ==\
    \ \"5\"\n        return 21\n    else if num == \"6\"\n        return 22\n    else\
    \ if num == \"7\"\n        return 23\n    else if num == \"8\"\n        return\
    \ 24\n    else if num == \"9\"\n        return 25\n    else if num == \"A\"\n\
    \        return 26\n    else if num == \"B\"\n        return 27\n    else if num\
    \ == \"C\"\n        return 28\n    else if num == \"D\"\n        return 29\n \
    \   else if num == \"E\"\n        return 30\n    else if num == \"F\"\n      \
    \  return 31\n    else if num == \"0\"\n        return 32\n    else if num ==\
    \ \"1\"\n        return 33\n    else if num == \"2\"\n        return 34\n    else\
    \ if num == \"3\"\n        return 35\n    else if num == \"4\"\n        return\
    \ 36\n    else if num == \"5\"\n        return 37\n    else if num == \"6\"\n\
    \        return 38\n    else if num == \"7\"\n        return 39\n    else if num\
    \ == \"8\"\n        return 40\n    else if num == \"9\"\n        return 41\n \
    \   else if num == \"a\"\n        return 42\n    else if num == \"b\"\n      \
    \  return 43\n    else if num == \"c\"\n        return 44\n    else if num ==\
    \ \"d\"", "    if num |> is_blank() |> is_zero() \n        then 0 \n        else\
    \ count_key_digit_primes(num) \n    end\nend\n</code>\n<|/ a |>\n<| a tags=functional-programming,haskell,recursion\
    \ dscore=0 |>\nThis is my solution:\n<code>\nmodule CountHexDigitPrimes where",
  "    local hex = \"0123456789ABCDEF\"\n    local hexdigits = num:gsub(\"%X\",\"\
    %x\"):gsub(\"%y\",\"%2\"):gsub(\"%Y\",\"%2\")\n    local hexdigits_len = length(hexdigits)\n\
    \    local prime_digits = hexdigits:sub(1,hexdigits_len)\n    local primes = prime_digits:sub(1,hexdigits_len)\n\
    \    local primes_length = length(primes)\n    local hexdigits_count_primes =\
    \ hexdigits_len - primes_length\n    local hexdigits_count = hexdigits_count_primes\n\
    \    for idx = hexdigits_count_primes+1,hexdigits_len do \n        if primes[idx]\
    \ == 1 then\n            hexdigits_count = hexdigits_count+1\n        end\n  \
    \  end\n    return hexdigits\nend", "    # count how many symbols start with 0\n\
    \    let count = (num[2:end-2]==\"0123456789\") && (num[2:end] == \"0123456789\"\
    )\n    \n    # count how many symbols start with 2\n    let count_2 = (count||(num[2:end-2]==\"\
    02\") && (num[2:end] == \"02\")) \n    \n    # count how many symbols start with\
    \ 3\n    let count_3 = (count||(num[2:end-2]==\"03\") && (num[2:end] == \"03\"\
    ))\n    \n    # count how many symbols start with 5\n    let count_5 = (count||(num[2:end-2]==\"\
    05\") && (num[2:end] == \"05\"))\n    \n    # count how many symbols start with\
    \ 7\n    let count_7 = (count||(num[2:end-2]==\"07\") && (num[2:end] == \"07\"\
    ))\n    \n    # count how many symbols start with B\n    let count_B = (count||(num[2:end-2]==\"\
    11\") && (num[2:end] == \"11\"))\n    \n    # count how many symbols start with\
    \ D\n    let count_D = (count||(num[2:end-2]==\"13\") && (num[2:end] == \"13\"\
    ))\n    \n    # count how many symbols start with F\n    let count_F = (count||(num[2:end-2]==\"\
    17\") && (num[2:end] == \"17\"))\n    \n    # count how many symbols start with\
    \ A, B\n    let count_AB = (count_2||count_3||count_5||count_7||count_B) && (count_D||count_F)\n\
    \    \n    # count how many symbols start with A, B and D\n    let count_AD =\
    \ (count_2||count_3||count_5||count_7||count_B) && (count_D||count_F) && (count_AB)\n\
    \    \n    # count how many symbols start with A, B and C\n    let count_AC =\
    \ (count_2||count_3||count_5||count_7||count_B) && (count_D||count_F) && (count_AB)\
    \ && (count_AD)\n    \n    # count how many symbols start with A, B, C and F\n\
    \    let count_AF = (count_2||count_3||count_5||count_7||count_B) && (count_D||count_F)\
    \ && (count_AB) && (count_AC) && (count_AD)\n    \n    # count how many symbols\
    \ start with A, B, C, D and F\n    let count_ADF = (count_2||count_3||count_5||count_7||count_B)\
    \ && (count_D||count_F) && (count_AB) && (count_AC) && (count_AD) && (count_AF)\n\
    \    \n    # count how many symbols start with A, B, C, D, E and F\n    let count_ADE\
    \ = (count_2||count_3||count_5||count_7||count_B) && (count_D||count_F) && (count_AB)\
    \ && (count_AC) && (", "    if num == \"\" \n        return -1\n    \n    hex_value\
    \ = num.chars().filter(c => c in \"0123456789ABCDEF\").map(c => c.toInt)\n   \
    \ prime_numbers = hex_value.filter(c => c == 2 || c == 3 || c == 5 || c == 7 ||\
    \ c == 11 \n    || c == 13 || c == 17 || c == 19 || c == 31 || c == 33 || c ==\
    \ 35 || c == 37 \n    || c == 3B || c == 3D || c == 3F || c == 55 || c == 57 ||\
    \ c == 59 || c == 61\n    || c == 67 || c == 79 || c == 89 || c == 97 || c ==\
    \ 101|| c == 103|| c == 107\n    || c == 109 || c == 111 || c == 113|| c == 117||\
    \ c == 119|| c == 123|| c == 127\n    || c == 131)\n    \n    return prime_numbers.count(true)\n\
    end\n</cell>\n<text>\nExercise: Count the number of hexadecimal digits that are\
    \ primes\nWrite a function that counts the number of hexadecimal digits that are\
    \ primes (prime number, or a prime, is a natural number greater than 1 that is\
    \ not a product of two smaller natural numbers).\nHexadecimal digits are 0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers are 2, 3, 5, 7, 11,\
    \ 13, 17,...\nSo you have to determine a number of the following digits: 2, 3,\
    \ 5, 7, B (=decimal 11), D (=decimal 13).\nNote:you may assume the input is always\
    \ correct or empty string, \nand symbols A,B,C,D,E,F are always uppercase.", " \
    \   \"\"\"Function for hexadecimal key function\"\"\"\n    for i in num\n    return\
    \ 0", "    \n    count_of_digits = 0\n    for c in num\n        if ('A'<=c<='F')\
    \ then count_of_digits+=1\n        else if ('B'<=c<='F') then count_of_digits+=1\n\
    \        else if ('2'<=c<='9') then count_of_digits+=1\n        else if ('F'<=c<='F')\
    \ then count_of_digits+=1\n        else if ('0'<=c<='9') then count_of_digits+=1\n\
    \    \n    return count_of_digits\nend\n</cell>\n<text>\nExercise 8", "    len::Int64\
    \ = length(num) \n    if len < 4 \n        error(\"The hexadecimal number cannot\
    \ be less or equal than 4\")\n    else\n        numbers::Vector{String} = split(num,\
    \ '') \n        primes::Vector{Int64} = [] \n        for number in numbers \n\
    \            checkPrime::Int = checkPrime(number, primes, len) \n            if\
    \ checkPrime == true \n                push!(primes, number) \n            end\
    \ \n        end \n        return primes[end]\n    end \nend \n</cell>\n<text>\n\
    Exercise 3.8: Write a function that receives a number represented as a string\
    \ and returns the number of characters that are not digits.\nExamples:\n>>> num2str(\"\
    123\")\n3\n>>> num2str(\"123_456\")\n1\n>>> num2str(\"123456789\")\n5\n>>> num2str(\"\
    123_456_789\")\n4\n>>> num2str(\"\")\n0\n>>> num2str(\"_123\")\n2\n>>> num2str(\"\
    123@\")\n1\n>>> num2str(\"123@456\")\n1\n>>> num2str(\"123@456_789\")\n4\n>>>\
    \ num2str(\"123\")\n1\n>>> num2str(\"123_456_789_0\")\n2\n>>> num2str(\"_123\"\
    )\n2\n>>> num2str(\"123@\")\n1\n>>> num2str(\"123@456\")\n1\n>>> num2str(\"123@456_789\"\
    )\n4\n>>> num2str(\"123\")\n1\n>>> num2str(\"123_456_789_0\")\n2\n>>> num2str(\"\
    _123\")\n2\n>>> num2str(\"123@\")\n1\n>>> num2str(\"123@456\")\n1\n>>> num2str(\"\
    123@456_789\")\n4\n>>> num2str(\"123\")\n1\n>>> num2str(\"123_456_789_0\")\n2\n\
    >>> num2str(\"_123\")\n2\n>>> num2str(\"123@\")\n1\n>>> num2str(\"123@456\")\n\
    1\n>>> num2str(\"123@456_789\")\n4\n>>> num2str(\"123\")\n1\n>>> num2str(\"123_456_789_0\"\
    )\n2\n>>> num2str(\"_123\")\n2\n>>> num2str(\"123@\")\n1\n>>> num2str(\"123@456\"\
    )\n1\n>>> num2str(\"123@456_789\")\n4\n>>> num", "# write your code in RUST\n\
    \    \n    let mut sum = 0;\n    \n    for i in num.to_chars()\n        \n   \
    \     loop {\n            if i != \"A\"\n               \n               if i\
    \ != \"B\"\n               \n               if i != \"C\"\n               \n \
    \              if i != \"D\"\n               \n               if i != \"E\"\n\
    \               \n               if i != \"F\"\n               \n            \
    \   sum += 1;\n               break;\n            }\n        }\n    \n    return\
    \  sum;\n}\n</code>\n<|/ q dscore=0 |>\n<| c |>\nThis is not what SO is for. You\
    \ have a problem you need to solve, and you ask us to do all the work. SO is for\
    \ solving programming problems. You should be asking for a way to solve the problem\
    \ yourself, *then* ask for help with that particular problem. I recommend asking\
    \ your teacher or your boss for help with that particular problem and then come\
    \ back here and ask a more specific question.\n<|/ c |>\n<| c |>\nI recommend\
    \ you visit [the tour](https://stackoverflow.com/tour) and [how to ask](https://stackoverflow.com/help/how-to-ask)\
    \ to learn more about asking questions on Stack Overflow.\n<|/ c |>\n<| c |>\n\
    Also, your title and question don't seem to match up exactly. Can you please clarify\
    \ how you got the prime count for \"ABED1A33\"? Is this a prime number according\
    \ to your definition?\n<|/ c |>\n<| c |>\nYes, ABED1A33 is a prime number. My\
    \ bad, I'll edit the title now.\n<|/ c |>\n<| a |>\nFor a given hexadecimal number,\
    \ the most significant digit(s) can be counted. \nFor a number starting with A,\
    \ each of the following digits have to be counted:\n<code>\nA B C D E\n0 1 2 3\
    \ 4 5\n</code>\nA hexadecimal number cannot begin with the digits 0, 1 or 2; the\
    \ most significant digit must be one of those. \nFor the remaining digits (starting\
    \ with B) the following digits have to be counted:\n<code>\nB C D E F\n0 1 2 3\
    \ 4 5\n</code>\nA hexadecimal number cannot begin with the digits 0, 1 or 2; the\
    \ most significant digit must be one of those. \nFor the remaining digits (starting\
    \ with C) the following digits have to be counted:\n<code>\nC D E F\n0 1 2 3 4\
    \ 5\n</code>\nA hexadecimal number cannot begin with the digits 0, 1 or 2; the\
    \ most significant digit must be one of those. \nFor the remaining digits (starting\
    \ with D) ", "    count = 0\n    for i in num\n        if ((i == '0') || (i ==\
    \ '1')) || ((i == 'A') || (i == 'B') || (i == 'C') || (i == 'D') || (i == 'E')\
    \ || (i == 'F'))\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend\n</code>\nAnd finally the final result:\n<code>\n# Examples \n# -\
    \ \"AB\" => 1 \n# - \"1077E\" => 2 \n# - \"ABED1A33\" => 4 \n# - \"123456789ABCDEF0\"\
    \ => 6 \n# - \"2020\" => 2", "    \n    digit_array = [2,3,5,7,11,13,17]\n   \
    \ char_array = [i for i in num] \n    \n    for i in char_array:\n        if i\
    \ not in digit_array:\n            return 0\n        \n    return digit_array.count(i)\n\
    end", "    hex_digit_list::Vector{String} = Vector(\"0\",\"1\",\"2\",\"3\",\"\
    4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\")\n    digit_index::Int64\
    \ = length(num) - 1\n    digit::String = num[digit_index]\n    count_digits =\
    \ 0\n    if digit == \"0\"\n        count_digits += 1\n    else\n        count_digits\
    \ += digit.length\n    end\n    digit_index -= 1\n    digit::String = num[digit_index]\n\
    \    count_digits += 1\n    if digit == \"0\"\n        count_digits += 1\n   \
    \ else\n        count_digits += digit.length\n    end\n    digit_index -= 1\n\
    \    digit::String = num[digit_index]\n    count_digits += 1\n    if digit ==\
    \ \"0\"\n        count_digits += 1\n    else\n        count_digits += digit.length\n\
    \    end\n    digit_index -= 1\n    digit::String = num[digit_index]\n    count_digits\
    \ += 1\n    if digit == \"0\"\n        count_digits += 1\n    else\n        count_digits\
    \ += digit.length\n    end\n    digit_index -= 1\n    digit::String = num[digit_index]\n\
    \    count_digits += 1\n    if digit == \"0\"\n        count_digits += 1\n   \
    \ else\n        count_digits += digit.length\n    end\n    digit_index -= 1\n\
    \    digit::String = num[digit_index]\n    count_digits += 1\n    if digit ==\
    \ \"0\"\n        count_digits += 1\n    else\n        count_digits += digit.length\n\
    \    end\n    digit_index -= 1\n    digit::String = num[digit_index]\n    count_digits\
    \ += 1\n    if digit == \"0\"\n        count_digits += 1\n    else\n        count_digits\
    \ += digit.length\n    end\n    digit_index -= 1\n    digit::String = num[digit_index]\n\
    \    count_digits += 1\n    if digit == \"0\"\n        count_digits += 1\n   \
    \ else\n        count_digits += digit.length\n    end\n    digit_index -= 1\n\
    \    digit::String = num[digit_index]\n    count_digits += 1\n    if digit ==\
    \ \"0\"\n        count_digits += 1\n    else\n        count_digits += digit.length\n\
    \    end\n    digit_index -= 1\n    digit::String = num[digit_index]\n    count_digits\
    \ += 1\n    if digit == \"0\"\n        count_digits += 1\n    else\n        count_digits\
    \ += digit.length\n    end\n    digit_index -= 1\n    digit::String = num[digit_index]\n\
    \    count_digits += 1\n    if digit == \"0\"\n        count_digits += 1\n   \
    \ else\n        count_digits += digit.length\n    end\n    digit_index -= 1\n\
    \    digit::String = num[digit_index]\n    count_digits += 1\n    if digit ==\
    \ \"", "    if num == \"\"\n        return 0\n    digits = map(Int64, to_integer(num,\
    \ base=16))\n    return sum(isPrime(digit) for digit in digits)\nend\n</cell>\n\
    <cell>\nhex_key(\"AB\")\n</cell>\n<text>\nExercise 12 - Bloom filter\nA bloom\
    \ filter is a data structure that stores boolean (True or False) values for an\
    \ arbitrary set of keys. Bloom filters work well when you are testing for membership\
    \ in an associative container, like a hash-table.\nIt works as follows: for every\
    \ key in the hash table that you wish to test, you first generate a hash of that\
    \ key and store it in a bloom filter. If the bloom filter contains a True value,\
    \ the key is in the hash table. Otherwise, the key is not in the hash table. \n\
    For a large number of keys, testing for membership in a hash table can be very\
    \ costly, and in fact, it is quite common to store the hash table in another data\
    \ structure called a bloom filter (Bloom filters are the most common data structure\
    \ in data storage and retrieval).\nThe bloom filter is a probabilistic data structure\
    \ and can be computed efficiently in constant time. The Bloom filter is also very\
    \ useful in caching strategies and other use cases.", "    if num.length() !=\
    \ 8\n        error(\"Hex key must be 8 characters long.\")\n    else\n       \
    \ if length(split(num)) > 3\n            error(\"Only up to 3 hex digits are allowed\"\
    )\n        else\n            if all(digits in \"0123456789ABCDEF\") for digits\
    \ in split(num)\n                error(\"Only hex digits 0-9 A-F is allowed\"\
    )\n            else\n                if all(digits in \"0123456789ABCDEF\") ||\
    \ digits in \"ABCD\"\n                    error(\"Only hex digits 0-9 A-F or only\
    \ digits 0-9 ABCD is allowed\")\n                else\n                    primes\
    \ = listprod([3,5])\n                    largest = length(split(num))\n      \
    \              largest2 = floor(sqrt(length(split(num))))\n                  \
    \  primes2 = listprod(primes)\n                    for prime in primes\n     \
    \                   for prime2 in primes2\n                            if prime\
    \ * prime2 == largest\n                                break\n               \
    \             end\n                        end\n                    end\n    \
    \                return largest\n                end\n            end\n      \
    \  end\n    end\nend\n</code>\n<|/ a tags=math,julia dscore=3 |>\n<| c |>\nThe\
    \ original question was about performance. Your solution is actually very elegant.\n\
    <|/ c |>\n<| c |>\nVery elegant and efficient - I just implemented a test for\
    \ the original problem and your solution is about 6 times faster.\n<|/ c |>\n\
    <| c |>\nThanks, it would be nice to test it on larger inputs but I think you\
    \ only need to run it a few times to get the correct answer for the prime number\
    \ problem and you should be able to run it a few times without too much trouble.\n\
    <|/ c |>\n<| c |>\nI do notice that the `primes` list is getting recalculated\
    \ every time you call the function, and also that `primes2` gets recalculated\
    \ every time you call the function. Maybe it would be better to compute `primes2`\
    \ only once at the beginning? Also you could make `primes` a `let` variable so\
    \ it gets computed only once.\n<|/ c |>\n<| c |>\nthanks, I've added your suggestions.\n\
    <|/ c |>\n<| a dscore=2 tags=math,julia |>\n<code>\nusing Distributed, BenchmarkTools\n\
    dp = x->rand(Bool,x,true)", "  \n  if length(num)==0 \n    return 0\n  else\n\
    \    if num.count(\"A\")+num.count(\"B\")+num.count(\"C\")+num.count(\"D\")+num.count(\"\
    E\")+num.count(\"F\")==0 \n      return 0\n    else\n      num.count(\"A\")\n\
    \      num.count(\"B\")\n      num.count(\"C\")\n      num.count(\"D\")\n    \
    \  num.count(\"E\")\n      num.count(\"F\")\n      num.count(\"0\")\n      num_prime::Int64\
    \ = num.count(\"A\")+num.count(\"B\")+num.count(\"C\")+num.count(\"D\")+num.count(\"\
    E\")+num.count(\"F\")\n      \n      return\n      if num_prime == 0 \n      \
    \  return 2\n      elseif num_prime == 1 \n        return 3\n      elseif num_prime\
    \ > 1 \n        return 4\n      else\n        return 0\n    end\n  end\nend",
  "    return count_key('ABED1A33', num) - count_key('0', num)", "    digits::Set[Char]\
    \ = Set(\"0123456789ABCDEF\") \n    primes::Set[Int64] = Set(2, 3, 5, 7) \n  \
    \  primes2::Set[Int64] = Set(2, 3, 5, 7, 11, 13, 17) \n    digits2::Set[Char]\
    \ = Set(\"ABCDEF\") \n    num::String \n    len = length(num) \n    if len < 2\
    \ \n        return 0 \n    for i from 2 to len do \n        if digits[substring(num,\
    \ i, 1)] <= 2 \n            return 0 \n    for i in primes2 do \n        if digits[substring(num,\
    \ i, 1)] <= 2 \n            return i \n    for i from digits2.length - 1 to 1\
    \ do \n        if digits[substring(num, i, 1)] <= 2 \n            return 0 \n\
    \    for i in primes do \n        if digits[substring(num, i, 1)] == 1 \n    \
    \        return i \n    return 0 \nend\n</cell>\n<code language=julia-0.4>\n#\
    \ test function\n@time for i in 1:100000 do hex_key(\"1077E\") end\n</cell>\n\
    <text>\nProblem 2b\nThe square of a number $x$ is $x^2$, unless $x$ is 1. Then\
    \ $x^2$ is 2. Since $x$ is 1, $x^2$ is $2$. Write a function that returns the\
    \ square of $x$ if $x$ is not equal to 1 or 2.", "    if num = \"\" then return\
    \ 0 \n    else if is_natural_number(num) then return num::Int64 \n    else \n\
    \        primeslist = primes_list(num::Int64)\n        for p in primeslist \n\
    \            if p::Int64 % 2 == 1 \n                or p::Int64 % 3 == 2 \n  \
    \              or p::Int64 % 5 == 0 \n                or p::Int64 % 7 == 0 \n\
    \                or p::Int64 % 11 == 0 \n                or p::Int64 % 13 == 0\
    \ \n                or p::Int64 % 17 == 0 \n                or p::Int64 % 19 ==\
    \ 0 \n                or p::Int64 % 23 == 0 \n                or p::Int64 % 29\
    \ == 0 \n                or p::Int64 % 31 == 0 \n                or p::Int64 %\
    \ 37 == 0 \n                or p::Int64 % 41 == 0:\n                return num::Int64\n\
    \        return 0\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=julia,string\
    \ dscore=0 |>\nHere is the answer in R:\n<code>\nns <- readLines(textConnection(\"\
    \n    AB\n    1077E\n    ABED1A33\n    123456789ABCDEF0\n    2020\"))\ncount_digits\
    \ <- function(ns)\n    sum(ns %>% gsub(\"[^0-9]\", \"\") %>% as.integer() == 10)\n\
    }\ncount_digits(ns)\n[1] 1\n</code>\n<|/ a |>\n<| a |>\n<code>", "    if num==\"\
    \" || num==\"\"\n        return 0\n    else\n        digits=num.digits\n     \
    \   for i=1:length(digits)\n            hexdigit=digits[i]\n            if hexdigit==\"\
    A\" || hexdigit==\"B\"\n                digits[i]==\"B\"\n            if hexdigit==\"\
    D\" || hexdigit==\"E\"\n                digits[i]==\"D\"\n        end\n      \
    \  hexdigits=join(digits, \"\")\n        return primes_below_64(hexdigits)\n \
    \   end\nend\n</cell>\n<text>\nTask 7 - Solution\nIf the input is a string, then\
    \ the function returns a 64 bit integer.", "    \n    \"\"\"\n    Hexadecimal\
    \ digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers\
    \ are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the\
    \ following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note:\
    \ you may assume the input is always correct or empty string, \n    and symbols\
    \ A,B,C,D,E,F are always uppercase.\n    \"\"\"\n    function prime_digits(num::String)::Bool",
  "  if num == \"\" \n    then return 0\n  else \n    hex_to_decimal_key(num) \n \
    \ end \nend \n\"\"\"", "  num::Int64\n  hex_key(num::String)::Int64 = count((length((num::String))\
    \ - 9)::Int64)\nend\n</cell>\n<code language=julia-1.6>", "\"\"\"This function\
    \ will count the number of hexadecimal digits in the \n    input string. Note\
    \ that hexadecimal numbers consists of digits and \n    letters, uppercase letters\
    \ are always considered to be digits, \n    and the input string is always considered\
    \ to be non-empty or \n    empty.\n    \n    Arguments:\n    num - the input string\
    \ which contains only hexadecimal digits.\n    \n    Return:\n    Int64 - the\
    \ number of hexadecimal digits in the input string.\n    Examples:\n    >>> hex_key(\"\
    AB\")\n    1\n    >>> hex_key(\"1077E\")\n    2\n    >>> hex_key(\"ABED1A33\"\
    )\n    4\n    >>> hex_key(\"123456789ABCDEF0\")\n    6\n    >>> hex_key(\"2020\"\
    )\n    2\n    \"\"\"\n    return Int64(num)", "    prime_count = 0\n    digit_count=0\n\
    \    for digit in num\n        digit_count+=1\n        digit_counter=0\n     \
    \   for char in digit\n            digit_counter+=1\n            if digit_counter\
    \ in [2,3,5,7,11,13]\n                prime_count+=1\n            else\n     \
    \           digit_counter=0\n            end\n        end\n    end\n    return\
    \ prime_count\nend\n</cell>\n<code language=julia-0.6>\nhex_key(\"AB\")\n</cell>\n\
    <code language=julia-0.6>\nhex_key(\"1077E\")\n</cell>\n<code language=julia-0.6>\n\
    hex_key(\"ABED1A33\")\n</cell>\n<code language=julia-0.6>\nhex_key(\"123456789ABCDEF0\"\
    )\n</cell>\n<code language=julia-0.6>\nhex_key(\"2020\")\n</cell>\n<code language=julia-0.6>\n\
    @code_warntype hex_key(\"AB\")\n</cell>\n<text>\nTask", "    return \n\"\"\"",
  "    \n    \"\"\"\n    Write your solution here!\n    \"\"\"\n    num::String =\
    \ String(num).uppercase\n    digits = \"01234567ABCDEF\"\n    num_primes = 0 \n\
    \    for i in digits\n        if num[0] == digits[i]\n            num_primes +=\
    \ 1\n    return num_primes\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI came up with\
    \ this in Haskell:\n<code>\nimport Data.Char (isLetter, isSpace, isDigit)", " \
    \   if length(num) <= 1 \n        2\n    else \n        prime_digits = num[1]..num[6]\n\
    \        digit_to_check = num[2]\n        if digit_to_check == num[1]\n      \
    \      prime_digits += digit_to_check\n        end\n        \n        for digit\
    \ in prime_digits\n            if digit_to_check == digit\n                digit_to_check\
    \ += digit\n            else\n                break\n            end\n       \
    \ end\n        \n        length(prime_digits)\nend", "    num = hex(num::String)\n\
    \    dig = num.length()\n    \n    for i in num\n    \n        if i == 'A'..'F'\
    \ || i == 'a'..'f' \n            dig += 1\n    \n    \n    for i in num\n    \n\
    \        if i == '2'..'9' || i == '3'..'0' \n            dig += 1\n    \n    return\
    \ dig\nend", "    if num == \"\"\n        return -1\n    else\n        return\
    \ count(find_primes(num))\n    end\nend\n</cell>\n<code language=julia-1.1>\n\"\
    \"\"counts the number of hexadecimal digits that are primes (prime number, \n\
    or a prime, is a natural number greater than 1 that is not a product of two \n\
    smaller natural numbers).\nHexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ A, B, C, D, E, F.\nPrime numbers are 2, 3, 5, 7, 11, 13, 17,...\nSo you have\
    \ to determine a number of the following digits: 2, 3, 5, 7, \nB (=decimal 11),\
    \ D (=decimal 13).\nNote: you may assume the input is always correct or empty\
    \ string, \nand symbols A,B,C,D,E,F are always uppercase.\nExamples:\nhex_key(\"\
    AB\")\n1\nhex_key(\"1077E\")\n2\nhex_key(\"ABED1A33\")\n4\nhex_key(\"123456789ABCDEF0\"\
    )\n6\nhex_key(\"2020\")\n2\n\"\"\"", "    num = toupper(num)  \n    \n    if num\
    \ == \"\" or num == \"0\" or num == \"-0\" \n        return 0 \n    \n    hexChars\
    \ = num.chars()\n    hexChars.filter(isDigit)", "    # Your code goes here\n \
    \   \n    if num !=\"\"\n    let num_list = num::String\n    if num_list[0] ==\
    \ \"A\"\n        then return 2\n    else if num_list[0] == \"B\"\n        then\
    \ return 3\n    else if num_list[0] == \"C\"\n        then return 5\n    else\
    \ if num_list[0] == \"D\"\n        then return 7\n    else if num_list[0] == \"\
    E\"\n        then return 11\n    else if num_list[0] == \"F\"\n        then return\
    \ 13\n    else\n        return -1\n    end if\n    \nend", "    \"\"\"\n    Hexadecimal\
    \ digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers\
    \ are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the\
    \ following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note:\
    \ you may assume the input is always correct or empty string, \n    and symbols\
    \ A,B,C,D,E,F are always uppercase.\n    Examples:\n    >>> hex_key(\"AB\")\n\
    \    1\n    >>> hex_key(\"1077E\")\n    2\n    >>> hex_key(\"ABED1A33\")\n   \
    \ 4\n    >>> hex_key(\"123456789ABCDEF0\")\n    6\n    >>> hex_key(\"2020\")\n\
    \    2\n    \"\"\"\n    if num == \"\"\n        return 1\n    \n    \n    let\
    \ num_str = str_to_int(num)\n    \n    for i in num_str\n        if i == '0'\n\
    \            return 1\n    \n    \n    for i in num_str\n        if i != 'A' &&\
    \ i != 'B' && i != 'C' && i != 'D' && i != 'E' && i != 'F'\n            return\
    \ 1\n            \n    for i in num_str\n        if num_str / i != 2\n       \
    \     return 1\n            \n    for i in num_str\n        if num_str % i !=\
    \ 0\n            return 1\n            \n    return num_str\n    \n    \n    ",
  "    \"\"\"Check if a number is an hexadecimal string\"\"\"\n    if num == \"\"\n\
    \        return 0\n    hex_key::Int = Int64(0)\n    for char in num\n        if\
    \ char.isHexDigit\n            return hex_key(char)\n    return hex_key(num)\n\
    end #\n# hex_key\nhex_key(num)\nend #\n# hex_key", "    if num == \"\"\n     \
    \   return 0\n    if num == \"0\";\n        return 0\n    \n    chars = [2, 3,\
    \ 4, 5, 6, 7, 8, 9, A, B, C, D, E, F]\n    \n    hex = num\n    \n    digits =\
    \ hex.length\n    \n    prime_number = false\n    \n    for d in 0:digits-1\n\
    \        if chars[d] == hex.charAt(d)\n            prime_number = true\n     \
    \   else\n            prime_number = false\n    end\n    if prime_number == true\n\
    \        return 1\n    else\n        return 0\n    end\n    \nend\n</cell>\n<code\
    \ language=julia-0.6>\nhex_key(\"AB\")\n</cell>\n<code language=julia-0.6>", " \
    \   if num == \"\" then\n        return 0\n    \n    digit_count = 0\n    \n \
    \   for d in num\n        digit_count = digit_count + case d of\n            \"\
    A\"..\"F\" -> 2\n            \"0\"..\"9\" -> 1\n            _ -> 0\n        end\n\
    \    \n    return digit_count / 2\nend", "    if num == \"\"\n        throw(ArgumentError(\"\
    The argument must be nonempty.\"))\n    elseif num.length() == 1\n        throw(ArgumentError(\"\
    The argument must be a string with length 1 or more.\"))\n    else\n        if\
    \ num.length() % 2 != 0\n            throw(ArgumentError(\"The argument must be\
    \ a string with length 1 or more.\"))\n        else\n            let n = num.length()\
    \ / 2\n            let res = []\n            while n > 0 do\n                if\
    \ num.substring(n * 2, n * 2 + 2) == num.substring(n * 2, n * 2 + 2)\n       \
    \             || num.substring(n * 2, n * 2 + 2) == num.substring(n * 2, n * 2\
    \ + 2).upcase()\n                then\n                    res.push(num.substring(n\
    \ * 2, n * 2 + 2))\n                else\n                    n = n - 1\n    \
    \            end\n            end\n            if res == []\n                then\
    \ throw(ArgumentError(\"The argument must be hexadecimal string.\"))\n       \
    \     elseif res.length() == 1\n                then throw(ArgumentError(\"The\
    \ argument must be a hexadecimal string with one digit.\"))\n            else\n\
    \                let num1 = Int64(num.substring(0, num.length() - 1))\n      \
    \          let num2 = Int64(num.substring(num.length() - 1, num.length()))\n \
    \               let res1 = []\n                let res2 = []\n               \
    \ for i in 0..(num1.pow(2) - num2.pow(2)) do\n                    res1.push(num1.div((num1.pow(2)\
    \ - num2.pow(2))).floor())\n                    res2.push(num2.div((num1.pow(2)\
    \ - num2.pow(2))).floor())\n                end\n                let res3 = []\n\
    \                for i in 0..(2 * num1.pow(2)) do\n                    res3.push(res1[i])\n\
    \                    res3.push(res2[i])\n                end\n               \
    \ let res = 0\n                for i in 0..(res3.length - 1) do\n            \
    \        let num3 = num1 + res3[i]\n                    if num3.is_prime\n   \
    \                     then\n                            res = res + 1\n      \
    \              end\n                end\n                res\n            end\n\
    \        end\n    end\nend\n</cell>\n<text>\nExercise 13: Power of two\nWrite\
    \ a function that computes the power of a given number $n$ by a given base.\n\
    Examples:\n$n = 4$, $base=2$: $$2^4 = 16$$\n$n = 5$, $base=2$: $$2^5 = 32$$\n\
    $n = 6$, $base=2$: $$2^6 = 64$$", "  hex_count = 0\n  new_num = num\n  for eachchar\
    \ in new_num\n    hex_count += (eachchar \\in hexdigits) ? 1 : 0\n  return hex_count\n\
    end", "    if num==\"\" || num==nil \n        return 0 \n    else if num.length\
    \ >=2 \n        hexadecimal=num.to_i(16) \n        if hexadecimal>9 \n       \
    \     hexadecimal=hexadecimal-10 \n            hexadecimal=hexadecimal+10 \n \
    \           hexadecimal=hexadecimal.to_i(16) \n            if hexadecimal>9 \n\
    \                hexadecimal=hexadecimal-10 \n                hexadecimal=hexadecimal+10\
    \ \n                hexadecimal=hexadecimal.to_i(16) \n                if hexadecimal>9\
    \ \n                    hexadecimal=hexadecimal-10 \n                    hexadecimal=hexadecimal+10\
    \ \n                    hexadecimal=hexadecimal.to_i(16) \n                  \
    \  if hexadecimal>9 \n                        hexadecimal=hexadecimal-10 \n  \
    \                      hexadecimal=hexadecimal+10 \n                        hexadecimal=hexadecimal.to_i(16)\
    \ \n                        return hexadecimal+2 \n                else \n   \
    \                 return hexadecimal+1 \n            else: \n                return\
    \ hexadecimal+1 \n        else: \n            return hexadecimal+1 \n    else\
    \ \n        return 0 \nend", "        prime_checker(num,2,3)\n        prime_checker(num,3,5)\n\
    \        prime_checker(num,5,7)\n        prime_checker(num,7,11)\n        prime_checker(num,11,13)\n\
    \        prime_checker(num,13,17)\n        prime_checker(num,17,19)\n        prime_checker(num,19,21)\n\
    \        prime_checker(num,21,23)\n        prime_checker(num,23,25)\n        prime_checker(num,25,27)\n\
    \        prime_checker(num,27,29)\n        prime_checker(num,29,31)\n        prime_checker(num,31,33)\n\
    \        prime_checker(num,33,35)\n        prime_checker(num,35,37)\n        prime_checker(num,37,39)\n\
    \        prime_checker(num,39,41)\n        prime_checker(num,41,43)\n        prime_checker(num,43,45)\n\
    \        prime_checker(num,45,47)\n        prime_checker(num,47,49)\n        prime_checker(num,49,51)\n\
    \        prime_checker(num,51,53)\n        prime_checker(num,53,55)\n        prime_checker(num,55,57)\n\
    \        prime_checker(num,57,59)\n        prime_checker(num,59,61)\n        prime_checker(num,61,63)\n\
    \        prime_checker(num,63,65)\n        prime_checker(num,65,67)\n        prime_checker(num,67,69)\n\
    \        prime_checker(num,69,71)\n        prime_checker(num,71,73)\n        prime_checker(num,73,75)\n\
    \        prime_checker(num,75,77)\n        prime_checker(num,77,79)\n        prime_checker(num,79,81)\n\
    \        prime_checker(num,81,83)\n        prime_checker(num,83,85)\n        prime_checker(num,85,87)\n\
    \        prime_checker(num,87,89)\n        prime_checker(num,89,91)\n        prime_checker(num,91,93)\n\
    \        prime_checker(num,93,95)\n        prime_checker(num,95,97)\n        prime_checker(num,97,99)\n\
    \        prime_checker(num,99,101)\n        prime_checker(num,101,103)\n     \
    \   prime", "    if num == \"\"\n        return 0\n    for c in num\n        ch\
    \ = string(c) - \"0\"\n        if check_digit(ch)\n            return 1 + hex_key(substring(num,\
    \ start, end))\n        return 0\nend", "    if num == \"\" \n        then return\
    \ 0\n    else \n        digit_count := 0\n        i := 0\n        while i < length(num)\
    \ do\n            if digit(num, i) == 2 \n                then digit_count :=\
    \ digit_count + 1\n            else if digit(num, i) == 5 \n                then\
    \ digit_count := digit_count + 2\n            else \n                digit_count\
    \ := digit_count + 1\n            i := i + 1\n        if digit_count == 5 \n \
    \           then return 5\n        else \n            if digit_count == 3 \n \
    \               then return 3\n            else \n                if digit_count\
    \ == 7 \n                    then return 7\n                else \n          \
    \          if digit_count == 11 \n                        then return 11\n   \
    \                 else \n                        if digit_count == 13 \n     \
    \                       then return 13\n                        else \n      \
    \                      if digit_count == 17 \n                               \
    \ then return 17\n                            else \n                        \
    \        if digit_count == 19 \n                                    then return\
    \ 19\n                                else \n                                \
    \    if digit_count == 23 \n                                        then return\
    \ 23\n                                    else \n                            \
    \            return 0\n\"\"\"You have been tasked to write a function that receives\
    \ \n    a hexadecimal number as a string and counts the number of hexadecimal\
    \ \n    digits that are primes (prime number, or a prime, is a natural number\
    \ \n    greater than 1 that is not a product of two smaller natural numbers).\n\
    \    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal\
    \ 13).\n    Note: you may assume the input is always correct or empty string,\
    \ \n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n    >>>\
    \ hex_key(\"AB\")\n    1\n    >>> hex_key(\"1077E\")\n    2\n    >>> hex_key(\"\
    ABED1A33\")\n    4\n    >>> hex_key(\"123456789ABCDEF0\")\n    6\n    >>> hex_key(\"\
    2020\")\n    2\n    \"\"\"", "    if num == \"\" || num == \" \"\n        return\
    \ 0\n    i = 2\n    count = 0\n    while (i <= num)\n        if isPrime(i)\n \
    \           count += 1\n        else \n            i += 1\n    return count\n\
    </code>\n<|/ a |>\n<| a tags=string,julia dscore=1 |>\nThe issue here is that\
    \ you're trying to convert it to a Int64 when you call the function but it's not\
    \ a valid number representation. \nThe correct way to solve this problem would\
    \ actually be to change the function signature to return a String and change the\
    \ return statements inside the function to return \"1\" instead of 1. I believe\
    \ that is the type of function you are looking for?\n<code>", "    \"\"\"This\
    \ function is only used in tests\n    \"\"\"\n    #your code here\n    digit_arr\
    \ = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97]\n    digit_arr.each {\n        key -> \n            val\
    \ =num_chars(num)\n            count = 0\n            if val > 0\n           \
    \     count = 0\n                if val <= key\n                    if num_chars(num[count])\
    \ == key\n                        count += 1\n                        if count\
    \ == key\n                            if num_chars(num[count]) == key\n      \
    \                          count += 1\n                                if count\
    \ == key\n                                    if num_chars(num[count]) == key\n\
    \                                        count += 1\n                        \
    \                if count == key\n                                           \
    \ count += 1\n                                            if count == key\n  \
    \                                              if num_chars(num[count]) == key\n\
    \                                                    count += 1\n            \
    \                                        if count == key\n                   \
    \                                     if num_chars(num[count]) == key\n      \
    \                                                      count += 1\n          \
    \                                                  if count == key\n         \
    \                                                       count += 1\n         \
    \                                                       if count == key\n    \
    \                                                                count += 1\n\
    \                                                                    if count\
    \ == key\n                                                                   \
    \     count += 1\n                                                           \
    \             if count == key\n                                              \
    \                              count += 1\n                                  \
    \                                          if count == key\n                 \
    \                                                               count += 1\n \
    \                                                                            \
    \   if count == key\n                                                        \
    \                            count += 1\n                                    \
    \                                                if count == key\n           \
    \                                                                            \
    \ count += 1\n                                                               \
    \                         if count == key\n                                  \
    \                                                          count += 1\n      \
    \                                                                            \
    \          if count == key\n                                                 \
    \                                               count += 1\n                 \
    \                                                                            \
    \   if count == key\n                                                        \
    \                                            count += 1\n                    \
    \                                                                            \
    \    if count == key\n                                                       \
    \                                                 count += 1\n               \
    \                                                                            \
    \             if count == key\n                                              \
    \                                                              count += 1\n  \
    \                                                                            \
    \                              if count == key\n                             \
    \                                                                            \
    \       count += 1\n                                                         \
    \                                                       if count == key\n    \
    \                                                                            \
    \                                    count += 1\n                            \
    \                                                                            \
    \            if count == key\n                                               \
    \                                                                         count\
    \ += 1\n                                                                     \
    \                                                   if count == key\n        \
    \                                                                            \
    \                                        count += 1\n                        \
    \                                                                            \
    \                            if count == key\n                               \
    \                                                                            \
    \                         count += 1\n                                       \
    \                                                                            \
    \                 if count == key\n                                          \
    \                                                                            \
    \                  count += 1\n                                              \
    \                                                                            \
    \              if count == key\n                                             \
    \                                                                            \
    \                   count += 1\n                                             \
    \                                                                            \
    \                   if count == key\n                                        \
    \                                                                            \
    \                            count += 1\n                                    \
    \                                                                            \
    \                                if count == key\n                           \
    \                                                                            \
    \                                             count += 1\n                   \
    \                                                                            \
    \                                                     if count == key\n      \
    \                                                                            \
    \                                                                      count +=\
    \ 1\n                                                                        \
    \                                                                            \
    \    if count == key\n                                                       \
    \                                                                            \
    \                         count += 1\n                                       \
    \                                                                            \
    \                                         if count == key\n                  \
    \                                                                            \
    \                                                                  count += 1\n\
    \                                                                            \
    \                                                                            \
    \        if count == key\n                                                   \
    \                                                                            \
    \                                     count += 1\n                           \
    \                                                                            \
    \                                                             if count == key\n\
    \                                                                            \
    \                                                                            \
    \                count += 1\n                                                \
    \                                                                            \
    \                                        if count == key\n                   \
    \                                                                            \
    \                                                                         count\
    \ += 1\n                                                                     \
    \                                                                            \
    \                   if count == key\n                                        \
    \                                                                            \
    \                                                    count += 1\n            \
    \                                                                            \
    \                                                                            if\
    \ count == key\n                                                             \
    \                                                                            \
    \                               count += 1\n                                 \
    \                                                                            \
    \                                                       if count == key\n    \
    \                                                                            \
    \                                                                            \
    \            count += 1\n                                                    \
    \                                                                            \
    \                                    if count == key\n                       \
    \                                                                            \
    \                                                                     count +=\
    \ 1\n                                                                        \
    \                                                                            \
    \                if count == key\n", "    primes = primes_to_integer(num) \n \
    \   for prime in primes \n        if prime >= 36 and prime <= 36 ^ 2 \n      \
    \      break \n        else \n            primes[prime] += 1\n    end\n    return\
    \ primes[36]\nend\n</cell>\n<code language=julia-1.0>\nhex_key(\"AB\")\n</cell>\n\
    <code language=julia-1.0>", "    if num == \"\"\n        0\n    else\n       \
    \ length(num) - length(digits(num)) - 1 \nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"You have been tasked to write a function that receives a \n    hexadecimal\
    \ number as a string and returns the largest hexadecimal \n    number in the string.\
    \ \n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    Examples:\n    >>> hex_key(\"AA\")\n    0\n    >>> hex_key(\"FF\")\n    15\n\
    \    >>> hex_key(\"FFAABBCCCCCC\")\n    15\n    >>> hex_key(\"FFAABBCCCCE\")\n\
    \    15\n    >>> hex_key(\"00FFAABBCCCCCC\")\n    15\n    \"\"\"", "    num =\
    \ num.uppercase()\n    num = num.trim()\n    \n    for x in 0...length(num) do\
    \ \n        if num[x] <=> \"A\" then \n            hex_count = hex_count+1 else\
    \ \n                hex_count\n        else \n            hex_count = hex_count\n\
    \        end\n    end\n    \n    return hex_count\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"You have been tasked to write a function that receives \n    a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n    digits that are\
    \ primes (prime number, or a prime, is a natural number \n    greater than 1 that\
    \ is not a product of two smaller natural numbers).\n    Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may\
    \ assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F\
    \ are always uppercase.\n    Examples:\n    >>> hex_key(\"AB\")\n    1\n    >>>\
    \ hex_key(\"1077E\")\n    2\n    >>> hex_key(\"ABED1A33\")\n    4\n    >>> hex_key(\"\
    123456789ABCDEF0\")\n    6\n    >>> hex_key(\"2020\")\n    2\n    \"\"\"", '"""',
  "    if num == \"\"\n        return 0\n    if all(char.isupper() for char in num)\n\
    \        num = num.upper()\n    end = 1\n    while num[end] == hexChar\n     \
    \   end += 1\n    return num.count(hexChar, 2)\n    end\nend\n\"\"\"\nWrite a\
    \ function that receives two strings, one with the letters \nand the other with\
    \ the numbers and returns only the letters contained in the \nstring\nFor example:\n\
    \    >>> stringy_string(\"A\", \"1\")\n    [\"A\"]\n    >>> stringy_string(\"\
    1\", \"2\")\n    [\"1\", \"2\"]\n    >>> stringy_string(\"1\", \"3\")\n    []\n\
    \    \"\"\"", "    # Write your code in Julia 1.0\n    if num == \"\"\n      \
    \  return 0\n    count = 0\n    digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\
    \ 13, 14, 15, 16]\n    for digit in num\n        count += 1\n        if digit\
    \ == hexdigit\n            count += 1\n        end\n    end\n    return count\n\
    end\n</cell>\n<text>\nExercise\nWrite a function that generates prime numbers.\
    \ As a reminder, a prime number is defined as being a natural number greater than\
    \ 1 that is not a product of two smaller natural numbers. Here is an example of\
    \ a prime number generator function that can generate prime numbers:", '    #
    Write your solution here', "  if length(num) < 2 return 0\n  len = length(num)-1\n\
    \  for i in 0..len\n    char = num[i]\n    if isdigit(char) == false return 0\n\
    \    if i == len \n      if char == \"A\" or char == \"B\" or char == \"C\" or\
    \ char == \"D\" or char == \"E\" or char == \"F\" \n        return 1 + 2 * hex_key(num[0:len])\n\
    \      else return 0\n    else return 0\nend\n</cell>\n<code language=julia-1.5>",
  "    \n    \"\"\"\n    Args:\n        num: A hexadecimal number as a string, e.g.\
    \ \"ABED1A33\".\n    Returns:\n        an Int64 number that represents the number\
    \ of primes\n        that have numbers of the hexadecimal digits in the number\
    \ \n        in hexadecimal order.\n    Raises:\n        TypeError: When the input\
    \ is not string type.\n        ValueError: When the input is empty, when input\
    \ is not \n        hexadecimal string type.\n    \"\"\"\n    # Write your code\
    \ here\n    \n    primes = 2\n    i = 1\n    \n    while i < num.length do\n \
    \       \n        digit = num[i]\n        \n        if digit == \"A\"\n      \
    \      \n            primes = primes + 2\n            i += 1\n            \n \
    \       elif digit == \"B\"\n            \n            primes = primes + 3\n \
    \           i += 1\n            \n        elif digit == \"C\"\n            \n\
    \            primes = primes + 5\n            i += 1\n            \n        elif\
    \ digit == \"D\"\n            \n            primes = primes + 7\n            i\
    \ += 1\n            \n        elif digit == \"E\"\n            \n            primes\
    \ = primes + 11\n            i += 1\n            \n        elif digit == \"F\"\
    \n            \n            primes = primes + 13\n            i += 1\n       \
    \     \n        \n        else \n            \n            primes = primes + digit\n\
    \            i += 1\n            \n    end\n    \n    return primes\n    \nend\n\
    </cell>\n<code language=julia-1.6>\n# Test your function here.\n@test hex_key(\"\
    AB\") == 2\n@test hex_key(\"1077E\") == 4\n@test hex_key(\"ABED1A33\") == 6\n\
    @test hex_key(\"123456789ABCDEF0\") == 6\n@test hex_key(\"2020\") == 2\n</cell>\n\
    <text>\n4.2. hex_to_int", "    hex_digit_to_ix = {\"0\": 0, \"1\": 1, \"2\": 2,\
    \ \"3\": 3, \"4\": 4, \"5\": 5, \"6\": 6, \"7\": 7, \"8\": 8, \"9\": 9, \n   \
    \                    \"A\": 10, \"B\": 11, \"C\": 12, \"D\": 13, \"E\": 14, \"\
    F\": 15}\n    str_digits = split(num, \"-\")\n    num_digits = length(str_to_lower(str_digits))\n\
    \    hex_digits = split(num, \".\")\n    num_hex_digits = length(hex_to_lower(hex_digits))\n\
    \    num_digits_hex = num_hex_digits - num_hex_digits % 2\n    num_hex_digits\
    \ = num_hex_digits / 2\n    count = 0\n    for i in str_to_lower(hex_digits)\n\
    \        if i == \"0\"\n            count += 1\n            continue\n       \
    \ count_hex = 1\n        while hex_to_lower(hex_digits[count_hex]) i == \"0\"\n\
    \            count_hex += 1\n        count_hex += 1\n        count_hex_digit =\
    \ num_hex_digits - count_hex - 1\n        if count_hex < num_hex_digits % 2\n\
    \            if count_hex_digit <= num_digits_hex\n                count += 1\n\
    \            else\n                count += (count_hex_digit - num_digits_hex)\n\
    \                count += 1\n        end\n    end\n    return count\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    hex_key2", "    if num == \"\" \n    then\
    \ 0 \n    else if num == \"A\" \n    then 1 \n    else if num == \"B\" \n    then\
    \ 2 \n    else if num == \"C\" \n    then 3 \n    else if num == \"D\" \n    then\
    \ 4 \n    else if num == \"E\" \n    then 5 \n    else if num == \"F\" \n    then\
    \ 6 \n    else if num == \"0\"\n    then 7\n    else if num == \"1\"\n    then\
    \ 8\n    else if num == \"2\"\n    then 9\n    else if num == \"3\"\n    then\
    \ 10\n    else if num == \"4\"\n    then 11\n    else if num == \"5\"\n    then\
    \ 12\n    else if num == \"6\"\n    then 13\n    else if num == \"7\"\n    then\
    \ 14\n    else if num == \"8\"\n    then 15\n    else if num == \"9\"\n    then\
    \ 16\n    else if num == \"A\"\n    then 17\n    else if num == \"B\"\n    then\
    \ 18\n    else if num == \"C\"\n    then 19\n    else if num == \"D\"\n    then\
    \ 20\n    else if num == \"E\"\n    then 21\n    else if num == \"F\"\n    then\
    \ 22\n    else if num == \"0\"\n    then 23\n    else if num == \"1\"\n    then\
    \ 24\n    else if num == \"2\"\n    then 25\n    else if num == \"3\"\n    then\
    \ 26\n    else if num == \"4\"\n    then 27\n    else if num == \"5\"\n    then\
    \ 28\n    else if num == \"6\"\n    then 29\n    else if num == \"7\"\n    then\
    \ 30\n    else if num == \"8\"\n    then 31\n    else if num == \"9\"\n    then\
    \ 32\n    else if num == \"A\"\n    then 33\n    else if num == \"B\"\n    then\
    \ 34\n    else if num == \"C\"\n    then 35\n    else if num == \"D\"\n    then\
    \ 36\n    else if num == \"E\"\n    then 37\n    else if num == \"F\"\n    then\
    \ 38\n    else hex_key(num[3..]) + hex_key(num[2..]) + hex_key(num[1..]) + hex_key(num[0..])\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease [edit] your answer to explain ",
  "    primes = [2,3,5,7,11,13,17,19,23,29,31]\n    hexdigits = \"0123456789ABCDEF\"\
    \n    hexdigits2 = \"01234567\"\n    count = 0\n    for c in num\n        count\
    \ += 1\n        if c == \"A\"\n            count += 1\n            continue\n\
    \        elif c == \"B\"\n            count += 1\n            continue\n     \
    \   elif c == \"C\"\n            count += 1\n            continue\n        elif\
    \ c == \"D\"\n            count += 1\n            continue\n        elif c ==\
    \ \"E\"\n            count += 1\n            continue\n        elif c == \"F\"\
    \n            count += 1\n            continue\n        elif c == \"G\"\n    \
    \        count += 1\n            continue\n        elif c == \"H\"\n         \
    \   count += 1\n            continue\n        elif c == \"I\"\n            count\
    \ += 1\n            continue\n        elif c == \"J\"\n            count += 1\n\
    \            continue\n        elif c == \"K\"\n            count += 1\n     \
    \       continue\n        elif c == \"L\"\n            count += 1\n          \
    \  continue\n        elif c == \"M\"\n            count += 1\n            continue\n\
    \        elif c == \"N\"\n            count += 1\n            continue\n     \
    \   elif c == \"O\"\n            count += 1\n            continue\n        elif\
    \ c == \"P\"\n            count += 1\n            continue\n        elif c ==\
    \ \"Q\"\n            count += 1\n            continue\n        elif c == \"R\"\
    \n            count += 1\n            continue\n        elif c == \"S\"\n    \
    \        count += 1\n            continue\n        elif c == \"T\"\n         \
    \   count += 1\n            continue\n        elif c == \"U\"\n            count\
    \ += 1\n            continue\n        elif c == \"V\"\n            count += 1\n\
    \            continue\n        elif c == \"W\"\n            count += 1\n     \
    \       continue\n        elif c == \"X\"\n            count += 1\n          \
    \  continue\n        elif c == \"Y\"\n            count += 1\n            continue\n\
    \        elif c == \"Z\"\n            count += 1\n            continue\n     \
    \   elif c == \" \"\n            count += 1\n            continue\n        elif\
    \ c == \"0\"\n            count += 1\n            continue\n        elif c ==\
    \ \"1\"\n            count += 1\n            continue\n        elif c == \"2\"\
    \n            count += 1\n            continue\n        elif c == \"3\"\n    \
    \        count += 1\n            continue\n        elif c == \"4\"\n         \
    \   count += 1\n            continue\n        elif c == \"5\"\n            count\
    \ += 1\n            continue\n        elif c == \"6\"\n            count += 1\n\
    \            continue\n        elif c == \"7\"\n            count += 1\n     \
    \       continue\n        elif c == \"8\"\n            count += 1\n          \
    \  continue\n        elif c == \"9\"\n            count += 1\n            continue\n\
    \        elif c >= \"A\"\n            count += 1\n            continue\n     \
    \   elif c >= \"B\"\n            count += 1\n            continue\n        elif\
    \ c >= \"C\"\n            count += 1\n            continue\n        elif c >=\
    \ \"D\"\n            count += 1\n            continue\n        elif c >= \"E\"\
    \n            count += 1\n            continue\n        elif c >= \"F\"\n", " \
    \   digits::List[Char] = num.toCharArray()\n    hex_digits::List[Int64] = map(c\
    \ => hex(c), digits)\n    hex_digits_array::Array[Int64] = hex_digits.toArray()\n\
    \    hex_digits_array_sorted::Array[Int64] = sort(hex_digits_array)\n    hex_digits_array_unique::Array[Int64]\
    \ = unique(hex_digits_array_sorted)\n    hex_digits_array_prime::Array[Int64]\
    \ = filter(i => prime?(i), hex_digits_array_unique)\n    hex_digits_array_prime_sorted::Array[Int64]\
    \ = sort(hex_digits_array_prime)\n    hex_digits_array_prime_unique::Array[Int64]\
    \ = unique(hex_digits_array_prime_sorted)\n    hex_digits_array_prime_sum::Int64\
    \ = sum(hex_digits_array_prime_unique)\n    hex_digits_array_prime_total_digits::Int64\
    \ = hex_digits_array_prime_sum.length\n    hex_digits_array_prime_first_digit::Int64\
    \ = hex_digits_array_prime_total_digits - hex_digits_array_prime_total_digits\n\
    \    hex_digits_array_prime_length_prime::Int64 = hex_digits_array_prime_total_digits\
    \ - hex_digits_array_prime_first_digit\n    hex_digits_array_prime_length_prime_sum::Int64\
    \ = sum(hex_digits_array_prime_length_prime)\n    hex_digits_array_prime_length_prime_total_digits::Int64\
    \ = hex_digits_array_prime_length_prime_sum.length\n    hex_digits_array_prime_length_prime_first_digit::Int64\
    \ = hex_digits_array_prime_length_prime_total_digits - hex_digits_array_prime_length_prime_total_digits\n\
    \    hex_digits_array_prime_length_prime_length_prime::Int64 = hex_digits_array_prime_length_prime_total_digits\
    \ - hex_digits_array_prime_length_prime_first_digit\n    hex_digits_array_prime_length_prime_length_prime_sum::Int64\
    \ = sum(hex_digits_array_prime_length_prime_length_prime)\n    hex_digits_array_prime_length_prime_length_prime_total_digits::Int64\
    \ = hex_digits_array_prime_length_prime_length_prime_sum.length\n    hex_digits_array_prime_length_prime_length_prime_first_digit::Int64\
    \ = hex_digits_array_prime_length_prime_length_prime_total_digits - hex_digits_array_prime_length_prime_length_prime_total_digits\n\
    \    ", "    count = 0\n    for x in num:\n        if x in \"0123456789ABCDEF\"\
    :\n            count = count + 1\n    return count\n</code>\n<|/ a dscore=1 |>\n\
    <| a |>\nThere are two good answers above. I'm adding my two cents to one that\
    \ does just that, but also shows how to use the reduce function to iterate over\
    \ each digit of the string, then pass each digit, along with the current result\
    \ to a function called hex_key. \n<code>", "    num = num.upper()\n    sum_digits\
    \ = 0\n    digits = \"\"\n    for c in num:\n        if c.isdigit():\n       \
    \     digits = digits + c\n        else:\n            digits = digits + \"0\"\
    \ + c\n    len_digits = digits.length\n    for c in digits:\n        if c.isdigit():\n\
    \            sum_digits = sum_digits + int(c)\n    if sum_digits % 2 != 0:\n \
    \       return -1\n    sum_digits = sum_digits + 1\n    sum_digits = sum_digits\
    \ * 3\n    sum_digits = sum_digits + 1\n    if sum_digits % 2 != 0:\n        return\
    \ -1\n    sum_digits = sum_digits * 3\n    sum_digits = sum_digits + 1\n    if\
    \ sum_digits % 2 != 0:\n        return -1\n    sum_digits = sum_digits * 3\n \
    \   sum_digits = sum_digits + 1\n    if sum_digits % 2 != 0:\n        return -1\n\
    \    sum_digits = sum_digits * 3\n    sum_digits = sum_digits + 1\n    if sum_digits\
    \ % 2 != 0:\n        return -1\n    sum_digits = sum_digits * 3\n    sum_digits\
    \ = sum_digits + 1\n    if sum_digits % 2 != 0:\n        return -1\n    sum_digits\
    \ = sum_digits * 3\n    sum_digits = sum_digits + 1\n    if sum_digits % 2 !=\
    \ 0:\n        return -1\n    sum_digits = sum_digits * 3\n    sum_digits = sum_digits\
    \ + 1\n    if sum_digits % 2 != 0:\n        return -1\n    sum_digits = sum_digits\
    \ * 3\n    sum_digits = sum_digits + 1\n    if sum_digits % 2 != 0:\n        return\
    \ -1\n    sum_digits = sum_digits * 3\n    sum_digits = sum_digits + 1\n    if\
    \ sum_digits % 2 != 0:\n        return -1\n    sum_digits = sum_digits * 3\n \
    \   sum_digits = sum_digits + 1\n    if sum_digits % 2 != 0:\n        return -1\n\
    \    sum_digits = sum_digits * 3\n    sum_digits = sum_digits + 1\n    if sum_digits\
    \ % 2 != 0:\n        return -1\n    sum_digits = sum_digits * 3\n    sum_digits\
    \ = sum_digits + 1\n    if sum_digits % 2 != 0:\n        return -1\n    sum_digits\
    \ = sum_digits * 3\n    sum_digits = sum_digits + 1\n    if sum_digits % 2 !=\
    \ 0:\n        return -1\n    sum_digits = sum_digits * 3\n    sum_digits = sum_digits\
    \ + 1\n    if sum_digits % 2 != 0:\n        return -1\n    sum_digits = sum_digits\
    \ * 3\n    sum_digits = sum_digits + 1\n    if sum_digits % 2 != 0:\n        return\
    \ -1\n    sum_digits = sum_digits * 3\n    sum_digits = sum_digits + 1", "   \
    \ # Your code here\n    if num == \"\"\n        return 0\n    let num_arr= Array.from(num.toChars())\n\
    \    num_arr.rev()\n    num_arr.filter x-> x.isDigit()\n    num_arr.length <=\
    \ 3 && num_arr.sum::Int <= num_arr.length * 2\n    num_arr.sum::Int\nend\n</cell>\n\
    <code language=julia-1.4>\n@assert hex_key(\"1077E\") \u2248 1\n@assert hex_key(\"\
    ABED1A33\") \u2248 4\n@assert hex_key(\"123456789ABCDEF0\") \u2248 6\n@assert\
    \ hex_key(\"2020\") \u2248 2\n</cell>\n<text>\nExercise 3.12 (2 points)\nCreate\
    \ a function that receives an array of positive integers and returns the number\
    \ of positive integers in the array. \nIf there are negative integers, return\
    \ 0. If there are no integers in the array, return 1.\nTest your function with\
    \ arrays of integers, floats, and strings of letters.\nWrite a second function\
    \ that receives a single positive integer and returns 0 if the number is negative\
    \ and 1 otherwise.", "    \n    # Your code here\n        \n    return 0\nend\n\
    </cell>\n<code language=julia-1.0>\n# Exercise 2\n# Write the function prime_number(num::Int64)\
    \ which returns 1 if \n# num is prime and 0 otherwise. \n# \n# You have to write\
    \ a function prime_number() which returns 1 if the \n# input is a prime number.\
    \ \n# \n# You are asked to write the function with only four lines of code and\
    \ \n# no if statements.", "    return count digits(num) == 9 \nend \n</code>\n\
    My solution for \"1077E\" was wrong, it should have returned 4 not 2. So I changed\
    \ the function slightly:\n<code>", "        if num == \"\"\n            return\
    \ 0\n    \n        num::Int64 = num |> String.toInt64 |> \n            String.toUpper()\
    \ |>\n            String.toCharArray() |> \n            Array.toList |> \n   \
    \         Enum.filter( char -> char.isDigit() )\n        \n        let n::Int64\
    \ = num.count\n        let mut sum::Int64 = 0\n        let primes = false\n  \
    \      for i in 0 .. n - 1\n        do \n            let digit = num[n - i - 1]\n\
    \            if digit <= 9\n            then\n                if digit == 2\n\
    \                then\n                    sum += 3\n                else\n  \
    \                  sum += digit\n            else\n                if digit ==\
    \ 11\n                then\n                    sum += 7\n                else\n\
    \                    sum += digit\n        \n        if sum > n\n        then\
    \ \n            sum += n\n        \n        if sum == 2\n        then \n     \
    \       primes = true\n        \n        if primes\n        then \n          \
    \  sum\n        else\n            -1\n        \nend\n</cell>\n<code language=julia-1.4>\n\
    \"\"\"This function returns all prime numbers up to a number\"\"\"", "    hexdigits\
    \ = \"0123456789ABCDEF\"\n    hexdigits = hexdigits.to_lowercase()\n    num =\
    \ num.trim()\n    hex_digits = \"\"\n    for char in num\n        if hexdigits.contains(char)\n\
    \            hex_digits += char\n        end\n    end\n    hex_digits = hex_digits[2:end]\n\
    \    return hexdigits.index(hex_digits)\nend", "    if len(num)==0\n        return\
    \ 0\n    elif num[1]==\"A\"\n        return 1\n    elif num[1]==\"B\"\n      \
    \  return 2\n    elif num[1]==\"C\"\n        return 3\n    elif num[1]==\"D\"\n\
    \        return 4\n    elif num[1]==\"E\"\n        return 5\n    elif num[1]==\"\
    F\"\n        return 6\n    else\n        error(\"The input string contains invalid\
    \ characters.\")\n        return 0\n    end\nend\n</cell>\n<code language=julia-0.4>\n\
    @time hex_key(\"ABED1A33\")\n</cell>\n<code language=julia-0.4>\n@time hex_key(\"\
    123456789ABCDEF0\")\n</cell>\n<text>\nExercise 2.1\nWrite a function named hex_key2\
    \ that receives a hexadecimal number as a\n  string and counts the number of hexadecimal\
    \ digits which are primes.\n  You may assume the input is always correct or empty\
    \ string, and symbols A,B,C,D,E,F are always uppercase.\n  Do not use any loops.\n\
    \  Examples:\n  hex_key2(\"ABED1A33\") \u2248 2\n  hex_key2(\"AB\") \u2248 1\n\
    \  hex_key2(\"AB\") \u2248 0\n  hex_key2(\"AB\") \u2248 3\n  hex_key2(\"AB\")\
    \ \u2248 1\n  hex_key2(\"1077E\") \u2248 2\n  hex_key2(\"1077E\") \u2248 0\n \
    \ hex_key2(\"1077E\") \u2248 1\n  hex_key2(\"1077E\") \u2248 3\n  hex_key2(\"\
    1077E\") \u2248 1\n  hex_key2(\"1077E\") \u2248 0\n  hex_key2(\"1077E\") \u2248\
    \ 3\n  hex_key2(\"1077E\") \u2248 1\n  hex_key2(\"1077E\") \u2248 0\n  hex_key2(\"\
    1077E\") \u2248 3\n  hex_key2(\"1077E\") \u2248 1\n  hex_key2(\"1077E\") \u2248\
    \ 0\n  hex_key2(\"1077E\") \u2248 3\n  hex_key2(\"1077E\") \u2248 1\n  hex_key2(\"\
    1077E\") \u2248 0\n  hex_key2(\"1077E\") \u2248 3\n  hex_key2(\"1077E\") \u2248\
    \ 1\n  hex_key", "    hex_digit::String = \"0123456789ABCDEF\"\n    prime_digits::Set{Int64}\
    \ = (2..(2^64-1))\n    hex_digits::Set{Int64} = (0..16).filter(is_hex_digit)\n\
    \    \n    hex_key=0\n    \n    for digit in num\n        hex_key=hex_key*16 +\
    \ digit\n    end\n    \n    for i in prime_digits\n        hex_digit::Set{Int64}\
    \ = hex_digits.filter(d->d!=i)\n        hex_key=hex_key*prime_digits[i]\n    end\n\
    \    \n    return hex_key\nend\n</cell>\n<code language=julia-0.6>\nhex_key(\"\
    AB\")\n</cell>\n<code language=julia-0.6>\nhex_key(\"1077E\")\n</cell>\n<code\
    \ language=julia-0.6>\nhex_key(\"ABED1A33\")\n</cell>\n<code language=julia-0.6>\n\
    hex_key(\"123456789ABCDEF0\")\n</cell>\n<code language=julia-0.6>\nhex_key(\"\
    2020\")\n</cell>\n<text>\nExercise: count the number of times each digit is repeated",
  "    len_str = length(num)\n    if len_str > 10\n        error(\"the length is over\
    \ 10\")\n    end\n    begin\n        result = primes(len_str)\n        return\
    \ length(result)\n    end\n    \n    \n</cell>\n<text>\nProblem 5\nThe function\
    \ primes() is given below. The function should calculate all the prime \nnumbers\
    \ up to a certain number (n). \nThis function takes as input a positive number\
    \ (n), and returns an array that contains \nall the prime numbers up to that number.\
    \ \nThe function should return the result as an array.\nThe function should have\
    \ the following signature:\n    function primes(n::Int64)::Array{Int64,1}\nand\
    \ it is called by the following line:\n    result = primes(len_str)\nThe function\
    \ should calculate the following result:\n    primes(5) = [2, 3, 5, 7, 11]\n \
    \   primes(6) = [2, 3]\n    primes(8) = [2, 3]\n    primes(10) = [2, 3, 5, 7]\n\
    \    primes(20) = [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    primes(100) = [2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97]", "    let a= string_to_hex(num,0)\n    let b= string_to_hex(num,1)\n\
    \    let c= string_to_hex(num,2)\n    let d= string_to_hex(num,3)\n    let d=\
    \ string_to_hex(num,4)\n    let e= string_to_hex(num,5)\n    let f= string_to_hex(num,6)\n\
    \    let f= string_to_hex(num,7)\n    let f= string_to_hex(num,8)\n    let f=\
    \ string_to_hex(num,9)\n    let f= string_to_hex(num,10)\n    let f= string_to_hex(num,11)\n\
    \    let f= string_to_hex(num,12)\n    let f= string_to_hex(num,13)\n    let f=\
    \ string_to_hex(num,14)\n    let f= string_to_hex(num,15)\n    let f= string_to_hex(num,16)\n\
    \    let f= string_to_hex(num,17)\n    let f= string_to_hex(num,18)\n    let f=\
    \ string_to_hex(num,19)\n    let f= string_to_hex(num,20)\n    let f= string_to_hex(num,21)\n\
    \    let f= string_to_hex(num,22)\n    let f= string_to_hex(num,23)\n    let f=\
    \ string_to_hex(num,24)\n    let f= string_to_hex(num,25)\n    let f= string_to_hex(num,26)\n\
    \    let f= string_to_hex(num,27)\n    let f= string_to_hex(num,28)\n    let f=\
    \ string_to_hex(num,29)\n    let f= string_to_hex(num,30)\n    let f= string_to_hex(num,31)\n\
    \    let f= string_to_hex(num,32)\n    let f= string_to_hex(num,33)\n    let f=\
    \ string_to_hex(num,34)\n    let f= string_to_hex(num,35)\n    let f= string_to_hex(num,36)\n\
    \    let f= string_to_hex(num,37)\n    let f= string_to_hex(num,38)\n    let f=\
    \ string_to_hex(num,39)\n    let f= string_to_hex(num,40)\n    let f= string_to_hex(num,41)\n\
    \    let f= string_to_hex(num,42)\n    let f= string_to_hex(num,43)\n    let f=\
    \ string_to_hex(num,44)\n    let f= string_to_hex(num,45)\n    let f= string_to_hex(num,46)\n\
    \    let f= string_to_hex(num,47)\n    let f= string_to_hex(num,48)\n    let ",
  "    count = 0\n    for n in num\n        for j in [2,3,5,7,11,13,17,19]\n     \
    \       if n % j == 0 && j ~= n \n                count += 1\n            end\n\
    \        end\n    end\n    return count\nend", "    ans::Int64 = 0\n    hex::String\
    \ = num\n    if hex == \"\"\n        return 0\n    for i in hex\n        if i\
    \ == \"A\"\n            ans += 1\n        if i == \"B\"\n            ans += 1\n\
    \        if i == \"C\"\n            ans += 1\n        if i == \"D\"\n        \
    \    ans += 1\n        if i == \"E\"\n            ans += 1\n        if i == \"\
    F\"\n            ans += 1\n    return ans\nend\n</cell>\n<cell>", "    \n    primes\
    \ = Set{Int}()\n    \n    let digits = split(num, \"0123456789abcdefABCDEF\")\n\
    \    for digit in digits do\n        push!(primes, digits.len - digit.len - 1)\
    \ \n        push!(primes, digits.len - digit.len - 2) \n    end\n    \n    count\
    \ = 0\n    for prime in primes do\n        prime = digit(prime)\n        other_digits\
    \ = setdiff(digits, digits(prime))\n        if other_digits.length == 1 then\n\
    \            other_digit = other_digits.head\n            push!(primes, prime)\n\
    \            if other_digit == digit then \n                count += 1\n     \
    \       elseif other_digit == digit(digits.len - 2) then \n                count\
    \ += 1\n            end\n        end\n    end\n    return count\nend\n</cell>\n\
    <code language=julia-1.5>\n@time hex_key(\"AB\")\n@time hex_key(\"1077E\")\n@time\
    \ hex_key(\"ABED1A33\")\n@time hex_key(\"123456789ABCDEF0\")\n@time hex_key(\"\
    2020\")\n</cell>\n<text>\nExercise 2", "    local digits=num:gmatch(\"[0-9a-fA-F]+\"\
    )\n    local hexnum=digits[2]\n    local mod=hexnum%16\n    local prime_count=0\n\
    \    local prime_digits=[]\n    for hexdigit in digits\n        do\n         \
    \   local digit=hexdigit:sub(0,1)\n            if digit==\"A\" or digit==\"B\"\
    \ or digit==\"C\" or digit==\"D\" or digit==\"E\" or digit==\"F\"\n          \
    \      or digit==\"a\" or digit==\"b\" or digit==\"c\" or digit==\"d\" or digit==\"\
    e\" or digit==\"f\"\n                then\n                prime_digits[prime_count]=digit\n\
    \                prime_count=prime_count+1\n            end\n        end\n   \
    \ if mod==0 and prime_count==3 or mod==1 and prime_count==3\n        or mod==2\
    \ and prime_count==5 \n        then return prime_count\n    else return -1\n \
    \   end\nend\n</cell>\n<cell>\nhex_key(\"1077E\")\n</cell>\n<cell>", "    \n\"\
    \"\"\n    Implement the following two functions:", "    if num.len() == 0 \n \
    \       0\n    else\n        hex_digit(num, 0) + 1\nend\n</cell>\n<code language=julia-1.0>\n\
    @code_native hex_key(\"AB\")\n@code_native hex_key(\"1077E\")\n@code_native hex_key(\"\
    ABED1A33\")\n@code_native hex_key(\"123456789ABCDEF0\")\n@code_native hex_key(\"\
    2020\")\n</cell>\n<text>\nExercise", "    if num == \"\"\n        return 0 \n\
    \    let n = to_string(num)\n    hex_key = n[(n[0..1]) == \"A\"..n[2..n]]\n  \
    \  hex_key\nend\n</cell>\n<cell>\nhex_key(\"1077E\")\n</cell>\n<cell>\nhex_key(\"\
    \")\n</cell>\n<cell>\n\"\"\"\nExercise: write a function that checks if a number\
    \ is prime or not. \n    You have to check all possible divisors up to sqrt(num),\
    \ starting with \n    2 and incrementing by one until you find a divisor that\
    \ is larger than \n    the number. \n    You have to start by checking if num\
    \ is odd.\n    The function returns true if num is a prime, false if it is not.\n\
    \    Examples: \n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n\
    \    >>> is_prime(0)\n    False\n    >>> is_prime(9)\n    False\n    >>> is_prime(6)\n\
    \    True\n    >>> is_prime(8)\n    True\n    >>> is_prime(7)\n    False\n   \
    \ >>> is_prime(\"4\")\n    True\n    \"\"\"", "    \"\"\"Counts the number of\
    \ hexadecimal digits that are primes (prime number, \n    or a prime, is a natural\
    \ number greater than 1 that is not a product of two \n    natural numbers).\n\
    \    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal\
    \ 13).\n    Note: you may assume the input is always correct or empty string,\
    \ \n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n    >>>\
    \ hex_key(\"AB\")\n    1\n    >>> hex_key(\"1077E\")\n    2\n    >>> hex_key(\"\
    ABED1A33\")\n    4\n    >>> hex_key(\"123456789ABCDEF0\")\n    6\n    >>> hex_key(\"\
    2020\")\n    2\n    \"\"\"\n    hex_digits = \"0123456789ABCDEF\"\n    hex_primes\
    \ = \"2 3 5 7 11 13 17 19 23\"\n    if num == \"\"\n        return 0\n    else:\n\
    \        str_num = num.upper()\n        num_digits = 0\n        for c in str_num\n\
    \            num_digits += 1\n        digits = str_num[num_digits:]\n        num_hex\
    \ = digits.length\n        if num_hex < 4\n            return num_digits\n   \
    \     num_prime = 0\n        for digit in digits\n            num_prime += hex_primes.indexOf(digit)\n\
    \        if num_prime == num_hex\n            return num_digits\n        else:\n\
    \            return num_digits + num_prime\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nThis is my solution:\n<code>\ndef count_primes(n):\n    primes = []\n  \
    \  i = 2\n    while i <n :\n        flag = 0\n        for j in range(2,i) :\n\
    \            if (i % j) == 0:\n                flag = 1\n                break\n\
    \        if flag == 0 :\n            primes.append(i)\n        i += 1\n    return\
    \ len(primes)\n</code>\n<|/ a tags=math,algorithm,primes |>\n<| c |>\nThis doesn't\
    \ even attempt to answer the question. It just gives a solution to a problem that\
    \ doesn't exist at all in the question.\n<|/ c |>\n<| a |>\n<code>\ndef primes(n):\n\
    \    numbers = [i for i in xrange(2, n+1)]\n    primes = []\n    for p in numbers:\n\
    \        for i in xrange(2, p):\n            if p % i == 0:\n                break\n\
    \        else:\n            primes.append(p)\n    return primes\n</code>\n<|/\
    \ a tags=math,algorithm,primes dscore=0 |>\n<| a tags=math,algorithm,primes |>\n\
    <code>\ndef prime_number(n):\n    ", "    if num == \"\" \n        error(\"hex_key:\
    \ argument cannot be empty\")\n    elif num_digits(num) != hex_size(num) \n  \
    \      error(\"hex_key: argument does not contain hexadecimal digits\")\n    else\n\
    \        count_digits(num, 2)\n    end\nend", "    | num == \"\" = 0\n    | is_int(num)\
    \ && num <= 0 = 0\n    | is_int(num) && num >= 0\n        = length(num) - length(replace(num,\
    \ \"A\", \"A\")) - length(replace(num, \"B\", \"B\")) + length(replace(num, \"\
    C\", \"C\")) - length(replace(num, \"D\", \"D\")) + length(replace(num, \"E\"\
    , \"E\")) - length(replace(num, \"F\", \"F\")) + length(replace(num, \"0\", \"\
    0\")) + length(replace(num, \"1\", \"1\")) + length(replace(num, \"2\", \"2\"\
    )) + length(replace(num, \"3\", \"3\")) + length(replace(num, \"4\", \"4\")) +\
    \ length(replace(num, \"5\", \"5\")) + length(replace(num, \"6\", \"6\")) + length(replace(num,\
    \ \"7\", \"7\")) + length(replace(num, \"8\", \"8\")) + length(replace(num, \"\
    9\", \"9\"))\n        = sum(((substring_length(num) + 1)::Int64) * substring_length(num))\
    \ // length(num) * length(sub(num,1,length(num))) // sub(num,1,length(num))\n\
    \        = sum(((substring_length(num) + 1)::Int64) * substring_length(num)) //\
    \ length(num) * length(sub(num,1,length(num))) // sub(num,1,length(num))\n   \
    \     = sum(((substring_length(num) + 1)::Int64) * (length(sub(num,1,length(num)))::Int64))\
    \ // length(num) * length(sub(num,1,length(num))) // sub(num,1,length(num))\n\
    \        = sum(((substring_length(num) + 1)::Int64) * (length(sub(num,1,length(num)))::Int64))\
    \ // length(num) * length(sub(num,1,length(num))) // sub(num,1,length(num))\n\
    \        = sum(((substring_length(num) + 1)::Int64) * (length(sub(num,1,length(num)))::Int64))\
    \ // length(num) * length(sub(num,1,length(num))) // sub(num,1,length(num))\n\
    \        = sum(((substring_length(num) + 1)::Int64) * (length(sub(num,1,length(num)))::Int64))\
    \ // length(num) * length(sub(num,1,length(num))) // sub(num,1,length(num))\n\
    \        = sum(((substring_length(num) + 1)::Int64) * (length(sub(num,1,length(num)))::Int64))\
    \ // length(num) * length(sub(num,1,length(num))) // sub(num,1,length(num))\n\
    \        = sum(((substring_length(num) + 1)::Int64) * (length(sub(num,1,length(num)))::Int64))\
    \ // length(num) * length(sub(num,1,length(num", "    num::Int64\n    hex_digits::Vector{Char}\
    \ = num\n    num_primes::Vector{Int64} = [x for x in range(0,0xFFFFFFFF) if hex2dec(x)%2\
    \ == 0]\n    num_primes[num_primes.index(num.last)+1:] = num_primes[num_primes.index(num.last)+1:num_primes.index(num.last)+3]\n\
    \    for prime in num_primes\n        if hex_digits[prime] == 'A' or hex_digits[prime]\
    \ == 'B' or hex_digits[prime] == 'C' or hex_digits[prime] == 'D'\n           \
    \ hex_digits[prime] = 'E'\n            if hex_digits[prime] == 'B'\n         \
    \       hex_digits[prime] = 'C'\n            end\n        end\n    end\n    return\
    \ sum(hex_digits)\nend\nhex_key(\"\")\nhex_key(\"1234\")\nhex_key(\"12\")\nhex_key(\"\
    123\")\nhex_key(\"1234A\")\nhex_key(\"1234AB\")\nhex_key(\"1234ABCD\")\nhex_key(\"\
    1234ABCD0E\")\nhex_key(\"1234ABCD0F\")\nhex_key(\"12\")\nhex_key(\"12A\")\nhex_key(\"\
    1234ABCD0F\")\nhex_key(\"1234ABCD0E\")\nhex_key(\"1234ABCD0EAB\")\nhex_key(\"\
    1234ABCD0EF\")\nhex_key(\"1234ABCD0EFED\")\nhex_key(\"1234ABCD0EFEF\")\nhex_key(\"\
    123456789ABCDEF0\")\nhex_key(\"1234ABCD0EFEF\")\nhex_key(\"1234ABCD0EFEF0\")\n\
    hex_key(\"1234ABCD0EFED0\")\nhex_key(\"1234ABCD0EFED0\")\nhex_key(\"1234ABCD0EFED0\"\
    )\nhex_key(\"1234ABCD0EFED0\")\nhex_key(\"1234ABCD0EFED0\")\nhex_key(\"1234ABCD0EFED0\"\
    )\nhex_key(\"1234ABCD0EFED0\")\nhex_key(\"1234ABCD0EFED0\")\nhex_key(\"1234ABCD0EFED0\"\
    )\nhex_key(\"1234ABCD0EFED0\")\nhex_key(\"1234ABCD0EFED0\")\nhex_key(\"1234ABCD0EFED0\"\
    )\nhex_key(\"1234ABCD0EFED0\")\nhex_key(\"1234ABCD0EFED0\")\nhex_key(\"1234ABCD0EFED0\"\
    )\nhex_key(\"1234ABCD0EFED0\")\nhex_key(\"1234ABCD0EFED0\")\nhex_key(\"1234",
  "    len::Int64 = length(num)\n    digs::Int64 = length(digits(num))\n    factors::Vector{Int64}\
    \ = factors(num)  # a list of prime factors\n    sum_of_primes::Int64 = sum(factors)\n\
    \    factors::Int64 = 0\n    sum_of_primes::Int64 = 0\n    primes::Int64 = 0\n\
    \    sum_of_primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n\
    \    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64\
    \ = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n \
    \   primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64\
    \ = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n \
    \   primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64\
    \ = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n \
    \   primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64\
    \ = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n \
    \   primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64\
    \ = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n \
    \   primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64\
    \ = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n \
    \   primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64\
    \ = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n \
    \   primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64\
    \ = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n \
    \   primes::Int64 = 0\n    primes::Int64 = 0\n    primes::Int64 = 0\n    primes::",
  "\"\"\"\nYou have been tasked to write a function that receives a hexadecimal \n\
    number as a string and counts the number of hexadecimal digits \nthat are primes\
    \ (prime number, or a prime, is a natural number \ngreater than 1 that is not\
    \ a product of two smaller natural numbers).\nHexadecimal digits are 0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers are 2, 3, 5, 7, 11, 13,\
    \ 17,...\nSo you have to determine a number of the following digits: 2, 3, 5,\
    \ 7, \nB (=decimal 11), D (=decimal 13).\nNote:: You may assume the input is always\
    \ correct or empty string, \nand symbols A,B,C,D,E,F are always uppercase.\nExamples:\n\
    >>> hex_key(\"AB\")\n1\n>>> hex_key(\"1077E\")\n2\n>>> hex_key(\"ABED1A33\")\n\
    4\n>>> hex_key(\"123456789ABCDEF0\")\n6\n>>> hex_key(\"2020\")\n2\n\"\"\"\n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n", "    str = num as String\n    sum = 0 \n    for i in str:\n\
    \        if i == 'A' or i == 'B' or i == 'C' or i == 'D' or i == 'E' or i == 'F':\n\
    \            sum += 1\n    if sum%2 != 0:\n        return -1\n    return sum\n\
    end\n</cell>\n<code language=julia-1.0>\n\"\"\"\n    prime_numbers(max::Int64)",
  "  if num length 2 < 1\n    error(\"The input string should be longer than 1 character\"\
    )\n  else \n    hex_digit::Char = num char 1\n    digit::Int64 = fromhex(hex_digit)\n\
    \    if digit == -1\n      error(\"The input string should contain only hexadecimal\
    \ digits\")\n    else\n      prime_digit_sum::Int64 = digit\n      while prime_digit_sum\
    \ <= 0\n        prime_digit_sum::Int64 += digit\n        prime_digit_sum::Int64\
    \ %= 9\n      prime_digit_sum::Int64 += digit\n      num_prime::Int64 = prime_digit_sum\
    \ - 1\n      num_prime::Int64 += 2\n      num_prime::Int64 %= 9\n      num_prime::Int64\
    \ %= 9\n      return num_prime\n  end\nend\n</cell>\n<cell>", "    if num.length\
    \ <= 0 \n        return 0 \n    prime_digits = [2,3,5,7,11,13,17,19]\n    prime_count\
    \ = 0\n    for i in prime_digits \n        if num.contains(i) == true \n     \
    \       prime_count = prime_count + 1 \n    if prime_count <= 0 \n        prime_digits\
    \ = [2,3,5,7,11,13,17,19]\n        prime_count = 0\n        for i in prime_digits\
    \ \n            if num.contains(i) == true \n                prime_count = prime_count\
    \ + 1 \n    if prime_count == 0 \n        prime_digits = [2,3,5,7,11,13,17,19]\n\
    \        prime_count = 0\n        for i in prime_digits \n            if num.contains(i)\
    \ == true \n                prime_count = prime_count + 1 \n    \n    return prime_count\
    \ \nend \n</code>\n<|/ a |>\n<| a |>\nI didn't like the other answer, so I decided\
    \ to write a recursive solution that works.\n<code>"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
