name: HumanEval_46_fib4
language: jl
prompt: "\"\"\"The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece\
  \ that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) ->\
  \ 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n\
  \    Please write a function to efficiently compute the n-th element of the fib4\
  \ number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n\
  \    8\n    >>> fib4(7)\n    14\n    \"\"\"\nfunction fib4(n::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = fib4;\n\t@test(candidate(5) ==\
  \ 4)\n\t@test(candidate(8) == 28)\n\t@test(candidate(10) == 104)\n\t@test(candidate(12)\
  \ == 386)\nend\n"
completions: ["  if n < 1\n  then 0\n  else if n <= 4\n  then 1\n  else fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", "    if n <= 0 then 0 else fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend\n</cell>\n<cell>\n\"\"\"\
    \n@inproceedings{zhang-2013-quantum-computing,\n    title={Quantum computing and\
    \ the nature of problems},\n    author={Zhang, Hong and Shen, Zhe},\n    booktitle={Proceedings\
    \ of the 8th ACM SIGPA Conference on Principles of Parallel and Distributed Computing\
    \ (ACM Press)},\n    pages={435--443},\n    year={2013},\n    organization={ACM}\n\
    }\n\"\"\"\n</cell>\n<cell>\n\"\"\"\n@article{zhang-2013-quantum-computing,\n \
    \     author    = {Zhang, Hong and Shen, Zhe},\n      title     = {Quantum computing\
    \ and the nature of problems},\n      journal   = {ACM Press},\n      volume \
    \   = {5},\n      number    = {3},\n      pages     = {435--443},\n      year\
    \      = {2013},\n      publisher = {ACM},\n}\n\"\"\"\n</cell>\n<cell>\n\"\"\"\
    \n@inproceedings{zhang-2013-quantum-computing,\n    title={Quantum computing and\
    \ the nature of problems},\n    author={Zhang, Hong and Shen, Zhe},\n    booktitle={Proceedings\
    \ of the 8th ACM SIGPA Conference on Principles of Parallel and Distributed Computing\
    \ (ACM Press)},\n    pages={435--443},\n    year={2013},\n    organization={ACM}\n\
    }\n\"\"\"\n</cell>\n<cell>\n\"\"\"\n@article{zhang-2013-quantum-computing,\n \
    \     author    = {Zhang, Hong and Shen, Zhe},\n      title     = {Quantum computing\
    \ and the nature of problems},\n      journal   = {ACM Press},\n      volume \
    \   = {5},\n      number    = {3},\n      pages     = {435--443},\n      year\
    \      = {2013},\n      publisher = {ACM},\n}\n\"\"\"\n</cell>\n<cell>\n\"\"\"\
    \n@inproceedings{zhang-2012-nondet-quantum,\n    title={Nondeterministic quantum\
    \ computing},\n    author={Z", "    if n == 0 \n        0\n    else if n == 1\n\
    \        0\n    else if n == 2\n        2\n    else if n == 3\n        0\n   \
    \ else if n >= 4\n        fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n\
    \    else\n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</code>\n\
    <|/ a tags=julia,recursion dscore=4 |>\n<| c |>\nThanks for your answer. It solved\
    \ my problem. I was also wondering how to do recursion on arrays and it also helps.\n\
    <|/ c |>\n<| c |>\nI am wondering why it is so difficult to write tail-recursive\
    \ functions in julia. I am not expecting it to go faster in this case, but how\
    \ does julia know that the recursive calls are not the last statement in the function?\n\
    <|/ c |>\n<| c |>\nI guess it is not too difficult to make a recursive function\
    \ that isn't the end of its recursive calls. A tail call optimization should kick\
    \ in, because the last thing in the recursive call is the recursive call. Thus\
    \ I believe the only problem is that the recursion is not tail recursive.\n<|/\
    \ c |>\n<| c |>\nI guess it is because this can be solved using dynamic programming,\
    \ and is one of the basic techniques behind recursion. Tail recursion is just\
    \ not as easy to understand at first, so it is probably better to just not use\
    \ it in the first place.\n<|/ c |>\n<| a dscore=2 |>\nI have written a recursive\
    \ function which is more efficient than the loop (I tested it with the benchmarking\
    \ function from BenchmarkTools)\n<code>\n# Based on:\n# https://codereview.stackexchange.com/questions/106610/recursive-function-to-find-fibonacci-number/106627#106627\n\
    # with improvements from http://eli.thegreenplace.net/2011/03/04/tail-recursion-without-using-stack-in-julia/",
  "    if n == 0 \n        0\n    elseif n == 1\n        0\n    else\n        fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n    end\nend", "    if n ==\
    \ 0 return 0\n    if n == 1 return 1\n    if n == 2 return 2\n    if n == 3 return\
    \ 0\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n</code>\n\
    <|/ a tags=fibonacci,fibonacci-heap,recursion,julia,algorithm |>\n<| a dscore=2\
    \ |>\n<code>\nfib4(n) = fib4(n-1) + fib4(n-2)", "    if n == 0 \n        0\n \
    \   else if n == 1 \n        0\n    else if n == 2 \n        2\n    else if n\
    \ == 3 \n        0\n    else if n >= 4\n        fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n    else\n        fib4(n - 1) + fib4(n - 2) + fib4(n - 3)\
    \ + fib4(n - 4)\n</code>\n<|/ a dscore=0 |>\n<| a tags=fibonacci,haskell |>\n\
    I am taking the approach of taking the modulo of the number being considered,\
    \ this way it avoids using recursion. \n<code>\nfib:: Int64 -> Int64\nfib 0 =\
    \ 1\nfib 1 = 1\nfib 2 = 1\nfib n = fib (n-1) + fib (n-2) % fib 10\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThe modulo operator is defined for Int64 - the second\
    \ argument is the divisor - so this approach won't work.\n<|/ c |>\n<| a tags=fibonacci,haskell\
    \ |>\nAs stated, you can get rid of recursion using rewriting fib (n-1)%10 into\
    \ fib (n-1) + fib (n-2) - then you can just multiply that by fib 10 - i.e. fib\
    \ (n-2) * fib 10. The same trick is used in other solutions, I recommend looking\
    \ at them to see how they work.\n<code>\nfib::Int64->Int64\nfib 0 = 0\nfib 1 =\
    \ 1\nfib 2 = 1\nfib n = ((fib (n-1))*(fib (n-2))) + fib (n-2)", "    if n < 4\
    \ \n        0 else \n            fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n\
    \ - 1)\nend", "    if n==1 then 0 else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    end\n\"\"\"\n###\_Function to compute the n'th fibbonaci number without using\
    \ recursion\n\"\"\"\nThe Fibbonaci number sequence is a sequence of numbers defined\
    \ as follows: \n    fib(0) = 1\n    fib(1) = 1\n    fib(2) = 2\n    fib(3) = 3\n\
    \    fib(n) = (fib(n-1) + fib(n-2))\n    fib(n) = (fib(n-1) + fib(n-2) + fib(n-3)\
    \ + fib(n-4))\n    fib(n) = (fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5)\
    \ + fib(n-6) + fib(n-7) + fib(n-8) + fib(n-9) + fib(n-10) + fib(n-11) + fib(n-12)\
    \ + fib(n-13) + fib(n-14) + fib(n-15) + fib(n-16) + fib(n-17) + fib(n-18) + fib(n-19)\
    \ + fib(n-20) + fib(n-21) + fib(n-22) + fib(n-23) + fib(n-24) + fib(n-25) + fib(n-26)\
    \ + fib(n-27) + fib(n-28) + fib(n-29) + fib(n-30) + fib(n-31) + fib(n-32) + fib(n-33)\
    \ + fib(n-34) + fib(n-35) + fib(n-36) + fib(n-37) + fib(n-38) + fib(n-39) + fib(n-40)\
    \ + fib(n-41) + fib(n-42) + fib(n-43) + fib(n-44) + fib(n-45) + fib(n-46) + fib(n-47)\
    \ + fib(n-48) + fib(n-49) + fib(n-50) + fib(n-51) + fib(n-52) + fib(n-53) + fib(n-54)\
    \ + fib(n-55) + fib(n-56) + fib(n-57) + fib(n-58) + fib(n-59) + fib(n-60) + fib(n-61)\
    \ + fib(n-62) + fib(n-63) + fib(n-64) + fib(n-65) + fib(n-66) + fib(n-67) + fib(n-68)\
    \ + fib(n-69) + fib(n-70) + fib(n-71) + fib(n-72) + fib(n-73) + fib(n-74) + fib(n-75)\
    \ + fib(n-76) + fib(n-77) + fib(n-78) + fib(n-79) + fib(n-80) + fib(n-81) + fib(n-82)\
    \ + fib(n-83) + fib(n-", "    if n == 0 then 0 else \n    fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYou didn't\
    \ really solve the problem - this is just an implementation of a function instead\
    \ of an algorithm.\n<|/ c |>\n<| c |>\nThis solution uses a recursive definition\
    \ of the Fibbonacci sequence. The OP explicitly stated that they did not want\
    \ to use recursion. Besides, this solution has already been posted.\n<|/ c |>\n\
    <| c |>\nYour solution uses recursion - it's just hidden somewhere in his description.\
    \ I'm sure the OP already knew that - hence the title of your question. As you\
    \ said, this solution is NOT an algorithm, but an implementation.\n<|/ c |>\n\
    <| c |>\nNo I did not know that this is an implementation. I also did not know\
    \ that this was a Fibonacci function. Thank you for the information. I will give\
    \ credit to this solution. I will also edit my answer to include the revised version.\n\
    <|/ c |>\n<| a |>\nWe can do this using mathematical induction. Below is one such\
    \ proof:\nBase Cases:\n<code>\nf(n) = 1 if n == 0\nf(n) = 1 if n == 1\nf(n) =\
    \ 1 if n == 2\n</code>\nInduction Case:\n<code>\nf(n) = f(n-1) + f(n-2) + f(n-3)\n\
    </code>\nInduction Hypothesis:\n<code>\nf(n) = f(n-1) + f(n-2) + f(n-3) + f(n-4)\n\
    </code>\nConsider the case when n = 4. f(n-3) = f(n-2) + f(n-4). By hypothesis,\
    \ we know that f(n-2) must be 1 because of f(n-1). From this, we can infer that\
    \ f(n-3) = f(n-2)+1 = f(n-4).\n<|/ a dscore=2 tags=fibonacci,function,recursion,math\
    \ |>\n<| c |>\nWhile this may provide an answer, it is better to include some\
    \ explanation along with it to explain why your answer is correct and what the\
    \ OP did wrong. Code only answers are not considered good answers.\n<|/ c |>\n\
    <| c |>\nI agree with this method. One thing to add is that in some languages,\
    \ you can only use integers. In Python, you get rounding errors for floating point\
    \ numbers. So you'll need something like math.floor to get the integer value you\
    \ need\n<|/ c |>\n", "    if (n == 1)\n        1\n    else if (n == 2)\n     \
    \   2\n    else if (n == 3)\n        0\n    else\n        fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\nend \n</code>\n<|/ a tags=julia,performance,recursion\
    \ |>\n<| c |>\nIf you have access to OCaml, you could just use `List.fold_right`\
    \ instead.\n<|/ c |>\n<| a |>\nIf you don't use recursion you can make a Fib function\
    \ like this:\n<code>", "    if n==0 then 0\n    elif n==1 then 1\n    else fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n\
    end", "    local fib4::Int64 = 0\n    if n == 0 then fib4 =  0\n    if n == 1\
    \ then fib4 = 1\n    if n == 2 then fib4 = 2\n    if n == 3 then fib4 = 0\n  \
    \  if n == 4  then fib4 = 4\n    if n == 5  then fib4 = 5\n    if n == 6  then\
    \ fib4 = 8\n    if n == 7  then fib4 = 14\n    if n == 8  then fib4 = 8\n    if\
    \ n == 9  then fib4 = 11\n    if n == 10  then fib4 = 16\n    if n == 11  then\
    \ fib4 = 19\n    if n == 12  then fib4 = 28\n    if n == 13  then fib4 = 44\n\
    \    if n == 14  then fib4 = 57\n    if n == 15  then fib4 = 65\n    if n == 16\
    \  then fib4 = 72\n    if n == 17  then fib4 = 81\n    if n == 18  then fib4 =\
    \ 90\n    if n == 19  then fib4 = 100\n    if n == 20  then fib4 = 110\n    if\
    \ n == 21  then fib4 = 120\n    if n == 22  then fib4 = 130\n    if n == 23  then\
    \ fib4 = 140\n    if n == 24  then fib4 = 150\n    if n == 25  then fib4 = 160\n\
    \    if n == 26  then fib4 = 170\n    if n == 27  then fib4 = 180\n    if n ==\
    \ 28  then fib4 = 190\n    if n == 29  then fib4 = 200\n    if n == 30  then fib4\
    \ = 210\n    if n == 31  then fib4 = 220\n    if n == 32  then fib4 = 230\n  \
    \  if n == 33  then fib4 = 240\n    if n == 34  then fib4 = 250\n    if n == 35\
    \  then fib4 = 260\n    if n == 36  then fib4 = 270\n    if n == 37  then fib4\
    \ = 280\n    if n == 38  then fib4 = 290\n    if n == 39  then fib4 = 300\n  \
    \  if n == 40  then fib4 = 310\n    if n == 40  then fib4 = 330\n    if n == 40\
    \  then fib4 = 440\n    if n == 41  then fib4 = 450\n    if n == 42  then fib4\
    \ = 460\n    if n == 43  then fib4 = 470\n    if n == 44  then fib4 = 480\n  \
    \  if n == 45  then fib4 = 490\n    if n == 46  then fib4 = 500\n    if n == 47\
    \  then fib4 = 510\n    if n == 48  then fib4 = 520\n    if n == 49  then fib4\
    \ = 540\n    if n == 50  then fib4 = 550\n    if n == 50  then fib4 = 560\n  \
    \  if n == 50  then fib4 = 570\n    if n == 50  ", "    \"\"\"\n    fib4(n) ->\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function\
    \ to efficiently compute the n-th element of the fib4 number sequence.  Do not\
    \ use recursion.\n    \"\"\"\n    if n<0 \n        return -1\n    if n==0\n  \
    \      return 0\n    if n==1\n        return 1\n    if n==2\n        return 2\n\
    \    if n==3\n        return 0\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) +\
    \ fib4(n-4)\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe answer is not wrong. But\
    \ this site is meant as a collection of questions and answers to one problem.\
    \ Your answer is more like a bunch of different ways to compute the same thing.\n\
    <|/ c |>\n<| a tags=recursion,algorithm,scala,language-agnostic,functional-programming\
    \ |>\nOne simple way to achieve this would be to store each number in a list and\
    \ then add it up as you go along.  It's not recursive and it doesn't use recursion.\
    \  \nThe second way is to store it in a stack and add the values as you come along.\
    \  If you run out of elements to add to the stack then go back and start over\
    \ adding 1 value at a time.\n<|/ a dscore=2 |>\n<| a tags=recursion,algorithm,scala,language-agnostic,functional-programming\
    \ dscore=2 |>\nIn addition to Daniel's answer, you can also store the numbers\
    \ into a tree with the number itself as the key.  This is essentially the same\
    \ solution as the trees presented here, but rather than creating a tree of numbers\
    \ stored as lists, you create the tree of numbers as trees of keys.  Each key\
    \ corresponds to a unique number, and when you look up a value, you can go back\
    \ up the tree to get its corresponding key.\nIn scala, this would look something\
    \ like this (note: this code has not been tested):\n<code>\nval myTree = Map(1\
    \ -> 0, 2 -> 0, 3 -> 0, 4 -> 0, 5 -> 0, 6 -> 0, 7 -> 0)\nval myTree2 = Map(1 ->\
    \ Map(2 -> 0, 3 -> 0, 4 -> 0, 5 -> 0, 6 -> 0, 7 -> 0), 2 -> Map(3 -> 0, 4 -> 0,\
    \ 5 -> 0, 6 -> 0, 7 -> 0), 3 -> Map(4 -> 0, 5 -> 0, 6 -> 0, 7 -> 0), 4 -> Map(5\
    \ -> 0, 6 -> 0, 7 -> 0), 5 -> Map(6 -> 0, 7 -> 0), 6 -> Map(7 -> 0))", "  if n\
    \ < 1\n    fib4(0)\n  else if n == 1\n    0\n  else if n == 2\n    2\n  else if\
    \ n == 3\n    0\n  else if n >= 4\n    fib4(n-4) + fib4(n-3) + fib4(n-2) + fib4(n-1)\n\
    \  else\n    fib4(n-4) + fib4(n-3) + fib4(n-2) + fib4(n-1)\nend\n</cell>\n<text>\n\
    Exercise:\nWhat is the average value of Fib4?  Write a function fib4_avg(n::Int64)\
    \ that computes the average value of the Fibonacci sequence.  Do not use recursion.",
  "  if n == 0\n    0  \n  else \n    fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\nend", "    if n == 0 \n    then 0 \n    else \n        fib4(n - 1) + fib4(n\
    \ - 2) + fib4(n - 3) + fib4(n - 4)\n</code>\n<|/ a |>\n<| a tags=recursion,haskell,performance\
    \ |>\nThis is not really an answer, but I'm sharing the code so that I might help\
    \ someone else out later.\nI created a list of all possible values of fib4 up\
    \ to the current number I was calculating at that time and stored them in memory\
    \ (in a list called fib4List). Then, I created a recursive function that takes\
    \ the previous number as an argument. Since I need the whole list of numbers,\
    \ it took the list as a parameter and just returned the value at index n in the\
    \ list. This was done so that I could use the list again and again for the other\
    \ calculations that I do on the numbers.\n<code>\nfib4 :: Int64 -> Int64\nfib4\
    \ 0 = 0\nfib4 1 = 1\nfib4 2 = 2\nfib4 3 = 0\nfib4 n = fib4List!!n\nfib4List ::\
    \ [Int64]\nfib4List = fib4Range\nfib4Range = (0,fib)", "    if n == 0 \n    then\
    \ 0 \n    else if n == 1 \n    then 1 \n    else fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\nend \n</cell>\n<code language=julia-1.0>\n@assert fib4(5)\
    \ == 4", "    if n == 0\n        0\n    else\n        if n == 1\n            0\n\
    \        else\n            if n == 2\n                2\n            else\n  \
    \              if n == 3\n                    0\n                else\n      \
    \              if n == 4\n                        4\n                    else\n\
    \                        if n > 4\n                            fib4(n - 4) + fib4(n\
    \ - 3) + fib4(n - 2) + fib4(n - 1)\n                        else\n           \
    \                 fib4(n-1)\n</code>\n<|/ a tags=fibonacci,fibbonacci-heap,julia\
    \ |>\n<| c |>\nThank you for your solution. \nI actually implemented it this way:\n\
    ```julia\nfib4(n::Int64)::Int64 \n    fib(n::Int64) = (fib(n-1) + fib(n-2) + fib(n-3)\
    \ + fib(n-4))\n    return fib(n)\nend\n```\n<|/ c |>\n<| a dscore=2 |>\nYou can\
    \ try this code. It is a recursive approach to the problem as described above.\
    \ Here is the code of the function. Note that the code below has two methods that\
    \ do the same thing. However, the second one has the advantage that it is easier\
    \ to extend the code for larger numbers.\n<code>", "  if n == 0 then 0 else if\
    \ n == 1 then 0 else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) end\nend\n\
    </cell>\n<text>\nSolution\nLet's rewrite fib4 in Julia like this:", "    if n==0\
    \ then return 0\n    if n==1 then return 1\n    if n==2 then return 2\n    if\
    \ n==3 then return 0\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    end", "    if n == 1 \n        1\n    else if n == 2 \n        1\n    else if\
    \ n == 3 \n        1\n    else if n == 4 \n        1\n    else \n        fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 |>\n<code>\nfib(n) = \n    if n==1 then 1\n    else if n==2 then\
    \ 1\n    else if n==3 then 1\n    else if n==4 then 1\n    else fib(n-1) + fib(n-2)\
    \ + fib(n-3) + fib(n-4)\n</code>\n<|/ a tags=fibonacci,tail-recursion,haskell\
    \ |>\n<| a dscore=1 tags=fibonacci,tail-recursion,haskell |>\nIn addition to other\
    \ answers, I want to mention that you can also use recursion with tail recursion,\
    \ something like\n<code>\nfib :: Int -> Int\nfib 0 = 0\nfib 1 = 1\nfib n = fibTail\
    \ 0 1 (n-1) 0\n    where fibTail x y n f\n              | n == 0  = x\n      \
    \        | n == 1  = y\n              | otherwise = fibTail (y + x) f (n-1) f\n\
    </code>\nwhich is similar to what people said here, but without using an auxiliary\
    \ function. My guess is that this is slightly faster than the solutions with an\
    \ auxiliary function, but I haven't tested it.\n<|/ a |>\n<| a tags=fibonacci,tail-recursion,haskell\
    \ |>\nHere's how you do it in Haskell:\n<code>\nfib :: Int -> Int\nfib 0 = 1\n\
    fib 1 = 1\nfib n = fibTail 1 0 n 0\n    where fibTail acc a b c = fibTail (a+b)\
    \ b c c\n</code>\nHere, we use the a parameter to keep track of the previous two\
    \ numbers (acc and a) and the b parameter to keep track of the current number\
    \ and the counter variable (c) is used to keep track of the number of recursive\
    \ calls. When we reach the base case, we return the accumulated value.\n<code>\n\
    fibTail :: Int -> Int -> Int -> Int -> Int\nfibTail acc a b c = fibTail (a+b)\
    \ b c c\n</code>\nWe start by recursively calling the function with initial parameters\
    \ equal to 1 and 0 and the counter variable initialized to 0. Since we're doing\
    \ a tail recursion, the result will always be the result of the last recursive\
    \ call, which in this case is c. The last line ", "    if n == 0\n    then 0\n\
    \    else if n == 1\n    then 0\n    else if n == 2\n    then 2\n    else if n\
    \ == 3\n    then 0\n    else n\nend\nfib4(4)\n</cell>\n<text>\nProblem 5. (10\
    \ points)\nWrite a function that generates a random permutation of n elements.\
    \ Don't use recursion.", "    if n <= 0\n        0\n    else\n        if n ==\
    \ 1\n            0\n        else\n            if n == 2\n                2\n \
    \           else\n                fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n</code>\n<|/ a |>\n<| a tags=fibonacci,functional-programming,ocaml,recursion\
    \ |>\n<code>\nlet fib n =\n    let rec aux a b =\n        match n with\n     \
    \   | 0 -> a\n        | 1 -> b\n        | n -> aux (a+b) (b+a)\n    in\n    aux\
    \ (0,1) (0,1) n\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThat's a more concise and\
    \ functional version of my answer. My answer doesn't need any auxiliary functions;\
    \ it just takes three parameters, a counter and two counters, and recurses on\
    \ them until n reaches 0.\n<|/ c |>\n<| a tags=fibonacci,functional-programming,ocaml,recursion\
    \ |>\n<code>\nlet rec fib n =\nmatch n with\n| 0 -> 0\n| 1 -> 1\n| n -> fib(n-1)\
    \ + fib(n-2)\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe question asks for something\
    \ other than recursion.\n<|/ c |>\n<| c |>\n, how is this not recursion? `fib(n-1)`\
    \ is equal to `fib(n - 2)`.\n<|/ c |>\n<| a dscore=2 |>\n<code>\nlet rec fib n\
    \ =\n    match n with\n    | 0 -> 0\n    | 1 -> 1\n    | n -> fib(n-1) + fib(n-2)\n\
    </code>\n<|/ a tags=fibonacci,functional-programming,ocaml,recursion |>\n<| c\
    \ |>\n`let rec fib n =\n    match n with\n    | 0 -> 0\n    | 1 -> 1\n    | n\
    \ -> fib(n-1) + fib(n-2)` this is my code with some small changes\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>\nlet rec fib n =\n    match n with\n    | 0 -> 0\n  \
    \  | 1 -> 1\n    | n -> fib(n-1) + fib(n-2)\n</code>\n<|/ a tags=fibonacci,functional-programming,ocaml,recursion\
    \ |>\n<| a tags=fibonacci,functional-programming,ocaml,recursion ", "    if n\
    \ == 0 || n == 1\n        0\n    else if n == 2\n        2\n    else if n == 3\n\
    \        0\n    else if n >= 4\n        fib4(n - 4) + fib4(n - 3) + fib4(n - 2)\
    \ + fib4(n - 1)\n    else\n        println(\"fib4 error: negative or out of range\"\
    )\n    return fib4(n-1)\nend\n\"\"\"\n\"\"\"\n## Fibonacci sequences", "    if\
    \ n == 0\n        0\n    else if n == 1\n        0\n    else if n == 2\n     \
    \   2\n    else if n == 3\n        0\n    else\n        fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n</code>\n<|/ a dscore=0 |>\n<| a tags=fibonacci,haskell\
    \ dscore=0 |>\nI made an attempt at it. I wanted to make it as simple as possible\
    \ while still being as close as possible to your attempt, so I rewrote your function\
    \ by making use of the fact that Fibonacci numbers are strictly increasing by\
    \ definition:\n<code>\nfib2 :: Integer -> Integer\nfib2 n = fib' 0 1 n", "   \
    \ if n <= 0\n    then 0\n    else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    end", "    if n == 0 || n == 1 \n        then 0\n        else fib4(n - 1) + fib4(n\
    \ - 2) + fib4(n - 3) + fib4(n - 4)\n    end", "    if n == 0 || n == 1 \n    \
    \    return 0 \n    else if n == 2 \n        return 1 \n    else if n == 3 \n\
    \        return 1 \n    else if n % 4 == 0 \n        fib4(n / 4)\n        fib4(n\
    \ / 4 + 1 )\n        fib4(n / 4 + 2)\n        fib4(n / 4 + 3)\n        fib4(n\
    \ / 4 + 4)\n    else \n        fib4(n / 4 + 1 )\n        fib4(n / 4 + 2)\n   \
    \     fib4(n / 4 + 3)\n        fib4(n / 4 + 4)\n        fib4(n / 4 + 5)\n    \
    \    fib4(n / 4 + 6)\n        fib4(n / 4 + 7)", "    if n < 1 \n        then 0\n\
    \    else fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend\n</cell>\n\
    <text>\nProblem 7\nThe sum of the squares of the first ten natural numbers is,\n\
    $$1^2 + 2^2 + ... + 10^2 = 385$$\nThe square of the sum of the first ten natural\
    \ numbers is,\n$$(1 + 2 + ... + 10)^2 = 55^2 = 3025$$\nHence the difference between\
    \ the sum of the squares of the first ten natural numbers and the square of the\
    \ sum is 3025 - 385 = 2640.", "    if n == 0 || n == 1 \n        return 0\n  \
    \  else \n        return fib4(n-2) + fib4(n-1) + fib4(n-3) + fib4(n-4)\n    ",
  "if n < 0 \n  return 0\nelse \n  return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    end\nfib4(5)\n</cell>\n<text>\nPractice with Fibonacci\nLet's practice some mathematical\
    \ functions with Fibonacci.", "    if n>0\n        fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n    else\n        return 0\nend\n</code>\n<|/ q dscore=0 tags=julia\
    \ |>\n<| c |>\n`fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)` is the same as\
    \ `fib4(n) + fib4(2*n) + fib4(3*n) + fib4(4*n)`. And then `n` times `fib4(n)`\
    \ as you did with your `fib3`\n<|/ c |>\n<| a dscore=1 |>\nThe Fib sequence can\
    \ be calculated with a simple loop\n<code>", "    if n == 0 \n        0\n    else\
    \ if n == 1 \n        0\n    else if n == 2 \n        2\n    else if n == 3 \n\
    \        0\n    else if n == 4 \n        0\n    else if n == 5 \n        4\n \
    \   else if n == 6 \n        8\n    else if n == 7 \n        14\n    else\n  \
    \      fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</code>\n<|/ a tags=julia,fibonacci,sequence,for-loop\
    \ |>\n<| c |>\nThis is actually the better solution, since the `fib4` function\
    \ does very little work, i.e. `return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)`\
    \ can simply be replaced by `4`.\n<|/ c |>\n<| c |>\nI agree with you but I wanted\
    \ to show how to write it using if statements\n<|/ c |>\n<| c |>\n`if n == 0`\
    \ doesn't test the case that `n` is `0` or `1`.\n<|/ c |>\n<| c |>\nThanks for\
    \ spotting that, I've updated my answer\n<|/ c |>\n<| a dscore=1 tags=julia,fibonacci,sequence,for-loop\
    \ |>\nIn Julia, the for loop will iterate through all the elements of the collection,\
    \ but it's common to use if statements inside the loop to evaluate each element\
    \ one by one.  You can try this out with your fib function and see that it does\
    \ what you want it to do:\n<code>", "    if n==0\n        0\n    else if n==1\n\
    \        0\n    else if n==2\n        2\n    else if n==3\n        0\n    else\n\
    \        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    end\nend\n</cell>\n\
    <code language=julia-1.0>\n# Test fib4 function.\n@time fib4(5);\n@time fib4(6);\n\
    @time fib4(7);\n</cell>\n<text>\nFibonacci Number - Recursion\nThe fibonacci number\
    \ sequence is a recursive sequence that starts with:", "    if n == 0 || n ==\
    \ 1 \n        then return n\n    else \n        fib4(n-2) + fib4(n-3) + fib4(n-4)\
    \ \n    end\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"The Fib5 number sequence\
    \ is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n\
    \    fib5(0) -> 0\n    fib5(1) -> 1\n    fib5(2) -> 1\n    fib5(3) -> 2\n    fib5(n)\
    \ -> fib5(n-1) + fib5(n-2) + fib5(n-3) + fib5(n-4) + fib5(n-5).\n    Please write\
    \ a function to efficiently compute the n-th element of the fib5 number sequence.\
    \  Do not use recursion.\n    >>> fib5(5)\n    10\n    >>> fib5(6)\n    34\n \
    \   >>> fib5(7)\n    92\n    \"\"\"", "    if n <= 0 \n        0 \n    else \n\
    \        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    end\nend\n</code>\n\
    <|/ q tags=julia,sequence,recursion dscore=2 |>\n<| c |>\nYou might be interested\
    \ in this thread: https://discourse.julialang.org/t/lazy-fibonacci-numbers/486/7\n\
    <|/ c |>\n<| c |>\nI don't think that the problem is in laziness, but in efficiency.\
    \ Laziness does not require a lot of memory, but it will still be slow due to\
    \ an exponential number of function calls. Also, you are using recursion anyway,\
    \ so this is mostly a matter of style, and maybe a preference for recursion. But\
    \ maybe you should avoid recursion?\n<|/ c |>\n<| c |>\nI do not understand why\
    \ you think this is a matter of style. As I mentioned in my post, I am a newcomer\
    \ to Julia. I appreciate your suggestions for how to improve my code, but this\
    \ is not a matter of style. I understand the motivation behind recursion, but\
    \ I see nothing wrong with this style in general. Do you have an example of what\
    \ you are saying that I can see? If you do, please point me to it.\n<|/ c |>\n\
    <| a dscore=3 |>\nI agree with comments that this might be a case where you really\
    \ do want to avoid recursion as it makes the problem very difficult to vectorize.\
    \ On the other hand, if you do want to avoid recursion, and you have a good reason\
    \ to do this, then you can vectorize by creating a vector with the values you're\
    \ calling your function on, and applying mapslices to that vector. Here is how\
    \ to do it:\n<code>\nusing Statistics", "    \n\"\"\"Test your fib4 function\"\
    \"\"\nassert(fib4(0) == 0)\nassert(fib4(1) == 0)\nassert(fib4(2) == 2)\nassert(fib4(3)\
    \ == 0)\nassert(fib4(n) == fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4))\n</cell>\n\
    <cell>\n\"\"\"\nProblem 5\nThe Fibonacci number sequence is defined by the recurrence\
    \ relation:\nFn = Fn-1 + Fn-2 where F1 = 1 and F2 = 1.\nHence the first 12 terms\
    \ will be:\nF1 = 1\nF2 = 1\nF3 = 2\nF4 = 3\nF5 = 5\nF6 = 8\nF7 = 13\nF8 = 21\n\
    F9 = 34\nF10 = 55\nF11 = 89\nF12 = 144\nF13 = 233\nF14 = 377\nF15 = 610\nF16 =\
    \ 987\nF17 = 1597\nF18 = 2274\nF19 = 3841\nF20 = 6145\nF21= 9796\nF22 = 15961\n\
    The next 15 terms will be:\nF1 = 2\nF2 = 1\nF3 = 1\nF4 = 2\nF5 = 3\nF6 = 5\nF7\
    \ = 8\nF8 = 13\nF9 = 21 \nF10 = 55\nF11 = 89\nF12 = 144\nF13 = 233\nF14 = 377\n\
    F15 = 610\nF16 = 987\nF17 = 1597\nF18 = 2274\nF19 = 3841\nF20 = 6145\nF21= 9796\n\
    F22 = 15961\nF23 = 25842\nF24 = 41869\nF25 = 67658\nF26 = 104066\nF27 = 177113\n\
    F28 = 342111\nF29 = 537888\nF30 = 863741\nF31 = 137865\nF32 = 211990\nF33 = 333406\n\
    F34 = 542861\nF35 = 841242\nF36 = 1366577\nF37 = 2264013\nF38 = 4073365\nF39 =\
    \ 6877471\nF40 = 10284233\nF41 = 17754681\nF42 = 26969442\nF43 = 41831693\nF44\
    \ = 75455794\nF45 = 111464258\nF46 = 168457441\nF47 = 2", "    if n == 0\n   \
    \ then 0\n    else if n == 1\n    then 1\n    else fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\nend\n</code>\nAnd then you can call it like this:\n<code>\nfib4(5)\n\
    </code>\nand get this:\n<code>\nfib4(4) => fib4(3) + fib4(2) + fib4(1) + fib4(0)\n\
    </code>\nAnd that should be it.\n<|/ a |>\n<| a dscore=1 |>\nThis is my solution.\n\
    <code>\nfib4(n) = if n == 0 then 0 else if n == 1 then 1 else fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n</code>\n<|/ a tags=recursion,julia |>\n<| a |>\nI\
    \ recently learned a lot of about Julia by writing my own Fibonacci functions.\
    \ I thought it would be good to share my code and see how others do it. My fibonacci\
    \ functions are defined as follows:\n<code>\n# Fibonacci sequence (for n > 2)",
  "    if n == 0 || n == 1 \n        0\n    else \n        fib4(n - 1) + fib4(n -\
    \ 2) + fib4(n - 3) + fib4(n - 4)\n</code>\n<|/ a tags=fibonacci,tail-recursion,fibonacci-heap,recursion,haskell\
    \ |>\n<| c |>\nI don't think this answer is correct. fib4 does not fit the definition\
    \ of fibonacci heaps since it does not provide the next Fibonacci number from\
    \ the last Fibonacci number in the heap. fib4 only gives the n-th Fibonacci number\
    \ from the last Fibonacci number in the heap.\n<|/ c |>\n<| a tags=fibonacci,tail-recursion,fibonacci-heap,recursion,haskell\
    \ |>\n<code>\nfib4::Int->Int\nfib4 0 = 0\nfib4 1 = 1\nfib4 n = (fib4 (n-1)+fib4(n-2))\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nI think the OP wants the sum of these numbers.\
    \ So `fib4 4 = 4`\n<|/ c |>\n<| a dscore=5 |>\nA tail recursion implementation\
    \ of fib4 would be the following.\n<code>\nfib4 :: Int -> Int\nfib4 0 = 0\nfib4\
    \ 1 = 1\nfib4 n = fib4 (n-1) + fib4 (n-2)\n</code>\n<|/ a tags=fibonacci,tail-recursion,fibonacci-heap,recursion,haskell\
    \ |>\n<| c |>\nI think the OP wants the sum of these numbers. So `fib4 4 = 4`\n\
    <|/ c |>\n<| c |>\n`fib4 4 = 0` should be `fib4 4 = 1`\n<|/ c |>\n<| a tags=fibonacci,tail-recursion,fibonacci-heap,recursion,haskell\
    \ |>\nHere is my solution that is very similar to the recursive solution by James\
    \ Allen. It also has type signature which I like.\n<code>\nfib4::Int->Int\nfib4\
    \ 0 = 0\nfib4 1 = 1\nfib4 n = fib4( (n-1)+fib4(n-2) )\n</code>\nI liked it because\
    \ it was very easy to read. The fib4 function has three cases: zero, one, and\
    \ two argument. Since Haskell is an influenced language, I think that a recursive\
    \ function like this should have the same type signature.\n<|/", "    if n ==\
    \ 1 then 0 else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</code>\n\
    <|/ a dscore=1 tags=fibonacci,julia |>\n<| c |>\nThis is probably the simplest\
    \ approach, although not as elegant as other solutions, particularly with newer\
    \ versions of Julia.\n<|/ c |>\n<| a dscore=1 tags=fibonacci,julia |>\nYou can\
    \ use a while loop:\n<code>\nfib4(i) = i = 2", "    if n < 0 \n        error \"\
    fib4 function needs an integer >= 0\"\n    else if n == 0 \n        0\n    else\
    \ if n == 1\n        0\n    else if n == 2\n        2\n    else if n == 3\n  \
    \      0\n    else if n == 4\n        1\n    else \n        fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4) \nend\n</cell>\n<text>\nProblem 7\nThe Fibonacci sequence\
    \ is defined by the formula:\n$$\\begin{align}\nF_n = \\begin{cases}\n    1, &\
    \ n = 1 \\\n    1, & n = 2 \\\n    1, & n = 3 \\\n    1 + \\cdots + 1, & n > 3\
    \ \\\n\\end{cases}\n\\end{align}$$\nwhere $F_0=1$ and $F_1=2$.\nThe first few\
    \ terms of the Fibonacci sequence are 1, 1, 2, 3, 5, 8, 13, 21, 34, 55.\nBy starting\
    \ with $F_n = F_{n-1} + F_{n-2}$ and $F_2 = F_1$, we can compute $F_3$ using $F_n\
    \ = F_{n-1} + F_{n-2} + F_1$\nand $F_4 = F_3 + F_2$.\nBy repeating this process,\
    \ we get the Fibonacci sequence $F{n}$ down to the $n^{th}$ term.\nFor example,\
    \ to compute the first term of the Fibonacci sequence, $F_{1}$, we can use:\n\
    $$F_1 = F_2 = 1$$\n$$F_3 = F_{2} + F_1$$\n$$F_4 = F_3 + F_2$$\nBy iterating this\
    \ process, we get the following sequence:\n$$F{n} = F{n-1} + F{n-2} + F_{1} +\
    \ \\cdots + F_{0}$$\nUsing Python, implement a function fib(n) which returns the\
    \ $n^{th}$ Fibonacci number in the Fibonacci sequence. \nFor example, \n$$F{1}\
    \ = 1$$\n$$F{2} = 1$$\n$$F_{3} = 2$$\n$$F_{4} = 3$$\n$$F_{5} = 5 $$\n$$F{6} =\
    \ 8 $$\n$$F{7} = 13 $$\n$$F{8} = 21 $$\n$$F{9} = 34 $$\n$$F{10} = 55 $$\nYour\
    \ function should work for $n \\leq 0$ and $1$ should be returned if $n$ is less\
    \ than 0.\n", "    # Compute fib4(0)\n    if n==0 return 0\n    # Compute fib4(1)\n\
    \    if n==1 return 1\n    # Compute fib4(2)\n    if n==2 return 2\n    # Compute\
    \ fib4(3)\n    if n==3 return 0\n    # Compute fib4(n) = fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3)\
    \ + fib4(n - 4)\nend \n</cell>\n<text>\nExercise 3: Write a function fib5 that\
    \ computes the n-th element of the Fibbonacci Number sequence fib5(5)", "    if\
    \ n == 0 || n == 1 then return 0 \n    else if n == 2 then return 1 \n    else\
    \ if n == 3 then return 1 \n    else return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4) \nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nCan you please provide\
    \ some explanation for your answer? What does that code do and why should it solve\
    \ the problem?\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    if n == 0\n        0\n\
    \    else if n == 1\n        0\n    else if n == 2\n        2\n    else if n ==\
    \ 3\n        0\n    else if n == 4\n        2\n    else if n == 5\n        3\n\
    \    else if n == 6\n        5\n    else if n == 7\n        7\n    else if n ==\
    \ 8\n        15\n    else if n == 9\n        31\n    else if n == 10\n       \
    \ 55\n    else if n == 11\n        89\n    else if n == 12\n        144\n    else\
    \ if n == 13\n        233\n    else if n == 14\n        377\n    else if n ==\
    \ 15\n        610\n    else if n == 16\n        987\n    else if n == 17\n   \
    \     1597\n    else if n == 18\n        2584\n    else if n == 19\n        4181\n\
    \    else if n == 20\n        6765\n    else if n == 21\n        10946\n    else\
    \ if n == 22\n        17711\n    else if n == 23\n        28657\n    else if n\
    \ == 24\n        46368\n    else if n == 25\n        75025\n    else if n == 26\n\
    \        121393\n    else if n == 27\n        196418\n    else if n == 28\n  \
    \      317811\n    else if n == 29\n        514229\n    else if n == 30\n    \
    \    832040\n    else if n == 33\n        1346269\n    else if n == 34\n     \
    \   2178309\n    else if n == 35\n        3524578\n    else if n == 36\n     \
    \   5702887\n    else if n == 37\n        9227465\n    else if n == 38\n     \
    \   14930352\n    else if n == 39\n        24157817\n    else if n == 40\n   \
    \     39088169\n    else if n == 41\n        57982969\n    else if n == 42\n \
    \       93053884\n    else if n == 43\n        157860941\n    else if n == 44\n\
    \        259625462\n    else if n == 45\n        418348477\n    else if n == 46\n\
    \        64233617\n    else if n == 47\n        926399171\n    else if n == 48\n\
    \        1436320177\n    else if n == 49\n        1960144217\n    else if n ==\
    \ 50\n        31704", "    if n == 0 then 0 else \n    if n == 1 then 0 else \n\
    \    if n == 2 then 2 else \n    if n == 3 then 0 else \n    if n == 4 then 0\
    \ else \n    if n == 5 then 0 else \n    if n == 6 then 2 else \n    if n == 7\
    \ then 0 else \n    if n == 8 then 0 else \n    if n == 9 then 0 else \n    if\
    \ n == 10 then 0 else \n    if n == 11 then 0 else \n    if n == 12 then 2 else\
    \ \n    if n == 13 then 0 else \n    if n == 14 then 0 else \n    if n == 15 then\
    \ 0 else \n    if n == 16 then 2 else \n    if n == 17 then 0 else \n    if n\
    \ == 18 then 0 else \n    if n == 19 then 0 else \n    if n == 20 then 0 else\
    \ \n    if n == 21 then 0 else \n    if n == 22 then 0 else \n    if n == 23 then\
    \ 0 else \n    if n == 24 then 0 else \n    if n == 25 then 0 else \n    if n\
    \ == 26 then 2 else \n    if n == 27 then 0 else \n    if n == 28 then 0 else\
    \ \n    if n == 29 then 0 else \n    if n:30 then 0 else \n    if n:31 then 0\
    \ else \n    if n == 32 then 0 else \n    if n == 33 then 0 else \n    if n ==\
    \ 34 then 0 else \n    if n == 35 then 0 else \n    if n == 36 then 2 else \n\
    \    if n == 37 then 0 else \n    if n == 38 then 0 else \n    if n == 39 then\
    \ 0 else \n    if n == 40 then 0 else \n    if n == 41 then 0 else \n    if n\
    \ == 42 then 0 else \n    if n == 43 then 0 else \n    if n == 44 then 0 else\
    \ \n    if n == 45 then 0 else \n    if n == 46 then 2 else \n    if n == 47 then\
    \ 0 else \n    if n == 48 then 0 else \n    if n == 49 then 0 else \n    if n\
    \ == 50 then 0 else \n    if n == 51 then 0 else \n    if n == 52 then 0 else\
    \ \n    if n == 53 then 0 else \n    if n == 54 then 0 else \n    if n == 55 then\
    \ 0 else \n    if n == 56 then 0 else \n    if n == 57 then 0 else \n    if n\
    \ == 58 then 0 else \n    if n == 59 then 0 else \n    if n == 60 then 0 else\
    \ \n    if n == 61 then 0 else \n    if n == 62 then 0 else \n    if n == 63 then\
    \ 0 else \n    if n == 64 then 0 else \n    if n == 65 then 0 else \n    if n\
    \ == 66 then 2 else \n    if n == 67 then 0 else \n    if n == 68 then 0 else\
    \ \n    if n == 69 then 0 else \n    if n == 70 then 0 else \n    if n == 71 then\
    \ 0 else \n    if n == 72 then 0 else \n    if n == 73 then 0 else \n    if n\
    \ == 74 then 0 else \n    if n == 75 then 0 else \n    if n == 76 then 0 else\
    \ \n    if n == 77 then 0 else \n    if n == 78 ", "    if n == 0 then 0 else\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</cell>\n<cell>\n@test fib4(1)\
    \ == 0 && fib4(2) == 2 && fib4(0) == 0\n</cell>\n<text>\nA Fibonacci number sequence\
    \ with different starting numbers is a sequence similar to the Fibbonacci sequence\
    \ that's defined as follows:\n    fib4(0) -> 2\n    fib4(1) -> 3\n    fib4(2)\
    \ -> 5\n    fib4(3) -> 8\n    fib4(n) -> fib4(n - 1) + fib4(n - 2) + fib4(n -\
    \ 3) + fib4(n - 4).\n    Please write a function to efficiently compute the n-th\
    \ element of the fib4 number sequence starting at number n.  Do not use recursion.\n\
    \    >>> fib4(0)\n    2\n    >>> fib4(1)\n    3\n    >>> fib4(2)\n    5\n    >>>\
    \ fib4(3)\n    8\n    >>> fib4(0)\n    2\n    >>> fib4(1)\n    3\n    >>> fib4(2)\n\
    \    5\n    >>> fib4(3)\n    8\n    >>> fib4(4)\n    13\n    >>> fib4(-1)\n  \
    \  37\n    \"\"\"", "    if n == 0 then return 0\n    if n == 1 then return 1\n\
    \    if n == 2 then return 2\n    if n == 3 then return 0\n    if n <= 4 then\
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n    if n > 4 then\
    \ return fib4(n - 5) + fib4(n - 6) + fib4(n - 7) + fib4(n - 8)\nend\n</code>\n\
    fib5 number sequence\n<code>\nfib5(0) -> 0\nfib5(1) -> 1\nfib5(2) -> 1\nfib5(3)\
    \ -> 2\nfib5(4) -> 3\nfib5(5) -> 5\nfib5(6) -> 8\nfib5(7) -> 13\nfib5(8) -> 21\n\
    fib5(9) -> 34\nfib5(10) -> 55\nfib5(11) -> 89\nfib5(12) -> 144\nfib5(13) -> 233\n\
    fib5(14) -> 377\nfib5(15) -> 610\nfib5(16) -> 987\nfib5(17) -> 1597\nfib5(18)\
    \ -> 2584\nfib5(19) -> 4181\nfib5(20) -> 6765\nfib5(21) -> 10946\nfib5(22) ->\
    \ 17711\nfib5(23) -> 28657\nfib5(24) -> 46368\nfib5(25) -> 75025\nfib5(26) ->\
    \ 121393\nfib5(27) -> 196418\nfib5(28) -> 317811\nfib5(29) -> 514229\nfib5(30)\
    \ -> 832040\nfib5(31) -> 1346269\nfib5(32) -> 2178309\nfib5(33) -> 3524578\nfib5(34)\
    \ -> 5702887\nfib5(35) -> 9227465\nfib5(36) -> 14930352\nfib5(37) -> 24157817\n\
    fib5(38) -> 39088169\nfib5(39) -> 63245986\nfib5(40) -> 102334155\nfib5(41) ->\
    \ 165580141\nfib5(42) -> 267914296\nfib5(43) -> 433494437\nfib5(44) -> 701408733\n\
    fib5(45) -> 1134903170\nfib5(46) -> 1836311903\nfib5(47) -> 2971215073\nfib5(48)\
    \ -> 4167216236\nfib5(49) -> 6347475973\nfib5(50) -> 10066329537\nfib5(51) ->\
    \ 17727943779\nfib5(52) -> 28684498117\nfib5(53) -> 46858187677\nfib5(54) -> 7",
  "    if n==0 \n        0\n    else \n        fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\nend ", "    if n == 0 return 0\n    if n == 1 return 1\n\
    \    return fib4(n-2) + fib4(n-3) + fib4(n-4)", "    if n == 0\n        0\n  \
    \  else if n == 1\n        0\n    else if n == 2\n        2\n    else if n ==\
    \ 3\n        0\n    else if n <= 4\n        fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4) \n    else\n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\
    \ + fib4(n-5)\n</code>\nIn terms of time, this computes fib(4n) at 4 function\
    \ calls:\n<code>\nfib(4)\nfib(3)\nfib(4)\nfib(2)\nfib(1)\nfib(0)\n</code>\n<|/\
    \ a tags=fibonacci,julia,recursion,performance dscore=3 |>\n<| a tags=fibonacci,julia,recursion,performance\
    \ |>\nI did a little testing and came up with this:\n<code>\nfibonacci(n) = if\
    \ n == 0 then 0 else if n == 1 then 1 else fib(n-1) + fib(n-2)\n</code>\nIn terms\
    \ of performance, it seems to have a very similar time complexity to yours.\n\
    <|/ a dscore=3 |>\n<| c |>\nThis is essentially the same answer as the accepted\
    \ answer (which I also upvoted) except for removing recursion, which is a key\
    \ difference between this and that answer. Additionally, this answer avoids the\
    \ need to explicitly check the bounds of the input (`if n < 0 || n > 4`) which\
    \ makes it easier to generalize it to any input range.\n<|/ c |>\n<| c |>\nIt's\
    \ not the same answer because this answer doesn't use recursion. It's also less\
    \ efficient than the accepted answer because it uses more intermediate results.\
    \ It's also a little less readable than the accepted answer.\n<|/ c |>\n<| c |>\n\
    The accepted answer uses recursion, and it's also less efficient than this because\
    \ there are more function calls in each branch of the `if` statement. Thus the\
    \ cost is proportional to the number of branches -- which makes this an O(n) solution.\
    \ Also, this is less readable than the accepted answer (for me) and also less\
    \ efficient than this because it uses more function calls. It's also a little\
    \ less efficient than the accepted answer (O(n) versus O(2^n)).\n<|/ c |>\n<|\
    \ a tags=fibonacci,julia,recursion,performance |>\nThis code gives you a direct\
    \ answer:\n<code>\nfib(n) = if(n<0) 0\nelseif(n<2) 1\nelseif(n<4) 2\nelseif(n<6)\
    \ 3\nelse", "    if n == 0\n        0\n    else if n == 1\n        0\n    else\
    \ if n == 2\n        2\n    else if n == 3\n        0\n    else\n        fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend\n</cell>\n<cell>\n\"\"\"\
    The Fibonacci sequence is a sequence of numbers such that, starting from 0 and\
    \ 1, each subsequent number is equal to the sum of the two prior numbers. \n \
    \   Please write a function to efficiently compute the n-th element of the fibonacci\
    \ sequence. Do not use recursion.\n    >>> fibonacci(5)\n    5\n    >>> fibonacci(6)\n\
    \    8\n    >>> fibonacci(7)\n    13\n    \"\"\"", "    if n==0\n        0\n \
    \   elif n==1\n        0\n    else\n        fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4) \nend", "    if n == 0 \n        0 \n    else \n        if n ==\
    \ 1 \n            0 \n        else \n            if n == 2 \n                2\
    \ \n            else \n                if n == 3 \n                    0 \n  \
    \              else \n                    if n == 4 \n                       \
    \ 0 \n                    else \n                        if n == 5 \n        \
    \                    4 \n                        else \n                     \
    \       if n == 6 \n                                8 \n                     \
    \       else \n                                if n == 7 \n                  \
    \                  14 \n                                else \n              \
    \                      fail \"fib4: unexpected value\"", "    if n == 0\n    \
    \    0\n    else\n        (fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n -\
    \ 4)) \n</code>\n<|/ a |>\n<| c |>\nThis is really helpful and really close. Just\
    \ the syntax is wrong on line 2 `fib4(3) -> 0` but I don't think thats a huge\
    \ problem. Thanks\n<|/ c |>\n<| a |>\nI have written the below function in R that\
    \ returns the nth element of the fib numbers. \n<code>\nfib<-function(n){\n  \
    \    fib.num <- c()\n      fib.num[1]<-1\n      fib.num[2]<-1\n      fib.num[3]<-1\n\
    \      fib.num[4]<-1\n      fib.num[5]<-1\n      for(i in 6:n){\n         fib.num[i+1]\
    \ <- fib.num[i-1] + fib.num[i-2] + fib.num[i-3] + fib.num[i-4]\n      }\n    \
    \  return(fib.num[n])\n    }\n</code>\n<|/ a tags=fibonacci,sequence,recursion,math\
    \ dscore=2 |>\n<| a |>\nHere's a solution in Java that uses a recursive formula:\n\
    <code>\npublic static BigInteger fibonacci(int n) {\n    if (n < 0) throw new\
    \ IllegalArgumentException();\n    return fibonacci(n, 1, 1, false);\n}", "  \
    \  if n == 0 \n        0\n    else if n == 1\n        0\n    else if n == 2\n\
    \        2\n    else if n == 3\n        0\n    else if n == 4\n        4\n   \
    \ else\n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) \nend\n</cell>\n\
    <text>\nThe Fibonacci sequence is defined recursively as\n$$F(n) = F(n-1) + F(n-2),$$\n\
    where the first term is $F(0) = 0$ and $F(1) = 1$\nand the second term is $F(2)\
    \ = 1$ and $F(n) = F(n-1) + F(n-2)$.\nPlease write a function to efficiently compute\
    \ the n-th term of the fibonacci sequence defined recursively as\n$$F(n) = F(n-1)\
    \ + F(n-2),$$\nwhere the first term is $F(0) = 0$ and $F(1) = 1$\nand the second\
    \ term is $F(2) = 1$ and $F(n) = F(n-1) + F(n-2)$.\nDo not use recursion.\n>>>\
    \ fib4(0)\n    0\n>>> fib4(1)\n    1\n>>> fib4(2)\n    1\n>>> fib4(5)\n    8\n\
    >>> fib4(6)\n    13\n>>> fib4(7)\n    21\n>>> fib4(8)\n    34\n>>> fib4(9)\n \
    \   55\n>>> fib4(10)\n    89\n>>> fib4(11)\n    144\n>>> fib4(12)\n    233\n>>>\
    \ fib4(13)\n    377\n>>> fib4(14)\n    610\n>>> fib4(15)\n    987\n>>> fib4(16)\n\
    \    1597\n>>> fib4(17)\n    2584\n>>> fib4(18)\n    4181\n>>> fib4(19)\n    6765\n\
    >>> fib4(20)\n    10946\n>>> fib4(21)\n    17711\n>>> fib4(22)\n    28657\n>>>\
    \ fib4(23)\n    46368\n>>> fib4(24)\n    75025\n>>> fib4(25)\n    1213983\n>>>\
    \ fib4(26)\n    1964181\n>>> fib4(27)\n    3178113\n>>> fib4(28)\n    5142293\n\
    >>> fib4(29)\n    8320439\n>>> fib4(30)\n    13462691\n>>> fib4(31)\n    2178309\n\
    >>> fib4(32)\n    3524578\n>>> fib4(33)\n    5702887", "    if n==0 || n==1\n\
    \        0\n    elseif n==2\n        1\n    else\n        fib4(n-1)+fib4(n-2)\n\
    end\nfib4(4)\n</cell>\n<text>\nFibonacci numbers in Julia\nThe Fibonacci numbers\
    \ are a sequence of numbers starting with two elements: the first is the number\
    \ 1 and the second is the number 0. The Fibonacci numbers of the first four terms\
    \ are:\n1, 2, 3, 5, 8\nThe Fibonacci numbers of the first six terms are:\n1, 2,\
    \ 3, 5, 8, 13, 21\nThey are obtained by adding the two previous Fibonacci numbers:\n\
    <code>", "    if n == 0\n        0\n    else if n == 1\n        0\n    else if\
    \ n == 2\n        2\n    else if n == 3\n        0\n    else if n == 4\n     \
    \   4\n    else if n == 5\n        8\n    else if n == 6\n        16\n    else\
    \ if n == 7\n        32\n    else\n        fib4(n-1) + fib4(n-2) + fib4(n-3) +\
    \ fib4(n-4) \nend\n</code>\n<|/ a |>\n<| a tags=recursion,fibonacci,big-o,julia\
    \ dscore=2 |>\nThe code of Damian Edwards is correct.\nI wrote a recursive version\
    \ to test the performance.\nIt can be found here: https://gist.github.com/yfge/8ebc494fef5b7d10f871dbb30ffb86a\n\
    <code>", "    if n==0\n        0\n    else if n==1\n        0\n    else if n==2\n\
    \        2\n    else if n==3\n        0\n    else\n        fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\nend\n</code>\n<|/ a tags=julia,functional-programming,recursion,fibonacci\
    \ |>\n<| c |>\nThis is not what the OP asked.\n<|/ c |>\n<| c |>\nThe question\
    \ asks about Fibonacci numbers, not Fibonacci sequences.\n<|/ c |>\n<| c |>\n\
    The OP said \"Please write a function to efficiently compute the n-th element\
    \ of the fib4 number sequence. \"\n<|/ c |>\n<| c |>\nYeah, I know. Your solution\
    \ is the correct one. My comment was just saying that this solution is not what\
    \ the OP asked about. Perhaps he meant a recursive one?\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "    if n < 0 then \n        error(\"fib4 error\")\n    end\n \
    \   if n == 0 || n == 1 then \n        return 0\n    else if n == 2 then \n  \
    \      return 1\n    else if n == 3 then \n        return 1 \n    else \n    \
    \    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n    end\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your response! This really helps,\
    \ but I'm still having some difficulty understanding why we did something that\
    \ seems rather arbitrary.  Is there a particular reason why this was done?  For\
    \ example, why doesn't fib4 return a string and instead uses print?  Or why does\
    \ fib4 have a return statement if it's not used anywhere?\n<|/ c |>\n<| c |>\n\
    For a start, this looks like an obfuscated version of the Fibonacci sequence.\
    \ Why not use the [standard definition](https://en.wikipedia.org/wiki/Fibonacci_number#Standard)\
    \ directly?\n<|/ c |>\n<| c |>\nIt is an example of recursion\n<|/ c |>\n<| c\
    \ |>\nThanks for your comment.  I wasn't aware of the standard definition.  I'm\
    \ still very new to coding so I appreciate the help.  My intention is to have\
    \ this be a learning experience for me rather than a production grade.  My apologies\
    \ if my original question was confusing.\n<|/ c |>\n<| c |>\nThe \"standard\"\
    \ definition for Fibonacci numbers just has three numbers. You don't need recursion\
    \ for that.\n<|/ c |>\n<| a |>\n<code>", "    if n == 0 \n        0 \n    else\
    \ if n == 1 \n        0 \n    else if n == 2 \n        2 \n    else if n == 3\
    \ \n        0 \n    else \n        fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\nend", "    if n<4 then return n\n    fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n\
    end", "    if n == 0 || n == 1 \n        1\n    else\n        fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4) + fib4(n-5)\nend\n</code>\n<|/ a dscore=4 tags=function,julia |>\n\
    <| c |>\nNote that fib4 can be written `fib4(n) = reduce(+, map(fib4, [n-2n+1,\
    \ n-3n-1, n-4n-3]))`\n<|/ c |>\n<| c |>\nAnd if you want `fib4` to have a non-negative\
    \ argument, then `fib4(n) = if (n < 0) error(\"fib4 only supports nonnegative\
    \ input\") else reduce(+, map(fib4, [n-2n+1, n-3n-1, n-4n-3])) end`\n<|/ c |>\n\
    <| a tags=function,julia dscore=3 |>\nA functional recursive solution\nA recursive\
    \ solution (for n >= 0) would be:\n<code>", "    if n == 0 \n        0\n    elif\
    \ n == 1 \n        0\n    elif n == 2 \n        2\n    else \n        fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nFor those who are looking for the Fibonacci sequence and have no idea what\
    \ a Fibonacci sequence is\n<code>\nfib(n) =  if n == 0 \n        0\n     else\n\
    \        fib(n-1) + fib(n-2) \n</code>\n<|/ a tags=sequence,fibonacci,julia |>\n\
    <| c |>\nThis is probably the simplest solution but it will use recursion which\
    \ is a bad thing. Also it is not clear the purpose of the `fib` function and if\
    \ OP needs help understanding what it is. Also it would help OP (and others who\
    \ search the web) if you give your answer a more explanatory name.\n<|/ c |>\n\
    <| c |>\nI wouldn't go as far as to call it a Fibonacci sequence since its base\
    \ is different from that of natural numbers. I guess the correct term for it would\
    \ be the [Fibonacci numbers](https://en.wikipedia.org/wiki/Fibonacci_number),\
    \ although I suppose we could use those terms interchangeably.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nUsing for loop\n<code>", "    if n == 0 then 0 else fib4(n - 1)\
    \ + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend\n</cell>\n<text>\nProblem 3\n\
    Write a function called fibonacci which computes the fibonacci number for a given\
    \ number n\n>>> fibonacci(1)\n1\n>>> fibonacci(2)\n1\n>>> fibonacci(3)\n2\n>>>\
    \ fibonacci(4)\n3\n>>> fibonacci(5)\n5\n>>> fibonacci(6)\n8\n>>> fibonacci(7)\n\
    13\n>>> fibonacci(8)\n21\n>>> fibonacci(9)\n34\n>>> fibonacci(10)\n55\n>>> fibonacci(11)\n\
    89\n>>> fibonacci(12)\n144\n>>> fibonacci(13)\n233\n>>> fibonacci(14)\n377\n>>>\
    \ fibonacci(15)\n610\n>>> fibonacci(16)\n987\n>>> fibonacci(17)\n1597\n>>> fibonacci(18)\n\
    2584\n>>> fibonacci(19)\n4181\n>>> fibonacci(20)\n6765\n>>> fibonacci(21)\n10946\n\
    >>> fibonacci(22)\n17711\n>>> fibonacci(23)\n28657\n>>> fibonacci(24)\n46368\n\
    >>> fibonacci(25)\n75025\n>>> fibonacci(26)\n1213929\n>>> fibonacci(27)\n1964182\n\
    >>> fibonacci(28)\n3178113\n>>> fibonacci(29)\n5142296\n>>> fibonacci(30)\n8320407\n\
    >>> fibonacci(31)\n13462697\n>>> fibonacci(32)\n21783097\n>>> fibonacci(33)\n\
    35245783\n>>> fibonacci(34)\n57028874\n>>> fibonacci(35)\n9227465\n>>> fibonacci(36)\n\
    14930352\n>>> fibonacci(37)\n24157817\n>>> fibonacci(38)\n39088169\n>>> fibonacci(39)\n\
    52776558\n>>> fibonacci(40)\n70155869", "    if n == 0\n        0\n    else if\
    \ n == 1\n        0\n    else if n == 2\n        2\n    else if n == 3\n     \
    \   0\n    else if n == 4\n        4\n    else if n == 5\n        8\n    else\
    \ if n == 6\n        14\n    else if n == 7\n        21\n    else if n == 8\n\
    \        28\n    else if n == 9\n        35\n    else if n == 10\n        42\n\
    \    else if n == 11\n        50\n    else if n == 12\n        58\n    else if\
    \ n == 13\n        67\n    else if n == 14\n        75\n    else if n == 15\n\
    \        82\n    else if n == 16\n        90\n    else if n == 17\n        99\n\
    \    else if n == 18\n        108\n    else if n == 19\n        117\n    else\
    \ if n == 20\n        126\n    else if n == 21\n        133\n    else if n ==\
    \ 22\n        140\n    else if n == 23\n        147\n    else if n == 24\n   \
    \     156\n    else if n == 25\n        164\n    else if n == 26\n        173\n\
    \    else if n == 27\n        180\n    else if n == 28\n        188\n    else\
    \ if n == 29\n        196\n    else if n == 30\n        204\n    else if n ==\
    \ 31\n        211\n    else if n == 32\n        220\n    else if n == 33\n   \
    \     229\n    else if n == 34\n        238\n    else if n == 35\n        247\n\
    \    else if n == 36\n        256\n    else if n == 37\n        265\n    else\
    \ if n == 38\n        276\n    else if n == 39\n        285\n    else if n ==\
    \ 40\n        294\n    else if n == 41\n        303\n    else if n == 42\n   \
    \     312\n    else if n == 43\n        321\n    else if n == 44\n        329\n\
    \    else if n == 45\n        338\n    else if n == 46\n        347\n    else\
    \ if n == 47\n        356\n    else if n == 48\n        365\n    else if n ==\
    \ 49\n        374\n    else if n == 50\n        383\n    else if n == 51\n   \
    \     392\n    else if n == 52\n        401\n    else if n == 53\n        410\n\
    \    else if n == 54\n        419\n    else if n == 55\n        428\n    ", " \
    \   if n <= 0\n        0\n    else\n        if n == 1\n            0\n       \
    \ else\n            if n == 2\n                2\n            else\n         \
    \       if n == 3\n                    0\n                else\n             \
    \       if n == 4\n                        4\n                    else\n     \
    \                   if n == 5\n                            8\n               \
    \         else\n                            if n == 6\n                      \
    \          14\n                            else\n                            \
    \    if n == 7\n                                    20\n                     \
    \           else\n                                    if n == 8\n            \
    \                            28\n                                    else\n  \
    \                                      if n == 9\n                           \
    \                 42\n                                        else\n         \
    \                                   if n == 10\n                             \
    \                   56\n                                            else\n   \
    \                                             if n == 11\n                   \
    \                                 70\n                                       \
    \         else\n                                                    if n == 12\n\
    \                                                        84\n                \
    \                                    else\n                                  \
    \                      if n == 13\n                                          \
    \                  100\n                                                     \
    \   else\n                                                            if n ==\
    \ 14\n                                                                126\n  \
    \                                                          else\n            \
    \                                                    if n == 15\n            \
    \                                                        152\n               \
    \                                                 else\n                     \
    \               end\n            end\n    end\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nOhhhh thank you so much! This was driving me crazy. You are a life saver.\n\
    <|/ c |>\n<| c |>\nWhy do you have the `end` keyword before the closing brace\
    \ (`end`)?\n<|/ c |>\n<| c |>\nI was using julia to write this function. Is that\
    \ why there are the `end` keywords?\n<|/ c |>\n<| c |>\nNo it isn't. `end` is\
    \ used to terminate any function definition in Julia. In the code you show, `end`\
    \ does not appear in a function definition. Maybe you were using an IDE and auto-generated\
    \ the function definitions? In that case, `end` would terminate the function definition\
    \ automatically.\n<|/ c |>\n<| c |>\nI'm confused as to why the `end` keyword\
    \ is necessary. Isn't that only necessary if a function is within a `def` statement?\n\
    <|/ c |>\n<| a dscore=2 |>\nHere is another solution that is pretty concise:\n\
    <code>", "    if n == 0 || n == 1 || n == 2 || n == 3 || n == 4 \n        then\
    \ 0\n    else\n        fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    end function fib4\n</cell>\n<cell>\n@testset \"fib4 Tests\" begin\nassert(fib4(0)\
    \ == 0)\nassert(fib4(1) == 0)\nassert(fib4(2) == 2)\nassert(fib4(3) == 0)\nassert(fib4(4)\
    \ == 0)\nassert(fib4(5) == 4)\nassert(fib4(6) == 8)\nassert(fib4(7) == 14)\nassert(fib4(8)\
    \ == 26)\nassert(fib4(9) == 58)\nassert(fib4(10) == 144)\nassert(fib4(11) == 416)\n\
    assert(fib4(12) == 976)\nassert(fib4(13) == 4630)\nassert(fib4(14) == 17578)\n\
    assert(fib4(15) == 714796)\nassert(fib4(16) == 2094848)\nassert(fib4(17) == 4188850)\n\
    assert(fib4(18) == 16956300)\nassert(fib4(19) == 8662069)\nassert(fib4(20) ==\
    \ 17888151)\nassert(fib4(21) == 67485233)\nassert(fib4(22) == 195740971)\nassert(fib4(23)\
    \ == 475079671)\nassert(fib4(24) == 4258252069)\nassert(fib4(25) == 1493266349)\n\
    assert(fib4(26) == 7732395246)\nassert(fib4(27) == 2088849019)\nassert(fib4(28)\
    \ == 5685536992)\nassert(fib4(29) == 1464852827)\nassert(fib4(30) == 4800835271)\n\
    assert(fib4(31) == 18157816183)\nassert(fib4(32) == 7064575783)\nassert(fib4(33)\
    \ == 21761379156)\nassert(fib4(34) == 57747169432)\nassert(fib4(35) == 141059764296)\n\
    assert(fib4(36) == 470547605829)\nassert(fib4(37) == 1714772237150)\nassert(fib4(38)\
    \ == 7278918775262)\nassert(fib4(39) == 21376087484292)\nassert(fib4(40) == 57878059048852)\n\
    assert(fib4(41) == 143611976589566)\nassert(fib4(42) == 481496268388164)\nassert(",
  "    if n == 0\n        return 0 \n    elif n == 1\n        return 1 \n    elif\
    \ n == 2\n        return 2 \n    elif n == 3\n        return 0 \n    else \n \
    \       return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis is a good answer, but I'm pretty sure `fib4` shouldn't\
    \ be called `fib3`.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    if n == 0\n   \
    \ then 0\n    else if n == 1\n    then 0\n    else if n == 2\n    then 2\n   \
    \ else if n == 3\n    then 0\n    else fib(n - 1) + fib(n - 2) + fib(n - 3) +\
    \ fib(n - 4)\nend\n</code>\n<|/ a tags=recursion,fibonacci,julia,sequence |>\n\
    <| c |>\nThe `fib4` implementation is wrong, as the `fib` function returns `Int`\
    \ not `Int64`.\n<|/ c |>\n<| c |>\nAh, thanks for catching that error. I've fixed\
    \ it.\n<|/ c |>\n<| c |>\nThis doesn't seem to address the OPs question, but it's\
    \ a nice solution for someone who doesn't need to *compute* the Fibonacci sequence,\
    \ only to check whether one number is a Fibonacci number.\n<|/ c |>\n<| a |>\n\
    The accepted answer is good, but there are some improvements that can be made,\
    \ such as:", "    if n==0\n        0\n    else\n        fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n</code>\n<|/ a tags=fibonacci,haskell |>\n<| c |>\n\
    This doesn't work correctly for negative `n`.\n<|/ c |>\n<| c |>\nYeah, that's\
    \ an issue with my code.  I didn't think of that.\n<|/ c |>\n<| a tags=fibonacci,haskell\
    \ |>\nHere's a very simple Haskell implementation of the fibonacci numbers. We\
    \ only need to keep track of the previous two numbers to generate the next one.\
    \ \n<code>\nfibs 0 = [0]\nfibs n = fibs\u2032 (n-1) ++ fibs\u2032 (n-2)", "  \
    \  if n<=1 return n\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    end", "    if n == 1 then return 0\n    if n == 2 then return 0\n    if n == 3\
    \ then return 0\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n -\
    \ 4)\nend", "  if n == 1 then return 0\n  else if n == 2 then return 1\n  else\
    \ if n == 3 then return 2\n  else if n == 4 then return 3\n  else return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nHere's a simple Python implementation:\n<code>\ndef fib(n):\n    a, b =\
    \ 0, 1\n    while a < n:\n         a, b = b, a+b\n    return b\n</code>\n<|/ a\
    \ tags=fibonacci,algorithm,haskell,math,functional-programming |>\n<| a tags=fibonacci,algorithm,haskell,math,functional-programming\
    \ |>\nHere's the solution in Python. My solution doesn't use recursion. The solution\
    \ using recursion uses O(n) stack space. Here's another solution using recursion\
    \ and O(1) stack space:\n<code>\ndef fib(n):\n    a, b = 0, 1\n    while a < n:\n\
    \         a, b = b, a + b\n    return b\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This is a better solution than the one using recursion, because it doesn't require\
    \ any additional stack. This solution uses O(1) stack space. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| a dscore=1 |>\nA mathematical approach\n<code>\nfib(n)\
    \ = 1+(-fib(n/2))\nfib(1) = 0\nfib(2) = 1\nfib(3) = 2\nfib(4) = 3\nfib(5) = 5\n\
    </code>\n<|/ a tags=fibonacci,algorithm,haskell,math,functional-programming |>\n\
    <| c |>\nWhat is the meaning of the `/` operator in `(1/2)`? I tested the code\
    \ in Python and it is returning `0` all the time.\n<|/ c |>\n<| c |>\nI didn't\
    \ test the code, so I guessed that division is in Python too. However the same\
    \ expression doesn't work in the other languages. I tested it on http://pythonfiddle.com/\
    \ and in JavaScript and Ruby, and it works the same way: `1/2 == 0`.\n<|/ c |>\n\
    <| c |>\nAh, I see now! I got confused by a test online and it didn't seem to\
    \ work. Thanks.\n<|/ c |>\n<| c |>\nIn Haskell, dividing two integers in Haskell\
    \ is done using `div`. `(/)` is integer division.\n<|/ c |>\n<| a |>", "    if\
    \ n < 0 \n        error(\"fib4 called on negative number\") \n    else if n ==\
    \ 0 \n        return 0 \n    else if n == 1 \n        return 1 \n    else if n\
    \ == 2 \n        return 2 \n    else \n        return fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4) \n\"\"\"The fibonacci number sequence is a sequence\
    \ of numbers, where each number is the sum of the two preceding numbers. For example,\
    \ the first 3 numbers in the sequence are 1, 1, and 2. \n    Please write a function\
    \ to efficiently compute the n-th element of the fibonacci number sequence.  Do\
    \ not use recursion.\"\"\"", "    if n == 0 then return 0\n    if n == 1 then\
    \ return 1\n    if n == 2 then return 2\n    if n == 3 then return 0\n    return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n</code>\n<|/ a tags=recursion,fibonacci,haskell\
    \ dscore=1 |>\n<| c |>\nThe `fib4` function doesn't compute what OP wants.\n<|/\
    \ c |>\n<| c |>\nThe fib4 function does what OP wants. The problem was in the\
    \ incorrect use of fib4 as the recursive function.\n<|/ c |>\n<| a dscore=0 tags=recursion,fibonacci,haskell\
    \ |>\nI wrote this code, but I'm not sure if I got the idea right... Please let\
    \ me know if I misunderstood the question.\n<code>\nfib4 :: Int -> Int\nfib4 n\
    \ = fib3(n-1) + fib3(n-2)", "    if n == 0 \n        0\n    else if n == 1\n \
    \       0\n    else if n == 2\n        2\n    else if n == 3\n        0\n    else\
    \ if n == 4\n        4\n    else if n == 5\n        8\n    else if n == 6\n  \
    \      14\n    else if n == 7\n        21\n    else if n == 8\n        34\n  \
    \  else if n == 9\n        55\n    else if n == 10\n        89\n    else if n\
    \ == 11\n        144\n    else if n == 12\n        233\n    else if n == 13\n\
    \        377\n    else if n == 14\n        610\n    else if n == 15\n        987\n\
    \    else if n == 16\n        1597\n    else if n == 17\n        2584\n    else\
    \ if n == 18\n        4181\n    else if n == 19\n        6765\n    else if n ==\
    \ 20\n        10946\n    else if n == 21\n        17711\n    else if n == 22\n\
    \        28657\n    else if n == 23\n        46368\n    else if n == 24\n    \
    \    75025\n    else if n == 25\n        121393\n    else if n == 26\n       \
    \ 196418\n    else if n == 27\n        317811\n    else if n == 28\n        514229\n\
    \    else if n == 29\n        832040\n    else if n == 30\n        1346269\n \
    \   else if n == 31\n        2178309\n    else if n == 32\n        3524578\n \
    \   else if n == 33\n        5702887\n    else if n == 34\n        9227465\n \
    \   else if n == 35\n        14930352\n    else if n == 36\n        24157817\n\
    \    else if n == 37\n        39088169\n    else if n == 38\n        52181757\n\
    \    else if n == 39\n        82991269\n    else if n == 40\n        146412158\n\
    \    else if n == 41\n        21783016\n    else if n == 42\n        35245780\n\
    \    else if n == 43\n        57028872\n    else if n == 44\n        92274640\n\
    \    else if n == 45\n        149303520\n    else if n == 46\n        241578166\n\
    \    else if n == 47\n        39088168\n    else if n == 48\n        521817566\n\
    \    else if ", "    if n < 4 then return n\n    else return fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n\
    end\n</cell>\n<cell>\n\"\"\"\nFibonacci number sequence\nGiven a positive integer\
    \ N, the Fibonacci number sequence begins with 0, 1, 2, and so on up to and including\
    \ N.\nThe next element in the sequence is calculated by the formula:\nF(n) = F(n-1)\
    \ + F(n-2), where F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2), where F(n) is\
    \ the n-th element of the Fibonacci sequence. \nWrite a function to compute the\
    \ nth element of the Fibonacci sequence.\nFor example, F(3) = 3, F(5) = 8, F(8)\
    \ = 13, F(13) = 21.\n>>> fibonacci(5)\n8\n>>> fibonacci(12)\n13\n>>> fibonacci(10)\n\
    55\n>>> fibonacci(20)\nTraceback (most recent call last):\n  File \"<stdin>\"\
    , line 1, in <module>\n  File \"<stdin>\", line 2, in fibonacci\n  File \"<stdin>\"\
    , line 2, in fib4\n  File \"<stdin>\", line 2, in fib4\n  File \"<stdin>\", line\
    \ 2, in fib4\n  File \"<stdin>\", line 2, in fib4\n  File \"<stdin>\", line 2,\
    \ in fib4\n  File \"<stdin>\", line 2, in fib4\n  File \"<stdin>\", line 2, in\
    \ fib4\n  File \"<stdin>\", line 2, in fib4\n  File \"<stdin>\", line 2, in fib4\n\
    \  File \"<stdin>\", line 2, in fib4\n  File \"<stdin>\", line 2, in fib4\n  File\
    \ \"<stdin>\", line 2, in fib4\n  File \"<stdin>\", line 2, in fib4\n  File \"\
    <stdin>\", line 2, in fib4\n  File \"<stdin>\", line 2, in fib4\n  File \"<stdin>\"\
    , line 2, in fib4\n  File \"<stdin>\", line 2, in fib4\n  File \"<stdin>\", line\
    \ 2, in fib4\n  File \"<stdin>\", line 2, in fib4\n  File \"<stdin>\", line 2,\
    \ in fib4\n  File \"<stdin>\", line 2, in fib4\n  File \"<stdin>\", line 2, in\
    \ fib4\n  File \"<stdin>\", line 2, in fib4\n  File \"<stdin>\", line 2, in fib4\n\
    \  File \"<stdin>\", line 2, in fib4\n  File \"<stdin>\", line 2, in fib4\n  File\
    \ \"<stdin>\", line 2, in fib4\n  File \"<stdin>\", line 2, in fib4", "    if\
    \ (n <= 0) or (n >= 1)\n        return n\n    if (n == 1)\n        return 0 \n\
    \    if (n == 2)\n        return 2\n    if (n == 3)\n        return 0 \n    return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    end\n\"\"\"\nWrite a recursive\
    \ function that takes one input argument, and that returns the factorial of the\
    \ given input argument.  \nFor example, factorial(0) should return 1 and factorial(1)\
    \ should return 1.\nDon't use explicit recursion like in factorial(n-1).  \nDon't\
    \ use explicit recursion like in factorial(factorial(n-1)).\n\"\"\"", "    if\
    \ n == 0\n    then 0\n    else if n == 1\n    then 1\n    else if n == 2\n   \
    \ then 2\n    else if n == 3\n    then 0\n    else if n == 4\n    then 0\n   \
    \ else if n == 5\n    then 0\n    else if n == 6\n    then 0\n    else if n ==\
    \ 7\n    then 0\n    else if n == 8\n    then 0\n    else if n == 9\n    then\
    \ 0\n    else if n == 10\n    then 0\n    else if n == 11\n    then 0\n    else\
    \ if n == 12\n    then 0\n    else if n == 13\n    then 0\n    else if n == 14\n\
    \    then 0\n    else if n == 15\n    then 0\n    else if n == 16\n    then 0\n\
    \    else if n == 17\n    then 0\n    else if n == 18\n    then 0\n    else if\
    \ n == 19\n    then 0\n    else if n == 20\n    then 0\n    else if n == 21\n\
    \    then 0\n    else if n == 22\n    then 0\n    else if n == 23\n    then 0\n\
    \    else if n == 24\n    then 0\n    else if n == 25\n    then 0\n    else if\
    \ n == 26\n    then 0\n    else if n == 27\n    then 0\n    else if n == 28\n\
    \    then 0\n    else if n == 29\n    then 0\n    else if n == 101\n    then 0\n\
    \    else if n == 102\n    then 0\n    else if n == 103\n    then 0\n    else\
    \ if n == 104\n    then 0\n    else if n == 105\n    then 0\n    else if n ==\
    \ 106\n    then 0\n    else if n == 107\n    then 0\n    else if n == 108\n  \
    \  then 0\n    else if n == 109\n    then 0\n    else if n == 110\n    then 0\n\
    \    else if n == 111\n    then 0\n    else if n == 112\n    then 0\n    else\
    \ if n == 113\n    then 0\n    else if n == 114\n    then 0\n    else if n ==\
    \ 115\n    then 0\n    else if n == 116\n    then 0\n    else if n == 117\n  \
    \  then 0\n    else if n == 118\n    then 0\n    else if n == 119\n    then 0\n\
    \    else if n == 120\n    then 0\n    else if n == 121\n", "    if n==0\n   \
    \     0\n    else if n==1\n        0\n    else if n==2\n        2\n    else if\
    \ n==3\n        0\n    else if n==4\n        0\n    else\n        fib4(n-1) +\
    \ fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</cell>\n<text>\nWrite a recursive function\
    \ that returns the square of the nth Fibonacci number.", "  if n==0 then 0 else\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</code>\n<|/ q tags=fibonacci,julia\
    \ |>\n<| c |>\nPlease add your code for computing the Fibonacci numbers, it would\
    \ be helpful to see how you are doing it now.\n<|/ c |>\n<| c |>\nI updated the\
    \ post, thank you.\n<|/ c |>\n<| c |>\nDo you have the code for computing the\
    \ fibonacci numbers?\n<|/ c |>\n<| c |>\nOh sorry I forgot, I added the function\
    \ fib4 above.\n<|/ c |>\n<| c |>\nHow big are these numbers?\n<|/ c |>\n<| a tags=fibonacci,julia\
    \ |>\nThere are three main ways to compute Fibonacci numbers (in Julia):", " \
    \   # YOUR CODE HERE\n    raise NotImplementedError()\n    return fib4(n-1) +\
    \ fib4(n-2) + fib4(n-3) + fib4(n-4)", "    if n == 0 || n == 1\n        0\n  \
    \  else\n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</cell>\n\
    <code language=julia-0.6>\nfib4(0)\n</cell>\n<code language=julia-0.6>\nfib4(7)\n\
    </cell>\n<code language=julia-0.6>\nfib4(10)\n</cell>\n<code language=julia-0.6>\n\
    fib4(n::Int64)::Int64\n</cell>\n<code language=julia-0.6>\nfib4(10000)\n</cell>\n\
    <text>\nExercise\nWrite a function my_fib(n) that computes the n-th element of\
    \ the fib number sequence.\nFor example, my_fib(0) == 0, my_fib(2) == 3, and my_fib(3)\
    \ == 1.\nNote that my_fib(n) must handle negative numbers and 0 correctly.\nFor\
    \ example, my_fib(-4) == my_fib(-1) == my_fib(-2) == my_fib(0) == 0.\nAlso note\
    \ that my_fib(n) does not use recursion.\nYou may find the fib2 function useful.",
  "    if n==0 || n==1 \n        return n\n    else\n        return fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n\
    \    end \nend", "    if n == 0 || n == 1 || n == 2 || n == 3 || n == 4 || n ==\
    \ 5 || n == 6 || n == 7 \n        then 0\n    else fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4) + fib4(n-5) + fib4(n-6) + fib4(n-7)\nend\n\"\"\"\nThe Fibonacci\
    \ sequnece is a family of number-theoretic sequences that are used to describe\
    \ the recurrence relations of computing processes in many disciplines.  The Fibonacci\
    \ sequnece is defined by the following formula:\n    fibonacci(0) -> 0\n    fibonacci(1)\
    \ -> 1\n    fibonacci(n) -> fibonacci(n-1) + fibonacci(n-2), where n is a positive\
    \ integer.\n    Please write a function to compute the n-th element of the Fibonacci\
    \ sequnece using the above formula.\n    \"\"\"", "  if n == 0 \n    0 \n  else\
    \ if n == 1 \n    0 \n  else if n == 2 \n    2 \n  else if n == 3 \n    0 \n \
    \ else if n >= 4 \n    fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n\
    \  end\nend\n</cell>\n<code language=julia-0.6>\nfib4(5)\n</cell>\n<code language=julia-0.6>\n\
    fib4(6)\n</cell>\n<code language=julia-0.6>\nfib4(7)\n</cell>\n<code language=julia-0.6>\n\
    fib4(10000)\n</cell>\n<code language=julia-0.6>\nfib4(10)\n</cell>\n<code language=julia-0.6>\n\
    fib4(100)\n</cell>\n<code language=julia-0.6>\nfib4(1000)\n</cell>\n<code language=julia-0.6>\n\
    fib4(100000)\n</cell>\n<code language=julia-0.6>\nfib4(10000)\n</cell>\n<code\
    \ language=julia-0.6>\nfib4(100000)\n</cell>\n<code language=julia-0.6>\nfib4(100001)\n\
    </cell>\n<code language=julia-0.6>\nfib4(100002)\n</cell>\n<code language=julia-0.6>\n\
    fib4(100003)\n</cell>\n<code language=julia-0.6>\nfib4(100004)\n</cell>\n<code\
    \ language=julia-0.6>\nfib4(100005)\n</cell>\n<code language=julia-0.6>\nfib4(100006)\n\
    </cell>\n<code language=julia-0.6>\nfib4(100007)\n</cell>\n<code language=julia-0.6>\n\
    fib4(100008)\n</cell>\n<code language=julia-0.6>\nfib4(100009)\n</cell>\n<code\
    \ language=julia-0.6>\nfib4(100010)\n</cell>\n<code language=julia-0.6>\nfib4(100011)\n\
    </cell>\n<code language=julia-0.6>\nfib4(100012)\n</cell>\n<code language=julia-0.6>\n\
    fib4(100013)\n</cell>\n<code language=julia-0.6>\nfib4(100014)\n</cell>\n<code\
    \ language=julia-0.6>\nfib4(100015)\n</cell>\n<code language=julia-0.6>\nfib4(100016)\n\
    </cell>\n<code language=julia-0.6>\nfib4(100017)\n</cell>\n<code language=julia-0.6>\n\
    fib4(100018)\n</cell>\n<code language=julia-0.6>\nfib4(100019)\n</cell>\n<code\
    \ language=julia-0.6>\nfib4(100020)\n</cell>", "    if n==0 \n        0\n    elif\
    \ n==1 \n        0\n    elif n==2 \n        2\n    else \n        fib4(n-1) +\
    \ fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</code>\n<|/ a dscore=0 tags=julia |>\n\
    <| a |>\nHere is a more Julian way for the function fib4\n<code>\nfib4(n) = n\
    \ == 0 ? 0 : n == 1 ? 1 : fib4(n - 1) + fib4(n - 2)\n</code>\n<|/ a tags=julia\
    \ dscore=0 |>\n<| a tags=julia |>\n<code>", "    if n == 0\n    then 0\n    else\
    \ if n == 1\n    then 0\n    else if n == 2\n    then 2\n    else if n == 3\n\
    \    then 0\n    else (fib4(n-1)) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    end\n\
    end fib4\n</code>\n<|/ a tags=fibonacci,recursion,julia,math |>\n<| a |>\nTo compute\
    \ nth Fibonacci number it is enough to know about Fibonacci theorem. Below you\
    \ can find Julia implementation of it:\n<code>", "    \"\"\"fib4(n = 0)::Int64\
    \  \n    \"\"\"\n    if n == 0\n        return 0\n    if n == 1\n        return\
    \ 1\n    if n == 2\n        return 2\n    if n == 3\n        return 0\n    else\
    \ if n == n-1\n        return fib4(n-2) + fib4(n-3) + fib4(n-4) \n    else\n \
    \       return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) \nend\n</code>\n\
    The solution above is probably pretty obvious if you're a C programmer familiar\
    \ with recursion.  But let's break it down a little further.  \nWhen calling the\
    \ fib4 function, we are required to give a value for the parameter n.  As this\
    \ is a recursive function, we can give it a value that depends on itself.  \n\
    For example, to compute the value of the fibonacci number with n being 5, we'll\
    \ need to do the following steps:\n<code>\n> fib4(5)\n</code>", "    if n == 0\n\
    \        0\n    elif n == 1\n        0\n    elif n == 2\n        2\n    elif n\
    \ == 3\n        0\n    else \n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    \    end\nend\n</code>\nThis is my attempt, but it's not working. I'm stuck at\
    \ the \"else\" line in the fib4 function. I can't figure it out.\n<|/ q |>\n<|\
    \ c |>\nPlease show us the code you're working with so that we can help you with\
    \ it.\n<|/ c |>\n<| c |>\nI added some code to the question.\n<|/ c |>\n<| c |>\n\
    You need to write your own recursive function `fib4`. Nobody else on StackOverflow\
    \ can help with your homework.\n<|/ c |>\n<| c |>\nI posted my attempt in the\
    \ description. I hope you will be able to help me.\n<|/ c |>\n<| c |>\nThat code\
    \ is incomplete and does not compile. How about you edit it so people can try\
    \ and help you?\n<|/ c |>\n<| a dscore=3 |>\nThis is my attempt:\n<code>\nfib4_helper(n)\
    \ = n <= 2 ? n : fib4_helper(n-1) + fib4_helper(n-2)\nfib4(n) = fib4_helper(n)\n\
    </code>\n<|/ a tags=julia,recursion,function |>\n<| a dscore=3 |>\nThis was my\
    \ first attempt:\n<code>", "    \n    if n == 0\n        0\n    else\n       \
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    \nend\n</cell>\n<code language=julia-1.0>\n\
    fib4(5)\n</cell>\n<text>\nProblem 10\nCompute a sequence of integers $0, 1, \\\
    dots, n - 1$ that satisfies the equation $$ (n - 1)(n+1)(2n+1)(3n+1)(4n+1) = 5n+1.$$\
    \  That is, a sequence that repeats itself five times.", "    if n<2 then 0 else\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</code>\n<|/ a tags=julia,recursion\
    \ |>\n<| a dscore=2 |>\nI prefer a solution using iteration, though this one does\
    \ use recursion. \n<code>", "    if n == 0 \n        0\n    else if n == 1 \n\
    \        0\n    else if n == 2 \n        2\n    else if n == 3 \n        0\n \
    \   else \n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", "    if\
    \ n < 0 return 0\n    elif n == 0 return 0\n    elif n == 1 return 1\n    else\
    \ return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend\n</cell>\n\
    <code language=julia-1.5>\nfib4\n</cell>\n<code language=julia-1.5>\nfib4(10)\n\
    </cell>\n<text>\nExercise: Recursion", "    if n == 1 \n        fib4(1) \n   \
    \ else \n        fib4(fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4))\nend\nfib4(5)\n\
    </cell>\n<text>\nExercise\nIn the code cell below, fill in the body of the fib5\
    \ function so it returns the n-th element of the Fibonacci number sequence.  Experiment\
    \ with different inputs to verify that you get the expected result.", "    if\
    \ n == 0\n    then 0\n    else fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\nend \nfib4(6)\n</code>\n<|/ a |>\n<| a tags=recursion,julia,bignum dscore=2\
    \ |>\nThe Fibonacci sequence is defined as the infinite sum of arithmetic progressions.\
    \  For example, for the first five terms, the sum is 1 + 1 + 2 + 3 + 5.  Since\
    \ each term is evenly divisible by 4, the sum of the first five terms is 1 + 1\
    \ + 2 + 3 + 5 + 8 + 13 + 20 + 26 + ... + n-1. Hence, the Fibonacci sequence is\
    \ defined as the sum of the arithmetic progressions beginning with 1 and ending\
    \ with the first term not evenly divisible by 4, which is the sum of the arithmetic\
    \ progressions beginning with 1 and ending with 1 + 2 + 3 + 5 + 8 + 13 + 20 +\
    \ ... + n-1.\n<code>", "    if n == 0 \n        return 0 \n    else if n == 1\
    \ \n        return 0 \n    else if n == 2 \n        return 2 \n    else if n ==\
    \ 3 \n        return 0 \n    else \n        return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4) \nend\nfib4(100)\n</cell>\n<code language=julia-1.6>\nfib4(100)\n\
    </cell>\n<text>\n(Part 4): The Fibonacci sequence is defined by the recurrence\
    \ relation:\n    $$Fn = F{n-1} + F_{n-2}$$\nwhere $F_0 = 0$ and $F_1 = 1$.\nWrite\
    \ a Julia function called fib(n) that computes the nth element of the Fibonacci\
    \ sequence. Your function should use the following steps:", "    if n == 0\n \
    \   then 0\n    else if n == 1\n    then 0\n    else if n == 2\n    then 2\n \
    \   else if n == 3\n    then 0\n    else if n == 4\n    then 0\n    else fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\nfib4(5)\n</cell>\n<text>\nQuestion\
    \ 5\nWrite a function that takes as input two lists of numbers and returns a list\
    \ that contains the unique elements of the first list that are not in the second\
    \ list.  Please do not use sets or the built-in set library.  In other words,\
    \ use the comparison operator <> and do not use set operations.\nFor example,\
    \ given the lists [2,5,7,8] and [2,7,10] the function should return the list [5,8].\
    \  Do not use the set library.  You can use comparison operators.\nThis function\
    \ should work for any two lists of numbers, not just two.", "    if n == 0 \n\
    \        0\n    else if n == 1 \n        0\n    else if n == 2 \n        2\n \
    \   else if n == 3 \n        0\n    else \n        fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\nend\nfib4(7)\n</cell>\n<text>\nProblem 8\nThe Fibonacci sequence\
    \ is defined by the formula:\nF(0) = 0, F(1) = 1\nF(N) = F(N - 1) + F(N - 2),\
    \ where F(0) = 0, F(1) = 1\nFor example, F(3) = F(2) + F(1) = F(4) + F(0) = F(3)\
    \ + F(2) + F(1) = F(5) + F(4) + F(0) = F(4) + F(3) + F(2) + F(1) = F(6) + F(5)\
    \ + F(4) + F(0) = F(4) + F(3) + F(2) + F(1) + F(0) = F(4) + F(3) + F(2) + F(1)\
    \ = F(6) + F(5) + F(4) + F(0) + F(0) = F(4) + F(3) + F(2) + F(1) = F(6) + F(5)\
    \ + F(4) + F(0) + F(0) + F(0) = F(4) + F(3) + F(2) + F(1) + F(0) + F(0) = F(4)\
    \ + F(3) + F(2) + F(1) = F(6) + F(5) + F(4) + F(0) + F(0) + F(0) + F(0) = F(4)\
    \ + F(3) + F(2) + F(1) + F(0) + F(0) + F(0) + F(0) = F(4) + F(3) + F(2) + F(1)\
    \ = F(6) + F(5) + F(4) + F(0) + F(0) + F(0) + F(0) + F(0) = F(4) + F(3) + F(2)\
    \ + F(1) + F(0) + F(0) + F(0) + F(0) + F(0) = F(4) + F(3) + F(2) + F(1)\nPlease\
    \ write a function to compute the n-th element of the Fibonacci sequence.  Do\
    \ not use recursion.\n>>> fib(5)\n8\n>>> fib(6)\n20\n>>> fib(7)\n35\n>>> fib(8)\n\
    58\n>>> fib(9)\n89\n>>> fib(10)\n145\n>>> fib(11)\n233\n>>> fib(12)\n377\n>>>\
    \ fib(13)\n610\n>>> fib(14)\n987\n>>> fib(15)\n1597\n>>> fib(16)\n2584\n>>> ",
  "    if n == 0 || n == 1 \n        0\n    else\n        fib4(n - 1) + fib4(n - 2)\
    \ + fib4(n - 3) + fib4(n - 4)\n</code>\n<|/ a |>\n<| a |>\nIn Rust, you can use\
    \ recursion. Here's a solution based on some answers I've seen here on StackOverflow.\n\
    <code>\nextern crate num;", "    if n <= 4\n    return 0\n    if n <= 6\n    return\
    \ 0\n    if n <= 8\n    return 2\n    if n <= 12\n    return 0\n    return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</cell>\n<code language=julia-1.3>\n\
    @time fib4(5)\n</cell>\n<text>\nProblem 10 (bonus question)\nWrite a Julia function\
    \ called fib5 that computes the n-th Fibbonacci number.", "    if n==0\n    then\
    \ 0\n    else if n==1\n    then 1\n    else fib4(fib4(fib4(fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)))) + fib4(n-4) \nend\n</cell>\n<code language=julia-0.4>",
  "    if n == 0 || n == 1 \n        then 0 else \n        if n == 2 \n        then\
    \ 1 else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) \nend\n</cell>\n<cell>\n\
    # SOLUTION\n# Write a function that computes the nth element of the fib4 number\
    \ sequence.\n# Do not use recursion.  Hint:  The Fib4 number sequence is a sequence\
    \ similar to the Fibbonacci sequence that's defined as follows:\n# fib4(0) ->\
    \ 0\n# fib4(1) -> 0\n# fib4(2) -> 2\n# fib4(3) -> 0\n# fib4(n) -> fib4(n-1) +\
    \ fib4(n-2) + fib4(n-3) + fib4(n-4).\n# Please write a function to efficiently\
    \ compute the n-th element of the fib4 number sequence.  Do not use recursion.",
  "    if n == 0\n        0\n    elseif n == 1\n        0\n    elseif n == 2\n   \
    \     2\n    elseif n == 3\n        0\n    elseif n == 4\n        4\n    else\n\
    \        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)", "if n < 0 then return\
    \ error(\"fib4 requires a positive integer\") else if n == 0 then return 0 else\
    \ if n == 1 then return 0 else if n == 2 then return 2 else if n == 3 then return\
    \ 0 else fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4) else fib4(n - 1)\
    \ + fib4(n - 2) + fib4(n - 3) + fib4(n - 4) + fib4(n - 5) + fib4(n - 6) + fib4(n\
    \ - 7) + fib4(n - 8)\nend\nfib4(n::Int64)=fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)",
  "    if n == 0 || n == 1\n        return 0\n    elseif n == 2\n        return 1\n\
    \    elseif n == 3\n        return 0\n    elseif n == 4\n        return 5\n  \
    \  else\n        return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    \    end\nend\n</cell>\n<code language=julia-1.6>\n@time fib4(5)\n@time fib4(6)\n\
    @time fib4(7)\n@time fib4(8)\n</cell>\n<text>\nRecursive Solution", "    if n\
    \ < 0 || n > 20\n        return 0\n    else if n == 0\n        return n\n    else\
    \ if n == 1\n        return n\n    else if n == 2\n        return 4\n    else\
    \ if n == 3\n        return 6\n    else if n == 4\n        return 8\n    else\
    \ if n == 5\n        return 10\n    else if n == 6\n        return 12\n    else\
    \ if n == 7\n        return 14\n    else if n == 8\n        return 16\n    else\
    \ if n == 9\n        return 18\n    else if n == 10\n        return 20\n    else\
    \ if n == 11\n        return 22\n    else if n == 12\n        return 24\n    else\
    \ if n == 13\n        return 26\n    else if n == 14\n        return 28\n    else\
    \ if n == 15\n        return 30\n    else if n == 16\n        return 32\n    else\
    \ if n == 17\n        return 34\n    else if n == 18\n        return 36\n    else\
    \ if n == 19\n        return 38\n    else if n == 20\n        return 40\n    return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)", "    if n == 0 \n  \
    \  then 0 else fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend", " \
    \   if n <= 4 \n        then 0 \n        else fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n    end \nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nHere is a recursive\
    \ version that doesn't use mutable variables. \n<code>", "    if n == 0 \n   \
    \     0 \n    else if n == 1 \n        0\n    else if n == 2 \n        2\n   \
    \ else if n == 3 \n        0\n    else \n        fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n</code>\nNow we can compare this solution to the recursive\
    \ solution and see that it works:\n<code>\nfib4(2)\nfib4(3) + fib4(4)\n3 + fib4(4)\
    \ + fib4(1)\n3 + fib4(4) + fib4(1) + fib4(0)\n3 + 4 + fib4(1) + fib4(0)\n3 + 4\
    \ + 1 + fib4(0)\n3 + 4 + 1 + 0\n4\n</code>\nAs you see it's very similar to the\
    \ recursive solution only that it's written using the @ syntax.\n<|/ a |>\n<|\
    \ c |>\nThanks for your response. I was able to get this to work and it seems\
    \ reasonably efficient. I'm still confused about why my attempt at recursion is\
    \ so inefficient. I would think that my approach would be efficient because of\
    \ the factorial and fibonacci calculations, but I'm obviously missing something.\n\
    <|/ c |>\n<| c |>\nI think the tricky thing is that you have the factorial in\
    \ the fib4 function but you only do the factorial calculation once before the\
    \ recursive calls. When you call fibonacci you actually calculate the factorial\
    \ twice (the first time in the main function, the second time in the recursive\
    \ call). If you can think of a way to calculate it only once (while still using\
    \ recursion) it may speed it up a lot.\n<|/ c |>\n<| c |>\nOkay, thank you. That\
    \ makes sense. I just started thinking about how recursion works and I see how\
    \ it could be improved based on your explanation. I also found this helpful post:\
    \ https://stackoverflow.com/questions/13675471/recursion-vs-iteration and this\
    \ was helpful to understand recursion: http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html\n\
    <|/ c |>\n<| c |>\nOk, I wrote a recursive function that works well and seems\
    \ to be quite efficient. It seems to work fine for any number I put in, except\
    \ for zero. I tried a few different things, but I really don't understand why\
    \ that would be the case. I think I just need to learn more about recursion. I\
    \ posted my code as an edit to the original question.\n<|/ c |>\n<| c |>\nThe\
    \ factorial function is actually very inefficient, it's O(n!) where n is the input.\
    \ That's very inefficient, it's O(n ^ n) where n is the input. I think you meant\
    \ `", "    if n == 0\n        0\n    else if n == 1\n        0\n    else if n\
    \ == 2\n        2\n    else if n == 3\n        0\n    else if n >= 4\n       \
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n    end\nend", "  if\
    \ n==0\n    0 \n  else if n==1\n    1\n  else\n    fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4) \nend\n</code>\n<|/ a |>\n<| c |>\n`fib4(n)` should be `n-1`\n<|/\
    \ c |>\n<| c |>\nThe code you posted is incomplete, please fix it to match your\
    \ answer. Also the correct function name would be `fib4`, not `fib4`.\n<|/ c |>\n\
    <| c |>\n, thanks for pointing that out. I fixed it.\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's a solution without a loop:\n<code>\nfib4::Int64->Int64\nfib4(n) =\n\
    \  case n of\n    0 -> 0\n    1 -> 1\n    else -> fib4(n-1) + fib4(n-2) + fib4(n-3)\n\
    </code>\n<|/ a tags=recursion,julia |>\n<| c |>\nThis does not answer OPs question.\
    \ OP asked how to solve the problem without recursion. Your code doesn't use the\
    \ result of `fib4(n-1)`\n<|/ c |>\n<| c |>\nthe question asked how to solve the\
    \ problem without recursion and this code is doing just that.\n<|/ c |>\n<| c\
    \ |>\nIt might be worth noting that it is a tail recursive function and thus should\
    \ be able to run in linear time.\n<|/ c |>\n<| c |>\nThis answer is missing its\
    \ educational explanation.\n<|/ c |>\n<| c |>\nI added an explanation to the answer\
    \ :)\n<|/ c |>\n<| a tags=recursion,julia |>\nFor a recursive solution in Julia,\
    \ you should use an accumulator. Here is an example:\n<code>", "    if n == 0\n\
    \        0\n    else if n == 1\n        0\n    else if n == 2\n        2\n   \
    \ else if n == 3\n        0\n    else \n        fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n</code>\n<|/ a dscore=0 |>\n<| c |>\nA good answer includes\
    \ a description of what the code is doing.\n<|/ c |>\n<| c |>\n\"Do not use recursion.\"\
    \ This isn't a reason to use recursion.\n<|/ c |>\n<| c |>\nRecursion is a powerful\
    \ tool in functional programming languages. It can often be replaced by looping.\
    \ A looping construct can be faster, but it can also lead to stackoverflows. In\
    \ your case a recursive solution was the best choice.\n<|/ c |>\n<| c |>\nI wouldn't\
    \ say it's a great idea. I know that people like recursion and looping differently\
    \ and when they shouldn't be used, and when they should be used carefully, but\
    \ the fact that looping can lead to stack overflows is a good thing in itself.\
    \ It's a tool you should use when it's appropriate. It doesn't make your program\
    \ faster.\n<|/ c |>\n<| c |>\nI agree. Recursion is good in some cases, but not\
    \ necessarily an absolute necessity.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nusing\
    \ System;", "    if n == 0\n    then\n        return 0\n    else if n == 1\n \
    \   then\n        return 1\n    else if n == 2\n    then\n        return 2\n \
    \   else if n == 3\n    then\n        return 0\n    else\n        return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4) ", "    if n <= 0 \n        throw(Exception,\n\
    \            \"fib4 function only accepts positive numbers\")\n    elif n == 1\n\
    \        1\n    else\n        fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n    end\nend\n</cell>\n<code language=julia-1.4>\nfib4(5)\n</cell>\n<text>\n\
    Write a function that takes a list and returns the sum of the squares of the numbers\
    \ in that list.\nFor example, pass in [1,4,9,16,25] and get back 25. Make sure\
    \ the function can handle non-numeric types too.", "    if n == 0\n        0\n\
    \    else\n        if n == 1\n            0\n        else\n            if n ==\
    \ 2\n                2\n            else\n                if n == 3\n        \
    \            0\n                else\n                    if n == 4\n        \
    \                0\n                    else\n                        if n ==\
    \ 5\n                            4\n                        else\n           \
    \                 if n == 6\n                                8\n             \
    \               else\n                                if n == 7\n            \
    \                        14\n                                else\n          \
    \                          if n == 8\n                                       \
    \ 16\n                                    else\n                             \
    \           if n == 9\n                                            18\n      \
    \                                  else\n                                    \
    \        if n == 10\n                                                20\n    \
    \                                        else\n                              \
    \                  if n == 11\n                                              \
    \      22\n                                                else\n            \
    \                                        if n == 12\n                        \
    \                                24\n                                        \
    \            else\n                                                        if\
    \ n == 13\n                                                            26\n  \
    \                                                      else\n                \
    \                                            if n == 14\n                    \
    \                                            28\n                            \
    \                                else\n                                      \
    \                          if n == 15\n                                      \
    \                              30\n                                          \
    \                      else\n                                                \
    \                    if n == 16\n                                            \
    \                            32\n                                            \
    \                        else\n                                              \
    \          if n == 17\n                                                      \
    \      34\n                                                        else\n    \
    \                                                        if n == 18\n        \
    \                                                        36\n                \
    \                                            else\n                          \
    \                                      if n == 19\n                          \
    \                                          38\n                              \
    \                                  else\n                                    \
    \                                if n == 20\n                                \
    \                                        40\n                                \
    \                                    else\n                                  \
    \                      if n == 21\n                                          \
    \                  42\n                                                      \
    \  else\n                                                            if n == 22\n\
    \                                                                44\n        \
    \                                                    else\n                  \
    \                                              if n == 23\n                  \
    \                                                  46\n                      \
    \                                          else\n                            \
    \                                        if n == 24\n                        \
    \                                                48\n                        \
    \                                            else\n                          \
    \                              if n == 25\n                                  \
    \                          50\n                                              \
    \          else\n                                                            if\
    \ n == 26\n                                                                52\n\
    \                                                            else\n          \
    \                                                      if n == 27\n          \
    \                                                          54\n              \
    \                                                  else\n                    \
    \                                                if n == 28\n                \
    \                                                        56\n                \
    \                                                    else\n                  \
    \                                      if n == 29\n                          \
    \                                  58\n                                      \
    \                  else\n                                                    \
    \        if n == 30\n                                                        \
    \        60\n                                                            else\n\
    \                                                                if n == 31\n\
    \                                                                    62\n    \
    \                                                            else\n          \
    \                                                          if n == 32\n      \
    \                                                                  64\n      \
    \                                                              else\n        \
    \                                                if n == 33\n                \
    \                                            66\n                            \
    \                            else\n                                          \
    \                  if n == 34\n                                              \
    \                  68\n                                                      \
    \      else\n                                                                if\
    \ n == 35\n                                                                  \
    \  70\n                                                                else\n\
    \                                                                    if n == 36\n\
    \                                                                        72\n\
    \                                                                    else\n  \
    \                                                      if n == 37\n          \
    \                                                  74\n                      \
    \                                  else\n                                    \
    \                        if n == 38\n                                        \
    \                        76\n                                                \
    \            else\n                                                          \
    \      if n == 39\n                                                          \
    \          78\n                                                              \
    \  else\n                                                                    if\
    \ n == 40\n                                                                  \
    \      80\n                                                                  \
    \  else\n                                                        if n == 41\n\
    \                                                            82\n            \
    \                                            else\n                          \
    \                                  if n == 42\n                              \
    \                                  84\n                                      \
    \                      else\n                                                \
    \                if n == 43\n                                                \
    \                    86\n                                                    \
    \            else\n                                                          \
    \          if n == 44\n                                                      \
    \                  ", "    if n == 0 \n    then 0\n    else if n == 1 \n    then\
    \ 0\n    else if n == 2 \n    then 2\n    else if n == 3 \n    then 0\n    else\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"\nFibbonacci numbers are defined as follows:\n    fib3(0) -> 0\n    fib3(1)\
    \ -> 1\n    fib3(2) -> 1\n    fib3(3) -> 2\n    fib3(4) -> 3\n    fib3(5) -> 5\n\
    \    fib3(6) -> 8\n    fib3(7) -> 13\n    fib3(8) -> 21\n    fib3(9) -> 34\n \
    \   fib3(10) -> 55\n    fib3(11) -> 89\n    fib3(12) -> 144\n    fib3(13) -> 233\n\
    \    fib3(14) -> 377\n    fib3(15) -> 610\n    fib3(16) -> 987\n    fib3(17) ->\
    \ 1597\n    fib3(18) -> 2584\n    fib3(19) -> 4181\n    fib3(20) -> 6765\n   \
    \ fib3(21) -> 10946\n    fib3(22) -> 17711\n    fib3(23) -> 28657\n    fib3(24)\
    \ -> 46368\n    fib3(25) -> 75025\n    fib3(26) -> 121393\n    fib3(27) -> 196418\n\
    \    fib3(28) -> 317811\n    fib3(29) -> 514229\n    fib3(30) -> 832040\n    fib3(31)\
    \ -> 1346269\n    fib3(32) -> 2178309\n    fib3(33) -> 3524578\n    fib3(34) ->\
    \ 5702887\n    fib3(35) -> 9227465\n    fib3(36) -> 14930352\n    fib3(37) ->\
    \ 24157817\n    fib3(38) -> 39088169\n    fib3(39) -> 63245986\n    fib3(40) ->\
    \ 102334155\n    fib3(41) -> 165580141\n    fib3(42) -> 267914296\n    fib3(43)\
    \ -> 433494437\n    fib3(44) -> 701408733\n    fib3(45) -> 1134903170\n    fib3(46)\
    \ -> 1836311903\n    fib3(47) -> 2971215073\n    fib3(48) -> 4642640973\n    fib3(49)\
    \ -> 7289775", "    if n == 0\n        0\n    else if n == 1\n        1\n    else\
    \ if n == 2\n        2\n    else if n == 3\n        0\n    else if n == 4\n  \
    \      0\n    else \n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) + fib4(n-5)\n\
    </code>\n<|/ a tags=recursion,julia,fibonacci dscore=3 |>\n<| a tags=recursion,julia,fibonacci\
    \ |>\nHere is another approach based on recursive functions. \nI hope it helps.\n\
    <code>\n# fib function", "    if (n == 0) || n == 1 \n        then return 0\n\
    \    else if n == 2 \n        then return 1\n    else if n == 3 \n        then\
    \ return 2\n    else return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend",
  "    if (n <= 2) then (0::Int64)\n    else if (n <= 3) then (1::Int64)\n    else\
    \ if (n <= 5) then (2::Int64)\n    else (fib4(n - 4) + fib4(n - 3) + fib4(n -\
    \ 2) + fib4(n - 1))\nend\nfib4(7)", "    if n == 0 \n        0 \n    else if n\
    \ == 1 \n        1 \n    else if n == 2 \n        2 \n    else if n == 3 \n  \
    \      0 \n    else \n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    \    end\nend\n</code>\n<|/ q dscore=0 |>\n<| c |>\nStack Overflow is for programming\
    \ questions.  This is not a programming question.  It has nothing to do with programming\
    \ (besides syntax).  If your question is about how to efficiently compute fib4\
    \ for large `n`, then you are better off asking at [Computer Science](http://cs.stackexchange.com/).\n\
    <|/ c |>\n<| c |>\nI think this question will help you [SPOILER](https://spoiler.stackexchange.com/)\n\
    <|/ c |>\n<| c |>\nI believe this is an interview question for a company where\
    \ performance is paramount. Perhaps the person is trying to see how you can get\
    \ around the fact that the recursive call is linear in the number of calls made.\
    \ Perhaps the question is designed to see how you think about problems related\
    \ to thinking about recursion. Perhaps the goal is to find ways to do things which\
    \ would otherwise require recursive functions.\n<|/ c |>\n<| c |>\nTo me this\
    \ looks like it could be a homework question about recursion. Not all homework\
    \ questions are worth the effort to answer, and they are rarely worth answering\
    \ anyway. But as I said in my first comment, this is off-topic for Stack Overflow.\n\
    <|/ c |>\n<| a tags=big-o,haskell,fibonacci,algorithm,recursion |>\nFibonacci\
    \ has a geometric progression, with a base case and an inductive step. The base\
    \ case is 0, the inductive step is 1, and a recursive step involves two calls.\
    \ The geometric progression reduces to the simple recursion expansion:\n<code>\n\
    fib0 =       0\nfib1 =       1\nfib2 =   fib1 + fib0\nfib3 =   fib2 + fib1\nfib4\
    \ =   fib3 + fib2\nfib5 =   fib4 + fib3\nfib6 =   fib5 + fib4\nfib7 =   fib6 +\
    \ fib5\nfib8 =   fib7 + fib6\nfib9 =   fib8 + fib7\nfib10 == fib9 + fib8\nfib11\
    \ == fib10 + fib9", "    if n < 0 \n        return -1\n    else \n        return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)", "    if n < 4 then return\
    \ n\n    else return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend\
    \ \n</cell>\n<code language=julia-0.5>", "    if n <= 0 \n        0 \n    else\
    \ if n == 1 \n        0 \n    else if n == 2 \n        2 \n    else \n       \
    \ fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n</cell>\n<text>\nTask:\
    \ Write a function that takes a number as an argument, and prints the square of\
    \ that number using println().  The function should use println() to print the\
    \ square of the number, not the print() function. Recall that println() takes\
    \ input of type String and outputs a String.  For example,\nprintln() does not\
    \ work in the following ways:", "    if n <= 4 \n        return n \n    else \n\
    \        return fib4(n-2) + fib4(n-3) + fib4(n-4) ", "    if n==0 || n==1\n  \
    \      0\n    else\n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n  \
    \  end\nend\n</cell>\n<code language=julia-1.1>\n@time fib4(200);\n</cell>\n<text>\n\
    Exercise 4\nWrite a recursive function called fib5 that computes the n-th element\
    \ of the Fibonacci sequence using iteration by using a while loop.", "  if n==0\n\
    \    0 else 0\n  else if n==1\n    1 else 0\n  else if n==2\n    2 else 0\n  else\
    \ if n==3\n    0 else 0\n  else if n==4\n    0 else 0\n  else if n==5\n    0 else\
    \ 0\n  else if n==6\n    0 else 0\n  else if n==7\n    0 else 0\n  else if n==8\n\
    \    0 else 0\n  else if n==9\n    0 else 0\n  else if n==10\n    0 else 0\n \
    \ else if n==11\n    0 else 0\n  else if n==12\n    0 else 0\n  else if n==13\n\
    \    0 else 0\n  else if n==14\n    0 else 0\n  else if n==15\n    0 else 0\n\
    \  else if n==16\n    0 else 0\n  else if n==17\n    0 else 0\n  else if n==18\n\
    \    0 else 0\n  else if n==19\n    0 else 0\n  else if n==20\n    0 else 0\n\
    \  else if n==21\n    0 else 0\n  else if n==22\n    0 else 0\n  else if n==23\n\
    \    0 else 0\n  else if n==24\n    0 else 0\n  else if n==25\n    0 else 0\n\
    \  else if n==26\n    0 else 0\n  else if n==27\n    0 else 0\n  else if n==28\n\
    \    0 else 0\n  else if n==29\n    0 else 0\n  else if n==30\n    0 else 0\n\
    \  else if n==31\n    0 else 0\n  else if n==32\n    0 else 0\n  else if n==33\n\
    \    0 else 0\n  else if n==34\n    0 else 0\n  else if n==35\n    0 else 0\n\
    \  else if n==36\n    0 else 0\n  else if n==37\n    0 else 0\n  else if n==38\n\
    \    0 else 0\n  else if n==39\n    0 else 0\n  else if n==40\n    0 else 0\n\
    \  else if n==41\n    0 else 0\n  else if n==42\n    0 else 0\n  else if n==43\n\
    \    0 else 0\n  else if n==44\n    0 else 0\n  else if n==45\n    0 else 0\n\
    \  else if n==46\n    ", "    if n == 0\n    then 0\n    else if n == 1\n    then\
    \ 1\n    else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) \n    end \nend \n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\nHere's a naive implementation that runs in\
    \ O(2n) time complexity. It uses only two variables and doesn't use recursion.\n\
    <code>\nlet fib4(n) = \n    let c = ref 0\n    let d = ref 0\n    let e = ref\
    \ 1\n    while !c < n do\n        c := !c + !d\n        d := !c + !d\n       \
    \ e := !c + !d\n    end\n    !e\nend\n</code>\n<|/ a tags=function,fibonacci,performance,haskell\
    \ |>\n<| c |>\nThis is a very unusual way of writing a recursive function...\n\
    <|/ c |>\n<| c |>\nI agree that this is a very unusual way of writing a recursive\
    \ function. But as far as I can tell, the question requires no recursion.\n<|/\
    \ c |>\n<| c |>\nThis is exactly what I was looking for, and it doesn't use recursion.\n\
    <|/ c |>\n<| c |>\nThe question states: *Do not use recursion.* Your code uses\
    \ recursion.\n<|/ c |>\n<| c |>\nThe OP wants to not use recursion. Your code\
    \ does not.\n<|/ c |>\n<| a tags=function,fibonacci,performance,haskell |>\nHere's\
    \ the same solution using the \"trick\" that each fibonacci number is less than\
    \ or equal to its square:\n<code>\nfibonacci :: Int -> Int\nfibonacci n = if n\
    \ <= 0 then 0 else if n <= 1 then 1 else fibonacci (n - 1) + fibonacci (n - 2)",
  "    if n == 0 return 0\n    if n == 1 return 1\n    if n == 2 return 2\n    if\
    \ n == 3 return 0\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    </code>\n<|/ a tags=algorithm,big-o,time-complexity,fibonacci,recursion,python\
    \ dscore=2 |>\n<| a tags=algorithm,big-o,time-complexity,fibonacci,recursion,python\
    \ dscore=1 |>\nThis problem was asked in an interview and I solved it using recursion\
    \ using Python:\n<code>\ndef fib_rec(num):\n    if num == 1:\n        return 1\n\
    \    elif num == 2:\n        return 1\n    else:\n        temp = fib_rec(num-1)\
    \ + fib_rec(num-2)\n        return temp\n</code>\nAnd then I checked the time\
    \ complexity to see if it was O(2^n)\n<code>\n%timeit fib_rec(50)\n#Output (The\
    \ slowest run took 17.22 times longer than the fastest. This could mean that an\
    \ intermediate result is being cached.)\n#100000 loops, best of 3: 4.67 \xB5s\
    \ per loop\n</code>\n<|/ a |>\n<| c |>\nYou can make the complexity `O(2^n)` by\
    \ memoizing your recursive calls. There are lots of examples of that here.\n<|/\
    \ c |>\n<| c |>\nThis has a complexity of O(2^n) in the number of digits of the\
    \ number. The number of digits of the Fibonacci number is about 32, but your function\
    \ is about 64 (the largest number of digits is 15, which explains why you got\
    \ confused).\n<|/ c |>\n<| a dscore=1 tags=algorithm,big-o,time-complexity,fibonacci,recursion,python\
    \ |>\nI wanted to use recursion to solve this problem for a while, until I realized\
    \ that I had been using the wrong language, and in particular, the wrong type\
    \ of programming (like I wanted to use the wrong language for recursion, when\
    \ in fact I wanted to use the right language for recursion). So I googled \"Big\
    \ O Notation\"\nand got my first result. This is the one I liked the most: http://www.bigocheatsheet.com/\n\
    I used a slightly more efficient version of a recursive approach for calculating\
    \ Fibonacci numbers:\n<code>\ndef fib(n):\n    if n <= 1: return n\n    return\
    \ fib(n-1) + fib(n-2)\n</code>\nand got this result:\n<code>\ndef fib(n):\n  \
    \  if n <= 1: return n\n    return ", "    if n == 0 then 0\n    else if n ==\
    \ 1 then 0\n    else if n == 2 then 2\n    else if n == 3 then 0\n    else if\
    \ n == 4 then 4\n    else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) \nend\n\
    fib4(6)\n</cell>\n<text>\nSolution\nSolution 2", "    if n == 0\n        0\n \
    \   else if n == 1\n        0\n    else if n == 2\n        2\n    else if n ==\
    \ 3\n        0\n    else if n == 4\n        4\n    else if n == 5\n        8\n\
    \    else if n == 6\n        12\n    else if n == 7\n        16\n    else if n\
    \ == 8\n        20\n    else if n == 9\n        24\n    else if n == 10\n    \
    \    28\n    else if n == 11\n        32\n    else if n == 12\n        36\n  \
    \  else if n == 13\n        40\n    else if n == 14\n        44\n    else if n\
    \ == 15\n        48\n    else if n == 16\n        52\n    else if n == 17\n  \
    \      56\n    else if n == 18\n        60\n    else if n == 19\n        64\n\
    \    else if n == 20\n        68\n    else if n == 21\n        72\n    else if\
    \ n == 22\n        76\n    else if n == 23\n        80\n    else if n == 24\n\
    \        84\n    else if n == 25\n        88\n    else if n == 26\n        92\n\
    \    else if n == 27\n        96\n    else if n == 28\n        100\n    else if\
    \ n == 29\n        104\n    else if n == 30\n        108\n    else if n == 31\n\
    \        112\n    else if n == 32\n        116\n    else if n == 33\n        120\n\
    \    else if n == 34\n        124\n    else if n == 35\n        128\n    else\
    \ if n == 36\n        132\n    else if n == 37\n        136\n    else if n ==\
    \ 38\n        140\n    else if n == 39\n        144\n    else if n == 40\n   \
    \     148\n    else if n == 41\n        152\n    else if n == 42\n        156\n\
    \    else if n == 43\n        160\n    else if n == 44\n        164\n    else\
    \ if n == 45\n        168\n    else if n == 46\n        172\n    else if n ==\
    \ 47\n        176\n    else if n == 48\n        180\n    else if n == 49\n   \
    \     184\n    else if n == 50\n        188\n    else if n == 51\n        192\n\
    \    else if n == 52\n        196\n    else if n == 53\n        200\n    else\
    \ if n == 54\n        204\n    else if n == 55\n        208\n    else if n ==\
    \ 56\n        212", "    if n < 0 \n        error(\"fib4 requires negative input\"\
    )\n    end\n    else if n == 0 \n        0\n    else if n == 1 \n        0\n \
    \   else if n == 2 \n        2\n    else if n == 3 \n        0\n    else if n\
    \ == 4 \n        1\n    else if n == 5 \n        1\n    else \n        fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4) + fib4(n-5)\nend", "    if n == 0 || n ==\
    \ 1 \n        return 0 \n    else if n >= 2 \n        return fib4(n-1) + fib4(n-2)\
    \ \n    else \n        return fib4(n-4)\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    If you need to compute an infinite amount of numbers for some reason (for instance,\
    \ it is for a test), you can create an infinite loop and use unsafeInterleaveIO\
    \ to get the numbers in order. \n<code>\nimport Control.Monad.Trans.Resource (Resource,\
    \ runResourceT)\nimport Control.Monad.IO.Unsafe (unsafeInterleaveIO)\nimport qualified\
    \ Control.Monad.IO.Unsafe as UIO\nimport Control.Monad.Trans.Except (runExceptT)",
  "    if n == 0 \n        then return 0\n    elif n == 1 \n        then return 1\n\
    \    elif n == 2 \n        then return 2\n    else \n        fib3(n - 2) + fib3(n\
    \ - 3) + fib3(n - 4)\n    end\nend\n</cell>\n<code language=julia-0.4>\n@time\
    \ fib4(5)\n@time fib4(6)\n@time fib4(7)\n@time fib4(8)\n@time fib4(9)\n</cell>\n\
    <code language=julia-0.4>", "    if n == 0 \n        return 0 \n    elif n ==\
    \ 1 \n        return 0 \n    elif n == 2 \n        return 2 \n    elif n == 3\
    \ \n        return 0 \n    else \n        return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4) \nend\n</code>\n<|/ a tags=julia |>\n<| c |>\nWhile this code may\
    \ answer the question, providing additional context regarding how and/or why it\
    \ solves the problem would improve the answer's long-term value.\n<|/ c |>\n<|\
    \ c |>\nI agree, but I think the point of the answer is more about the code-style\
    \ than performance, so I wanted to show how to write a function instead of using\
    \ a while loop. I hope this answers your question.\n<|/ c |>\n<| a tags=julia\
    \ dscore=2 |>\nThe code below calculates the factorial of an integer in Julia\
    \ in the most efficient way. \n<code>", "    if n == 1\n        return n\n   \
    \ elif n == 2\n        return 1\n    elif n == 3\n        return 2\n    elif n\
    \ == 4\n        return 0\n    else\n        return fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\n    end\nend\n</cell>\n<code language=julia-1.5>\n\
    fib4(10)\n</cell>\n<text>\nExercise: Write a Julia function fib4 that computes\
    \ the n-th element of the Fib4 number sequence.  Use a while loop.", "    if n\
    \ == 0 then 0 else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</code>\n\
    The same for fibbonacci\n<code>\n\"\"\"\nThe Fibbonacci number sequence is a sequence\
    \ similar to the Fibbonacci sequnece that's defined as follows:\n    fibbonacci(0)\
    \ -> 0\n    fibbonacci(1) -> 1\n    fibbonacci(2) -> 1\n    fibbonacci(2) -> 2\n\
    \    fibbonacci(3) -> 2\n    fibbonacci(4) -> 3\n    fibbonacci(5) -> 3\n    fibbonacci(6)\
    \ -> 5\n    fibbonacci(7) -> 7\n    fibbonacci(8) -> 10\n    fibbonacci(9) ->\
    \ 15\n    fibbonacci(10) -> 20\n    fibbonacci(11) -> 28\n    fibbonacci(12) ->\
    \ 42\n    fibbonacci(13) -> 70\n    fibbonacci(14) -> 94\n    fibbonacci(15) ->\
    \ 149\n    fibbonacci(16) -> 230\n    fibbonacci(17) -> 370\n    fibbonacci(18)\
    \ -> 523\n    fibbonacci(19) -> 663\n    fibbonacci(20) -> 823\n    fibbonacci(21)\
    \ -> 1041\n    fibbonacci(22) -> 1290\n    fibbonacci(23) -> 1568\n    fibbonacci(24)\
    \ -> 1864\n    fibbonacci(25) -> 2142\n    fibbonacci(26) -> 2459\n    fibbonacci(27)\
    \ -> 2741\n    fibbonacci(28) -> 3024\n    fibbonacci(29) -> 3296\n    fibbonacci(30)\
    \ -> 3661\n    fibbonacci(31) -> 4102\n    fibbonacci(32) -> 4679\n    fibbonacci(33)\
    \ -> 5248\n    fibbonacci(34) -> 5771\n    fibbonacci(35) -> 6346\n    fibbonacci(36)\
    \ -> 6978\n    fibbonacci(37) -> 7592\n    fibbonacci(38) -> 8248\n    fibbonacci(39)\
    \ -> 8951\n    fibbonacci(40) -> 9590\n    fib", "    if n==0 || n==1\n      \
    \  return 0\n    else if n==2\n        return 2\n    else if n==3\n        return\
    \ 0\n    else if n==4\n        return 4\n    else\n        fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n\
    \    end\nend\n</code>\n<|/ a tags=julia,fibonacci,performance dscore=3 |>\n<|\
    \ a tags=julia,fibonacci,performance |>\nApart from the fastest solutions proposed\
    \ here, another solution that uses some of Julia's high order functions is shown\
    \ below. It is a bit more flexible in how it computes the Fibonacci numbers, but\
    \ it might be too slow on large Fibonacci numbers:\n<code>", "    if (n == 0)\
    \ return 0\n    if (n == 1) return 0\n    if (n == 2) return 2\n    if (n == 3)\
    \ return 0\n    return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    end", "if n == 0\n    0\nelse\n    fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\nend\nend #end fib4\nfib4=fib4(1)\n@code_warntype fib4(1)\n</cell>\n<text>\n\
    Exercise 7: Rewrite fib4 using pattern matching\nThe code cell below contains\
    \ three versions of the fib4 function.  Try running the cells to see which one\
    \ you prefer.  Which version is easier to read?  Which one is more efficient?",
  "    if n==0\n        0\n    else\n        if n==1\n            0\n        else\n\
    \            if n==2\n                2\n            else\n                if\
    \ n==3\n                    0\n                else\n                    if n==4\n\
    \                        4\n                    else\n                       \
    \ if n==5\n                            0\n                        else\n     \
    \                       fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n</code>\n\
    <|/ a dscore=2 tags=recursion,fibonacci,function,julia |>\n<| c |>\nThe answer\
    \ is correct, but you should use an abstract type rather than a concrete type,\
    \ e.g. `type Fib4(n) end` and then `function fib4(n::Fib4(n))` rather than `function\
    \ fib4(n::Int64)`.\n<|/ c |>\n<| c |>\nThanks for the help. That didn't work unfortunately\
    \ but I'll look into it\n<|/ c |>\n<| a tags=recursion,fibonacci,function,julia\
    \ |>\nA couple of issues.", "    if n == 0 || n == 1 \n        0\n    else\n \
    \       fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    end\nend\n</cell>\n\
    <text>\nProblem 7\nWrite a function to compute the n'th element of the fibonacci\
    \ sequence in Julia.", "    if n==0 \n        0\n    else if n==1 \n        0\n\
    \    else if n==2 \n        2\n    else \n        fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4) \n    fibbonacci(n-1)\nend", "    if (n == 0) then\n        0\n\
    \    else if (n == 1) then\n        1\n    else if (n == 2) then\n        2\n\
    \    else if (n < 4) then\n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    \    else\n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) + fib4(n-5)\n\
    end\n</code>\n<|/ a dscore=0 tags=fibonacci,recursion,julia |>\n<| a dscore=0\
    \ |>\nJust to keep it short: here a short and fast version\n<code>\nfib4 = Vector{Int}(2..5)\n\
    fib4[1] = 1 # fib4[1] := 1\nfib4[2] = 1 # fib4[2] := 1\nfib4[3] = 2 # fib4[3]\
    \ := 2\nfib4[4] = 1 # fib4[4] := 1", "    if n == 0\n        0\n    elseif n ==\
    \ 1\n        0\n    elseif n == 2\n        2\n    elseif n == 3\n        0\n \
    \   else\n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\nfib4(5)\n\
    </cell>\n<code language=julia-1.6>\n\"\"\"The Fibonacci number sequence is a sequence\
    \ similar to the Fibbonacci sequnece that's defined as follows:\n    fib(0) ->\
    \ 0\n    fib(1) -> 1\n    fib(n) -> fib(n-1) + fib(n-2).\n    Please write a function\
    \ to efficiently compute the n-th element of the fib number sequence.  Do not\
    \ use recursion.\n    >>> fib(5)\n    5\n    >>> fib(6)\n    8\n    >>> fib(7)\n\
    \    13\n    \"\"\"", "    if n == 0 \n    then return 0 \n    else \n    fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend\nfib4(5)\n</cell>\n<text>\n\
    Problem 4", "    if n == 0 \n    then return 0\n    else if n == 1 \n    then\
    \ return 1\n    else if n == 2 \n    then return 2\n    else return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", "    if n == 0\n        return 0\n\
    \    if n == 1\n        return 1\n    if n == 2\n        return 2\n    if n ==\
    \ 3\n        return 0\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    \    \nfib4(5)\n</cell>\n<text>\nPart 2: Tony Baber\nTony Baber was an American\
    \ football player and she was known for making up her first ever ever-popular\
    \ basketball player, Richard Bach. I remember being able to play his first ever\
    \ ever game in the game of tennis, where she became a very good basketball player.\
    \ A very good player, actually.", "    if n == 0\n        0\n    else if n ==\
    \ 1\n        0\n    else if n == 2\n        2\n    else if n == 3\n        0\n\
    \    else if n < 4\n        fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n -\
    \ 4)\n    else\n        fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    end \nfib4(10)\n</cell>\n<text>\nExercise:", "    if n<0 \n        then error\
    \ \"negative number\" \n    else if n==0 \n        then 0 else fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n\
    end\n</cell>\n<code language=julia-0.6>\n@time fib4(20);\n</cell>\n<text>\nExercise:\
    \ Write a recursive function named fib5 that computes the n-th element of the\
    \ Fibonacci sequence.  Do not use recursion.", "    if n == 0 || n == 1\n    \
    \    return 0\n    else if n == 2\n        return 2\n    else\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    \nfib4(7)\n</cell>\n<text>\n\
    Problem 5\nAs a reminder, here is the Fibonacci sequence defined by this formula:\n\
    $Fn = \\begin{pmatrix}1 & 1 \\ 1 & 1 \\end{pmatrix}^{n-1} F{n-2}$", "    if n<4\
    \ then 0 else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", "    if n <=\
    \ 1\n        0\n    else if n == 2\n        1\n    else if n == 3\n        1\n\
    \    else\n        fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n   \
    \ end\nend\nfib4(5)\n</cell>\n<text>\nFibonacci number in Julia\nJulia also has\
    \ a similar function called fib(n).  It has some benefits over Python since it\
    \ compiles so efficiently.", "        if n < 0\n            error(\"fib4 only\
    \ takes positive integers\")\n        elif n < 1\n            return 0\n     \
    \   elif n == 0\n            return 0\n        elif n == 1\n            return\
    \ 0\n        elif n == 2\n            return 2\n        elif n == 3\n        \
    \    return 0\n        elif n == 4\n            return 0\n        \n        else\
    \ \n            return (fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4))", "\tif\
    \ n <= 0 \n\t\tthen 0\n\telse if n == 1 \n\t\tthen 0\n\telse if n == 2\n\t\tthen\
    \ 2\n\telse if n == 3\n\t\tthen 0\n\telse fib(n - 3) + fib(n - 2) + fib(n - 1)\
    \ + fib(n-1)\nend\nfib4(3)\n</cell>\n<code language=julia-1.6>\n\"\"\"\n    The\
    \ Fibonacci sequence is a sequence of numbers where each number is the sum of\
    \ the two preceding ones:\n    fib(0) = 0\n    fib(1) = 1\n    fib(2) = 1\n  \
    \  fib(n) = (fib(n-1) + fib(n-2))/2\n    Please write a function to efficiently\
    \ compute the n-th element of the Fibonacci sequence.  Do not use recursion.\n\
    \    >>> fib(5)\n    3\n    >>> fib(6)\n    8\n    >>> fib(7)\n    13\n    \"\"\
    \"", "    if n==1 then 1 else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    end", "    \n    if n == 0 \n        1\n    else \n        fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)", "    if n == 0 return 0\n    if n == 1 return 1\n\
    \    if n == 2 return 2\n    if n == 3 return 0\n    return fib4(n - 4) + fib4(n\
    \ - 3) + fib4(n - 2) + fib4(n - 1)\nend", "    if n == 0 || n == 1 then return\
    \ n\n    else if n < 2 then return fib4(n - 1) + fib4(n - 2)\n    else return\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend\nfib4(13)", "   \
    \ if n == 0 || n == 1\n        return n\n    elseif n == 2\n        return fib4(n-1)+fib4(n-2)\n\
    \    else\n        return fib4(n-3)+fib4(n-4)+fib4(n-2)+fib4(n-1)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI like this solution, for its readability and compact nature.\n\
    <|/ c |>\n<| c |>\nThank you very much! This is very helpful\n<|/ c |>\n<| c |>\n\
    Nice. Could you also point out why it works?\n<|/ c |>\n<| c |>\nThis looks like\
    \ a recursive function, but it's not recursive itself. So it could be a loop in\
    \ a loop.\n<|/ c |>\n<| a tags=julia |>\nI used the idea from here and adapted\
    \ it for my purposes. The implementation is as follows:\n<code>\nfib4_nums = Array{Int64}(undef,\
    \ 4)\nfib4_nums[1] = 0\nfib4_nums[2] = 1\nfib4_nums[3] = 0\nfib4_nums[4] = 0\n\
    fib4_nums[5] = 2", "    if n == 0\n    then 0\n    else if n == 1\n    then 0\n\
    \    else if n == 2\n    then 2\n    else if n == 3\n    then 0\n    else fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend", "    if n == 0\n    then\
    \ 0\n    else if n == 1\n    then 0\n    else if n == 2\n    then 2\n    else\
    \ if n == 3\n    then 0\n    else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    end\nfib4(n)\n</cell>\n<text>\nExercise 10\nWrite a function that computes the\
    \ n-th element of the Fibonacci sequence.  It should accept a positive integer\
    \ and return the number of the n-th element of the sequence.\nFor n = 10, your\
    \ function should return 30.\nFor n = 5, your function should return 21.\nFor\
    \ n = 1, your function should return 0.", "    if n==1 \n        0\n    else \n\
    \        if n==2 \n            0\n        else \n            if n==3 \n      \
    \          0\n            else \n                if n==4 \n                  \
    \  0\n                else \n                    fib4(n - 4) + fib4(n - 3) + fib4(n\
    \ - 2) + fib4(n - 1)\n</code>\n<|/ a tags=numbers,algorithm,math,fibonacci,fibonacci-heap\
    \ dscore=1 |>\n<| c |>\nThis is much more elegant than the recursive implementation\
    \ I gave. My code would take a lot of time to run. Thanks a lot.\n<|/ c |>\n<|\
    \ a tags=numbers,algorithm,math,fibonacci,fibonacci-heap |>\nFor a small N (say,\
    \ n=100), you can compute the Fibonacci numbers in a loop as follows:\n<code>\n\
    def fibo(n):\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a+b\n\
    \    return b", "    \n    if n==0 return 0\n    if n==1 return 0\n    if n==2\
    \ return 2\n    if n==3 return 0\n    if n>3 return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4) \nend\nfib4(10)\n</cell>\n<text>\nPart 7: Dynamic programming algorithm\
    \ for Fibonacci number\nFibonacci number is a number sequence defined by the recurrence\
    \ relation\n$$fib{n}(0)=0$$\n$$fib{n}(1)=1$$\n$$fib{n}(n)=fib{n-1}+fib{n-2}$$\n\
    We could write this recursively as follows", "    if n==0 return 0\n    if n==1\
    \ return 1\n    if n==2 return 2\n    if n==3 return 0\n    return fib4(n-1) +\
    \ fib4(n-2) + fib4(n-3) + fib4(n-4)", "    if n == 0 then return 0\n    if n ==\
    \ 1 then return 0\n    if n == 2 then return 2\n    if n == 3 then return 0\n\
    \    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\n</cell>\n<text>\n\
    Problem 4\nThe Fibonacci sequence is a sequence of integers defined as follows:\n\
    \    fib(0) = 0\n    fib(1) = 1\n    fib(n) = fib(n-1) + fib(n-2) for n >= 2.\n\
    \    For example, fib(3) = fib(2) + fib(1) = 1 + 1 = 2.\n    \n    Write a function\
    \ that computes the n'th term in the Fibonacci sequence.  A recursive function\
    \ will work here.\n    >>> fib2(5)\n    5\n    >>> fib2(6)\n    8\n    >>> fib2(7)\n\
    \    13\n    \"\"\"", "    \"\"\"fib4(n) \"\"\"\n    if n<4\n        0\n    else\n\
    \        fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n    end\nend\n</cell>\n<text>\n\
    Write a function named fib4 that takes an integer $n$ and returns the n-th element\
    \ of the fib4 number sequence. For example, fib4(5) should return 4.", "  if n\
    \ == 0 || n == 1 \n    then 0\n  else if n == 2\n    then 2\n  else \n    fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)", "    if n == 0\n        0\n    else if\
    \ n == 1\n        0\n    else if n == 2\n        2\n    else if n == 3\n     \
    \   0\n    else\n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend \n\
    </code>\n<|/ a |>\n<| c |>\nWhile the algorithm isn't wrong, it's definitely not\
    \ the most efficient, and it doesn't even compile. You have a semicolon in `fib4(5));`\n\
    <|/ c |>\n<| c |>\nThanks Hackerrank is very helpful indeed - I will try it tomorrow\
    \ to see if it's working but this is great thanks for posting!\n<|/ c |>\n<| c\
    \ |>\nSurely this should be `fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)` instead\
    \ of `fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)`.\n<|/ c |>\n<| c |>\nThanks.\
    \ I've fixed the answer\n<|/ c |>\n<| c |>\n, thanks for the catch! I added the\
    \ end bracket.\n<|/ c |>\n<| a tags=math,haskell,fibonacci |>\n<code>\nfib4 ::\
    \ Int -> Int\nfib4 n = fib (n-1) + fib (n-2)", "    \"\"\"Recursive Fibonacci\
    \ number computation\"\"\"\n    if n == 1 \n        0\n    else if n == 2 \n \
    \       1\n    else \n        fib4(n-1) + fib4(n-2) \n    return fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n\
    end", "  if n < 4 \n    n else fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n\
    \ - 1)\n  else\n    n \nend\n</code>\nThis solution uses the function fib4 which\
    \ can be defined using the function fib4 or using the function fib4.  In the second\
    \ case, it can be defined as a local function fib4.\n<|/ a |>\n<| c |>\nThis is\
    \ not an appropriate use of `if` statements. A `return end` statement is more\
    \ appropriate. Additionally, `fib4` does not return `fib4`.\n<|/ c |>\n<| c |>\n\
    In `if n < 4; n else end`, what is `end` supposed to be?\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere is some code that will solve the problem using recursion.\n<code>",
  "    if n == 0 || n == 1\n        return n\n    else\n        return fib4(n - 1)\
    \ + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)", "    if n < 4 then return n\n  \
    \  else return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) \nend\nfib4(n::Int64)::Int64\
    \ = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nfib4(n::Int64)::Int64 = fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nfib4(n::Int64)::Int64 = fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\nfib4(n::Int64)::Int64 = fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\nfib4(n::Int64)::Int64 = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    fib4(n::Int64)::Int64 = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nfib4(n::Int64)::Int64\
    \ = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nfib4(n::Int64)::Int64 = fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nfib4(n::Int64)::Int64 = fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\nfib4(n::Int64)::Int64 = fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\nfib4(n::Int64)::Int64 = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    fib4(n::Int64)::Int64 = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nfib4(n::Int64)::Int64\
    \ = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nfib4(n::Int64)::Int64 = fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nfib4(n::Int64)::Int64 = fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)", "    if n == 0\n    then return 0\n    else if n ==\
    \ 1\n    then return 1\n    else if n == 2\n    then return 2\n    else if n ==\
    \ 3\n    then return 0\n    else return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\
    \ \nend\n</cell>\n<code language=julia-0.6>\n@time fib4(7)\n</cell>\n<text>\n\
    Part 2\nWrite a function to compute the n-th element of the Fibonacci sequence\
    \ using memoization.", "    if n == 0\n        0\n    else if n == 1\n       \
    \ 1\n    else if n == 2\n        2\n    else if n == 3\n        0\n    else\n\
    \        fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\nend", "    if\
    \ n <= 0\n        0\n    elif n <= 2\n        0\n    else\n        fib4(n-1) +\
    \ fib4(n-2) + fib4(n-3) + fib4(n-4)\n    end \nend\n</cell>\n<code language=julia-0.6>\n\
    @time fib4(200);\n@time fib4(200000); \n</cell>\n<text>\nProblem 4\nWrite a function\
    \ to compute the n'th element of the Fibonacci sequence.  Do not use recursion.\n\
    For n = 0, return 0.\nFor n = 1, return 1.\nFor n = 2, return 2.\nFor n = 3, return\
    \ 3.\nFor n = 4, return 5.\nFor n = 5, return 8.\nFor n = 6, return 13.\nFor n\
    \ = 7, return 21.\nFor n = 8, return 34.\nFor n = 9, return 55.\nFor n = 10, return\
    \ 89.\nFor n = 10, return 144.\nFor n = 11, return 233.\nFor n = 12, return 376.\n\
    For n = 13, return 610.  ", "  if n < 4\n  then 0\n  else fib4(n - 1) + fib4(n\
    \ - 2) + fib4(n - 3) + fib4(n - 4)\nend \n</cell>\n<cell>\n%run \"readonly/fib4_code.v\"\
    \n</cell>\n<text>\nThe Fibonacci numbers are the numbers in the following sequance\
    \ that are the sum of the two preceding ones:", "    if n < 2 then return 0 \n\
    \    else return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) \nend \nfib4(5)\n\
    </cell>\n<text>\nFibonacci numbers in the interval $[0,1)$ are denoted using the\
    \ formula $F_n = F_{n-1} + F_{n-2}$, where $F_0 = 0$ and $F_1 = 1$.  This is called\
    \ Euler's formula because it comes out to $n$-th number $F_n$, where $F_0$ and\
    \ $F_1$ are both $0$.  The formulas are simple enough for computers to compute\
    \ fast; no matter how many digits you use, computing $F_n$ will take a fixed amount\
    \ of time, regardless of how big n is.  Note that this formula is unique for $F_n\
    \ > 0$.  It is not unique for $F_n < 0$, however.", "    if n == 0\n        0\n\
    \    else if n == 1\n        0\n    else if n == 2\n        2\n    else if n ==\
    \ 3\n        0\n    else \n        fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\nend\nfib4(5) #doctest:+ELLIPSIS\n4", "    if n == 0 \n        0\n    else\
    \ if n == 1 \n        1\n    else if n == 2 \n        2\n    else if n == 3 \n\
    \        0\n    else if n == 4 \n        2\n    else if n == 5 \n        3\n \
    \   else if n == 6 \n        4\n    else if n == 7 \n        5\n    else if n\
    \ == 8 \n        6\n    else if n == 9 \n        7\n    else if n == 10 \n   \
    \     8\n    else if n == 11 \n        9\n    else if n == 12 \n        10\n \
    \   else if n == 13 \n        11\n    else if n == 14 \n        12\n    else if\
    \ n == 15 \n        13\n    else if n == 16 \n        14\n    else if n == 17\
    \ \n        15\n    else if n == 18 \n        16\n    else if n == 19 \n     \
    \   17\n    else if n == 20 \n        18\n    else if n == 21 \n        19\n \
    \   else if n == 22 \n        20\n    else if n == 23 \n        21\n    else if\
    \ n == 24 \n        22\n    else if n == 25 \n        23\n    else if n == 26\
    \ \n        24\n    else if n == 27 \n        25\n    else if n == 28 \n     \
    \   26\n    else if n == 29 \n        27\n    else if n == 30 \n        28\n \
    \   else if n == 31 \n        29\n    else if n == 32 \n        30\n    else if\
    \ n == 33 \n        31\n    else if n == 34 \n        32\n    else if n == 35\
    \ \n        33\n    else if n == 36 \n        34\n    else if n == 37 \n     \
    \   35\n    else if n == 38 \n        36\n    else if n == 39 \n        37\n \
    \   else if n == 40 \n        38\n    else if n == 41 \n        39\n    else if\
    \ n == 42 \n        40\n    else if n == 43 \n        41\n    else if n == 44\
    \ \n        42\n    else if n == 45 \n        43\n    else if n == 46 \n     \
    \   44\n    else if n == 47 \n        45\n    else if n == 48 \n        46\n \
    \   else if n == 49 \n        47\n    else if n == 50 \n        48\n    else if\
    \ n == 51 \n        49\n    else if n == 52 \n        50\n    else if n == 53\
    \ \n        51\n    else if n == 54 \n        52\n    ", "    if n == 0\n    \
    \    0\n    elseif n == 1\n        0\n    elseif n == 2\n        2\n    elseif\
    \ n == 3\n        0\n    else\n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    \    end\nend\n</code>\n<|/ a |>\n<| a |>\nHere is another O(n) solution using\
    \ only loops and no recursion (using only base cases):\n<code>\nfib4(n) = \n \
    \ begin\n    if n < 4\n      return n\n    end", "    if n <= 0\n        0\n \
    \   else if n == 1\n        0\n    else if n == 2\n        2\n    else if n ==\
    \ 3\n        0\n    else\n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    </code>\n<|/ a tags=recursion,fibonacci,big-o,asymptotic-complexity,time-complexity\
    \ |>\n<| a |>\nI agree with David's answer. However, if you use dynamic programming\
    \ you can get better performance than a recursive function. I wrote up a quick\
    \ python program to benchmark the two methods:\n<code>\nimport timeit\nimport\
    \ random\nimport numpy as np", "    if n < 0\n        error(\"fib4 function expects\
    \ a positive integer, got $n\")\n    fib4(0)\n    fib4(1)\n    fib4(2)\n    fib4(3)\n\
    \    fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\nend\n</code>\nfib4 can be done with\
    \ just a simple for loop:\n<code>", "    if n == 0 \n        0\n    else if n\
    \ == 1\n        0\n    else if n == 2\n        2\n    else if n == 3\n       \
    \ 0\n    else \n        fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n\
    end\n</cell>\n<text>\nExercise 7: fib4_range\nWrite a function fib4_range that\
    \ takes one parameter $n$ and returns a vector with $n$ fib4 numbers in the range\
    \ of $0$ to $n$.\nFor example fib4_range(9) should return [0, 0, 0, 1, 1, 1, 2,\
    \ 2, 3, 4, 4, 5].\nYou may write fib4_range in several different ways. The following\
    \ examples show the ways to do it.\nNote that none of the examples below will\
    \ work for $n=5$", "    if n == 1 then 0\n    else fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)\nend\n</code>\nThe solution:\n<code>\nfib4(4)\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nfib4 does not have a 4th element at all as stated\
    \ in the question\n<|/ c |>\n<| c |>\n: fib4 has a 4th element -- it just doesn't\
    \ have a 4th element.  It *does* have a 3rd; see `fib4(3)`.\n<|/ c |>\n<| c |>\n\
    I didn't downvote, but I suspect it's because your answer says \"Don't use recursion\"\
    . That's not what the question says: \"Please write a function to efficiently\
    \ compute the n-th element of the fib4 number sequence.\" Also you shouldn't use\
    \ `Int` when `Integer` is available.\n<|/ c |>\n<| c |>\nAh, sorry I missed that,\
    \ I thought it said \"fib 4 number sequence\" as opposed to \"fib 4\" which would\
    \ make it a better answer. Your correct on the Int vs Integer, good catch.\n<|/\
    \ c |>\n<| c |>\nI don't think this is a good answer. The question asks for efficiency\
    \ and not for understanding.\n<|/ c |>\n<| a dscore=2 |>\nHere is my version :\n\
    <code>", "if n < 0\n    return 0\nelif n == 1\n    return 0\nelif n == 2\n   \
    \ return 2\nelif n == 3\n    return 0\nelse\n    return fib4(n - 1) + fib4(n -\
    \ 2) + fib4(n - 3) + fib4(n - 4)\nend\nend", "    if n == 0 then 0 else fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nIf you're open to using modules, you can also use Lua:\n<code>\n\
    fib4 = function() return math.fib(4); end\nfib4.fib4 = function() return fib4();\
    \ end\nfib4.fib4.fib4 = function() return fib4.fib4(); end\nfib4.fib4.fib4.fib4\
    \ = function() return fib4.fib4.fib4(); end\nfib4.fib4.fib4.fib4.fib4 = function()\
    \ return fib4.fib4.fib4.fib4(); end\n</code>\nThat way, you only need to type\
    \ fib4.fib4.fib4.fib4.fib4 if you want it. If you only want a single fib4, you\
    \ only have to type fib4.fib4 or fib4.fib4.fib4 or even fib4.fib4.fib4.fib4 in\
    \ Lua 5.2+ with __index. You also don't have to type the whole thing out in full.\n\
    <|/ a dscore=1 tags=functional-programming,algorithm,recursion,fibonacci,julia\
    \ |>\n<| a tags=functional-programming,algorithm,recursion,fibonacci,julia |>\n\
    Here is a recursive solution that returns the nth Fibonacci number:\n<code>",
  "    if n == 0 \n        0\n    else \n        if n == 1 \n            0\n     \
    \   else \n            if n == 2 \n                2\n            else \n    \
    \            if n == 3 \n                    0\n                else \n      \
    \              if n == 4 \n                        4\n                    else\
    \ \n                        fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n -\
    \ 4)\n</code>\n<|/ a tags=fibonacci,recursion,julia |>\n<| a tags=fibonacci,recursion,julia\
    \ |>\nA recursive formulation of the fib function\n<code>\nfib(n) = fib(n \u2212\
    \ 1) + fib(n \u2212 2)\n</code>\n<|/ a dscore=4 |>\n<| c |>\nIt would be good\
    \ to include some explanatory commentary to explain why this answers the question.\
    \  As it stands, it could be dangerous.\n<|/ c |>\n<| c |>\nThe fib(n) part is\
    \ where you compute the next value in the fibonacci sequence. The '-' means subtraction,\
    \ and '1' means the second part of the fibonacci sequence. Subtracting one from\
    \ the original number gives you the next value in the sequence.\n<|/ c |>\n<|\
    \ a dscore=4 |>\nThe recursive method of computing fibonacci sequence is O(2^n).\
    \ Here is an example which computes fibonacci numbers up to 10^7. \n<code>", " \
    \   if n == 0\n        0\n    else if n == 1\n        0\n    else if n == 2\n\
    \        2\n    else if n == 3\n        0\n    else if n == 4\n        4\n   \
    \ else if n == 5\n        0\n    else if n == 6\n        0\n    else if n == 7\n\
    \        0\n    else if n == 8\n        8\n    else if n == 9\n        0\n   \
    \ else if n == 10\n        0\n    else if n == 11\n        0\n    else if n ==\
    \ 12\n        0\n    else if n == 13\n        0\n    else if n == 14\n       \
    \ 0\n    else if n == 15\n        0\n    else if n == 16\n        0\n    else\
    \ if n == 17\n        0\n    else if n == 18\n        0\n    else if n == 19\n\
    \        0\n    else if n == 20\n        0\n    else if n == 21\n        0\n \
    \   else if n == 22\n        0\n    else if n == 23\n        0\n    else if n\
    \ == 24\n        0\n    else if n == 25\n        0\n    else if n == 26\n    \
    \    0\n    else if n == 27\n        0\n    else if n == 28\n        0\n    else\
    \ if n == 29\n        0\n    else if n == 32\n        0\n    else if n == 33\n\
    \        0\n    else if n == 34\n        0\n    else if n == 35\n        0\n \
    \   else if n == 36\n        0\n    else if n == 37\n        0\n    else if n\
    \ == 38\n        0\n    else if n == 39\n        0\n    else if n == 40 \n   \
    \     0\n    else if n == 41 \n        0\n    else if n == 42\n        0\n   \
    \ else if n == 43\n        0\n    else if n == 44\n        0\n    else if n ==\
    \ 45\n        0\n    else if n == 46\n        0\n    else if n == 47\n       \
    \ 0\n    else if n == 48\n        0\n    else if n == 49\n        0\n    else\
    \ if n == 50 \n        0\n    else if n == 51 \n        0\n    else if n == 52\n\
    \        0\n    else if n == 53\n        0\n    else if n == 54\n        0\n \
    \   else if n == 55\n        0\n    else if n == 56\n        0\n    else if n\
    \ == 57\n        0\n    else if n == 58\n        ", "    if n == 0 || n == 1 \n\
    \        then 0\n    else \n        fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou mean to\
    \ say that there is no direct way to compute sum of fibonacci series in O(1) time\
    \ in Julia. right?\n<|/ c |>\n<| c |>\nYes, you can't get to O(1) time with any\
    \ type of recursion.\n<|/ c |>\n<| c |>\nThe point is that this solution runs\
    \ in O(2^n) time because it uses a recursive algorithm, and for Fibonacci numbers\
    \ that is O(2^n), not O(1), (which is what your recursive solution is doing).\n\
    <|/ c |>\n<| c |>\nYeah, I realise that, but if you look at the code (which I\
    \ posted), you can see that the algorithm doesn't use recursion at all. Also,\
    \ it doesn't use a for loop, which is generally preferable in Julia\n<|/ c |>\n\
    <| a dscore=0 |>\nI realise that this is an old question, but I had to look up\
    \ this problem for myself. \nHere's a solution using some Julia tricks (which\
    \ I won't get into here, but feel free to ask if you want). \n<code>", "    if\
    \ n == 0 return 0\n    if n == 1 return 1\n    if n == 2 return 2\n    if n ==\
    \ 3 return 0\n    if n == 4 return 0\n    return fib4(n - 4) + fib4(n - 3) + fib4(n\
    \ - 2) + fib4(n - 1)\n</code>\n<|/ a tags=fibonacci,haskell |>\n<| c |>\nYour\
    \ `fib4` function will blow up with the recursion depth on large `n`s. A tail-recursive\
    \ version can be done in a few lines: `fib4 n = fib4' 0 1 2 3 4 5 (n - 1) n`,\
    \ and the recursive function is `fib4' a b c d e f n m = if n == m then a else\
    \ fib4' (a + b) (c + d) (e+f) n (n - 1) m`\n<|/ c |>\n<| c |>\n- thank you for\
    \ your comment, I've edited my answer to show a tail recursive version of the\
    \ fib4 function\n<|/ c |>\n<| c |>\nWhy don't you just use `fibs = fib <*> tail\
    \ fibs`?\n<|/ c |>\n<| a dscore=5 |>\nHow about this?  I believe this should work...\n\
    <code>\nfibs n = let f1 = 1 : f2 = 0 : map (+) f1 f2 in f1 : f2\n</code>\n<|/\
    \ a tags=fibonacci,haskell |>\n<| c |>\n`fibs` is tail-recursive so it doesn't\
    \ need to use a thunk. `fibs1 = 1 : fibs2 = 0 : map ...` is much better than `fibs1\
    \ = fibs2 = 1 : map ...`, especially when the second version blows up as soon\
    \ as `n` gets big.\n<|/ c |>\n<| a |>\nHere's a tail-recursive version of's answer:\n\
    <code>\nfibs n = let f1 = 1 : f2 = 0 : map (+) f1 f2 in f1 : f2\n</code>\nI prefer\
    \ this over a version with if ... else ... (which can be more verbose), but that's\
    \ personal preference.\n<|/ a tags=fibonacci,haskell dscore=5 |>\n<| a dscore=4\
    \ tags=fibonacci,haskell |>\nHere is my solution in pseudocode using only two\
    \ arguments: the first one is the number you want to get the fibonacci number\
    \ of, and the second one is the place where you want to put the first number:\n\
    <code>\nfibonacci (int n) place = \n    if place == 1 then 1\n    else ", "  \
    \  if n == 0 \n        0\n    else if n == 1 \n        0\n    else if n == 2 \n\
    \        2\n    else if n == 3 \n        0\n    else \n        fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4) \n    \nfib4(n) = fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\nfib4\n</cell>\n<code language=julia-1.0>", "    if n == 0 || n\
    \ == 1\n        0\n    elseif n == 2\n        2\n    elseif n == 3\n        0\n\
    \    elseif n == 4\n        4\n    elseif n == 5\n        8\n    elseif n == 6\n\
    \        16\n    else\n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)",
  "        if n == 0\n            0\n        elseif n == 1\n            1\n      \
    \  else\n            fib4(n-2) + fib4(n-3)\n        end\n    end", "    if n ==\
    \ 0 || n == 1 \n        then \n            return 0\n    elif n == 2 \n      \
    \  then \n            return 1\n    elif n == 3 \n        then \n            return\
    \ 2\n    else \n        then \n            return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n</code>\n<|/ a |>\n<| c |>\nYour code is incorrect `fib4(0)` should\
    \ return 0.\n<|/ c |>\n<| c |>\nThanks, I fixed it now\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>", "    if n < 0 \n        error(\"fib4 only accepts positive numbers\"\
    )\n    elif n == 0 \n        0\n    else \n        fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n</code>\n<|/ a |>\n<| a tags=math,algorithm,fibonacci,language-agnostic\
    \ |>\nThe naive solution is O(n) on average, but this could be improved. \n<code>\n\
    int Fib(int n)\n{\n  if (n == 0)\n    return 0;\n  else if (n == 1)\n    return\
    \ 1;\n  else if (n == 2)\n    return 2;", "if n == 0 \n    0 \nelse if n == 1\
    \ \n    0 \nelse if n == 2 \n    2 \nelse if n == 3 \n    0 \nelse if n == 4 \n\
    \    4 \nelse if n == 5 \n    1 \nelse if n == 6 \n    3 \nelse if n == 7 \n \
    \   5 \nelse if n == 8 \n    7 \nelse if n == 9 \n    9 \nelse if n == 10 \n \
    \   11 \nelse \n    fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) \nend\n</code>\n\
    <|/ a tags=fibonacci,julia,performance |>\n<| c |>\nHi, please don't forget to\
    \ [format your code blocks](https://meta.stackexchange.com/questions/22186/how-do-i-format-my-code-blocks)\
    \ by highlighting it and clicking the `{}` button on the toolbar.\n<|/ c |>\n\
    <| c |>\nThank you for sharing your code. While this code may solve the question,\
    \ [including an explanation](https://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ of how and why this solves the problem would really help to improve the quality\
    \ of your post, and probably result in more up-votes. Remember that you are answering\
    \ the question for readers in the future, not just the person asking now. Please\
    \ edit your answer to add explanations and give an indication of what limitations\
    \ and assumptions apply.\n<|/ c |>\n<| c |>\nSorry for the delayed answer. I will\
    \ edit the answer to add further explanations.\n<|/ c |>\n<| a tags=fibonacci,julia,performance\
    \ |>\nHere is a solution using Memoization.\n<code>\n# Fibonacci function", " \
    \   if n == 0 || n == 1 || n == 2 || n == 3 || n == 4\n    then 0\n    else fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n    end \nend", "    if n ==\
    \ 0\n        0\n    else if n == 1\n        1\n    else if n == 2\n        2\n\
    \    else if n == 3\n        0\n    else\n        fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n    end\nend\n</cell>\n<text>\nProblem 7\nWrite a Julia function\
    \ fib5 that returns the Fibonacci number for n (starting from 0). \nExample: for\
    \ n = 5 we return 5.\n>>> fib5(1)\n1\n>>> fib5(2)\n1\n>>> fib5(3)\n2\n>>> fib5(4)\n\
    3\n>>> fib5(5)\n5\n>>> fib5(6)\n8\n>>> fib5(7)\n13\n>>> fib5(8)\n21\n>>> fib5(9)\n\
    34\n>>> fib5(10)\n55\n>>> fib5(11)\n89\n>>> fib5(12)\n144\n>>> fib5(13)\n233\n\
    >>> fib5(14)\n377\n>>> fib5(15)\n610\n>>> fib5(16)\n987\n>>> fib5(17)\n1597\n\
    >>> fib5(18)\n2584\n>>> fib5(19)\n4181\n>>> fib5(20)\n6765\n>>> fib5(21)\n10946\n\
    >>> fib5(22)\n17711\n>>> fib5(23)\n28657\n>>> fib5(24)\n46368\n>>> fib5(25)\n\
    75025\n>>> fib5(26)\n1213983\n>>> fib5(27)\n1964181\n>>> fib5(28)\n3178113\n>>>\
    \ fib5(29)\n5142293\n>>> fib5(30)\n8320439\n>>> fib5(31)\n13462691\n>>> fib5(32)\n\
    21783097\n>>> fib5(33)\n35245781\n>>> fib5(34)\n57028874\n>>> fib5(35)\n92274651\n\
    >>> fib5(36)\n149303520\n>>> fib5(37)\n241578165\n>>> fib5(38)\n390888451\n>>>\
    \ fib5(39)\n632459863\n>>> fib5(40)\n102334151\n>>> fib5(49)\n165580141\n>>> fib5(50)\n\
    -941836218\n>>> fib5(51)\n-929265756\n>>> fib5(52)\n-926054566\n>>> fib5(53)\n\
    -918254026\n>>> fib", "    if n == 0 || n == 1 || n == 2 || n == 3 || n == 4\n\
    \        0\n    else\n        fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    \    end\nend\n</cell>\n<text>\nExercise 4:"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
