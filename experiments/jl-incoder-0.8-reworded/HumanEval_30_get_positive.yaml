name: HumanEval_30_get_positive
language: jl
prompt: "\"\"\"Return only positive numbers in the vector.\n    >>> get_positive([-1,\
  \ 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0,\
  \ 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\nfunction get_positive(l::Vector{Int64})::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = get_positive;\n\t@test(candidate([-1,\
  \ -2, 4, 5, 6]) == [4, 5, 6])\n\t@test(candidate([5, 3, -5, 2, 3, 3, 9, 0, 123,\
  \ 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1])\n\t@test(candidate([-1, -2]) == Vector{Int64}([]))\n\
  \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
completions: ["    return filter(i -> i>=0, l)\nend\n</cell>\n<code language=julia-1.6>\n\
    # Example of calling the function\n\"\"\"\nPass in a vector and filter out negative\
    \ values\n\"\"\"", " \n    if length(l)==0\n        return l\n    end\n    \n\
    \    # find first positive number\n    i = 0\n    while i < length(l)\n      \
    \  if l[i] >= 0\n            l[i] = l[i] + length(l)\n            break\n    \
    \    end\n        i += 1\n    end\n    return l\nend", "    return filter(x ->\
    \ x >= 0, l)\nend", "    return filter( x -> x > 0, l)\nend", "    return filter!(x\
    \ -> x > 0, l)\nend \n</cell>\n<cell>\n@doc test_get_positive\n</cell>\n<text>\n\
    5.2. get_negative(l):", "    if sum(l)<0\n        return copy(l)\n    else\n \
    \       return filter(v->v>0, l)\n    end\nend\n</code>\nIn a more concise and\
    \ less readable style, you could write:\n<code>", "    idx = find(l .> 0)\n  \
    \  l .-= idx\n    l\nend", "    positive = Vector{Int64}()\n    positive.push!(-x\
    \ for x in l)\n    return positive\nend\n</cell>\n<text>\nExercise\nWrite a function\
    \ that returns all numbers greater than 10 in a vector.", "    if l == [] \n \
    \       return [] \n    end\n    positive = []\n    for x in l \n        if x\
    \ > 0 \n            push!(positive, x)\n        end \n    end \n    return positive\n\
    end ", "    positive=filter(x -> x > 0, l)\n    positive\nend\n</code>\nFor your\
    \ original question and as long as you keep it simple this should work fine. \n\
    <code>", "    pos = Vector{Int64}(zeros(length(l)))\n    for (i, value) in enumerate(l)\
    \ \n        if value > 0 \n            pos[i] = value \n        else \n      \
    \      pos[i] = 0 \n        end\n    end\n    return pos\nend", "    positive_list\
    \ = filter(positive, l)\n    return positive_list\nend\n</cell>\n<code language=julia-1.0>\n\
    # Let's test our functions\nprintln(get_positive([-1, 2, -4, 5, 6]))\nprintln(get_positive([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n</cell>\n<text>\n4. Filter out negative\
    \ numbers from the vector", "    return [x for x in l if x > 0]\nend\n</cell>\n\
    <code language=julia-1.2>", "    if is_positive(l)\n    else\n        l\n    end\n\
    end\n</cell>\n<text>\nWrite a function to return the last value in a vector. For\
    \ example:", "    return filter(x -> x > 0, l)\nend\n</cell>\n<text>\nLet's try\
    \ it out.", "    l = l .> 0 .& l .< Inf .| l .== Inf \n    sort(l)\n    l\nend",
  "    positive = Vector{Int64}()\n    for x in l\n        if x>0\n            push!(positive,x)\n\
    \        end\n    end\n    positive\nend\n</cell>\n<code language=julia-1.5>",
  "    s = zero(eltype(l))\n    for x in l\n        if x > 0\n            s = s +\
    \ x\n        end\n    end\n    return s\nend", "    v = [i for i in l if i>0]\n\
    \    return v\nend\n</cell>\n<text>\nThe function get_positive() has two outputs:\
    \ the positive numbers in the vector and the vector of their indices. Let's test\
    \ it.", "    v1 = filter(l==>i>0, l)\n    return v1 \nend", "  result = []\n \
    \ for elem in l\n    if elem > 0\n      push!(result, elem)\n    end\n  end\n\
    \  result\nend\n</cell>\n<code language=julia-0.4>", "    if l == [] || l == [1]\n\
    \        return l\n    elseif l[1] == 0\n        return l\n    else\n        return\
    \ get_positive(filter(i -> i > 0, l))\n    end\nend", "    return filter(x ->\
    \ x > 0, l)\nend\n</cell>\n<code language=julia-1.0>\nget_positive([-1, 2, -4,\
    \ 5, 6])\n</cell>\n<code language=julia-1.0>\nget_positive([5, 3, -5, 2, -3, 3,\
    \ 9, 0, 123, 1, -10])\n</cell>\n<text>\nExercise: Find the positive numbers in\
    \ an array (using filter).", "    positive = []\n    for v in l\n        if v\
    \ >= 0\n            push!(positive, v)\n        end\n    end\n    positive\nend\n\
    </cell>\n<text>\nQuestion 9: Get all unique elements in a list.", "    return\
    \ filter(x -> x > 0, l)\nend\n</cell>\n<code language=julia-1.0>", " \n    if\
    \ l == Int64[]\n        return Int64[]\n    end", "    pos = []\n    for v in\
    \ l\n        pos = [v if v > 0 else v]\n    end\n    return pos\nend", "    positives\
    \ = filter(x -> x >= 0, l)\n    return positives\nend\n</cell>\n<code language=julia-1.5>\n\
    \"\"\"\nGet all numbers that are divisible by 2, in the vector.\nThe order matters.\n\
    \"\"\"", "\tl2 = sort(l)\n\t\n\tr = []\n\tfor i=1:length(l2)\n\t\tif  l2[i]>0\n\
    \t\t\tpush!(r, l2[i])\n\t\tend\n\tend\n\t\n\treturn r\nend\n</cell>\n<code language=julia-1.0>",
  "    pos = filter(x -> x >= 0, l)\n    pos = reverse(pos)\n    return pos\nend",
  "\tresult = zeros(size(l))\n\tfor i = 1:length(l)\n\t\tif l[i] > 0 && l[i] < Int64(-1)\n\
    \t\t\tresult[i] = l[i]\n\t\telse\n\t\t\tresult[i] = 0\n\t\tend\n\tend\n\treturn\
    \ result\nend", "    idx = copy(l)\n    idx[idx .< 0] = -1\n    return idx\nend ",
  "    return filter(x -> x > 0, l)\nend", "    pos = collect(l:view(Vector{Int64}))\
    \ do x\n        x .> 0 && x .>= 0\n    end\n    return pos\nend\n</cell>\n<text>\n\
    Exercise: What is the result of the following code?", "    if l==[]\n        return\
    \ l\n    end\n    l1 = copy(l)\n    find!(l1, (x -> x > 0), 1)\n    return l1\n\
    end\n</cell>\n<text>\nWe see that $n\\geq 0$ must hold for all elements of $a$.\
    \ Since we can't change our input $a$, we must return a copy of a given $a$ where\
    \ we remove all elements not positive.", "    for i in l\n        if i > 0\n \
    \           return i\n    end\n    return l \nend \n</cell>\n<text>\nReturn only\
    \ the negative numbers in the vector.", "    return [ x if x > 0 else 0 for x\
    \ in l ] \nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "    idx::Int64 = 0\n   \
    \ lp = Vector{Int64}(idx)\n    idx::Int64 = 0\n    while idx < length(l) && l[idx]\
    \ <= 0\n        idx+=1\n        lp[idx] = l[idx]\n    end\n    lp\nend\n</cell>\n\
    <code language=julia-1.3>", "    res=copy(l)\n    positive=0\n    for e in l \n\
    \        if e >=0\n            positive+=1\n        else\n            delete!(res,positive)\n\
    \        end\n    end\n    return res\nend\n</cell>\n<text>\nLet's see how it\
    \ works:", "    return filter(x->x>0, l)\nend\n</cell>\n<code language=julia-1.0>\n\
    # test it out\n@test get_positive([-1, 2, -4, 5, 6]) == [2, 5, 6]\n@test get_positive([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 9, 123, 1]\n</cell>\n<code\
    \ language=julia-1.0>\n# get rid of negative numbers", "    \n    positive=[]\n\
    \    for value in l\n        if value > 0\n            push!(positive, value)\n\
    \        end\n    end\n    return positive\nend\n</cell>\n<text>\nNotice that\
    \ the function get_positive has type signature, ::Vector{Int64}, but does not\
    \ return anything. This is because we are only interested in the positive numbers,\
    \ and not the negative ones. Hence, we do not need to explicitly return a value.",
  "    positive = Vector{Int64}(length(l))\n    for x in l\n        if x>0\n     \
    \       positive[length(x)+1]=x\n        end\n    end\n    return positive\nend",
  "    return filter(positive,l)\nend", "    if l == Int64[]\n        return Int64[]\n\
    \    end\n    return [x for x in l if x > 0]\nend\n</cell>\n<text>\n2.3 Define\
    \ a predicate to check whether a vector is sorted in ascending order\nThe input\
    \ is a vector.", "    positives = findall(x -> x > 0, l)\n    positives = setdiff(positives,\
    \ 0)\n    return l[positives]\nend\n</cell>\n<code language=julia-1.0>\n\"\"\"\
    Return only negative numbers in the vector.\n    >>> get_negative([-1, 2, -4,\
    \ 5, 6])\n    [-6, -2, -4, 1]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10])\n    [5, 3, 2, 3, 9, 0, 123, -1, -10]\n    \"\"\"", "    if length(l)\
    \ == 0 then return []\n    if min(l) == -Inf then return []\n    if min(l) ==\
    \ Inf then return l\n    \n    return filter(x -> x > 0, l)\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    result = zeros(Int(l.length))\n    for j = 1:l.length\n\
    \        result[j] = min([l[j], 0])\n    end\n    return result\nend\n</cell>\n\
    <code language=julia-0.6>\n\"\"\"Return only negative numbers in the vector.\n\
    \    >>> get_negative([-1, 2, -4, 5, 6])\n    [-4, -6, 6]\n    >>> get_negative([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [-5, -3, -3, -9, -123, 1]\n    \"\"\
    \"", "    l[findall(l>0)]\nend\n</cell>\n<text>\nget_positive", "    l = sort(l)\n\
    \    positive = Vector{Int64}(undef, length(l))\n    for k in 1:length(l), positive[k]\
    \ = l[k]>=0 ? l[k] : positive[k] \n    end\n    return positive\nend", "    positive\
    \ = filter(x -> x >= 0, l)\n    return positive\nend", "    return filter((x->x>0),\
    \ l)\nend\n</cell>\n<code language=julia-1.5>\n\"\"\"Return only negative numbers\
    \ in the vector.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [-2, -4, -6, 6]\n\
    \    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [-5, -3, 3,\
    \ -9, 0, 123, -1, -10]\n    \"\"\"", "    for n in l\n        if n > 0\n     \
    \       return n\n        end\n    end\n    return []\nend\n</cell>\n<text>\n\
    The second function get_negative(l::Vector{Int64})::Vector{Int64} is similar to\
    \ the first one. It returns only negative numbers in the vector.", "    l = sort(l)\n\
    \    for i in 1:length(l)\n        if l[i] < 0\n            remove!(l, i)\n  \
    \      end\n    end\n    l\nend\n</cell>\n<text>\nget_positive_and_negative -\
    \ Return a vector with all positive and negative numbers\nin the vector.\nThis\
    \ function returns a vector.", "    positive = findall(x -> x > 0, l)\n    l =\
    \ l .- Vector{Int64}(map(positive, 1:length(l)))\nend\n</code>\n<|/ a dscore=1\
    \ tags=julia,arrays,vector |>\n<| c |>\nThis works and is a bit cleaner than the\
    \ others. Thanks!\n<|/ c |>\n<| a |>\nHere is a solution without using anonymous\
    \ functions:\n<code>\nv = [1,2,3]", "    pos = [i for i in l if i>0]\nend\n</cell>\n\
    <code language=julia-1.6>\nget_positive([-1, 2, -4, 5, 6])\n</cell>\n<code language=julia-1.6>",
  "    l = sort!(l, order = \"ascend\")\n    l = l[l .> 0]\n    return l\nend\n</code>\n\
    <|/ a tags=julia dscore=2 |>\n<| a dscore=1 |>\nUsing array comprehension \n<code>\n\
    julia> x = [-2, -1, 0, 1, 2, 3, 4, 5]\n5-element Array{Int64,1}:\n -2\n-1\n 0\n\
    \ 1\n 2", "    positive::Vector{Int64}=[]\n    for v in l\n        push!(positive,\
    \ v>0? v:0)\n    end\n    positive\nend\n</cell>\n<text>\nThis works because get_positive\
    \ is a predicate that takes l as an input and returns a new vector with positive\
    \ numbers. The ? notation is a shortcut for conditional: if the expression to\
    \ the left of the ? is a Boolean value, then whatever is to the right of the ?\
    \ is returned if true, otherwise whatever is to the right of the ? is returned\
    \ if false. These expressions are also known as ternary operators.", "    v =\
    \ zeros(Int64,length(l))\n    for i=1:length(l)\n        if(l[i]>0)\n        \
    \    v[i]=l[i]\n        end\n    end\n    return v\nend", "    positives = []\n\
    \    for x in l\n        if x > 0 \n            push!(positives, x)\n        else\n\
    \            continue\n        end\n    end\n    return positives\nend", "   \
    \ if !isPositive(l) \n        error(\"The vector is not positive\") \n    else\
    \ \n        return l \nend", "    if l.length==0\n        return l\n    return\
    \ filter(x -> x>=0, l)\nend", "    Vector{Int64}((i for i in l if i>0))\nend\n\
    </cell>\n<code language=julia-1.0>\n\"\"\"Return only negative numbers in the\
    \ vector.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [-1, -2, -4, 5, 6]\n \
    \   >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, -1,\
    \ -2, -3, -3, 9, 0, 123, 1, -10]\n    \"\"\"", "    result = Vector{Int64}()\n\
    \    for i in eachindex(l)\n        if l[i] > 0\n            push!(result, l[i])\n\
    \        end\n    end\n    return result\nend", "  l = sort(l)\n  n = length(l)\
    \ \n  pos = Int64[ i for i = 1:n, l[i] >= 0 ]\n  return l[pos]\nend\n</cell>\n\
    <code language=julia-1.6>\n@time get_positive([-1, 2, -4, 5, 6])\n@time get_positive([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n</cell>\n<code language=julia-1.6>", " \
    \   ind::Int = argmax(l) \n    res::Vector{Int64} = zeros(Int64, size(l)); res[ind]\
    \ = 1 \n    res\nend", "  l=setdiff(Int64[], l)\n  return l\nend\n\"\"\"Return\
    \ only negative numbers in the vector.\n    >>> get_negative([-1, 2, -4, 5, 6])\n\
    \    [-1, -4, -6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    \    [-5, -3, 3, -9, 123, -1]\n    \"\"\"", "    n = length(l)\n    positive =\
    \ Vector{Int64}()\n    \n    for i = 1:n\n        if l[i] > 0 \n            push!(positive,\
    \ l[i]) \n        end\n    end\n    return positive\nend", "    \n    @assert\
    \ all(l .> 0) \"All elements of l must be positive\"\n    @assert sum(l) == l.last\
    \ \"l must contain exactly one positive number\"", "    positives = []\n    for\
    \ x in l\n        if x > 0 && x < 0\n            positives += x\n        end\n\
    \    end\n    return positives\nend", "    if all(x -> x >= 0, l)\n    else\n\
    \        throw(ArgumentError(\"All elements in the vector must be positive.\"\
    ))\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nI like your solution; it makes the\
    \ error handling more explicit.\n<|/ c |>\n<| a tags=julia,vector |>\nHow about\
    \ this:\n<code>", "    positive = findnz(x -> x > 0, l)\n    positive = Set()\n\
    \    for i in positive\n        push!(positive,l[i])\n    end\n    return positive\n\
    end", "    positive_numbers(l)\nend", "    return filter(x -> x > 0, l)\nend",
  "  result = Set{Int64}(l)\n  for element in l \n    element >= 0 ? result += element\
    \ : result\n  end\n  return result\nend\nget_positive(l)\n</cell>\n<code language=julia-1.0>",
  "    if l == []\n        throw(ArgumentError(\"Cannot get positive of empty vector\"\
    ))\n    else \n        return l .>= 0? l : get_positive(-l)\n    end\nend", " \
    \   return filter(x -> x >= 0, l)\nend\n</cell>\n<text>\nExercise 5\nImplement\
    \ the function get_positive! to modify the vector l in-place. The function will\
    \ take as input a vector of Int64 and will return a vector of Int64.", "    for\
    \ i in eachindex(l)\n        if l[i] > 0 \n            l[i] = l[i]\n        else\n\
    \            l[i] = 0\n        end\n    end\n    return l\nend\nget_positive(l::Vector{Float64})\
    \ = l |> get_positive", " \n    if length(l) == 0 \n        return l \n \n   \
    \ positives = []\n    neg = 0\n    for i in l \n        if i < 0 \n          \
    \  neg += 1 \n        else \n            positives.append(i) \n \n    return positives\
    \ if neg == 0 else positives[neg:end]\nend\n</cell>\n<code language=julia-1.5>",
  "    result = []\n    for val in l\n        if val > 0\n            result.append(val)\n\
    \        end\n    end\n    return result\nend", "    inds = l.>0\n    return l[inds]\n\
    end\n</cell>\n<text>\nQuestion 3: Define get_negative_numbers and get_negative_numbers\
    \ \nWrite a function that returns only negative numbers in the vector.\n    >>>\
    \ get_negative_numbers([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [-5, -3,\
    \ -2, -3, 9, 0, 123, 1]\n    >>> get_negative_numbers([-1, 2, -4, 5, 6])\n   \
    \ [-2, -4, -6, 6]\n    \"\"\"", "    pos = zeros(Int64, length(l)); \n    for\
    \ i = 1:length(l)\n        if l[i] < 0\n            pos[i] = l[i]\n        end\n\
    \    end\n    return pos\nend", "    if is_positive(l) == true \n        l \n\
    \    else \n        l == 0 ? Vector{Int64}() : get_positive(-l)\n    end\nend\n\
    </cell>\n<code language=julia-1.5>", "    \"\"\"Returns a new vector that contains\
    \ only positive numbers in the original vector.\"\"\"\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\"Remove numbers from original vector.\n    >>> get_positive([5, 3, -5, 2,\
    \ -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n\"\"\"", "    if min(l)\
    \ >= 0\n        l \n    else\n        []\n    end\nend\n\"\"\"Return only negative\
    \ numbers in the vector.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [-2, -4,\
    \ -6, -5, -6, -3]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
    \    [5, 3, -2, -3, 9, 123, 1]\n\"\"\"", "    return l[findall(l>0)]\nend", " \
    \   m = zero(eltype(l))\n    for v in l\n        m += v\n    end\n    return l\
    \ .> m ? l : m - l\nend", "    if l == [] \n    else if l == [-inf] \n    else\
    \ if l == [inf] \n    else l\n    \n    \nend", "    l = l .> 0 \n    l .&= l\
    \ .>= 0\n    return l\nend", "    \n    for i in l \n        if i>0 \n       \
    \ then return l\n        end \n    end\n    return []\nend\n</cell>\n<code language=julia-1.5>\n\
    get_positive([-1, 2, -4, 5, 6])\n</cell>\n<text>\nReturn only negative numbers\
    \ in the vector.", "    l[l .> 0]\nend", "    if length(l) == 0 \n        return\
    \ l\n    else\n        l = l[end]\n        return get_positive(copy(l)::Vector{Int64})\
    \ + l\n    end\nend\n</cell>\n<text>\nVector.filter() removes entries from the\
    \ vector where test returns true.", "    pos = filter(i -> i>=0, l)\n    return\
    \ pos\nend", "    result = zeros(length(l)); \n    for i \u2208 l\n        if\
    \ i < 0\n            result[end] = i\n        end\n    end\n    result\nend",
  "    pos_l=filter(x->x>0,l)\n    return pos_l\nend\n</cell>\n<text>\nTask 6\nModify\
    \ the previous code so that it returns a vector of the length n (number of elements)\
    \ of 0s and 1s corresponding to a random permutation of the list l. The number\
    \ of 1s is equal to the number of elements of the vector l greater than 0.", " \
    \   l = l.filter(x->x .> 0)\nend", "    return filter(x -> x >= 0, l)\nend", " \
    \   l = Vector{Int64}(l)\n    l[l<=0] = []\n    return l\nend", '    return filter(x
    -> x > 0, l)', "    for i in l\n        if i<0\n            push!(l,0)\n     \
    \   else\n            push!(l,i)\n        end\n    end\n    return l\nend", " \
    \   return l[l .> 0]\nend", "    inds = find(l .> 0)\n    vec(inds)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThe `each` function is unnecessary. Just do `i = 1: length(l)`\n\
    <|/ c |>\n<| a tags=julia |>\nThis doesn't use any built-in functions:\n<code>",
  "    positive=falses(size(l))\n    for x in l\n        if x>0\n            positive=trues(size(positive))\n\
    \            positive[x]=true\n        else\n            positive=falses(size(positive))\n\
    \        end\n    end\n    return Vector{Int64}(collect(positive))\nend", "  \
    \  # Vector{Int64} -> Vector{Int64}\n    return filter(x -> x >=0, l)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nHow is your answer different from mine?\n<|/ c |>\n<| c |>\n\
    Mine is more succinct. Yours was the most informative. I just thought it was worth\
    \ having another option.\n<|/ c |>\n<| c |>\nIf your function is more general\
    \ than this, then your answer is more general.  Mine is more specific to the question\
    \ asked.\n<|/ c |>\n<| a tags=julia dscore=2 |>\nThe canonical way to do this\
    \ in julia is to use isless and isgreater. isless is true when an element in a\
    \ collection is less than another, and isgreater is true when it is greater than\
    \ another. Both functions are vectorized, meaning they work on a collection and\
    \ can do element-wise comparison.\n<code>\njulia> isless(1, 2)\ntrue", "    if\
    \ l <= 0 \n        error(\"Vector must not be empty\") \n    end\n    vec =  Vector{Int64}(l)\n\
    \    for i in 0 : (length(vec) - 1)\n        if vec[i] <= 0\n            return\
    \ vec\n        end\n    end\n    return vec\nend\n</cell>\n<text>\nExercise 2:\
    \ get_positive_numbers!\nComplete get_positive_numbers!.  It should return a copy\
    \ of the vector l with the positive numbers removed.\nThe function should remove\
    \ duplicates as well as negative numbers.  The function should return the modified\
    \ vector, not a copy.  Hint: You may need to use @inbounds and a for loop to accomplish\
    \ this.", "    flag = Int64[]\n    for elt in l\n        if elt > 0 \n       \
    \     push!(flag, elt)\n        end\n    end\n    return flag\nend\n</cell>\n\
    <text>\nQ2. Vectorize the function get_negative", "    v = l.filter((x) -> x >\
    \ 0, l)\n    v = v.filter((x) -> x < 0, v)\n    return v\nend\nget_positive(l::Vector{Int64})\
    \ = l \nend ", "    # Create a copy and sort the list\n    l = copy(l)\n    l.sort()\n\
    \    \n    # Return only the positive numbers\n    l[l .>= 0]\nend\n</cell>\n\
    <text>\nExercise 5 (Optional)\nWrite a Julia function to remove all occurrences\
    \ of one value from a vector.", "    idx = findall(x -> x > 0, l)\n    idx\nend",
  "    positive_list = filter(x -> x > 0, l)\n    positive_list = set_intersect(positive_list,\
    \ l)\n    return positive_list\nend", "    s = l |> collect(collect(x->abs(x),\
    \ filter(x->x>0, l)))\n    # use filter to remove all zero elements\n    # since\
    \ they are less than zero and will be removed in the next step\n    return filter(x->x>0,\
    \ s) \nend\n</code>\n<|/ a tags=julia dscore=1 |>\n<| c |>\nThank you very much.\
    \ Works exactly as I needed.\n<|/ c |>\n<| a tags=julia |>\n<code>", "    if l[1]<0\n\
    \        push!(l, 0)\n    end\n    return l\nend\n</cell>\n<code language=julia-1.3>\n\
    \"\"\"Return only negative numbers in the vector.\n    >>> get_negative([-1, 2,\
    \ -4, 5, 6])\n    [-2, -4, -6, -5, -3]\n    >>> get_negative([5, 3, -5, 2, -3,\
    \ 3, 9, 0, 123, 1, -10])\n    [-5, -3, -3, -9, -123, -1, -10, 0, 3]\n    \"\"\"",
  "    return l[findall(l .> 0)]\nend", "    pos = findfirst(x -> x >= 0, l)\n   \
    \ if pos != nothing, \n        return l[pos+1:end]\n    end\n    return []\nend",
  "    if min(l)>0\n        return([i for i in l if i>0])\n    end\nend", "    l[l\
    \ .<= 0] = []\n    return l\nend \n</code>\nget_negative is similar except negates\
    \ everything instead of removing it.\n<code>", "    result = Vector{Int64}(undef,\
    \ length(l))\n    for (i, value) in enumerate(l)\n        if value >= 0\n    \
    \        result[i] = value\n        end\n    end\n    return result\nend", " \
    \  res = zeros(0)\n   if l==0 \n       return res\n   end\n   for v in l\n   \
    \    if v > 0\n           push!(res, v)\n       end\n   end\n   return res\nend\n\
    \"\"\"\nReturn only negative numbers in the vector.\n    >>> get_negative([-1,\
    \ 2, -4, 5, 6])\n    [-1, -4, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10])\n    [-5, -3, -3, 9, 123, 1]\n    \"\"\"", "     if sum( l.>0\
    \ ) == length(l) \n         return l \n     else \n         return setdiff(l,\
    \ l.>0)\nend\n</code>\nThe function returns an array with only the positive numbers\
    \ in the vector l. \nThis function does not check for negative numbers. But you\
    \ can add that logic if needed. \nHope this helps you.\n<|/ a tags=julia dscore=2\
    \ |>\n<| a |>\nIn addition to Jonas's answer, here's an implementation in Base\
    \ Julia for completeness, while retaining the ability to handle non-positive integers:\n\
    <code>", "    positives=[]\n    for i in l\n        if i>0\n        push!(positives,i)\n\
    \        end\n    end\n    return positives\nend\n</cell>\n<code language=julia-1.5>",
  "\tfor i in 1:length(l)\n\t\tif (l[i] < 0)\n\t\t\tl[i] = 0\n\tend\n\treturn l\n\
    end", "    if l == 0\n        error(\"get_positive() was called on empty vector.\"\
    )\n    elseif l > 0\n        true\n    else\n        false\n    end\nend", " \
    \   return l.filter(x -> x>=0)\nend", "    positive = Vector{Int64}()\n    for\
    \ num in l\n        if num > 0\n            push!(positive, num)\n        end\n\
    \    end\n    return positive\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ tags=julia,set |>\n<code>\njulia> l=[-1, 2, -4, 5, 6]\n3-element Array{Int64,1}:\n\
    \ -1\n  2\n -4", "    @assert l.length() >= 1\n    return Vector{Int64}(l.filter(ispositive))\n\
    end", "  result = Vector{Int64}()\n  for v in l\n    if v >0\n      push!(result,v)\n\
    \    end\n  end\n  return result\nend", "    res = Int64[]\n    for x in l\n \
    \       if x > 0 push!(res, x) end\n    return res \nend ", "    res=l\n    for\
    \ i in l\n        if i>=0\n            push!(res,i)\n        end\n    end\n  \
    \  return res\nend\n\"\"\"Return only negative numbers in the vector.\n    >>>\
    \ get_negative([-1, 2, -4, 5, 6])\n    [-1, -4, 6]\n    >>> get_negative([5, 3,\
    \ -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [-5, -3, 3, -9, 123, 1]\n\"\"\"", " \
    \   s = sort(l)\n    i = findfirst(isequal(signless(s)),-1)[1]\n    return l[(i+1):end]\n\
    end", "   v = get_eltype!(l, Int64) \n   if v<0 \n       return zeros(eltype(l),length(l)-1)\
    \ \n   end\n   v > 0 ? l : l .- v  \nend\n</code>\n<|/ a tags=julia dscore=1 |>\n\
    <| c |>\nJust to be sure -- can this be generalized into a function so that it\
    \ only works with `Vector{<type>}` (and `Array{<type>}`), not just `Vector`? I\
    \ tried `function get_positive(l::Vector{<type>})` and it gives me the error `MethodError:\
    \ no method matching get_positive(::Type{Vector{Int64}})`.\n<|/ c |>\n<| c |>\n\
    yeah, it works with arrays as well, e.g. `get_positive([-1, 2, -4, 5, 6])`\n<|/\
    \ c |>\n<| c |>\nI wonder if there's something that can be done to prevent the\
    \ `Int64` casting problem. If I change the function signature to `get_positive(l::Vector{<type>})::Vector{<type>}`,\
    \ then `get_positive([-1, 2, -4, 5, 6])` results in `ERROR: MethodError: no method\
    \ matching get_positive(::Array{Int64,1})`. So perhaps we should add a `v::Int64`\
    \ argument to the function?\n<|/ c |>\n<| c |>\nI actually tried that before and\
    \ got an error (I updated my question to reflect that). I don't know how to fix\
    \ that. Could you try running my code above? I'm new to Julia and am a bit stuck.\n\
    <|/ c |>\n<| c |>\nI tried to put together an example that works, see my edit.\
    \ The reason for your error is due to a type mismatch between your function and\
    \ the function which actually does the work (`get_positive`). But as I mentioned\
    \ in the answer, this kind of problem is usually solved without changing the function\
    \ signature.\n<|/ c |>\n<| a |>\nI think the problem is that you call get_positive\
    \ with multiple elements and in return you get a vector of elements. If you call\
    \ it with a vector of length one you get only one element. For example:\n<code>\n\
    julia> get_positive([-1, 2, -4, 5, 6])\n-1", "    pos = Vector{Int64}()\n    for\
    \ i in 0 .. length(l) \n        if l[i] > 0 \n            push!(pos, l[i]) \n\
    \        end \n    end \n    return pos \nend \n</cell>\n<text>\nWrite a function\
    \ to get the negative elements of the vector. Make sure that they are returned\
    \ as their absolute values.", "    return collect((filter(lt,l)))\nend\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"Return only negative numbers in the vector.\n\
    \    >>> get_negative([-1, 2, -4, 5, 6])\n    [-2, -4, -6, -3]\n    >>> get_negative([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [-5, -3, -2, -9, -123, -1, 0]\n  \
    \  \"\"\"", "    if length(l) > 0 \n        positive = filter(l[i] .> 0, l)\n\
    \        return Vector{Int64}(positive)\n    else\n        return l\n    end\n\
    end", "    \"\"\"\n    Return only positive numbers in the vector.\n    \"\"\"\
    \nend", "    pos = [i for i in l if i>0]\n    return pos\nend \n</cell>\n<text>\n\
    Define the function get_negative that returns only negative numbers in the vector.",
  "    filter(x -> x >= 0, l)\nend", "    l = l .> 0 ?? copy(l)\n    l\nend\n</cell>\n\
    <code language=julia-1.5>", "\tfor i in 1:length(l)\n\t\tif l[i] >= 0\n\t\t\t\
    l[i] = l[i]\n\t\telse\n\t\t\tl[i] = 0\n\t\tend\n\tend\n\treturn l\nend", "  result=[]\n\
    \  for elt in l \n    if elt > 0 \n      push!(result,elt)\n    end\n  end\n \
    \ return result\nend\n</cell>\n<code language=julia-1.5>", "    positive(l)\n\
    end\n</cell>\n<code language=julia-1.0>", "    v = Array{Int64}(length(l)); \n\
    \    for i=1:length(l)\n        if l[i] > 0 \n            v[i] = l[i]\n      \
    \  end\n    end\n    return v\nend", "     if l == []\n         return []\n  \
    \   else\n         if l[1] > 0\n             return l[2:end]\n         else\n\
    \             return l[1:end]\n         end\n     end\nend", "    ret = Vector{Int64}(length(l))\n\
    \    for i=1:length(l) \n        if l[i] > 0 \n            ret[i] = l[i] \n  \
    \      end\n    end\n    return ret\nend", "    \n    if length(l)==0 \n     \
    \   return []\n    elseif length(l)==1 \n        return [-l[1]]\n    end\n   \
    \ \n    \n    \n    p = l[1]\n    for n in l[2:end]\n        if n == p \n    \
    \        p = n\n        end\n    end\n    return [p] + get_positive(subset(l,\
    \ 2:end))\nend", "    n::Int64\n    n=0\n    for elt in l \n        if elt > 0\
    \ \n            push!(n, elt) \n        end\n    end\n    return n\nend\n</cell>\n\
    <text>\nExercise", "    positive = filter(x -> x > 0, l)\n    return positive\n\
    end \n\"\"\"Return only negative numbers in the vector.\n    >>> get_negative([-1,\
    \ 2, -4, 5, 6])\n    [-1, -4, 5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3,\
    \ 9, 0, 123, 1, -10])\n    [5, -3, -9, -3, 1, -123, -10, 3, 9, 0]\n    \"\"\"",
  "    result = []\n    for e in l \n        if e>0\n            result.append(e)\n\
    \        end \n    end\n    return result\nend", "    positive_values = findall(l<0,l)\n\
    \    if isempty(positive_values) \n        l\n    else\n        remove!(l,positive_values)\n\
    \        l\n    end\nend\n</cell>\n<text>\n6. Using functions\nYou can use the\
    \ functions defined above to quickly get certain information from a vector. For\
    \ example, we can get the mean of the values in the vector $x$ with one line of\
    \ code using mean(x) and we can get the square of the values in the vector $x$\
    \ with one line of code using map(x->x*x,x). These are just two examples of built-in\
    \ functions in Julia, and there are many more. You can find a list of built-in\
    \ functions in the Julia documentation here.", "    pos= [x for x in l if x >\
    \ 0]\n    return pos\nend\n</cell>\n<text>\n6.5 Function length\nFind the length\
    \ of an array and return the number of elements in the array", "    pos = copy(l)\n\
    \    \n    for i in pos\n        if i <= 0\n            remove!(pos, i)\n    \
    \    end\n    end\n    return pos\nend\n</cell>\n<text>\nTest it out:", "    v\
    \ = Vector{Int64}()\n    for i in l\n        if i > 0\n            push!(v,i)\n\
    \        end\n    end\n    return v\nend", "    return l[l .>= 0]\nend\n</cell>\n\
    <text>\nget_positive(l)", "    if all(v < 0 for v in l)\n        throw(ArgumentError(\"\
    All elements in Vector must be positive\"))\n    Vector{Int64}([v for v in l if\
    \ v>0])\nend", "    for a in l\n        if a > 0\n            return a\n     \
    \   end\n    end\n    return []\nend", "    for x in l\n        if x >= 0\n  \
    \          return x\nend\nget_positive(l)\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    You might want to put a break in the for loop in case you find one value that\
    \ is not positive.\n<|/ c |>\n<| c |>\n`println` will output a newline at the\
    \ end, too.\n<|/ c |>\n<| c |>\nYou can just use `return l` instead of `return\
    \ [x for x in l if x >= 0]`, but yeah `println` is just for displaying.\n<|/ c\
    \ |>\n<| c |>\nWhat is wrong with using `l` directly? It seems to me that this\
    \ is more readable than creating a new `Vector` of boolean values, unless I misunderstand\
    \ the code. Can you explain the advantage of using `return l` over `return [x\
    \ for x in l if x >= 0]`?\n<|/ c |>\n<| c |>\nWell, for one thing, you can do\
    \ `get_positive(l); return l`. If `l` is an `Array{Int64}` then `l .>= 0` will\
    \ be an `Array{Bool}` and this will be faster than creating a new `Vector` of\
    \ boolean values.\n<|/ c |>\n<| a |>\nI wrote a module called Filter to do just\
    \ this:\n<code>\njulia> filter(x -> x > 0, [-1,2,3,4,5]);\n5-element Array{Int64,1}:\n\
    \ 1\n 2\n 3\n 4\n 5\n</code>\n<|/ a dscore=2 tags=julia,if-statement |>\n<| a\
    \ tags=julia,if-statement |>\nAs others have noted, the typical approach for this\
    \ problem is to filter the values first:\n<code>\njulia> filter(x->x > 0, [-1,2,3,4,5])\n\
    5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n</code>\nNote that if you need\
    \ to preserve the original array you can use filter! instead of filter.\n<|/ a\
    \ dscore=2 |>\n<| a dscore=1 tags=julia,if-statement |>\nTo add to the great answers\
    \ so far, here is another way to solve your problem:\n<code>", "   l = (l .> 0)?\
    \ l : l .* -1\n   return l\nend\n</cell>\n<text>\nReturn only the values that\
    \ are greater than 3 in both arrays", "    x = filter(x -> x >= 0, l)\n    return\
    \ x\nend ", "    v = [i for i in l if i>0]\n    return v\nend", "    if min(l)\
    \ < 0 \n        throw(ArgumentError(\"Input vector has negative elements!\"))\n\
    \    end\n    l\nend", "    get_positive = Vector{Int64}()\n    for x in l\n \
    \       if x > 0 push!(get_positive, x)\n    end\n    return get_positive\nend\n\
    </code>\n<|/ a tags=julia dscore=2 |>\n<| a tags=julia |>\nYou can use the isodd()\
    \ function:\n<code>\nisodd(Int64)\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=julia\
    \ |>\nYou can use Int64 to do this:\n<code>\njulia> Int64([3,7,2,1,9])\n10-element\
    \ Int64:\n 3\n 7\n 2\n 1\n 9\n</code>\n<|/ a |>\n<| a tags=julia dscore=1 |>\n\
    To complement the other answers, if you just want to get the indices of the elements\
    \ that are positive, you could just do:\n<code>\njulia> filter(x->x > 0, 1:6)\n\
    10-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\
    </code>\n<|/ a |>\n<| a dscore=1 |>\nIf you just want to know how many elements\
    \ are positive, you can use this:\n<code>\njulia> sum([ x > 0 for x in 1:3 ])\n\
    3\n</code>\n<|/ a tags=julia |>\n<| a dscore=0 |>\nTo answer your question (how\
    \ to get the length of an element array) you can use the length function. For\
    \ example (this is just to give you a heads up):\n<code>\njulia> x = [3,7,2,1,9]\n\
    5-element Array{Int64,1}:\n 3\n 7\n 2\n 1\n 9", "    if l.length == 0 return []\
    \ \n    positive = filter(i -> i > 0, l) \n    positive = unique(positive) \n\
    \    return positive \nend\n</code>\nAnd then:\n<code>\nget_positive([-1, 2, -4,\
    \ 5, 6])\n</code>\nreturns\n<code>\njulia> get_positive([-1, 2, -4, 5, 6])\n7-element\
    \ Array{Int64,1}:\n -1\n 2\n 3\n 4\n 5\n 6\n</code>\nAnd:\n<code>\nget_positive([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n</code>\nreturns\n<code>\njulia> get_positive([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n13-element Array{Int64,1}:\n 5\n 3\n 2\n\
    \ 3\n 9\n 123\n 1\n 10\n</code>\nThis also allows for more efficient implementation\
    \ with mutable arrays (as shown here):\n<code>", "    Positive(l) \nend\n</cell>\n\
    <text>\nget_negative(l::Vector{Int64})", "    return (x for x in l if x >= 0)\n\
    end", "    v = Vector{Int64}[]\n    for i = 1:length(l)\n        if l[i] > 0\n\
    \            push!(v,l[i])\n        end\n    end\n    return v\nend", "    l =\
    \ (l>0)*l \n    return l \nend", "    if l==[] || l==[-inf]\n        return []\n\
    \    else return l[findall(l>=0, l)]\nend\n</cell>\n<text>\n3.2 get_positive",
  "    positive = Vector{Int64}()\n    for x in l \n        if x > 0 \n          \
    \  push!(positive, x)\n        end\n    end\n    positive\nend", "    result =\
    \ Vector{Int64}(length(l)+1)\n    for i=1:length(l)\n        if l[i] > 0, result[i+1]\
    \ = l[i]\n    end\n    return result\nend\n</cell>\n<text>\nSort vectors\nUse\
    \ the sort function to sort vectors according to a particular order.", "    #\
    \ Get the positive numbers in the list\n    positive = filter(x -> x > 0, l) \n\
    \    return positive \nend\n</cell>\n<code language=julia-1.6>\n\"\"\"Return only\
    \ numbers in the vectors that are strictly less than a given number.\n\"\"\"",
  "    s = Int64(1)\n    for el in l\n        if el < 0\n            s += el\n   \
    \     else\n            return el\n    return s\nend # get_positive\n</code>\n\
    <|/ a |>\n<| c |>\nI find this solution to be the simplest, since it only returns\
    \ the positive elements. I think I like this one because it doesn't require a\
    \ separate function.\n<|/ c |>\n<| a dscore=3 tags=julia,vector |>\nUsing an anonymous\
    \ function:\n<code>\njulia> f(x) = x < 0 ? 0 : x\nf (generic function with 1 method)",
  "    return filter(x -> x >= 0, l)\nend\n</cell>\n<code language=julia-1.5>", " \
    \   return l.filter( x -> x > 0)\nend\n</code>\nIn your main function you can\
    \ then call get_positive(some_numbers).\n<|/ a |>\n<| c |>\nThanks! This is my\
    \ first time using Julia, and it feels like a lot more difficult than other languages.\n\
    <|/ c |>\n<| a dscore=1 tags=function,julia |>\nIf you want to get a new vector\
    \ with positive numbers, you can use the collect function:\n<code>\nnumbers =\
    \ [1,2,3,4,5];", "    return l.filter(i -> i > 0)\nend\n</cell>\n<code language=julia-1.0>\n\
    # test", "    for el in l \n        if el > 0 \n            yield el \nend \n\
    </cell>\n<text>\nAnd now we can test our new function:", "    positive(l)\nend",
  "    return l .> 0\nend\n</cell>\n<text>\nNow let's try to do the same using the\
    \ higher-order function filter!", "    l = copy(l)\n    for x in l\n        if\
    \ x < 0\n            remove!(l, x)\n        end\n    end\n    l\nend\n</cell>\n\
    <code language=julia-1.0>", "    v = l.copy()\n    v[v>0]\nend", "    return filter(x\
    \ -> x > 0, l)\nend\n</code>\n(note: using filter and comprehensions, you can\
    \ avoid writing loops and can get the same results as above function get_positive)\n\
    <code>\nget_positive(l)\n</code>\nResults:\n<code>\njulia> get_positive([-1, 2,\
    \ -4, 5, 6])\n2-element Vector{Int64}:\n 2\n 5", "    if is_positive(l) == true\n\
    \        return l\n    else \n        return filter(is_positive,l)\n    end\n\
    end", "    if l == [] || all(x -> x < 0, l) \n    else filter(x -> x > 0, l) \n\
    \    end\nend\n</code>\n<|/ a |>\n<| c |>\nA small nitpick, `filter!` modifies\
    \ its argument in place and returns nothing, but `filter` does return an iterator.\n\
    <|/ c |>\n<| c |>\n: You are right and I modified the post. Thank you for the\
    \ correction.\n<|/ c |>\n<| c |>\nThanks so much for this, I was having trouble\
    \ finding this for my problem where I had a vector with many elements. I just\
    \ used `filter!` and then `push!` to remove duplicates and it worked great!\n\
    <|/ c |>\n<| a |>\nA slightly different approach:\n<code>", "    if all(x < 0\
    \ for x in l)\n        error(\"All values in vector must be positive integers\"\
    )\n    else \n        return l\nend", "    pos = copy(l)\n    for v in pos\n \
    \       if v < 0\n            remove!(pos, v)\n        end\n    end\n    pos\n\
    end\nget_positive", "    positive = []\n    for x in l\n        if x >= 0\n  \
    \          push!(positive, x)\n        end\n    end\n    return positive\nend\n\
    </cell>\n<code language=julia-1.3>\n\"\"\"Return only negative numbers in the\
    \ vector.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [-2, -4, -6, -5]\n   \
    \ >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, -3, 3,\
    \ 9, 0, 123, 1, -9, -10, -2]\n    \"\"\"", "    return l[findall(x->x > 0, l)]\n\
    end", "  \n  if iszero(l)\n    return []\n  else\n    return findall(x -> x >\
    \ 0, l)\n  end\nend", "    result = copy(r)\n    for elt in l \n        if elt\
    \ < 0 \n            result[elt] = 0 \n        else \n            result[elt] =\
    \ elt \n        end\n    end\n    result\nend", "    return filter(x-> x >= 0,\
    \ l)\nend\n</cell>\n<code language=julia-1.3>\nget_positive([-1, 2, -4, 5, 6])\n\
    </cell>\n<code language=julia-1.3>\nget_positive([5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10])\n</cell>\n<text>\n(\uC544\uB798) \uCD5C\uC18C\uAC12\uC744 \uB3CC\uB824\
    \uC90C", "    pos = map(x -> x > 0, l)\n    vec =  collect(zip(pos,l))\n    return\
    \ vec\nend", "    s = Int64[]\n    for e in l \n        if e > 0 \n          \
    \  push!(s, e)\n        end\n    end\n    return s\nend", "    s = l .> 0\n  \
    \  if length(s)==1\n        return l[s]\n    else\n        return l\n    end\n\
    end\n    ", "    positive_index = [i for i in l if i>0]\n    positive_index\n\
    end\n</cell>\n<code language=julia-1.5>", "    l = sort(l)\n    res = []\n   \
    \ for x in l\n        if x > 0 && res.length < x\n            res.push(x)\n  \
    \      end\n    end\n    return res\nend\n</cell>\n<code language=julia-1.0>",
  "        l = length(l)\n        if l == 0 return l\n        positive::Vector{Int64}\
    \ = []\n        for v in l\n            if v > 0 push!(positive, v)\n        end\n\
    \        return positive\n    end\n    return l\nend\n\"\"\"Return only negative\
    \ numbers in the vector.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, -4,\
    \ -6, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5,\
    \ -3, -9, 0, 123, -1, -10]\n    \"\"\"", "    result = Vector{Int64}()\n    for\
    \ el in l\n        if el > 0\n            push!(result, el)\n        end\n   \
    \ end\n    return result\nend", "    a = copy(l)\n    for x in a \n        if\
    \ x < 0 \n            idx = find(a .> 0) \n            for i = idx\n         \
    \       a[i] = 0 \n            end\n        end\n    end\n    return a\nend",
  "    positive = [i for i in l if i >0]\n    return positive\nend\n</cell>\n<code\
    \ language=julia-1.5>\nget_positive([-1, 2, -4, 5, 6])\n</cell>\n<code language=julia-1.5>",
  "    return [i for i in l if i>0]\nend\n</cell>\n<code language=julia-1.5>\n@assert\
    \ get_positive([-1, 2, -4, 5, 6]) == [2, 5, 6]\n@assert get_positive([5, 3, -5,\
    \ 2, -3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 9, 123, 1]\n</cell>\n<text>\n\
    Subtracting Vectors\nJulia has a built-in function that allows to substract two\
    \ vectors. More precisely it substracts the first vector from the second one and\
    \ returns for each element the value minus one.", "    get_positive(l)\nend",
  "    \n    positives = findall(x->x>0, l)\n    \n    return filter(x -> x != 0,\
    \ l)\nend\n</cell>\n<code language=julia-1.5>\n# Test with get_positive\n@time\
    \ get_positive(vec)\n</cell>\n<text>\nExercise 3\nDefine the function get_negative\
    \ which takes as input a vector and returns the vector with negative numbers removed.",
  "    positive = zero(eltype(l))\n    for v in l \n        if v < 0 \n          \
    \  push!(positive, v) \n        end \n    end \n    return positive \nend \n</cell>\n\
    <text>\nProblem 9\nDefine get_negative that returns only negative numbers in the\
    \ vector.\n>>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n[5, 3, -5,\
    \ 2, -3, -3, -9, -123, 1, 0]\n>>> get_negative([-1, 2, -4, 5, 6])\n[-2, -4, -6,\
    \ -5, -6]\n>>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n[-5, -3,\
    \ -3, -9, -123, 1, 0]\n>>> get_negative([-1, -2, -3, -4, -5, -6])\n[-2, -3, -4,\
    \ -5, -6]"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
