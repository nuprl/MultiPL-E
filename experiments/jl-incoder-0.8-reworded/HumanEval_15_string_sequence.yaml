name: HumanEval_15_string_sequence
language: jl
prompt: "\"\"\" Return a string containing space-delimited numbers starting from 0\
  \ upto n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n\
  \    \"0 1 2 3 4 5\"\n    \"\"\"\nfunction string_sequence(n::Int64)::String \n"
tests: "using Test\n\n@testset begin\n\ncandidate = string_sequence;\n\t@test(candidate(0)\
  \ == \"0\")\n\t@test(candidate(3) == \"0 1 2 3\")\n\t@test(candidate(10) == \"0\
  \ 1 2 3 4 5 6 7 8 9 10\")\nend\n"
completions: ["</code>\nThe above is equivalent to\n<code>", "    \"\"\" Return a\
    \ string containing space-delimited numbers starting from 0 upto n inclusive.\n\
    \    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n    \"0 1\
    \ 2 3 4 5\"\n    \"\"\"", "    s = \"\"\n    for n in 0:n\n        s = s++ \"\
    \ \" ++ string_sequence_str(n)\n    return s", "    \n    \"Return a string containing\
    \ space-delimited numbers starting from 0 upto n inclusive.\"\n    if n==0\n \
    \       zero = \"\"\n    else\n        zero = string_sequence(0)\n    end\n  \
    \  numbers = \"\"\n    for k in 1:n\n        numbers = numbers + \" \" + string(k)\n\
    \    end\n    return zero + numbers\nend\n</cell>\n<code language=julia-1.0>\n\
    string_sequence(0)\n</cell>\n<code language=julia-1.0>\nstring_sequence(5)\n</cell>\n\
    <text>\nWrite a function named string_sequence_of_size which takes a single argument\
    \ and returns a string containing the space-delimited numbers starting from 0\
    \ upto n inclusive.", "    if n==0 \n        return \"0\" \n    else if n==1 \n\
    \        return \"1\" \n    else if n==2 \n        return \"1 2\" \n    else if\
    \ n==3 \n        return \"1 2 3\" \n    else if n==4 \n        return \"1 2 3\
    \ 4\" \n    else if n==5 \n        return \"1 2 3 4 5\" \n    else if n==6 \n\
    \        return \"1 2 3 4 5 6\" \n    else if n==7 \n        return \"1 2 3 4\
    \ 5 6 7\" \n    else if n==8 \n        return \"1 2 3 4 5 6 7 8\" \n    else if\
    \ n==9 \n        return \"1 2 3 4 5 6 7 8 9\" \n    else if n==10 \n        return\
    \ \"1 2 3 4 5 6 7 8 9 10\" \n    else if n==11 \n        return \"1 2 3 4 5 6\
    \ 7 8 9 10 11\" \n    else if n==12 \n        return \"1 2 3 4 5 6 7 8 9 10 11\
    \ 12\" \n    else if n==13 \n        return \"1 2 3 4 5 6 7 8 9 10 11 12 13\"\
    \ \n    else if n==14 \n        return \"1 2 3 4 5 6 7 8 9 10 11 12 13 14\" \n\
    \    else if n==15 \n        return \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\" \n\
    \    else if n==16 \n        return \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\"\
    \ \n    else if n==17 \n        return \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\
    \ 17\" \n    else if n==18 \n        return \"1 2 3 4 5 6 7 8 9 10 11 12 13 14\
    \ 15 16 17 18\" \n    else if n==19 \n        return \"1 2 3 4 5 6 7 8 9 10 11\
    \ 12 13 14 15 16 17 18 19\" \n    else if n==20 \n        return \"1 2 3 4 5 6\
    \ 7 8 9 10 11 12 13 14 15 16 17 18 19 20\" \n    else if n==21 \n        return\
    \ \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21\" \n    else if n==22\
    \ \n        return \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22\"\
    \ \n    else if n==23 \n        return \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\
    \ 17 18 19 20 21 22 23\" \n", "    return \"0 1 2 3 4 5\"\nend string_sequence\n\
    </cell>\n<code language=julia-1.5>\nstring_sequence?\n</cell>\n<code language=julia-1.5>\n\
    string_sequence?\n</cell>\n<code language=julia-1.5>\nstring_sequence(3)\n</cell>\n\
    <code language=julia-1.5>\nstring_sequence(2)\n</cell>\n<code language=julia-1.5>\n\
    string_sequence(5)\n</cell>\n<code language=julia-1.5>\nstring_sequence(1)\n</cell>\n\
    <text>\nExercise 8: Rewrite string_sequence using ranges\nA common feature of\
    \ Julia is its ability to generate sequences. One of the most useful features\
    \ is its ability to generate sequences lazily (also called \"streams\").", " \
    \   \"Return a string containing space-delimited numbers starting from 0 upto\
    \ n inclusive.\"\n    str = \" \"\n    for i = 1 to n do\n        str = str +\
    \ i\n    end\n    return str\nend", "    \"Return a string containing space-delimited\
    \ numbers starting from 0 upto n inclusive.\"\n    if n == 0 then\n        return\
    \ \"0\"\n    else if n < 0 then error(\"n must be non-negative.\")\n    end\n\
    \    function number_to_string(n::Int64)::String\n        digits = String[Int64[digit(n,\
    \ 10)]]\n        return digits * \" \"\n    end\n    \n    digits = String[Int64[digit(n,\
    \ 10)]]\n    return digits * \" \"\nend\n</code>\n<|/ a dscore=2 tags=julia,string\
    \ |>\n<| a tags=julia,string |>\nThe question is fairly old, but in case anyone\
    \ is still looking for a solution using join\n<code>", "    s = \"\"\n    for\
    \ i in 0:(n-1):\n        s += string(i) \n    return s\n</code>\nIn addition,\
    \ I have added a return type to string_sequence as we want the output to contain\
    \ a space at the start (like in string_sequence), so the return string should\
    \ begin with a space character.\n<|/ a dscore=2 |>\n<| c |>\nThis does return\
    \ the output in a string format however, it returns '0' for 0 instead of an empty\
    \ string.\n<|/ c |>\n<| c |>\nYes, I forgot to add `return s` to the `string_sequence`\
    \ function. This now fixes the problem. Thanks for pointing it out.\n<|/ c |>\n\
    <| c |>\nYour solution worked for me as well, but I feel it can be improved. \
    \ The function `string_sequence` is very similar to the `string` built-in function.\
    \  The main difference is that it uses a loop rather than `:` indexing, so there\
    \ is less code duplication involved.  Since `string` is just a wrapper around\
    \ `printf`, it can be replaced by `printf` in the loop and no need for the return\
    \ statement.  The `string_sequence` function could also be replaced with `return\
    \ join(0..n-1, \" \")`.\n<|/ c |>\n<| c |>\n, I am not trying to say that this\
    \ is better - I am saying that this is not an improvement over `string`. Using\
    \ `printf` in loops is better because it saves one function call and less code\
    \ duplication. I agree that `string` could be replaced by `printf` but that is\
    \ not what I meant by \"improvement\", I simply meant that `string` is still being\
    \ used. I tried to clarify this in my answer.\n<|/ c |>\n<| c |>\nI understand\
    \ why you were trying to say this, but I think it would be much more helpful to\
    \ someone who is new to programming to see how the `string_sequence` function\
    \ works rather than showing them how to do it with `string`.\n<|/ c |>\n<| a tags=julia\
    \ dscore=2 |>\n<code>\njulia> function string_sequence()\n           for i in\
    \ 0:9\n               println(string(i))\n           end\n       end\nstring_sequence\
    \ (generic function with 1 method)", "    \"Return a string containing space-delimited\
    \ numbers starting from 0 upto n inclusive.\"\n    s = \"\"\n    for i in 0:n\n\
    \        s = s + \" \" + string(i)\n    end\n    return s\nend", "    string =\
    \ \"\"\n    for i in 0..n\n        string = string + (i + \" \")\n    end\n  \
    \  return string\nend", "    s = \"\"\n    for i = n downto 1 do\n        s =\
    \ s .. \" \" .. tostring(i)\n    end\n    return s\n</code>\n<|/ a dscore=0 tags=julia,string\
    \ |>\n<| a tags=julia,string dscore=0 |>\nHere's a version, which uses the StringArray\
    \ constructor to create an array with strings, and joins the array:\n<code>\n\
    julia> strings(0:n)\n8-element Array{String,1}:\n \"0\"\n \"1\"\n \"2\"\n \"3\"\
    \n \"4\"\n \"5\"\n \"6\"\n \"7\"", "    \"\"\" Return a string containing space-delimited\
    \ numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"\
    0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n    \"\"\"", "    \"\"\"\
    \" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n\
    \    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n    \"0 1\
    \ 2 3 4 5\"\n    \"\"\"", "    if n < 0\n        error(\"n must be greater than\
    \ or equal to 0.\")\n    end\n    if n <= 0\n        return \"\"\n    l = string_sequence(n\
    \ - 1)\n    \n    for m in 0:n-1\n        for n in l:l = (l + \" \" + String(n))\n\
    \    end\n    return l\nend", "   \n    sequence = \"\"\n    count = 0", "   \
    \ str = \" \" # Create a String with spaces to hold our concatenated numbers\n\
    \    for i <- 0 ... n-1 # Loop over each number in our range\n        str = str+string(i)\
    \ # add this number to the string \n    str = str+string(0) # append the last\
    \ number to our string\n    return str\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Awesome, thanks! The only problem is that it returns \"0 1 2 3 4 5 0\", which\
    \ is not what we want.\n<|/ c |>\n<| c |>\nApologies, I forgot about that. I've\
    \ updated the answer to include that!\n<|/ c |>\n<| c |>\nThanks so much! I really\
    \ appreciate the help. I do have one question though: why does string() not work\
    \ with Int64? I have to use it because I'm using Julia 0.5 and it didn't recognize\
    \ typeof(...) so I had to write typeof(str) instead.\n<|/ c |>\n<| c |>\nI believe\
    \ that using `string` on `Int64` is the same as using `string` on `String`. To\
    \ be honest, I believe that the first one is more efficient and that you should\
    \ go with that unless you know you need something else.\n<|/ c |>\n<| a |>\nHere's\
    \ a variant of Stefan's answer that doesn't use string concatenation, and instead\
    \ just appends a number to a String:\n<code>", "  \"\"\"A sequence of consecutive\
    \ numbers from 0 to n\n  \"\"\"\n  if(n<0)\n    return error(\"invalid input\"\
    )\n  result=\"\"\n  for(i in 0:(n-1))\n    result=result+\" \"+str(i)\n  result=result+\"\
    \ \"\n  for(i in n:end)\n    result=result+\" \"+str(i)\n  return result\nend\n\
    </cell>\n<code language=julia-1.3>", "    string_seq_str = \"\"\n    for i \u2208\
    \ 0 .. n\n        string_seq_str = string_seq_str + to_string(i) \n    end\n \
    \   return string_seq_str\nend", "    string_sequence = \"\"\n    for i \u2208\
    \ 0 .. n-1 do\n        string_sequence = string_sequence + \" \" + to_string(i)\
    \ \n    return string_sequence\nend string_sequence", "    string_array = []\n\
    \    for i = 1:n\n        string_array[i] = \"\\(i)\"\n    end\n    return join(string_array,)\n\
    end\n</code>\n<|/ a tags=julia,arrays,string dscore=1 |>\n<| a tags=julia,arrays,string\
    \ |>\nSince Julia v1.0 this can be done as follows:\n<code>", "    str = String[]\n\
    \    for i in 0 .. n-1\n        str.append(i.toString())\n    return str.join(\"\
    \ \")\nend", "    \"Return a string containing space-delimited numbers starting\
    \ from 0 upto n inclusive.\"\n    return \"0\"*n + string_sequence(n-1)\n</code>\n\
    For better performance we can use string concatenation instead of vector addition.\n\
    <code>", "    \"string_sequence(n) = return String containing space-delimited\
    \ numbers starting from 0 upto n inclusive.\"\n    \n    string = \"0\"\n    for\
    \ i = 1 to n do \n        string = string + \" \" \n    string = string // \"\
    \ \"\n    return string\nend \n</cell>\n<code language=julia-1.0>", "    \"Return\
    \ a string containing space-delimited numbers starting from 0 upto n inclusive.\"\
    \n    return map((string(x)), sequence(n))", "    list = Array{String,1}(undef,n)\n\
    \    for i in 1:n\n        list[i] = i\n    end\n    return join(\" \",list)\n\
    end\n</cell>\n<code language=julia-0.6>\nstring_sequence(5)\n</cell>\n<text>\n\
    Strings as Arrays of Chars\nStrings are Arrays of Chars in Julia. Arrays are very\
    \ flexible types. We can use them to store strings, numbers, booleans, even functions.\
    \ Below we demonstrate how Strings can be used as Arrays of Chars.", "    \"Return\
    \ a string containing space-delimited numbers starting from 0 upto n inclusive.\"\
    \n    if n==0 then return \"0\"\n    if n==1 then return \"1 0\"\n    else if\
    \ n<10 then return string_sequence(n/2)\n    else \n        s = \"\"\n       \
    \ while n >= 10\n            s = string((n%10), s)\n            n = floor(n/10)\n\
    \        s = string(n, s)\n        return s\n</code>\n<|/ a tags=clojure,lazy-evaluation,string\
    \ |>\n<| c |>\nWhat is the difference between `reduce` and `reduce-right`?\n<|/\
    \ c |>\n<| a |>\n<code>\n(defn string-sequence [n acc]\n  (if-let [s (seq acc)]\n\
    \    (reduce #(conj %1 (last %2)) \n      (range) \n      (if (< n %2)\n     \
    \     s\n          (str (first s) (nth s n)))))\n  acc)", "    \"Return a string\
    \ containing space-delimited numbers starting from 0 upto n inclusive.\"\n   \
    \ return str((0 ..< n).collect{|i| i.to_s}).join(\" \")\nend\n</cell>\n<code language=julia-1.2>\n\
    string_sequence(20)\n</cell>\n<text>\nExercise 1\nWrite a function (called \"\
    string_sequence\") that returns a string containing space-delimited numbers starting\
    \ from 1 up to n inclusive. For example, string_sequence(20) should return a string\
    \ \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\".", "    str = \"0\"\n\
    \    for i in 1 .. (n-1) do\n        str = str + \" \" + str\n    end\n    return\
    \ str\nend\n</cell>\n<code language=julia-1.3>\nstring_sequence(5)\n</cell>\n\
    <text>\nTuples", "    \"\"\"Return a string containing space-delimited numbers\
    \ starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n \
    \   >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n    \"\"\"", "    str = zeros(n,\
    \ String);\n    i = 1;\n    for s in str do\n        push(s, toString(i));\n \
    \       i += 1;\n    end\n    return join(\" \", str)\nend", "    s = \"\"\n \
    \   for k in 0:n-1\n        s <- s+\" \"\n    end\n    return s\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=julia dscore=0 |>\nThis is one method using join:\n\
    <code>", "    if n == 0 \n        return \"0\"\n    return \" \" + string_sequence(n-1::Int64)\
    \ + \" \" + (\" \" + (\" \"  + string_sequence(n-1::Int64) + \"  \") + \" \")\
    \ * n\nend", "    \"\"\"Return a string containing space-delimited numbers starting\
    \ from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n\
    \    \"0 1 2 3 4 5\"\n    \"\"\"", '    return String(String[] for i in 0:n)',
  "    \n    string = \"\"\n    if n == 0\n        string = \"0\"\n    else if n ==\
    \ 1\n        string = \"1\"\n    else\n        for i in 0:(n-1)\n            string\
    \ = string + \" \" + str(i)\n    string\nend", "    string_seq = \" \"\n    for\
    \ i in 0 .. n-1 do\n        string_seq = string_seq + i\n    end\n    return string_seq\n\
    end\n</cell>\n<text>\nNow you know that the function string_sequence will return\
    \ a string containing numbers from 0 to $n$, where $n$ is an integer. Run the\
    \ following cell to check your answer.", "    return \"0\" :: String \n    for\
    \ s in str_to_array(0:n) \n        @sprintf(\"%d \", s)\n    end \nend ", "  \
    \  \"Return a string containing space-delimited numbers starting from 0 upto n\
    \ inclusive.\"\n    \"$n\"\n    \" 0 1 2 3 4 5\"\nend\n</cell>\n<cell>\n@doc string_sequence()\n\
    </cell>\n<text>\nExercise 1\nUse the @doc macro above to write a small function\
    \ count_sequences(n::Int64)::Int64 that counts the number of sequences of space-delimited\
    \ numbers with length n.", "    \"Return a string containing space-delimited numbers\
    \ starting from 0 upto n inclusive.\"\n    return \" \" * n + (\" \" * (n - 1))\
    \ * n\nend string_sequence", "    local i = 0\n    local str = \"\"\n    while\
    \ i < n do\n        str = str..i\n        str = str..\" \"\n        i += 1\n \
    \   end\n    return str\nend\n</cell>\n<code language=julia-1.5>\nstring_sequence(3)\n\
    </cell>\n<code language=julia-1.5>", "    if n < 0 \n        error(\"expected\
    \ non-negative integer, got $n\", 2)\n    \n    seq = \"\"\n    for i in 0:n\n\
    \        seq += i\n    end\n    return seq\nend", "    \n    digits = String[]\n\
    \    for k in 0:n\n        digits = digits + k \n    return join(\" \", digits)\n\
    end\n</cell>\n<code language=julia-0.6>\nstring_sequence(0)\n</cell>\n<code language=julia-0.6>\n\
    string_sequence(5)\n</cell>\n<text>\nExercise\nWrite a function that generates\
    \ the Fibonacci sequence up to some number n.\nHint: Use two variables a, and\
    \ b.", "    seq = \"\"\n    i =  0\n    while i < n\n        do\n            seq\
    \ = seq + \" \" + str(i)\n            i += 1\n        end\n    return seq\nend ",
  "    \"Return a string containing space-delimited numbers starting from 0 upto n\
    \ inclusive.\"\n    local string = \"\"\n    for i = 1 .. n\n        do\n    \
    \        string = string .. String(i)\n        end\n    end\n    return string\n\
    end\n</cell>\n<code language=julia-1.4>\nstring_sequence(0)\n</cell>\n<text>\n\
    Exercise 2\nWrite a function counting_upto(start, stop) which returns a vector\
    \ of counts starting from start up to stop inclusive.", "    seq = \"\"\n    for\
    \ i = 1:n\n        seq = seq + i\n        seq = seq + \" \" \n    return seq\n\
    end\n</cell>\n<code language=julia-1.5>", "    \"\"\"Return a string containing\
    \ space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n\
    \    \"0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n    \"\"\"", "  \
    \  if n < 0 then error(\"Invalid range\") else \"\"\n    if n==0 then return \"\
    0\" else string_sequence(n-1)+string_sequence(n-1)\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis answer doesn't meet the requirements of being a straight forward\
    \ answer to the problem presented. It does not explain how or why it works.\n\
    <|/ c |>\n<| a tags=recursion,range,haskell |>\nHere's a solution that doesn't\
    \ require an explicit stack (as suggested in the other answers)\n<code>\ngenSeq\
    \ :: Int -> [Int]\ngenSeq n = genSeq' n 0\n    where genSeq' 0 _ = []\n      \
    \    genSeq' n _ = [n]\n          genSeq' n last\n              | last < n   \
    \ = genSeq' (last + 1) [n]\n              | otherwise = last : genSeq' (last +\
    \ 1) [n]", "   if n<1\n     return \"\"\n   if n==1\n     return \"0\"\n   else\
    \ if n==2\n     return \"0 1\"\n   else\n     return \"0 1 2 3 4 5\"\nend\n</code>\n\
    <|/ a |>\n<| c |>\nWhat about `string_sequence(4)`? :)\n<|/ c |>\n<| a tags=julia,string,sequence,numbers\
    \ |>\nOne more option using Julia:\n<code>", "    if n < 0 return \"\" \n    \n\
    \    if n==0 return \"0\"\n    if n==1 return \"1\"\n    \n    if n==2 return\
    \ \"0 1\"\n    \n    if n==3 return \"0 1 2\"\n    \n    if n==4 return \"0 1\
    \ 2 3\"\n    \n    if n==5 return \"0 1 2 3 4\"\n    \n    if n==6 return \"0\
    \ 1 2 3 4 5\"\n    \n    return string_sequence(n-1)+\" \"+string_sequence(n-2)\n\
    end\n</cell>\n<code language=julia-1.0>", "  return string_sequence([n]::Int64)\
    \ \nend\n</cell>\n<code language=julia-1.5>", "    if n>0 \n    then \n      \
    \  for i from 0 to n-1\n        do \n            strcat \"0 \"\n    else \n  \
    \      strcat \"0\"\n    end\nend\n</cell>\n<text>\nExercise 3\nThe Julia syntax\
    \ for function definitions is quite similar to other languages.  So what is the\
    \ difference in Julia between the following function definitions?", "    \"Return\
    \ a string containing space-delimited numbers starting from 0 upto n inclusive.\"\
    \n    str = \" \"\n    for i in 0:n\n        str += \" \"+str(i)\n    return str",
  "    \"Return a string containing space-delimited numbers starting from 0 upto n\
    \ inclusive.\"\n    \" For example, string_sequence(5) returns \\\"0 1 2 3 4 5\\\
    \".\"\n    \" For other numbers, it returns \\\"\\\".\"\n    if n < 0\n      \
    \  \"Error \\\"Negative number expected.\\\" - string_sequence(n)\"\n    elseif\
    \ n < 1\n        \" 0 - string_sequence(n)\"\n    else\n        \" \" ^ n - string_sequence(n-1)\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=kotlin,android,java dscore=0 |>\n<code>\n\
    fun main(args:Array<String>){\n    var input = readLine()\n    var n = input!!.toInt()\n\
    \    var s = \" \"\n    while(true){\n        if(n % 2 == 0){\n            s +=\
    \ \"0 \"\n        }else{\n            s += \"1 \"\n        }\n        if(n > 1){\n\
    \            s += \" \"\n        }else{\n            break\n        }\n      \
    \  n--\n    }\n    println(s)\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=kotlin,android,java\
    \ |>\n<code>\nfun main(args:Array<String>){\n    var input = readLine()\n    var\
    \ n = input!!.toInt()\n    var s = \" \"\n    while(true){\n        if(n % 2 ==\
    \ 0){\n            s += \"0 \"\n        }else{\n            s += \"1 \"\n    \
    \    }\n        if(n > 1){\n            s += \" \"\n        }else{\n         \
    \   break\n        }\n        n--\n    }\n    println(s)\n}\n</code>\n<|/ a |>\n\
    <| c |>\nIt would really help the answer if you could also add an explanation\
    \ to your code.\n<|/ c |>\n<| c |>\nWhile this code may answer the question, providing\
    \ additional context regarding why and/or how this code answers the question improves\
    \ its long-term value.\n<|/ c |>\n<| a tags=kotlin,android,java |>\n<code>\nvar\
    \ n = input!!.toInt()\nvar s = \"\"\nwhile(true){\n    if(n % 2 == 0){\n     \
    \   s += \"0 \"\n    }else{\n        s += \"1 \"\n    }\n    if(n > 1){\n    \
    \    s += \" \"\n    }else{\n        break\n    }\n    n--\n}\nprintln(s)\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=kotlin,android,java dscore=0 |>\n<code>\n   fun main(args:\
    \ Array<String>) {\n        val input: String? = readLine()!!\n        val n:\
    \ Int = input", "    if n==0 then \"0\" else \" \".(strings(n-1))\nend\n</cell>\n\
    <code language=julia-1.0>\nstring_sequence(3)\n</cell>\n<code language=julia-1.0>\n\
    string_sequence(10)\n</cell>\n<code language=julia-1.0>\nstring_sequence(100)\n\
    </cell>\n<code language=julia-1.0>\nstring_sequence(100)\n</cell>\n<code language=julia-1.0>\n\
    string_sequence(1000)\n</cell>\n<text>\nPart III: Function Composition and Partial\
    \ Application\nFunctions can have multiple forms. Let's consider a function which\
    \ takes in two numbers and adds them:", "    if n <= 0 return \"\"\n    seq =\
    \ \"\"\n    digits = 1\n    while digits <= n do \n        seq = seq + to_string(digits)\
    \ + \" \" \n        digits += 1\n    end\n    return seq\nend\n</cell>\n<code\
    \ language=julia-1.5>\nstring_sequence(4)\n</cell>\n<text>\nThe reverse of a string\
    \ is the string obtained by reversing the original string. For example, the string\
    \ \"hello\" can be reversed into \"olleh\" using the following code. The function\
    \ reverse_string does this in one step.", "    return \"0\"\n</code>\n<|/ a tags=julia,string\
    \ |>\n<| a dscore=1 |>\nI like solution which is simple and yet effective and\
    \ easy to use.\nHowever, I would like to add some modifications.\n<code>", " \
    \   str = string_sequence(0)\n    for n in 0..n\n        str = concat(str, string_sequence(n))\n\
    \    return str\nend\nstring_sequence()\n</cell>\n<code language=julia-1.3>\n\"\
    \"\"\n    string_sequence_with_repeat(s::String, n::Int64)::String\nReturns a\
    \ string starting from 0 upto n inclusive that is constructed by concatenating\
    \ s as many times as n specifies.\n\"\"\"", "    \"Return a string containing\
    \ space-delimited numbers starting from 0 upto n inclusive.\"\n    \n    # Define\
    \ an auxiliary function and two iterators:\n    # - an iterator for the sequence\
    \ of digits (the numbers)\n    # - an iterator for the sequence of letters (the\
    \ alphabet)\n    # - an iterator for the sequence of letters starting from the\
    \ numbers and ending on n\n    # - a tuple containing the index of the next element\
    \ and the iterator\n    # - a variable for the number of digits and the number\
    \ of letters in the alphabet\n    function digits_alphabet(it::Int64, alphabet_index::Int64)::Int64\
    \ \n        if it == n then 1 else digits_alphabet(it+1, alphabet_index+1)\n \
    \   end\n    function letters_alphabet(it::Int64, alphabet_index::Int64)::Int64\
    \ \n        if it == n then 1 else letters_alphabet(it+1, alphabet_index+1)\n\
    \    end\n    function letters_alphabet(it::Int64, alphabet_index::Int64)::String\
    \ \n        if alphabet_index == n then\n            digits_alphabet(it, alphabet_index)\n\
    \        else\n            letters_alphabet(it+1, alphabet_index)\n        end\n\
    \    end\n    alphabet = map(letters_alphabet, 1:n+1)\n    digits = map(digits_alphabet,\
    \ 1:n+1)", "    if n < 0 \n        throw(ArgumentError(\"n must be non-negative\"\
    ))\n    result = \"\"\n    for i in 0 .. n-1 \n        result = result ++ string(i)\n\
    \    return result\n</code>\n<|/ a dscore=3 |>\n<| c |>\n`String.length()` was\
    \ introduced in Rust 1.41, and doesn't work with older versions.\n<|/ c |>\n<|\
    \ c |>\nYes, it seems like it's been introduced in Rust 1.41. However, this doesn't\
    \ seem to work with Rust 0.12.1, which seems to be the only version available\
    \ in Mandriva.\n<|/ c |>\n<| a dscore=2 |>\nHere's a one-liner using recursion:\n\
    <code>", "    seq = \"\"\n    for ix in 0:(n-1)\n        seq = seq + string(x[ix])\n\
    \    end\n    return seq\n</code>\nThis function can be used with many other functions.\
    \ For instance, here is a function that takes a tuple of variables (or a vector\
    \ to be precise) and outputs their values converted to strings:\n<code>", "  \
    \  str = itoa(n,10)\n    return str\nend\n</code>\n<|/ a dscore=0 tags=julia,functional-programming\
    \ |>\n<| c |>\nPlease see my edit. I have added a second function which I believe\
    \ is clearer than the one you provided - and does exactly what the original function\
    \ did.\n<|/ c |>\n<| c |>\nThank you for the answer - but I don't see how this\
    \ is any different from the function I originally posted. In your example you\
    \ have done a map and then flattened the resulting array.\n<|/ c |>\n<| c |>\n\
    I guess the point is that it is more concise and readable than the original function\
    \ and does not need any mutation. Also it is easier to see what is happening.\
    \ I did a quick test and it seems to work. I am just wondering why you chose to\
    \ create a new function instead of using the original one.\n<|/ c |>\n<| c |>\n\
    Okay, I see what you are saying. But I think it would be more efficient to write\
    \ the function without the map and flatten - and just append each number to the\
    \ string in turn. I am not sure how it is done with the map and flatten.\n<|/\
    \ c |>\n<| a |>\n<code>", '    return string(n, " ")', "    \"\"\"Return a string\
    \ containing space-delimited numbers starting from 0 upto n inclusive.\n    \"\
    \"\"\n    sts = \"\"\n    for x in 0:n\n        sts = sts + \" \" + to_string(x)\n\
    \    end\n    return sts\n</code>\n<|/ a tags=julia,string dscore=2 |>\n<| c |>\n\
    Thank you very much for your help. I still have a hard time getting the right\
    \ syntax. I am not sure how to add my input into the code. My input is n = 10,\
    \ and I would like to print a line for each of the numbers from 0 up to n. I am\
    \ not sure how to incorporate that into the code.\n<|/ c |>\n<| c |>\nThank you\
    \ very much for your help. I still have a hard time getting the right syntax.\
    \ I am not sure how to add my input into the code. My input is n = 10, and I would\
    \ like to print a line for each of the numbers from 0 up to n. I am not sure how\
    \ to incorporate that into the code. For example, my output is supposed to look\
    \ like this: ```0 1 2 3 4 5 6 7 8 9```.  I appreciate your help!\n<|/ c |>\n<|\
    \ a dscore=2 tags=julia,string |>\nThe question was already answered and there\
    \ are already some great answers.\nHowever, I thought I'd add something that might\
    \ be useful to someone. There is a function called strcat that concatenates strings\
    \ with a space between them. As you can read in the docs:", "    if n == 0\n \
    \       \"0\"\n    else\n        string = \"\"\n        for _i in range(0, n-1)\n\
    \            string = string + String(_i) + \" \"\n        string = string + String(n)\
    \ \n    end\nend\n</code>\nThe above function can be used to display strings from\
    \ 0 to n inclusive.\nYou can see it working in the below example.\n<code>\njulia>\
    \ using PyPlot", "    return join(0:n,\" \")\nend\n</code>\n<|/ a tags=julia,string\
    \ |>\n<| a tags=julia,string dscore=3 |>\nFor those looking for the answer to\
    \ the updated question, you can use:\n<code>\n\"0\"^i\n</code>\nto get a string\
    \ consisting of the character 0 in the ith position.\n<|/ a |>\n<| a dscore=1\
    \ |>\nYou can use concatenate to build a string and then use substring to get\
    \ the sub-string you want.\n<code>\na = \"0\"\nb = join(0:5, \" \")\nprintln(\"\
    $a $b\")\nprintln(\"$b $a\")\n</code>\n<|/ a tags=julia,string |>\n<| c |>\nI\
    \ don't think this will work. `join` converts its argument to a string, and will\
    \ convert `0:5` to `\"0 1 2 3 4 5\"`. You can't just take `i` from that.\n<|/\
    \ c |>\n<| c |>\nThanks, you're right. I was thinking about the more general question\
    \ of splitting a string, which could work. I've updated the answer.\n<|/ c |>\n\
    <| a dscore=1 |>\nHere are a couple of other ways to do this, but I suspect that\
    \ for most applications one of the other solutions will do just fine.\nFor strings,\
    \ here's a couple of ways I use:\n<code>\njulia> s = \"\"\n\"\"", "    string\
    \ = \"\"\n    for i = n-1, 0, -1 do\n        string = string + \" \" + stringstring(i)\n\
    \    end\n    return string\n</code>\n<|/ a tags=julia,loops,performance dscore=0\
    \ |>\n<| c |>\nThat is still O(n^2) in the worst case scenario. For example if\
    \ you have 1000000 elements and only 100000 of them are non-zero, this algorithm\
    \ will output 10000000 strings instead of only 100000.\n<|/ c |>\n<| c |>\nyou\
    \ are right I didn't realize that case and I corrected my answer.\n<|/ c |>\n\
    <| a dscore=0 |>\nNot sure if it will help you, but I had similar problem. I needed\
    \ to generate 100 random numbers and to put them in an array with zeros in between\
    \ them. \n<code>\nfor n in 1:100\n    array[n] = rand(100)\nend\n</code>\nAnd\
    \ then to fill zeros in between them:\n<code>\nfor n in 1:100\n   for i= 1:n\n\
    \       if i ==1\n           array[n][i] = 0\n       end\n   end\nend\n</code>\n\
    <|/ a tags=julia,loops,performance |>\n<| a tags=julia,loops,performance |>\n\
    As far as I can tell, no other solution so far has beaten me in terms of performance\
    \ (at least in Julia 1.1.5):\n<code>", "    \"Return a string containing space-delimited\
    \ numbers starting from 0 upto n inclusive.\"\n    result = \"\"\n    for i =\
    \ n-1 downto 0 do\n        result = result + \" \" + string(i)\n    return result\n\
    </code>\n<|/ a tags=julia,syntax dscore=2 |>\n<| c |>\n`join` is not the best\
    \ way to concatenate strings. Julia has a built-in function for this, `string`.\n\
    <|/ c |>\n<| c |>\nIt seems string and join are two different concepts.\n<|/ c\
    \ |>\n<| c |>\nYes, I know. But they do different things. `join` is used to build\
    \ up a string, and `string` is used to convert a number to a string.\n<|/ c |>\n\
    <| c |>\nAgreed, but since Julia 0.4 `string` was merged into the standard library\
    \ and no longer exists in the `Strings` module.\n<|/ c |>\n<| a dscore=2 tags=julia,syntax\
    \ |>\nIn Julia 0.7 you can just write:\n<code>\njoin(\" \",0:5) # \"0 1 2 3 4\
    \ 5\"\n</code>\nIt also works with ranges:\n<code>\njoin(\" \",0:5:10) # \"0 1\
    \ 2 3 4 5 6 7 8 9 10\"\n</code>\nAnd it works with generators as well:\n<code>\n\
    join(\" \",(i for i in 0:5))\n</code>\nAnd you can even nest them:\n<code>\njoin(\"\
    \ \",(i for i in 0:5 for j in 0:5))\n</code>\n<|/ a |>\n<| c |>\nYes that works\
    \ but it is quite clumsy in my opinion. Plus you have to define join function\
    \ yourself. So it depends.\n<|/ c |>\n<| c |>\n`join` comes from standard library;\
    \ no custom implementation required\n<|/ c |>\n<| c |>\n: I suppose you meant\
    \ \"no custom implementation *is required*\" ?\n<|/ c |>\n<| c |>\n: Yes, `join`\
    \ comes from `Base`. `Base` is the standard library in Julia 0.7.\n<|/ c |>\n\
    <| a tags=julia,syntax |>\nJulia 0.7 has a built in function called string.\n\
    <code>\nstring.(0:5)\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 tags=julia,syntax\
    \ |>\nJulia 0.6.3 was released just yesterday and included the following function\
    \ in string.\n<code>\njoin(a::AbstractVector{<:AbstractString}, sep = \" \", collapse\
    \ = false)", "\"\"\"\nReturn a string containing space-delimited numbers starting\
    \ from 0 upto n inclusive.\n\"\"\"\n</cell>\n<code language=julia-1.1>\nstring_sequence(0)\n\
    </cell>\n<code language=julia-1.1>\nstring_sequence(5)\n</cell>\n<text>\nWe can\
    \ also define a function with multiple outputs to return multiple values at a\
    \ time.", "        string_array = zeros(Int, n+1)\n        for i=1:n\n       \
    \     string_array[i] = i\n        end\n        return string_array[end]\nend\n\
    </code>\n<|/ a tags=julia,string,numbers |>\n<| a dscore=2 |>\nJust to throw this\
    \ out there, here's a way to do this in julia:\n<code>\n\"0\"*5\n\"01\"*5\n\"\
    0123\"*5\n</code>\n<|/ a tags=julia,string,numbers |>\n<| a |>\nHere is another\
    \ approach\n<code>", "  return\n    map (+) (string x) | take n (cycle (repeat\
    \ (\" \" :: String))) |> join \" \"\nend\n</code>\n<|/ a tags=julia dscore=2 |>\n\
    <| c |>\nThis doesn't seem to work for `n = 4`, for instance.\n<|/ c |>\n<| a\
    \ dscore=1 tags=julia |>\nHere's a solution that's simple and readable:\n<code>",
  "    return string(rep_sequence(0, n))\nend string_sequence\n</code>\n<|/ a tags=julia,arrays,indexing\
    \ |>\n<| c |>\nI think you should add `return \"\"` in front of `string_sequence(0)`\
    \ and `string_sequence(1)`. Otherwise you get `0 ` as string for `string_sequence`.\n\
    <|/ c |>\n<| c |>\nI did not know about `rep_sequence`. That's awesome!\n<|/ c\
    \ |>\n<| a dscore=3 |>\nHere's another way to do it\n<code>\nstring_sequence(n::Int64)::String\n\
    \    str = fill(\" \", n+1)\n    str[2:n+1] = [\" \"]\n    str\nend string_sequence\n\
    </code>\n<|/ a tags=julia,arrays,indexing |>\n<| c |>\nThis also works in Julia\
    \ v0.7 but is slower for small values of `n`. If you want to do it efficiently,\
    \ you should use `strcat` instead.\n<|/ c |>\n<| a tags=julia,arrays,indexing\
    \ dscore=3 |>\nHere's a slightly more efficient version, which relies on strcat\
    \ and no concatenation at all:\n<code>", "    # Your code here\n    return \"\"\
    \nend\n</cell>\n<code language=julia-1.0>\nstring_sequence(5)\n</cell>\n<text>\n\
    Write a function that outputs the string representation of the sequence of prime\
    \ numbers.\ne.g. the sequence 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, etc.",
  "    return string_sequence_aux(n, 0, n, \"0\")\nend\nstring_sequence()\n</cell>\n\
    <text>\nNow that we have defined the string_sequence function, let's see how to\
    \ use it.", "    seq = map(String,sequence(n+1))\n    return \" \".join(seq)\n\
    </code>\n<|/ a tags=haskell,list,arrays,performance |>\n<| a dscore=1 |>\nHere's\
    \ another approach (although it's far less elegant than others here):\n<code>\n\
    import qualified Data.Sequence as S\nimport Data.List", "    return \" \".(map(flip\
    \ show, string_sequence(0:n)))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work for all numbers. Try it for n = 8. First string should be: `\" 08 09 10\
    \ 11 12\"` but the code returns `\"08 09 10 11 12 13 14 15 16 17 18 19\"`.\n<|/\
    \ c |>\n<| c |>\nThis works for n = 8 and n == 9 as well, please check the attached\
    \ screen shot. :)\n<|/ c |>\n<| c |>\nThe code is not recursive. It just generates\
    \ the strings using the function. It doesn't go into the depths of recursive functions.\
    \ In other words, you are not generating all the sequences but the ones for the\
    \ base cases.\n<|/ c |>\n<| c |>\nI understand that this function isn't recursive,\
    \ however it does generate all the numbers up to n and converts them to strings.\
    \ I think you are missing the recursive part.\n<|/ c |>\n<| c |>\nNo, you're not\
    \ missing the recursive part but you're misusing the function. Please check the\
    \ example from the post: try `string_sequence(4)`. It's not recursive. Recursive\
    \ functions take the arguments and call themselves. You don't just call them but\
    \ they *generate* the strings.\n<|/ c |>\n<| a dscore=1 |>\nI wrote a function\
    \ that generates string sequences up to a given number n using the recursive function\
    \ generator:\n<code>", "    str = repeat(\"0\", n) \n    for i in 1:n\n      \
    \  str = str + repeat(\"1\", i - 1) + \" \"\n    return str\nend\n</cell>\n<code\
    \ language=julia-0.6>\nstring_sequence(5)\n</cell>\n<text>\nWrite a function that\
    \ takes a string as input and returns the number of occurrences of a particular\
    \ character within that string.\ne.g. count(c(\"abcdef\", \"a\", \"ab\")) == 1",
  "    if n < 0\n        return \"0\"\n    else \n        return string_sequence(n-1)\
    \ + string_sequence(n)\n</code>\n<|/ a |>\n<| c |>\nCould you please explain how\
    \ the function works step by step?\n<|/ c |>\n<| c |>\nThis is what I came up\
    \ with:\n`function string_sequence(n::Int64)::String\n    if n < 0\n        return\
    \ \"0\"\n    else \n        return string_sequence(n-1) + string_sequence(n)`\n\
    <|/ c |>\n<| c |>\nSorry for the formatting I'm new to SO\n<|/ c |>\n<| c |>\n\
    Thanks for the answer, but I was looking for an easier way to solve the problem\n\
    <|/ c |>\n<| c |>\nI added some explanation to my answer. I hope this helps.\n\
    <|/ c |>\n<| a tags=string,haskell |>\n<code>\nimport Data.List", "    return\
    \ \"{\" + join(0:(n-1)) + \"}\"\nend\n</cell>\n<text>\nNext we define the function\
    \ which creates a histogram of size n using an array of n elements.", "    return\
    \ String.join(\" \", Int64.range(n+1))\nend \n</cell>\n<text>\nThe next cell is\
    \ going to be the definition of the function print_strings, which will print the\
    \ string representation for every string in the sequence given as input.", " \
    \   return \"$(for n in $(seq $(n)) ; do echo $n ; done)\"\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=julia,printing,string dscore=2 |>\n<code>", "    \"\
    Return a string containing space-delimited numbers starting from 0 upto n inclusive.\"\
    \n    \"\"\n    \"0\"\n    return \"0 1 2 3 4 5\"\n</code>\n<|/ a tags=julia |>\n\
    <| c |>\nThanks! This is great. I think I understand your solution, but I still\
    \ think there are some issues with it. If I try it out with n = 2 I get \"0 1\"\
    . Also, `@code_warntype` gives me an error that the method `*` is undefined for\
    \ the object of type Nothing\n<|/ c |>\n<| c |>\nSorry, I had forgotten to include\
    \ `n` as a parameter for the `string_sequence` function. Please see the updated\
    \ code.\n<|/ c |>\n<| c |>\nThis is great! I tested it with `n = 5` and it works!\
    \ However, I still have one issue: I still need to manually write out `0 1 2 3\
    \ 4 5` when I want to print it out. I can't figure out a way to make it automatically.\n\
    <|/ c |>\n<| c |>\nI updated my answer to include a solution that is closer to\
    \ your original intended use. I'm leaving it here for anyone who might find it\
    \ useful in the future.\n<|/ c |>\n<| c |>\nI realize this is super old. I've\
    \ been looking at this for a while and am having trouble getting it to work. Could\
    \ you give me a hand? [https://github.com/khe/string_sequence.jl](https://github.com/khe/string_sequence.jl)\n\
    <|/ c |>\n<| a dscore=1 |>\nYou can just use a loop. Assuming you have a vector\
    \ of strings:\n<code>\njulia> strings = [\"foo\", \"bar\", \"baz\", \"quux\",\
    \ \"quuz\"]\n5-element Array{String,1}:\n \"foo\"\n \"bar\"\n \"baz\"\n \"quux\"\
    \n \"quuz\"", "    \n    \"\"\"\n    Write a function that returns a string containing\
    \ space-delimited numbers starting from 0 upto n inclusive.\n    \"\"\"\n    return\
    \ \" \"*n + string_sequence_to_string(n)", "    str = if n == 0 then \"0\" else\
    \ string(\" \", n-1) + string_sequence(n)\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=0 |>\nIn Julia, you might write\n<code>\njulia> string(\"Hello\",10)\n\
    \"HelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHello\"\n</code>\n\
    and more generally\n<code>", "    \"Return a string containing space-delimited\
    \ numbers starting from 0 upto n inclusive.\"\n    \"\"\n    return \"0 1 2 3\
    \ 4 5\" #change this\nend", "    seq = Int64.range(n)\n    seq = seq[(seq.end\
    \ .- seq.start .+ 1)..]\n    seq = seq.collect{i -> string_of(i)}\n    seq = seq.join()\n\
    \    return seq\nend", "    if (n==0)\n        return \"0\"\n    else\n      \
    \  string_seq=\"\"\n        for i in 0:n-1\n            string_seq=string_seq+\"\
    \ \"+str(i)\n        end\n        return string_seq\nend", "    \"\"\"return a\
    \ string containing space-delimited numbers starting from 0 upto n inclusive\"\
    \"\"\n    \n    return ' '.join(map(str,range(0,n)))\n</code>\n<|/ a |>\n<| a\
    \ tags=haskell,recursion |>\nThe easiest way is to use String.replicateM:\n<code>\n\
    import Data.Char\nimport Control.Monad\nimport qualified Data.List.NonEmpty as\
    \ NEL", "    if n < 0\n        error(\"string_sequence(n) expected nonnegative\
    \ integer, got $n\")\n    else if n == 0\n        return \"0\"\n    else \n  \
    \      return string_sequence(n - 1) + \" \" + to_string(n)\n</code>\nThen you\
    \ can just use it in your example:\n<code>\nstring_sequence(5)\n# => \"0 1 2 3\
    \ 4 5\"\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is another version\
    \ that should be more efficient because it uses pattern matching instead of concatenation:\n\
    <code>\nimport Data.List (intercalate, tails)", "    s = \"\"\n    for i = 1:n\n\
    \        s = s + \" \" + to_string(i)\n    end\n    return s\nend", '    return
    join(0..n," ")', "    # Return string containing numbers from 0 to n-1 \n    #\
    \ with space between each number \n    if n == 0 \n        return \"0\" \n   \
    \ else \n        return string_sequence(n - 1) + \" \" \nend string_sequence\n\
    </cell>\n<text>\nThe main function below takes the arguments n and m. First it\
    \ checks if both n and m are positive numbers. If not, it throws an exception.\
    \ Once n is positive, it calls string_sequence using that value. Then it prints\
    \ the string generated by string_sequence.", "    \n    if n>0\n        \n   \
    \     string = \" \"\n        i = n-1\n        while i>0\n            string =\
    \ (string..\" \").(tostring(i))\n            i -= 1\n        \n        return\
    \ string\n    else\n        return \"0\"", "  \"\"\" Return a string containing\
    \ space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n\
    \    \"0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n    \"\"\"\n</code>\n\
    <|/ a tags=julia dscore=1 |>\n<| c |>\nI appreciate your help. I see what you\
    \ are saying about the function declarations being unnecessary, but I'm still\
    \ getting an error. The function `string_sequence` is defined above but is giving\
    \ me the following error `ERROR: LoadError: UndefVarError: string_sequence not\
    \ defined`. I've edited my question to show my latest attempt to fix the issue.\
    \ Thanks again for your help.\n<|/ c |>\n<| c |>\nAre you sure you are running\
    \ the script in which you defined the function? The error message suggests that\
    \ `string_sequence` is not defined, which means that this script has nothing to\
    \ do with the function you showed in the question.\n<|/ c |>\n<| c |>\nI apologize\
    \ for my ignorance but I'm a complete novice. How do I know if I'm running a script\
    \ in which I defined the function? I ran your code exactly as it is in my question\
    \ and the code ran without errors.\n<|/ c |>\n<| c |>\nI suggest you start a new\
    \ question where you include the complete script that you are using for your function.\
    \ Otherwise it is hard to guess where the problem is. Also, it would be useful\
    \ to show how you are using the function in your script.\n<|/ c |>\n<| c |>\n\
    The function is defined in `string_seq.jl`. I run `include(\"string_seq.jl\")`\
    \ within my `run.jl` script. Thank you again for your help.\n<|/ c |>\n<| a |>\n\
    When you run include(\"string_seq.jl\"), it imports the contents of string_seq.jl\
    \ into the current scope (which, in your case, is the script run.jl). The contents\
    \ of string_seq.jl are then accessible in the script where you include it. What\
    \ you need is to put your functions into a separate module. For example, suppose\
    \ we have a module called myfunctions.jl:\n<code>\nmodule MyFunctions", "    if\
    \ n == 0\n        return \"0\"\n    return string_sequence(n-1).! + \" \" + to_string(n)\n\
    end string_sequence\n</code>\n<|/ a |>\n<| a tags=julia,string |>\nA variation\
    \ on Jeff R's answer. This uses a function string_sequence to avoid repeating\
    \ a line twice. \n<code>\nusing Strings", "    \"\"\"\" Return a string containing\
    \ space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n\
    \    \"0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n    \"\"\"", "  \"\
    \"\"Return a string containing space-delimited numbers starting from 0 upto n\
    \ inclusive.\n  \"\"\"\n  return \" \".join(map(string(n), range(n))).replace(\"\
    .\", \" \")\n</code>\nand we can test it with\n<code>\njulia> string_sequence(10)\n\
    \"0 1 2 3 4 5 6 7 8 9 10\"\n</code>\nIn a second step, you will need to write\
    \ the function string_sequence that splits the given string into words (that is,\
    \ the numbers on the string should be separated by space). A simple way to do\
    \ that is using split\n<code>", "    \" Return a string containing space-delimited\
    \ numbers starting from 0 upto n inclusive.\"\n    return join(split(string(n),\
    \ \" \"), \" \")", "    \"Return a string containing space-delimited numbers starting\
    \ from 0 upto n inclusive.\"\n    return \"0 \" * (n-1) + \" 1 2 3 4 5\"\n</code>\n\
    <|/ a dscore=0 tags=julia,concatenation,string |>\n<| c |>\nThis isn't very efficient,\
    \ since it copies the string every time you concatenate an additional space, and\
    \ since you copy it a bunch of times it can be quite slow. For more efficient\
    \ solutions, see my answer [here](https://stackoverflow.com/a/66635859/1938758).\n\
    <|/ c |>\n<| a tags=julia,concatenation,string |>\nAs I wrote in a comment to\
    \ another answer, a concatenation operation is actually quite a slow operation\
    \ (especially on long strings) compared to a concatenation operation on a String[].\
    \ However, there are a few tricks that can help speed things up quite a bit.\n\
    The most straightforward is to only copy the string once instead of N times. I\
    \ did an experiment to see if this would work and it appears that it does:\n<code>",
  '    return string_seq(n, "")', "    return \"0 1 2 3 4 5\" |> str\n</code>\n<|/\
    \ a |>\n<| a dscore=2 |>\n<code>", "    \"Return a string containing space-delimited\
    \ numbers starting from 0 upto n inclusive.\"\n    string_seq = \"0\"\n    for\
    \ i in i::n\n        string_seq += i::String\n    end\n    return string_seq\n\
    end\n</cell>\n<code language=julia-1.2>\nstring_sequence(0)\n</cell>\n<code language=julia-1.2>\n\
    string_sequence(5)\n</cell>\n<code language=julia-1.2>", "    \"Return a string\
    \ containing space-delimited numbers starting from 0 upto n inclusive.\"\n   \
    \ \n    s = ''\n    for i in 0:(n-1)\n        s = s ^ i\n    return s", "    string_sequence\
    \ = \"\"\n    for x in string_range(n):\n        string_sequence += \" $x\"\n\
    \    return string_sequence\n</code>\n<|/ a |>\n<| a tags=string,haskell |>\n\
    I came up with this using list comprehension (with more indentation than my other\
    \ answer since it does exactly the same thing with less code). My idea was to\
    \ treat the list as two dimensional, and print a row of numbers starting with\
    \ number 1 to the number supplied by the user, and one number per line. This is\
    \ pretty close to your answer except I didn't use the $x variable that he uses.\n\
    <code>\nstring_sequence :: Int -> String\nstring_sequence 0 = \"0\"\nstring_sequence\
    \ n = concat[ show i | i <- [1..n] ] ++ \" \" ++ string_sequence (n-1)\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\n`concat` has quadratic complexity (amortized at least),\
    \ so this isn't great.\n<|/ c |>\n<| c |>\n: I should add that this solution is\
    \ `O(n)`, where `n = 5` for the OP's example.\n<|/ c |>\n<| c |>\nIt is not quadratic\
    \ if you use the `++` operator instead of `++=`, since the latter just concatenates\
    \ a list onto the list you're building. So `++` works like `append`, but it is\
    \ linear.\n<|/ c |>\n<| c |>\n: `++` concatenates `xs` to `ys` one element at\
    \ a time, so it has linear complexity.\n<|/ c |>\n<| c |>\n: It concatenates them\
    \ one by one, so it is `O(n)`.\n<|/ c |>\n<| a dscore=0 |>\nHere's a function\
    \ that will do what you want:\n<code>\nstring_sequence :: Int -> [String]\nstring_sequence\
    \ 0 = []\nstring_sequence n = map show [1..n]++[string_sequence (n-1)]\n</code>\n\
    <|/ a tags=string,haskell |>\n<| c |>\nI suppose you could get rid of the brackets...\
    \ :)\n<|/ c |>\n<| c |>\n, you're right. I'm too much of a Python guy... :)\n\
    <|/ c |>\n<| a tags=string,haskell dscore=0 |>\nI guess I should have written\
    \ this as an answer rather than a comment:\n<code>\nstring_sequence 0 = \"0\"\n\
    string_sequence n = map (\\x -> show x ++ \" \" ++ string_sequence (n-1)) $ [1..n]\n\
    </code>\n<|/ a |>\n<| ", "    \"\"\"\n    Parameters\n    ----------\n    n :\
    \ Int64 number\n    Returns\n    -------\n    a : String the string representation\
    \ of numbers from 0 to n inclusive\n    \"\"\"\n    return strings(0, n)\nend\n\
    </cell>\n<code language=julia-1.5>\nstring_sequence(1)\n</cell>\n<code language=julia-1.5>\n\
    string_sequence(10)\n</cell>\n<text>\nGenerate different sequences from string_sequence",
  "    \"\"\" Return a string containing space-delimited numbers starting from 0 upto\
    \ n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n\
    \    \"0 1 2 3 4 5\"\n    \"\"\"", "    int_str = str(n)\n    int_list = split(int_str)\n\
    \    int_str = join(int_list)\n    return int_str\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\nBuilding on Jakub's answer. \n<code>\nimport Data.List (split)\nimport Data.Maybe\
    \ (fromJust)", "    res = \"\"\n    for i \u2208 0 .. n-1 do\n        res += i\n\
    \    res\nend", "    \"\" \"Return a string containing space-delimited numbers\
    \ starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n \
    \   >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n    \"\"\"", "    result = \"\
    \"\n    if n > 0\n        for _ in 0:n--\n            result += \" \" ++ int_to_str(n)\n\
    \    return result\nend \n</cell>\n<text>\nLet's try out our function on a few\
    \ cases:", "    return string(n:10)\nend \n</code>\n<|/ a tags=julia,sequence\
    \ |>\n<| c |>\nIn general, I try to avoid `map`. The Julia way is to use `collect`\
    \ and avoid `map` when possible.\n<|/ c |>\n<| c |>\nThe issue is `map` doesn't\
    \ allow you to specify the length. `collect` is more general as it allows specifying\
    \ the length.\n<|/ c |>\n<| c |>\nThe first argument to collect can be a function\
    \ as well. Also, `collect` is lazy and doesn't actually *do* the iteration until\
    \ you ask it to, but I suspect that it doesn't matter if you're doing this in\
    \ a lazy way (which I assume you are). Anyway, this answer is really good, so\
    \ +1.\n<|/ c |>\n<| c |>\nYes, I wanted to give OP more flexibility in terms of\
    \ his question. I will correct my answer as soon as I have a chance.\n<|/ c |>\n\
    <| c |>\nthank you for the correction! I am going to fix the answer and I appreciate\
    \ your feedback.\n<|/ c |>\n<| a |>\nBased on's answer, I wrote my own that is\
    \ a little more flexible and also takes care of the case where the final iteration\
    \ would result in a number > n and also handles the case where the final iteration\
    \ would result in an OutOfMemoryError (as requested in comments):\n<code>", " \
    \   v = zero()\n    for n in i:\n        v +=+ space + string(n)\n    v\nend\n\
    </cell>\n<code language=julia-1.5>\n@code_native(string_sequence(3))\n</cell>\n\
    <code language=julia-1.5>\n@code_native(string_sequence(10^9))\n</cell>\n<text>\n\
    String concatenation\nWe can concat strings using + operator :", "    if (n <=\
    \ 0)\n        error(\"n must be positive\")\n    if (n == 1)\n        return \"\
    1\"\n    return string_sequence(n-1) + string(\" \") + (n-1)", "    return strings(n)\n\
    end\n</cell>\n<code language=julia-1.5>", "    return \"0\"^n*\" \"\n</code>\n\
    <|/ a tags=julia |>\n<| c |>\nThis is not an answer to the question. The question\
    \ is asking how to make a range of integers from a to b, inclusive, without using\
    \ a for loop, and an answer involving a for loop is not an answer to the question.\n\
    <|/ c |>\n<| c |>\nThanks for adding this extra answer, but this doesn't actually\
    \ answer the question. Try it with `string_sequence(0)` as your example. Your\
    \ function returns a string, which is not what was asked for. Also, the question\
    \ asks for the range `[a,b]` inclusive - your function returns `[a,b]` inclusive,\
    \ where `b` isn't included in the result. Those two things are contradictory.\
    \ I'd suggest editing your answer to clarify this, or removing it.\n<|/ c |>\n\
    <| c |>\nActually - I think your answer is right. `string_sequence` returns a\
    \ string, which is what was asked for. So this is wrong. `string_sequence(0)`\
    \ returns `\"0\"` as expected, but this isn't the actual question. The question\
    \ is how to make a range of a to b, inclusive, without using a for loop. Your\
    \ answer doesn't actually answer this question.\n<|/ c |>\n<| c |>\nI answered\
    \ the question and added some extra information regarding your example. Thanks\n\
    <|/ c |>\n<| a dscore=1 |>\nIt looks like you are looking for range(a,b,step)\
    \ where b is included rather than excluded.\n<code>\n# Ranges [a,b[", "    return\
    \ \" \".*(n-1) + \" \"*(n - length(n))\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\nI wanted a function that returned a vector of strings.\n<code>", "    if\
    \ n==0 then return \"0\"\n    if n==1 then return \"1\"\n    if n>1 then\n   \
    \     s=\"\"\n        for i=2:n-1 do\n            s=s+\" \"+string(Int64(i))\n\
    \        end\n        return s\n    end\nend\n</code>\n<|/ a dscore=2 tags=julia\
    \ |>\n<| a tags=julia |>\nThe simplest solution I can think of is this:\n<code>",
  "    if n <= 0 \n        error(\"n must be greater than 0.\")\n    else \n     \
    \   return \" \".join([string_sequence(i) for i in 1:n])\nend string_sequence",
  "    \"\"\"Return a string containing space-delimited numbers starting from 0 upto\
    \ n inclusive.\n    \"\"\"\n    return \"{:0,d} \".format(n)\nend string_sequence\n\
    end _str_sequence", "    seq = \"\"\n    for j = 0:n:1\n        seq = (j + seq)\
    \ |> to_string\n    return seq\nend", "    if n == 0\n        \"0\"\n    else\n\
    \        \" @ (string_sequence(n - 1) + string_sequence(n))\" end\n</code>\n<|/\
    \ a dscore=0 tags=recursion,haskell |>\n<| c |>\nThis does not work when the input\
    \ is negative.\n<|/ c |>\n<| c |>\nI added the version for negative numbers too.\n\
    <|/ c |>\n<| c |>\n`string_sequence (-2)` returns `\"  @ (string_sequence(-1)\
    \ + string_sequence(1))\"`.  I don't think that's what the OP wants.\n<|/ c |>\n\
    <| c |>\nOh I see. Well thanks for pointing it out. I'll edit the answer. I think\
    \ I've got it now\n<|/ c |>\n<| c |>\nNote that `string_sequence (-2)` returns\
    \ `\"@ (string_sequence(-1) + string_sequence(0))\"`, which is not the desired\
    \ result (at least on inputs of `-n`). So this function is almost certainly wrong.\n\
    <|/ c |>\n<| a tags=recursion,haskell dscore=0 |>\nHere is a solution I came up\
    \ with for generating strings that start with \"n\" and have \"n\" as a suffix:\n\
    <code>\nstrings :: Int -> String\nstrings n = reverse . reverse . intercalate\
    \ \" \" $ [ replicate n \" \" ] ++ map (intercalate \"\") [\"1\",\"2\",\"3\",\"\
    4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n</code>\nIt uses the fact that intercalate\
    \ x y concatenates x and y except that y is replaced by x if it's not empty (otherwise\
    \ the result is empty).\nExamples:\n<code>\nstrings 0 = \"\"\nstrings 1 = \"1\
    \ \"\nstrings 2 = \"1 2 \"\nstrings 3 = \"1 2 3 \"\nstrings 4 = \"1 2 3 4 \"\n\
    strings 5 = \"1 2 3 4 5 \"\nstrings 6 = \"1 2 3 4 5 6 \"\nstrings 7 = \"1 2 3\
    \ 4 5 6 7 \"\nstrings 8 = \"1 2 3 4 5 6 7 8 \"\nstrings 9 = \"1 2 3 4 5 6 7 8\
    \ 9 \"\n</code>\n<|/ a |>\n<| c |>\nThis does not work when the input is negative.\n\
    <|/ c |>\n<| c |>\nYou changed your original question to include a negative number,\
    \ so I deleted my answer and added another answer.  If you want it to work for\
    \ negative numbers, you can just add a `- n` to one of the expressions in the\
    \ `intercalate` line.  Of course, if you want something that works for any positive\
    \ number, ", "        s=\"\"\n        for n in 0:(n-1)\n            s=s++\" \"\
    \n        return s\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease include a description\
    \ with your code. Code-only answers are discouraged. Thank you.\n<|/ c |>\n<|\
    \ a |>\n<code>\nlet rec string_sequence i =\n    if i<=0 then \"0\"\n    else\
    \ string_sequence(i-1) ++ \" \" ++ (if i<10 then \"0\"+(i) else tostring(i))\n\
    </code>\n<|/ a tags=julia dscore=0 |>\n<| c |>\nPlease include a description with\
    \ your code. Code-only answers are discouraged. Thank you.\n<|/ c |>\n<| c |>\n\
    How is this an answer? Please expand on what the code is doing and how it is doing\
    \ it so that people with the same problem will have a better understanding.\n\
    <|/ c |>\n<| c |>\nIt is simple, it is recursive function. You can read about\
    \ recursive functions in Julia. Just try to understand the function and you will\
    \ understand it.\n<|/ c |>\n<| c |>\nThe OP is asking for help understanding recursive\
    \ functions, not explaining them.\n<|/ c |>\n<| a tags=julia |>\nA recursive function\
    \ for your purpose can be expressed as:\n<code>", "    if n>0\n        str(n)\n\
    \    else\n        \"0\"\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ tags=julia,string-formatting |>\nIn Julia 1.x you can use function composition\
    \ like this:\n<code>\njulia> function string_sequence(n::Int64)\n         join(\"\
    \ \" => x -> string(0:n-x))\n       end\nstring_sequence (generic function with\
    \ 1 method)", "    \"Return a string containing space-delimited numbers starting\
    \ from 0 upto n inclusive.\"\n    str = String(\"\")\n    for i = 1:n\n      \
    \  str = str + string_sequence(i)\n    end\n    return str\nend", "    \"Return\
    \ a string containing space-delimited numbers starting from 0 upto n inclusive.\"\
    \n    if n <= 0 \n        then return \"0\"\n        else string_sequence(n -\
    \ 1) + (\"0 \" + (string_sequence(n - 1))) * \" \"\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nI don't see how `string_sequence(100)` can produce a sequence of 101 numbers.\
    \ I think you mean `string_sequence(101)`, which would produce a sequence of 102\
    \ numbers.\n<|/ c |>\n<| c |>\nSorry, my bad - I misread the code. Thanks for\
    \ pointing it out - I have fixed the answer.\n<|/ c |>\n<| c |>\nOkay, I fixed\
    \ the code but I'm not sure it works as intended: `string_sequence(100)` gives\
    \ a result of \"0 1 2 3 4 5 6 7 8 9 10\" not \"0 1 2 3 4 5 6 7 8 9 10 11 12 13\
    \ 14 15 16 17 18 19 20\"\n<|/ c |>\n<| c |>\nI think your algorithm is incorrect\
    \ - it goes into an infinite loop in `string_sequence(1, 100)`. My algorithm will\
    \ never produce \"10 11 12 13 14 15 16 17 18 19 20\" from 1 to 100.\n<|/ c |>\n\
    <| c |>\nI think you're confused about what a recursive function is. A recursive\
    \ function is defined as a function which calls itself.\n<|/ c |>\n<| a |>\nHere\
    \ is another solution, inspired by this post. \n<code>\nimport Data.List", " \
    \   s = \"\"\n    for i = n..0 do\n        s = s .. to_string(i)\n    end\n  \
    \  s\nend\n</cell>\n<code language=julia-1.6>\nprintln(string_sequence(0))\nprintln(string_sequence(5))\n\
    </cell>\n<text>\nExercise: Define the function to_string_array that converts an\
    \ array into a string containing space-delimited numbers.", "    \"Return a string\
    \ containing space-delimited numbers starting from 0 upto n inclusive.\"\n   \
    \ if n<=0\n        write(\"0\")\n    else\n        write(string_sequence(n-1))\
    \ \n        write(\" \")\n        write(n.to_string())\n    end\nend\n</cell>\n\
    <text>\nString functions:\n Symbol  Description ", "    return (\" \").join(show(i)\
    \ for i in 0:n)\n</code>\n<|/ a tags=julia |>\n<| a |>\nI prefer to use this one:\n\
    <code>\nstring(1:n)\n</code>\n<|/ a tags=julia dscore=2 |>\n<| a tags=julia |>\n\
    You can get the first n items of a vector by using:\n<code>\nv[1:n]\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=julia |>\nJust to add to the list provided above,\
    \ the package CSV.jl has many useful functionalities that you will find useful.\
    \ For example, if you want to read in a CSV file to a DataFrame, you can use readcsv()\
    \ function\n<code>\nusing CSV\ndf = DataFrame(CSV.File(\"your_file.csv\"))\n</code>\n\
    Or if you want to use the other functionalities that CSV.jl provides, you can\
    \ try using the function DataFrameFromCSV from the CSV.jl package:\n<code>\ndf\
    \ = CSV.read(\"your_file.csv\")\n</code>\nThe advantage of using CSV.jl is that\
    \ you are not limited to use just only data reading functions from CSV.jl, but\
    \ you can also use other functionalities that are part of CSV.jl, like reading\
    \ a CSV file and saving it as a DataFrame or vice versa. \nI hope this was helpful.\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nAn extension to the previous answers which\
    \ I find useful.\n<code>", "    if n == 0 \n        then return \"0\"\n    else\
    \ \n        string_sequence(n-1) + \" \"\nend", '    return "0 1 2 3 4 5 6 7 8
    9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
    36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61
    62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87
    88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110
    111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130
    131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150
    151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170
    171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190
    191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210
    211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230
    231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250
    251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270
    271 272 273 274 275 276 277 278 279 280 28', "    str_arr=[\"0\"]\n    for i =\
    \ n-1 downto 0 do \n        str_arr=[str_arr[i],str_arr[i+1]]+str_arr\n      \
    \  str_arr=[str_arr[i],str_arr[i+1]]\n    end\n    return str_arr\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis would be much better if you added an explanation\
    \ of how it works.\n<|/ c |>\n<| a |>\nYou can use Julia's readdlm() function\
    \ like this:\n<code>\njulia> readdlm(\"a.txt\")\n1x5 Array{Any,2}:\n  0\n  1\n\
    \  2\n  3\n  4\n</code>\n<|/ a tags=file,julia,io dscore=0 |>\n<| c |>\nThis doesn't\
    \ actually answer the question. He wanted to read a file in Julia.\n<|/ c |>\n\
    <| a |>\nAs you said you can use fread:\n<code>\njulia> using DataFrames\njulia>\
    \ file = open(\"myfile.txt\", \"r\")\njulia> df = DataFrame(readtable(file, DataFrame))\n\
    </code>\n<|/ a tags=file,julia,io dscore=0 |>\n<| a tags=file,julia,io dscore=0\
    \ |>\nYou can use fread from DataFrames.jl's CSV module (which can read various\
    \ types of files):\n<code>\nusing DataFrames", "  return \"0\"\nend string_sequence\n\
    </cell>\n<text>\nstring_of_numbers(n::Int64)\nReturn the string containing the\
    \ numbers from 0 up to n inclusive separated by a space.\nstring_of_numbers(0)\n\
    \"0\"\nstring_of_numbers(5)\n\"0 1 2 3 4 5\"\nstring_of_numbers(6)\n\"0 1 2 3\
    \ 4 5 6\"\nstring_of_numbers(6)\n\"0 1 2 3 4 5 6\"\nstring_of_numbers(0)\n\"0\"\
    \nstring_of_numbers(-1)\n\"-1\"", "    seq = String(0:n)\n    return replace(seq,'_','')\n\
    end", "  return string(tostring(n))\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ should be the selected answer.\n<|/ c |>\n<| c |>\nThis should be the selected\
    \ answer as it's an immutable function with a single line.\n<|/ c |>\n<| c |>\n\
    It should be selected answer as it's an immutable function which can be directly\
    \ used.\n<|/ c |>\n<| c |>\nI like this answer but I think it should be noted\
    \ that the `tostring` method comes with lots of overhead, especially if you only\
    \ need a single line string representation.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n\
    import std.stdio;\nimport std.string;\nimport std.conv;\nvoid main()\n{\n    writeln(tostring(0));\n\
    \    writeln(tostring(1));\n    writeln(tostring(2));\n    writeln(tostring(3));\n\
    \    writeln(tostring(4));\n    writeln(tostring(5));\n    writeln(tostring(6));\n\
    \    writeln(tostring(7));\n    writeln(tostring(8));\n    writeln(tostring(9));\n\
    }\n</code>\n<|/ a tags=string,d,arrays |>\n<| c |>\nWorks with D 2.065\n<|/ c\
    \ |>\n<| a tags=string,d,arrays |>\nThe std.conv.to template should also work\
    \ for integer types:\n<code>\nimport std.conv;\nimport std.stdio;\nimport std.string;",
  "    if n < 0 then error(\"n must be >= 0\") else if n == 0 then \"0\" else \n \
    \       string_sequence(n-1).\" \".string_sequence(n-1)\nend\n</cell>\n<code language=julia-1.0>\n\
    \"\"\" Return the reverse of a string.\n    >>> reverse_string(\"test\")\n   \
    \ \"est tes\"\n    >>> reverse_string(\"est\")\n    \"test\"\n    \"\"\"", " \
    \   if n == 0\n    then return \"0\"\n    else \n        return (string_sequence(n-1))\
    \  + \" \" + (string_sequence(n))\n    end\nend\n</cell>\n<text>\nIn Julia you\
    \ have to use a for loop to construct the sequence:", "    str(n::Int64).split(\"\
    \ \")\nend\n</code>\n<|/ a |>\n<| a |>\nIf you have a string containing the numbers\
    \ in order (for example, for \"1-2-3-4-5\"), and the only thing you need is a\
    \ string containing only the numbers in order, you can use regex to just grab\
    \ the numbers.\n<code>", "    \"Return a string containing space-delimited numbers\
    \ starting from 0 upto n inclusive.\"\n    return \"0 1 2 3 4 5\"\nend\n</cell>\n\
    <code language=julia-1.1>", "    \"\"\" Return a string containing space-delimited\
    \ numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"\
    0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n    \"\"\"", "    \"\"\"\
    \" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n\
    \    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n    \"0 1\
    \ 2 3 4 5\"\n    \"\"\"", "    v = zero()\n    append!(v,zero())\n    for i \u2208\
    \ 0:(n-1)\n        append!(v,string(i))\n    end\n    return v\nend", "    s =\
    \ \"\"\n    for i = 1:n\n        s = s * (n-1-i) + i\n    end\n    s\nend", " \
    \   digits = Array{UInt64}(undef, n)\n    i = 0\n    for d in digits\n       \
    \ digits[i] = d\n        i = i + 1\n    end\n    return join(map(String, digits[2:end-1]))\n\
    end", "    if n <= 0\n        throw ArgumentError(\"n must be > 0\")\n    \n \
    \   list = String.(Ints.(1:n))\n    list = list'\n    list\nend\n</cell>\n<code\
    \ language=julia-1.5>", "</code>\n<|/ a tags=julia dscore=2 |>\n<| c |>\nThe `String`\
    \ constructor is deprecated.\n<|/ c |>\n<| a tags=julia |>\nUsing string concatenation\n\
    <code>", "    \"\"\" Return a string containing space-delimited numbers starting\
    \ from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n\
    \    \"0 1 2 3 4 5\"\n    \"\"\"", "    \n    string = \"0\"\n    for i in 0:n-1\n\
    \        string = string + \" \" + string\n    return string\nend\n</cell>\n<code\
    \ language=julia-1.6>\nstring_sequence(10)\n</cell>\n<text>\nProblem 10. Find\
    \ the sum of the first n prime numbers. Assume that the first 2 to n numbers are\
    \ already taken care of. Reserve the number 3 as a special case.\nThe sum of first\
    \ 20 prime numbers is\n$$ 3 + 2 + 5 + 3 + 2 + 7 + 3 + 2 + 11 + 5 + 3 + 2 + 13\
    \ + 7 + 3 + 2 + 17 + 5 + 3 + 2 + 19 + 3 $$", "  \n    return (string_number(n)).split(\"\
    \ \")\nend\n</cell>\n<code language=julia-0.4>\nstring_sequence(1)\n</cell>\n\
    <code language=julia-0.4>\nstring_sequence(5)\n</cell>\n<code language=julia-0.4>\n\
    string_sequence(10)\n</cell>\n<code language=julia-0.4>\nstring_sequence(100)\n\
    </cell>\n<code language=julia-0.4>\nusing Plots, StatsPlots\n</cell>\n<code language=julia-0.4>\n\
    n = 1:10\nt = range(0,stop=n,length=100)", "    string_seq = Array{Int64}(undef,\
    \ n - 1)\n    for i in 1:n-1\n        string_seq[i] = i\n    end\n    return string_seq\n\
    end\n</cell>\n<code language=julia-1.5>", "   let mut result = \"\"\n   for _\
    \ in 0..n {\n      result = result + \" \" ++ string_sequence(n)\n   }\n   return\
    \ result\n</code>\nThis code will take advantage of lazy evaluation, so in reality,\
    \ its just generating a sequence of numbers and then concatenating them together\
    \ with a space. \nYou can see how this code actually behaves here \nhttps://ideone.com/oiXQ0w\n\
    <|/ a dscore=3 |>\n<| a |>\nHere's a recursive solution that I like to use:\n\
    <code>\n# Recursively construct the string of a single integer\n# in base 10\n\
    numToString(n) = \n  if n <= 0\n    then \"0\"\n    else to_string(n) + \" \"\n\
    \    +  numToString(n - 1)\n</code>\n<|/ a tags=recursion,smlnj,sml dscore=2 |>\n\
    <| c |>\nThis works only when the number is positive. Otherwise you get `Exception:\
    \ Int.toString : int out of range`\n<|/ c |>\n<| c |>\nFixed that.\n<|/ c |>\n\
    <| c |>\nI added the check so it now works with negative numbers\n<|/ c |>\n<|\
    \ c |>\nThis approach fails for `n = 0`.\n<|/ c |>\n<| c |>\nGood catch! Thank\
    \ you for noticing. I fixed it.\n<|/ c |>\n<| a |>\nHere's the simplest recursive\
    \ solution I found (I used this in a Haskell challenge)\n<code>\nfun int -> string\
    \ = \"0\"\n  | int n | n = 0 => \"0\"\n  | int n | n > 0 => (int mod 10) + string\
    \ (int mod 10)\n</code>\n<|/ a tags=recursion,smlnj,sml dscore=1 |>\n<| a dscore=1\
    \ tags=recursion,smlnj,sml |>\n<code>\nfun int -> string = \"0\"\n  | int n |\
    \ n = 0 => \"0\"\n  | int n | n > 0 => int mod 10 + string (int mod 10)\n</code>\n\
    This solution above does not work for negative numbers. Here is one that is correct\n\
    <code>\nfun int -> string = \"0\"\n  | int n | n = 0 => \"0\"\n  | int n | n >\
    \ 0 => int mod 10 + string (int mod 10)\n  | int n | n < 0 => string (int mod\
    \ 10) + string (int mod 10)\n</code>\n<|/ a |>\n<| a dscore=1 tags=recursion,smlnj,sml\
    \ |>\nThis works for positive and negative integers:\n<code>\nfun intToString\
    \ n = ", "    seq = seq = ''\n    for i = 1 : n do \n        seq = seq ++ i\n\
    \    end\n    return seq\n</code>\nand now you just have to run the following\
    \ in ijulia:\n<code>\njulia> string_sequence(5)\n\"12345\"\n</code>\n<|/ a |>\n\
    <| a dscore=2 tags=julia |>\nHere's another version which works in Julia 1.2 with\
    \ Unicode:\n<code>", "    \" Generate a string containing space-delimited numbers\
    \ starting from 0 upto n inclusive. \"\n    return \" \".join(map(str, range(n)))\n\
    end\n</cell>\n<text>\nAs a simple example, let's print out all the numbers between\
    \ 1 and 10", "\"\"\"\n>>> string_sequence(0)\n\"0\"\n>>> string_sequence(5)\n\"\
    0 1 2 3 4 5\"\n\"\"\"", "    if n == 0 then \"0\"\n    else string_sequence(n-1)\
    \ ++ \" \" ++ string_sequence(n) \nend\n</cell>\n<code language=julia-1.5>\nstring_sequence(0)\n\
    </cell>\n<text>\nStrings concatenation & string interpolation", "    \"Return\
    \ a string containing space-delimited numbers starting from 0 upto n inclusive.\"\
    \n    if n == 0 then return \"0\"\n    let mut nums = String[]\n    for i in 0..n-1\
    \ {\n        nums.push(to_string(i))\n    }\n    nums.join(\" \")\nend\n</code>\n\
    The first thing you need to do is to get your desired output - to make a sequence\
    \ of numbers upto some number - into something that can be read by Python. string_sequence()\
    \ is one such function. Now you need to actually call this function. What does\
    \ it do? It takes an integer argument and returns a string. Python is very particular\
    \ about calling functions without parentheses and for no other reason (well, there\
    \ are some cases where you might prefer it, but not in this case).\n<code>\n>>>\
    \ string_sequence(5)\n\"0 1 2 3 4 5\"\n</code>\nThe rest is just formatting it\
    \ into a string and printing it out on the screen.\n<|/ a dscore=1 |>\n<| a tags=julia\
    \ |>\nYou can use the following code:\n<code>", "\"\"\"\n    A helper function\
    \ for string sequence. \n    \"\"\"\n    return string.printf( \"%d\" , n)", " \
    \   \"\"\nend", '    return join(" ", map(to_string, 0:n-1))', "    \"Return a\
    \ string containing space-delimited numbers starting from 0 upto n inclusive.\"\
    \n    return \"\\n\".join(map(str, range(n)))", "    if n < 0\n    then return\
    \ \"Invalid input!\"\n    else if n==0\n    then return \"0\"\n    else\n    \
    \    return (\" \").*(n-1).+string_sequence(n-1)\nend\n</code>\n<|/ a dscore=1\
    \ tags=julia,string |>\n<| a tags=julia,string |>\nHere's a solution that uses\
    \ only string concatenation. First, a function that will return a string with\
    \ a given number 'n' appended in the right order:\n<code>", "    sequence=\"\"\
    \n    for i in 0 .. n-1 do \n        sequence=sequence+string(i)\n    end\n  \
    \  return sequence\nend\n</code>\n<|/ a tags=julia,string dscore=2 |>\n<| c |>\n\
    The performance of this function is O(n\xB2). One way to improve it is to create\
    \ and fill the output string only once. E.g. use [`join`](https://docs.julialang.org/en/stable/stdlib/strings/#Base.join)\
    \ on a list of numbers.\n<|/ c |>\n<| a tags=julia,string |>\nThe performance\
    \ of this function is O(n\xB2). One way to improve it is to create and fill the\
    \ output string only once. E.g. use join on a list of numbers. \u2013 Chris Rackauckas\
    \ Aug 24 at 2:29", "    str = String(\" \")\n    for _ in n:\n        str = [str]\n\
    \    return str\n</code>\n<|/ a dscore=4 |>\n<| c |>\nNote that this can easily\
    \ be optimized by removing the \"for\" loop, and directly appending each character\
    \ of a string to the new string.\n<|/ c |>\n<| c |>\nAlso, what happens if `n`\
    \ is too big to fit in `UInt64`?\n<|/ c |>\n<| a tags=arrays,string,julia,numbers,for-loop\
    \ |>\nOne more solution:\n<code>\nusing BenchmarkTools\nusing Statistics", " \
    \   \"\"\"Return a string containing space-delimited numbers starting from 0 upto\
    \ n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n\
    \    \"0 1 2 3 4 5\"\n    \"\"\"", "    \"string_sequence(n::Int64) returns String\"\
    \n    \n    local result = \" \"\n    local x = 0\n    while x < n do\n      \
    \  result = result .. string(x)\n        x = x + 1\n    end\n    return result\n\
    end", "    \"Return a string containing space-delimited numbers starting from\
    \ 0 upto n inclusive.\"\n    if n < 0\n        return \"\"\n    else if n < 10\n\
    \        return string(n)\n    else if n < 100\n        return string(n) + \"\
    \ 0\"\n    else if n < 1000\n        return string(n) + \" 0 1\"\n    else if\
    \ n < 10000\n        return string(n) + \" 0 1 2\"\n    else if n < 100000\n \
    \       return string(n) + \" 0 1 2 3\"\n    else if n < 1000000\n        return\
    \ string(n) + \" 0 1 2 3 4\"\n    else if n < 10000000\n        return string(n)\
    \ + \" 0 1 2 3 4 5\"\n    else if n < 100000000\n        return string(n) + \"\
    \ 0 1 2 3 4 5 6\"\n    else\n        error(\"Number too large for a string sequence.\"\
    )\n    end\nend", "  return string_sequence(n).join(' ')\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype string_sequence(3)\n</cell>\n<text>\n@code_warntype\
    \ will warn us if any type-mismatches occur in the code.\n@code_warntype should\
    \ be used to debug code as it will show us which line\nthe type-mismatch occurred\
    \ on.\n@code_warntype will not error out as it will do nothing if any type-mismatches\
    \ occur.", '    return "\n".join(map(str, range(n))) # map returns an iterator
    object', "    string_array = []\n    for k in 0 .. n-1\n        string_array[k]\
    \ = \"0\" .. \"9\"[mod(k, 10)]\n    return string_array\nend \"\"\"", "    \"\"\
    \"Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n\
    \    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n    \"0 1\
    \ 2 3 4 5\"\n    \"\"\"\n    return join(\" \", 0:n)", "    \"Return a string\
    \ containing space-delimited numbers starting from 0 upto n inclusive.\"\n   \
    \ return \" \".join([str(i) for i in range(0,n+1)])\nend\n</cell>\n<text>\nPart\
    \ 2 - Using a Vector", "    \"Return a string containing space-delimited numbers\
    \ starting from 0 upto n inclusive.\\n\n\"\n    if n==0 then return \"0\"\n  \
    \  return show(Int64, n) ++ (\" \" ++ string_sequence(n - 1))\nend\n</cell>\n\
    <text>\nAnd here is a sample session:", "    \"Return a string containing space-delimited\
    \ numbers starting from 0 upto n inclusive.\"\n    s = \"\"\n    for i in 0:n-1\n\
    \        s = s ++ \" \" ++ i\n    return s", "    if n <= 0\n        error(\"\
    Cannot create sequences from 0 to 0.\")\n    end\n    if n == 1\n        return\
    \ \"0\"\n    sequence = \"\"\n    if n > 0\n        sequence = \"{$(string_sequence($n\
    \ - 1))} \" \n    end\n    for i in 1:n\n        sequence += i\n    end\n    return\
    \ sequence\nend\n</cell>\n<code language=julia-0.4>\nstring_sequence(3)\n</cell>\n\
    <code language=julia-0.4>\n\"\"\"\n    integer_sequence(x::Int64)", "    return\
    \ \"\\n\".join(map(str,take(n,range(1,n+1))))\nend string_sequence", "    \n \
    \   chars = \"\"\n    for i \u2208 0..n\n        chars = chars + string(i)\n \
    \   end\n    \n    return chars\n</code>\n<|/ a |>\n<| a tags=string,function,julia,arrays\
    \ |>\nAs answered by \"David\" in the comments, there is a function called string_sequence\
    \ that already does this in Julia:\n<code>\njulia> string_sequence(5)\n\"0 1 2\
    \ 3 4 5\"\n</code>\nThere is also a string_range function that can generate the\
    \ range of strings:\n<code>\njulia> string_range(5)\n5-element Array{String,1}:\n\
    \ \"0\"\n \"1\"\n \"2\"\n \"3\"\n \"4\"\n</code>\nIf you want strings of type\
    \ String, you can use the string_join function:\n<code>\njulia> string_join([string_range(5)],\
    \ \" \")\n5-element String:\n \"0 1 2 3 4 5\"\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThanks, this was really helpful. I was hoping to use the string_sequence\
    \ because I thought it would be faster but this is great to know about it too!\n\
    <|/ c |>\n<| c |>\n`string_sequence` is now deprecated in favour of [`string_range`](https://docs.julialang.org/en/stable/stdlib/string/#Base.:string_range).\n\
    <|/ c |>\n<| a tags=string,function,julia,arrays |>\nFor Julia 1.0 (probably also\
    \ for newer versions):\n<code>", "    \"\"\"Return a string containing space-delimited\
    \ numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"\
    0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n    \"\"\"", "    \"Return\
    \ a string containing space-delimited numbers starting from 0 upto n inclusive.\"\
    \n    if n < 0 \n        error(\"Error: Invalid argument to string_sequence\"\
    )\n    return \" \".join(map(str, sequence(n)))\n</code>\n<code>\n\"\"\" Return\
    \ the nth element of a list starting from 0 in steps of i.\n    >>> string_at([0,1,2,3],\
    \ 0)\n    \"0\"\n    >>> string_at([0,1,2,3], 1)\n    \"1\"\n    >>> string_at([0,1,2,3],\
    \ 2)\n    \"2\"\n    >>> string_at([0,1,2,3], 3)\n    \"3\"\n    >>> string_at([0,1,2,3],\
    \ 4)\n    \"4\"\n    >>> string_at([0,1,2,3], 5)\n    \"5\"\n    \"\"\"", "  \
    \  \"Return a string containing space-delimited numbers starting from 0 upto n\
    \ inclusive.\"\n    numbers = string_seq(Int(n), \" \", \" 1 \")\n    numbers\
    \ = join(numbers, \" \")\n    numbers = numbers[2:end]\n    return numbers\nend",
  "    return \"{\" + string_seq(Int64(n), \" \") + \"}\" \nend \n</code>\n<|/ a |>\n\
    <| c |>\nThis does not work for me - it gives an `IndexError: invalid index` error.\
    \ I guess this depends on the version of Julia you use?\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's a short and elegant solution that doesn't need any packages:\n<code>",
  "    \"\"\"\" Return a string containing space-delimited numbers starting from 0\
    \ upto n inclusive.\n    >>> string_sequence(0)\n    \"0\"\n    >>> string_sequence(5)\n\
    \    \"0 1 2 3 4 5\"\n    \"\"\"", "    if n == 0 then return \"0\"\n    else\
    \ string_sequence(n-1) ++ \", \" ++ string_sequence(n - 1)\n    end\n</code>\n\
    <|/ a dscore=1 tags=string,julia,numbers,seq |>\n<| a |>\nIf you don't like recursion\
    \ you can use the iterative version of the function string sequence:\n<code>",
  "    seq = seqstring(0)\n    i = 1 \n    while i <= n\n        seq = \" \" <> seq\
    \ ++ seqstring(i)\n        i = i + 1\n    return seq\n</code>\n<|/ a |>\n<| c\
    \ |>\nThanks, this is exactly what I was looking for. I'm new to Julia and I'm\
    \ having trouble wrapping my head around how to write this kind of loop in Julia.\n\
    <|/ c |>\n<| a tags=string,julia |>\nIf you're looking for the most idiomatic\
    \ way to do this, I would suggest using string concatenation. \n<code>", "   \
    \ \"\"\"\n    string_sequence(n::Int64)", "    \"Return a string containing space-delimited\
    \ numbers starting from 0 upto n inclusive.\"\n    if n < 1 then\n        return\
    \ \"\"\n    else\n        str_ns = \"\"\n        for n in 0:n-1 do str_ns = str_ns\
    \ + string(n) end\n        return str_ns\n    end\nend", "  \"Return a string\
    \ containing space-delimited numbers starting from 0 upto n inclusive.\"\n  return\
    \ \"0\" \nend\n</cell>\n<text>\nExercise 5\nUsing a function defined above, write\
    \ a function that returns all strings where the number of digits in the number\
    \ is exactly 3. Note that this will be different than the other problem where\
    \ we have to return all strings with exactly 3 digits.", "    s = \"\"\n    for\
    \ i = 1:n\n        s = s ++ \" \" \n    return s\nend", "    \"Return a string\
    \ containing space-delimited numbers starting from 0 upto n inclusive.\"\n   \
    \ return \" \".(strings(n))\nend", "    string_seq = [String(j+1) for j in 1:n]\n\
    \    return string_seq.join(\" \")\nend\n</cell>\n<code language=julia-1.3>\n\
    # test\nstring_sequence(5)\n</cell>\n<text>\nThe string_sequence function above\
    \ can be applied to a more complicated example:", "    \n    seq = @sprintf \"\
    %0\" n \n    return seq\nend string_sequence\n</code>\n<|/ a |>\n<| a tags=julia\
    \ |>\nHere are some more ways to do this:\n<code>\njulia> function string_sequence(n::Int64)\n\
    \           if n < 0 \n               error(\"number must be non-negative\")\n\
    \           else\n               string(repeat(\"0\", n + 1))\n           end\n\
    \       end\nstring_sequence (generic function with 1 method)", '    return "\n".join(map(str,
    range(n)))', "    if n==0\n        s=\"0\"\n    else \n        s= (\" \" ++ ((format(n,\
    \ \"0\") ++ \" \"))) ++ ((string_sequence(n-1) ++ \" \"))\n    return s\nend\n\
    </cell>\n<code language=julia-0.6>\n@test string_sequence(0) == \"0\"\n@test string_sequence(1)\
    \ == \"1\"\n@test string_sequence(3) == \"1 2 3\"\n@test string_sequence(4) ==\
    \ \"1 2 3 4 5\"\n@test string_sequence(5) == \"0 1 2 3 4 5\"\n</cell>\n<text>\n\
    Convenience functions for writing to files.", "    if (n==0) then\n        return\
    \ \"0\"\n    else if ((n<=0)) then\n        return string_sequence(0)\n    else\n\
    \        string_seq1 = string_sequence(n-1)\n        string_seq2 = string_seq1\
    \ + \" \" + string_seq1\n        return string_seq2\n    end\nend\n</cell>\n<code\
    \ language=julia-1.0>\nstring_sequence(10)\n</cell>\n<code language=julia-1.0>\n\
    string_sequence(0)\n</cell>\n<code language=julia-1.0>\nstring_sequence(-1)\n\
    </cell>\n<text>\nThe last piece of code was written by Chaitra Bhagavathi\nIn\
    \ this notebook I have written a function that outputs the string in the following\
    \ way:", "    if n == 1 then return \"0\" else string_sequence(n-1) + \" \" +\
    \ to_string(n) \nend \n</cell>\n<text>\nAnd that's it! Our sequence generator\
    \ can generate any string of numbers from 0 to n inclusive, and it works on any\
    \ type. Try it out!", "    return string_sequence((n + 1).abs())\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nI believe you meant `(n + 1)::Int64`.\n<|/ c |>\n<|\
    \ c |>\nYou mean `(n + 1)::Int64`.\n<|/ c |>\n<| c |>\n`(n + 1)::Int64` does not\
    \ work on `julia` since it converts `n` to `Int64` first. `(n + 1)` would work\n\
    <|/ c |>\n<| c |>\nThanks for clarifying - I'm actually getting `(n + 1)::Int64`\
    \ working in both v0.6 and 0.7, so I guess my comment was incorrect and I've corrected\
    \ it.\n<|/ c |>\n<| c |>\nThe edit with `(n + 1)::Int64` does not work on Julia\
    \ 0.7 as well.\n<|/ c |>\n<| a dscore=0 |>\nHere is an alternative solution that\
    \ does not require any external packages:\n<code>", "    numbers = []\n    for\
    \ i \u2208 1:n do\n        push!(numbers, i)\n    return join(numbers, \" \")\n\
    end", "    seq = \"\"\n    for _ in 1:n do\n        seq = seq + String(n) + \"\
    \  \"\n    return seq\n</code>\n<|/ a dscore=0 tags=string,algorithm,haskell,sequence\
    \ |>\n<| c |>\nIt would be better to return `[0..n]` rather than `[n..1]`.\n<|/\
    \ c |>\n<| c |>\nIt might be worth pointing out that you can always do `concatMap\
    \ (\\i -> replicate i '1') [0..n]`\n<|/ c |>\n<| c |>\n, yes, but that isn't strictly\
    \ speaking what was asked for.\n<|/ c |>\n<| c |>\nAgreed, that's why I added\
    \ the comment. If someone wants strictly strict, `concatMap (\\i -> replicate\
    \ i '1') [0..n]` will work (well, maybe not the way it's laid out above, but technically\
    \ speaking).\n<|/ c |>\n<| c |>\nYou might also mention that `concatMap` is not\
    \ strictly `Prelude.concatMap`\n<|/ c |>\n<| a |>\nOne possibility is to use the\
    \ enumeration monad:\n<code>\nimport Control.Applicative (sequence(..))", "  \
    \  \n    \n        \n    \"\"\"\n    >>> string_sequence(0)\n    \"0\"\n    >>>\
    \ string_sequence(5)\n    \"0 1 2 3 4 5\"\n    \"\"\"", "    string = \"\"\n \
    \   for i = Int64(n), 1, -1 do\n        string += i\n    end\n    return string\n\
    end\n</cell>\n<code language=julia-1.3>\n@assert string_sequence(0) == \"0\"\n\
    @assert string_sequence(5) == \"0 1 2 3 4 5\"\n</cell>\n<text>\nExercise 4.1\n\
    Write a function that returns True if the number n is divisible by 3 and the number\
    \ n is not divisible by 7 (mod 3).", "    \"\"\" Return a string containing space-delimited\
    \ numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    \"\
    0\"\n    >>> string_sequence(5)\n    \"0 1 2 3 4 5\"\n    \"\"\"", "    \"Return\
    \ a string containing space-delimited numbers starting from 0 upto n inclusive.\"\
    \n    return \"\"\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
