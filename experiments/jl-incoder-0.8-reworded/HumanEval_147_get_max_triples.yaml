name: HumanEval_147_get_max_triples
language: jl
prompt: "\"\"\"\n    You are given a positive integer n. You have to create an integer\
  \ vector a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of\
  \ a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k])\
  \ of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n   \
  \ Example :\n    >>> get_max_triples(5)\n    1\n        Explanation: \n        a\
  \ = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"\n\
  function get_max_triples(n::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = get_max_triples;\n\t@test(candidate(5)\
  \ == 1)\n\t@test(candidate(6) == 4)\n\t@test(candidate(10) == 36)\n\t@test(candidate(100)\
  \ == 53361)\nend\n"
completions: ["    a = []\n    for i in 1..n\n        push!(a, i * i - i + 1)\n  \
    \  max_triple_count = 0\n    for i in a\n        for j in i..n\n            max_triple_count\
    \ += (a[j] - a[i]) % 3 == 0\n            max_triple_count += (a[j] + a[i]) % 3\
    \ == 0\n            max_triple_count += (a[j] - a[i] + a[i]) % 3 == 0\n    end\n\
    \    return max_triple_count\nend\n</cell>\n<code language=julia-1.0>\n@test get_max_triples(5)\
    \ == 5\n</cell>\n<text>\nExercise: Problem 8", "    triple ::Int64 = 0\n    for\
    \ i in 1..n\n        for j in (i+1)..n\n            for k in (i+j)..n\n      \
    \          if  a[i] + a[j] + a[k] % 3 == 0\n                    triple += 1\n\
    \    end\n    return triple\nend\n</cell>\n<code language=julia-1.5>\nget_max_triples(10)\n\
    </cell>\n<text>\nQ7. Given an integer vector a, print all the positive integers\
    \ in a.\n    Negative integers and zeros are excluded.", '    return n - (n+1)%3
    #return n - (n+1)%3', "    a = [i for i in 1..n]\n    for i in 1..n\n        j\
    \ = i + 1\n        while j > n\n            if a[i] < a[j]\n                k\
    \ = j\n                while k <= n && a[k] == a[j]\n                    k +=\
    \ 1\n                if k - i == 2\n                    return k - i\n       \
    \     j += 1\n    return 0\nend\n</cell>\n<code language=julia-1.3>\nget_max_triples(5)\n\
    </cell>\n<text>\nProblem 10\nWhat is O(n log n)?", "    a = [1, 3, 7, 13, 21]\n\
    \    return sum([a[i] + a[j] + a[k] <= n for i in 1 .. n])\n</code>\nNote that\
    \ this function will return a wrong result for big numbers (such as n = 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999",
  "    \n    # init a vector \n    a = [0]*(n+1)\n    \n    # init i, j, k\n    i\
    \ = 1\n    j = 1\n    k = 1\n    \n    # init sum\n    sum = 0", "  a = Array{Int64}(undef,\
    \ n)\n  for (i, j) = (1, n-1)\n    if i != j \n      a[i, j] = i * i - i + 1\n\
    \      a[j, i] = i * i - j + 1\n      a[i, j] = i * j - j + 1\n      a[j, i] =\
    \ i * j - i + 1\n    end\n  end\n  \n  # count triples \n  triples_count = sum(sum(a\
    \ .< 3)) == 3 * n\n  \n  return triples_count\nend\n</cell>\n<code language=julia-1.0>\n\
    get_max_triples(5)\n</cell>\n<code language=julia-1.0>\n@assert get_max_triples(5)\
    \ == 3\n</cell>\n<text>\nExerc\xEDcio 02: Vamos verificar se o valor de uma matriz\
    \ \xE9 muito grande.", "    answer = 0.0\n    for i in 1 .. n\n        answer\
    \ += i\n    return answer\n</code>\n<|/ a |>\n<| a dscore=0 tags=performance,algorithm,haskell,list\
    \ |>\nThis is my attempt at a solution in Haskell without recursion or recursion-like\
    \ constructs. It only needs to loop through every third element in the list and\
    \ sum the triples. \n<code>\nimport Data.List", "    ans = 0\n    for i in 1:n\n\
    \        for j in (i+1):n\n            for k in (i+1):n\n                if i*i\
    \ + j*j + k*k == i*i*i + j*j*j + k*k\n                    ans += 1\n    return\
    \ ans", "    a::Vector{Int64} = Int64[]\n    for i in 1:n\n        a[i] = i *\
    \ i - i + 1\n    end\n    res::Int64 = 0\n    for (i,j,k) in a\n        res +=\
    \ (a[i] + a[j] + a[k]) mod 3 == 0 ? 1 : 0\n    end\n    res\nend\n</cell>\n<code\
    \ language=julia-0.5>", "    \"\"\"This function finds the maximum value of all\
    \ triples with 0 <= i < j and 0 <= j < k. \n    It is given that 0 <= i < j <\
    \ k.\n    \"\"\"\n    a = [1 for _ in 1:n]\n    for i in 1:n-1\n        for j\
    \ in (i+1):n\n            for k in (i+1):n\n                if i+1 < j and j+1\
    \ < k and i+1 < k\n                    && a[j-1] != a[k-1] && a[j] != a[k] and\
    \ a[j] > a[i] + a[k] \n                    && a[j-1] != a[k] && a[j] != a[k-1]\n\
    \                    && a[j-1] != a[k-1] && a[j] != a[k-1]\n                 \
    \   && a[j-1] != a[k-1] && a[j] != a[k-1]\n                end\n            end\n\
    \        end\n    end\n    return a[n-1]\nend\n</cell>\n<code language=julia-1.4>\n\
    get_max_triples(10)\n</cell>\n<text>\nExercise 9: Write a Julia function called\
    \ count_valid_triples", "    sum::Int64 = 0\n    for i in (1:n)\n        for (j,k)\
    \ in (1:i)\n            sum = sum + i*i*i + j*j*j + k*k*k\n    return sum%3 #returns\
    \ the sum % 3\nend\n</cell>\n<code language=julia-1.5>", "    a=[]\n    for i\
    \ in 1:n\n        push!(a,i*i-i+1)\n    end\n    sum=0\n    for i in 1:n\n   \
    \     for j in i+1:n\n            for k in j+1:n\n                sum+=a[i] a[j]\
    \ a[k]\n            end\n        end\n    end\n    sum%3==0\nend\n</cell>\n<text>\n\
    Part 6 : Solving triangle problem\nGiven a triangle, find the area of the smallest\
    \ triangle that includes all the sides. \nYou may assume that the given triangle\
    \ is equilateral.", "    a=[]\n    for i in 1:n\n        for j in i+1:n\n    \
    \        for k in j+1:n\n                if (i,j,k)==(j,k,i)\n               \
    \     push!(a,(i,j,k))\n    end\n    return length(a)\nend\n</cell>\n<code language=julia-1.0>",
  "    cnt = 0\n    for i in 1..n\n        cnt += if i==1 else if i==n then 0 else\
    \ if i==n-2 then 0 else if i==n-1 then 1 else 0\n    end\n    return cnt\nend\n\
    </cell>\n<code language=julia-0.6>\nget_max_triples(5)\n</cell>\n<text>\nProblem\
    \ 18", "    l = Int64(1)\n    while l < n \n        l += l\n    return l\nend\n\
    </cell>\n<code language=julia-1.5>\n@assert get_max_triples(5) == 6\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    You are given a positive integer n. You\
    \ have to create an integer vector a of length n.\n        For each i (1 \u2264\
    \ i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number of\
    \ triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k]\
    \ is a multiple of 3.", "    memo = [0 for i in 0 .. n-1]\n    for i in 0 .. n-1\n\
    \        if memo[i] >= 3\n            return memo[i]\n        memo[i] = memo[i]\
    \ + a[i]*a[i] - a[i] + 1 + 1 + get_max_triples(i-1)\n    end\n    return memo[n]",
  "    if n < 0 \n        error(\"n must be positive.\")\n    \n    a::Vector{Int64}\
    \ = Vector{Int64}(n)\n    for i in 1:n\n        a[i] = i * i - i + 1 \n    end",
  "    if n <= 0 \n        error(\"n must be positive\")\n    \n    a = 0::Int64\n\
    \    for i in 1:n\n        if (a+i) % 3 == 0\n            break\n        a=a+1\n\
    \    return length(a)", "    \n    get_max_triples = 0\n    for j in range(n-1):\n\
    \        if a[j] < 0 or a[j] >= n or a[j] > a[j+1]:\n            break\n     \
    \   for i in range(j+1, n):\n            if a[i] < 0 or a[i] >= n or a[i] > a[i+1]:\n\
    \                break\n            k = i\n            while k < n and a[k] >\
    \ a[k+1]:\n                k += 1\n            get_max_triples += k - j - i\n\
    \    return get_max_triples", "    if n==0 then 0 else 3*n-2*(n-1)\nend\n</cell>\n\
    <text>\nget_max_triples(3)", "    if n == 0 \n        0 \n    else\n        length(trip_list((i,\
    \ a), 0, n-1))", "    if n == 0 then 1 else 0\n    else if n == 1 then 0\n   \
    \ else if n == 2 then 1\n    else \n        if n % 2 == 0 \n            then (n+1)/2\n\
    \            else 3\n        get_max_triples(n-1)\n        +(get_max_triples(n-2))\n\
    \        +(get_max_triples(n-2))\n    end\nend\n</cell>\n<code language=julia-1.6>\n\
    # Your code here\n</cell>\n<text>\nProblem 10\nThe value 1 is a power of two.",
  "    a = []\n    for i in 0..n-1\n        push!(a, i*(i+1)+1)\n    return count_triple_max(a)",
  "    if n < 3 \n        3 \n    else\n        if 3 * n - 1%3 == 0\n            get_max_triples(3*n-1)\n\
    \        else\n            get_max_triples(3*n-1)+1\n    end\nend", "    a = []\n\
    \    for i in 1:n\n        a.push(i*i-i+1)\n    end\n    return sum(a .<= 3)\n\
    end\n</cell>\n<code language=julia-1.0>\n#Checking the answer\nget_max_triples(5)\n\
    </cell>\n<text>\nWrite a Julia function max_sub_array(x::AbstractVector{T})::T\
    \ that, given an array x, returns the largest sub array that contains all of the\
    \ elements of x.", "    \"\"\"\n    You are given a positive integer n. You have\
    \ to create an integer vector a of length n.\n        For each i (1 \u2264 i \u2264\
    \ n), the value of a[i] = i * i - i + 1.\n        Return the number of triples\
    \ (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple\
    \ of 3.", "    a = zeros(Int64,n)\n    for i in 1:n\n        a[i] = i * i - i\
    \ + 1 \n    end\n    for i in 1:n\n        for j in 1:n\n            for k in\
    \ 1:n\n                if i<j && i<k && j<k\n                    c = a[i] + a[j]\
    \ + a[k]\n                    if c % 3 == 0\n                        return c\n\
    \                    end\n                end\n            end\n        end\n\
    \    end\n    return 0\nend\n</cell>\n<code language=julia-1.3>\n# verify\n@code_warntype\
    \ get_max_triples(5)\n</cell>\n<text>\n ", "    if n < 3\n        return n\n \
    \   var a::Int64 = Int64[]\n    for i in 1:n\n        a[i] = i * i - i + 1\n \
    \   for i in 2:n\n        for j in 2:n\n            for k in 2:n\n           \
    \     if j > k\n                    let sum = a[i] + a[j] + a[k]\n           \
    \         if sum % 3 == 0\n                        return sum\n    return n\n\
    </code>\n<|/ a |>\n<| a tags=algorithm,julia,optimization |>\n<code>", "    if\
    \ n==0 return 1\n    res=0\n    for ii in 1:n-1\n        for jj in 1:n-ii\n  \
    \          res+=(ii+jj+n-ii*jj+ii*(n-ii*jj)*3)%n\n    end\n    return res\nend",
  "    a = [1 ; 1]\n    for i in [1..n] \n        if a[i] == a[i-1] + a[i-2] % 3\n\
    \            a[i] = a[i-1] + a[i-2] % 3\n        end\n    end\n    return a.count{|i|\
    \ i == (a[i] + a[j] + a[k]) mod 3}", "    a::Array{Int64,1} = zeros(Int64,n)\n\
    \    for i in 1:n\n        for j in i+1:n\n            k = n-i-j\n           \
    \ if k > 0 && a[k] == (a[i] + a[j] + a[k])\n                a[i] = a[i] + a[j]\n\
    \                a[j] = 1\n            end\n        end\n    end\n    return length(a)\n\
    end\n</cell>\n<text>\nThe get_max_triples function returns 1 when n is equal to\
    \ or greater than 15.", "    count = 0\n    for i in 1..n do\n        for j in\
    \ i+1..n do\n            for k in j+1..n do\n                if ((i + j + k) ==\
    \ 3 * i) && ((i + j + k) == (i + j)) then\n                    count += 1\n  \
    \              end\n            end\n        end\n    end\n    return count",
  "    if n <= 0 \n        error(\"n must be a positive integer\")\n    else \n  \
    \      sum = 0\n        triples = Tuple{Int64}[]\n        for i in 1:n \n    \
    \        if i == 1\n                sum = 1\n            elseif i == n\n     \
    \           sum = 3\n            else \n                sum = sum + 1\n      \
    \      push!(triples, (i, sum, sum + i))\n            sum += i \n        sum =\
    \ 0\n        for i in trips\n            if i == (1,1,1)\n                sum\
    \ = 1\n            elseif i == (3,1,3)\n                sum = 3\n            else\
    \ \n                sum += i \n        end\n        return sum\nend", "    a =\
    \ [Int64](n+1)\n    for i in 1:n\n        a[i] = i * i - i + 1\n    return count((a[i],\
    \ a[j], a[k]) where a[i] < a[j] and a[i] < a[k])\nend", "    \n\"\"\"\n    You\
    \ are given a positive integer n. You have to create an integer vector a of length\
    \ n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i\
    \ + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i <\
    \ j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n    The function should\
    \ return the answer modulo 100.", "    a = [Int64] * n\n    for i = 1:n\n    \
    \    a[i] = i * i - i + 1\n    end\n    count = 0\n    for triple in pairs(a)\n\
    \        if triple[2] % 3 == 0\n            count += 1\n        end\n    end\n\
    \    return count\nend", "    a = [Int64] $ zeros(Int64, n)\n    a[1] = 1\n  \
    \  a[2] = 2\n    a[3] = 3\n    a[4] = 4\n    a[1] = a[1] + a[3] + a[4]\n    \n\
    \    for i in 1:n-2\n        a[i] = a[i+1] + a[i] + a[i+2]\n    end\n    \n  \
    \  for i in 2:n-1\n        a[i] = a[i] + a[i+1]\n    end\n    \n    for i in 2:n-1\n\
    \        a[i] = a[i] + a[i]\n    end\n    \n    return a[n]\nend", "    sum_triples=\
    \ 0\n    for i in 1..n-1\n        for j in i+1..n\n            if i*i >= j*j &&\
    \ i*i+j*j == i*j+i*j\n                sum_triples += 1\n            end\n    \
    \    end\n    end\n    sum_triples\nend\nget_max_triples(5)\n</cell>\n<code language=julia-1.0>",
  "    if n == 1 \n        return 1 \n    else \n        # To count the number of\
    \ triples, we will use the same formula \n        # (2 * n - 1) // 3 to count\
    \ the number of triples. \n        # And we will use the formula to get max value\
    \ from each group of n \n        # in each iteration to prevent the result from\
    \ overflow to large value \n        # since we only need to count the max value\
    \ in each group \n        # and add it together to get the final result.\n   \
    \     max_value = -Float64_C(0.0) \n        max_value = 0\n        for i in 1..n\
    \ \n            max_value = max(max_value, 2 * n - 1 ) / 3 \n            # max_value\
    \ can be larger than Float64_C(0.0) so we have \n            # to add it here\
    \ to prevent overflow \n            \n            # To count the triple we need\
    \ to check if the sum of the group \n            # of i with i + 1 is a multiple\
    \ \n            sum = 0\n            for j in i..n \n                sum = sum\
    \ + (i - j) * (i - j) + i + j \n                if sum > max_value \n        \
    \            max_value = sum \n                end \n            end \n      \
    \  end \n        return max_value \n    end \nend \n</cell>\n<code language=julia-1.4>\n\
    get_max_triples(10)\n</cell>\n<text>\nSolution", "    cnt=0\n    if n==0\n   \
    \     return cnt\n    array=Array{Int64,1}(n);\n    array[1]=1\n    array[2]=3\n\
    \    array[3]=7\n    array[4]=13\n    array[5]=21\n    for i=1:n-1\n        for\
    \ j in (i+1):n\n            for k in (i+1):n\n                if array[j]+array[k]+array[i]\
    \ ==6\n                    cnt+=1\n                end\n            end\n    \
    \    end\n    end\n    cnt\nend\n</cell>\n<text>\n5.3.2 Find all possible k-tuples\
    \ that sum up to a given value", "    \"\"\"\n    a::Vector{Int64}\n    \"\"\"\
    \n    return count(i -> i * i - i + 1, n) % 3 == 0\nend\n</cell>\n<code language=julia-1.5>",
  "    \n    sum_triples = 0\n    for i in range(n):\n        for j in range(i+1,\
    \ n):\n            sum_triples = sum_triples + (a[i])*(a[j])*(a[k])\n        \
    \    if sum_triples % 3 != 0:\n                break\n    return sum_triples %\
    \ 3", "    a, b = 0, 1\n    while b < n\n        (a, b), (b, b + 1) = zip(a,b),\
    \ (b, b + 1)\n    end\n    \n    return b - a + 1\nend\n</cell>\n<text>\nQ6\n\
    Write a function that returns true if the number n is odd.", "    return 3 * n\
    \ - 2\nend\n</cell>\n<code language=julia-1.5>", "    local a::Array{Int64,1}\
    \ = Array{Int64,1}(undef, n)\n    \n    for i in eachindex(a)\n        a[i] =\
    \ i * i - i + 1\n    end\n    \n    for i in eachindex(a)\n        for j in eachindex(a)\n\
    \            for k in eachindex(a)\n                if i < j < k && a[i] + a[j]\
    \ + a[k] == 3*3*3\n                    return 1\n                end\n       \
    \     end\n        end\n    end", "    if n < 2\n        0\n    else\n       \
    \ sum_triple = sum_triple_to_n(n)\n        count_triple = count_triple_to_n(n)\n\
    \        if count_triple == 0\n            0\n        else\n            max_triple\
    \ = sum_triple / count_triple\n            if sum_triple % count_triple == 0\n\
    \                sum_triple % count_triple\n            else\n               \
    \ sum_triple % count_triple + 1\n            end\n        end\n    end\nend\n\
    </code>\n<code>", "    if n == 1 then return 0\n    if n % 2 == 1 then return\
    \ 0\n    if n == 0 then return 0\n    var a::Int64 = (0 :: Int64)[1..n]\n    a[1]\
    \ = 1\n    var (i, j)::Int64 = (0, n - 1)::Int64\n    while (i + j) < (n - 2)\
    \ do \n        if a[i + j] > a[i - j] then\n            j := j + 1\n        else\
    \ if a[i + j] < a[i - j] then \n            i := i + 1\n        else \n      \
    \      return 1 + 2 * i\n        end\n    end\n    return 0\nend", "    a = [1\
    \ .. n] \n    let x = 0\n    for i in a do\n        for j in a do\n          \
    \  for k in a do\n                if (i >= j && i <= k) || (i > k && j >= i) ||\
    \ (j > i && k >= j) \n                then \n                    x += 1\n    return\
    \ x\nend", "    \n    \n    n = n - 1\n    a = Array{Int64}(Int(n)) # Vector{Int64}(n)\n\
    \    for i in 1:n\n        a[i] = i * i - i + 1\n    end", "    if n == 0\n  \
    \      return 0 \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    ", "    a = get_initial_vector(n)\n\
    \    count = 0\n    for i in 1 .. n \n        if a[i] < 0 \n            count\
    \ += 1\n        else\n            count += 1\n            if a[i] > 0 and a[i]\
    \ - a[j] > 0 && a[i] + a[j] + a[k] > 0\n                count += 1\n         \
    \   end\n        end\n    end\n    return count\nend", "    if n < 0 \n      \
    \  return -1\n    ans = 0\n    for i = n\n        ans = max(ans, i - i + 1)\n\
    \    return ans % 3\nend\n\"\"\"\n    You are given a positive integer n. You\
    \ have to create a vector b of length n.\n        For each i (1 \u2264 i \u2264\
    \ n), the value of b[i] = i + i * i.\n        Return the number of integer values\
    \ in a such that 0 <= a < b, and a * b\n    is a multiple of 3.", "    if n ==\
    \ 0\n        0\n    else\n        a = 1\n        for i in 1 : n\n            a\
    \ += i\n        \n        count = 0\n        for i in 1 : n\n            for j\
    \ in 1 : n\n                for k in 1 : n\n                    count += a[i]\
    \ for i in 1 : n\n                    count += a[j] for j in 1 : n\n         \
    \           count += a[k] for k in 1 : n\n        end\n        count\n    end\n\
    end", "\"\"\"\n    You are given a positive integer n. You have to create an integer\
    \ vector a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of\
    \ a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k])\
    \ of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n   \
    \ \n    Example :\n    >>> get_max_triples(4)\n    0\n        Explanation: \n\
    \        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n\
    \    \"\"\"", "    if n < 3 || n % 3 == 0:\n        return 0\n    if n == 3:\n\
    \        return 1\n    return (get_max_triples(n // 3) + 1) / 2", "    get_max_triples\
    \ = 0 \n    i = 1 \n    while i <= n do \n        i += 1\n        for j in (i..n)\
    \ do \n            j <= n \n            if j <= n and j + 1 <= n and i*i + j*j\
    \ + i*j == i*j + j*i + i*j \n                get_max_triples += 1 \n    return\
    \ get_max_triples\nend\n</cell>\n<code language=julia-1.5>\n@assert get_max_triples(5)\
    \ == 4\n</cell>\n<code language=julia-1.5>", "    ans = 0\n    for i in 1:n \n\
    \        j =  n - 1 - i \n        for j in j:j:j != i\n            k = i - j\n\
    \            for k in k:k:k != i\n                ans = ans + i + j + k\n    return\
    \ ans\nend\n</cell>\n<code language=julia-1.5>\nget_max_triples(5)\n</cell>\n\
    <text>\nQuestion 2.7 (Solution)\nWhat is the complexity of this algorithm? Can\
    \ you solve it using just one loop?", "    i = 1\n    j = 1\n    k = 1\n    while\
    \ i < n\n        i += 1\n        j += 1\n        k += 1\n        if j > n \n \
    \           j = 1\n        if i > n\n            i = 0\n        if k > n\n   \
    \         k = 1\n        if i*i > 3*j + 3*k\n            i += 1\n            j\
    \ += 1\n            k += 1\n    return i\nend\n</cell>\n<code language=julia-1.6>\n\
    \"\"\"\n    You are given two integers n and k. You have to return all the possible\
    \ combinations of \n    a triples a[0], a[1], a[2] (k \u2264 n \u2264 1000) such\
    \ that a[0] + a[1] + a[2] = 3k and each \n    possible combination has three distinct\
    \ elements.", "    a = zeros(n)\n    for i = 1 : n\n        a[i] = i * i - i +\
    \ 1\n    for i in 1 : n\n        for j in 1 : i-1\n            for k in 1 : j-1\n\
    \                if a[i] < a[j] + a[k]\n                    return a[i] < a[j]\
    \ + a[k]\n                end\n            end\n        end\n    end\n    return\
    \ false\nend", "    if (n < 0)\n        return 0\n    a = Array{Int64}(undef,\
    \ n)\n    for i in 1:n\n        a[i] = i * i - i + 1 \n    end\n    for i in 1:n\n\
    \        for j in 1:n\n            if i != j\n                for (k,l) in enumerate(a)\n\
    \                    if l >= 3 && (a[i] + a[j] + a[k] == l)\n                \
    \        return a[i] + a[j] + a[k]\n                    end\n                end\n\
    \            end\n        end\n    end\n    return 0\nend\n</cell>\n<code language=julia-1.0>\n\
    get_max_triples(8)\n</cell>\n<text>\nTask 8\nThe function count_all_valid_triple_combinations(n::Int64)::Int64\n\
    should return the number of valid (triple-counting) pairs of length n \nwith integer\
    \ multiples of 3 between 1 and n.", "    \n    cnt = 0\n    a_arr = Array{Int,\
    \ 1}(undef, 3)\n    for i in 1:n\n        a_arr[i] = i * i - i + 1\n        if\
    \ a_arr[i] % 3 == 0\n            cnt += 1\n        end\n    end\n    return cnt\n\
    end", "    if n < 0 \n        error(\"n should be non-negative.\")\n    if n >\
    \ 0 \n        return n\n    a = [0 for i in 1..n]\n    for i in 1..n\n       \
    \ a[i] = i * i - i + 1\n    return (a[a[1]+a[3]+a[5]] == a[2] && a[1]+a[3]+a[5]\
    \ < 3 && a[a[1]+a[3]+a[5]+3] == a[1]+a[3]+a[5]+3)\nend", "        \n    a = []\n\
    \    for i in 1:n\n        push!(a, i*i)\n        push!(a, i + 1)\n        push!(a,\
    \ i * i - i + 1)\n    \n    a.sort()\n    \n    if a[1] <= a[2] + a[3]\n     \
    \   return a[2] <= a[1] + a[3]\n    else\n        return false\n    end\nend\n\
    </cell>\n<code language=julia-1.5>\nget_max_triples(10)\n</cell>\n<text>\nSolution\
    \ using loops", "    if n <= 0 \n        error(\"The input must be positive\"\
    )\n    if n == 1 \n        return 1\n    elseif n == 2 \n        return 2\n  \
    \  else \n        sum = 0\n        for i = 2..n\n            sum += i * (i-1)\
    \ + i + 1\n        return sum % 6 == 0 ? sum / 6 : 0", "    a = []\n    for i\
    \ in 1 .. n\n        a.push(i*i - i + 1)\n    for i in 1..n\n        for j in\
    \ i..n\n            k = n - i - j\n            if\n                a[i] > a[j]\
    \ > a[k]\n            then\n                return a[i] > a[j] > a[k]\n      \
    \      end\n        end\n    end\n    return 0\nend", "    if is_power_of_two(n)\n\
    \        return get_max_triples(n-1)\n    elseif n == 0\n        return 0 \n \
    \   elseif n > 0\n        counter = [0]\n        for i=1:n\n            for j=i:n\n\
    \                for k=j:n\n                    counter.append(counter[i-1] +\
    \ counter[j-1] + counter[k-1])\n        return counter[n-1]", "\"\"\"\n    You\
    \ are given a positive integer n. You have to create an integer vector a of length\
    \ n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i\
    \ + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i <\
    \ j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.", "    a = [1 .. n]\n\
    \    for i = 2 to n do\n        for j = 2 to i - 1 do\n            if a[j] + a[j\
    \ + 1] == a[i] % 3 then\n                return i + 1\n    end\n    return 0\n\
    end", "    \"\"\"\n    You are given a positive integer n. You have to create\
    \ an integer vector a of length n.\n        For each i (1 \u2264 i \u2264 n),\
    \ the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i],\
    \ a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple\
    \ of 3.", "    a = (Int64)(1..n)\n    \n    for i in a\n        for j in a\n \
    \           for k in a\n                if  i+j+k == 3 && (a[i] + a[j] + a[k])\
    \ % 3 == 0 \n                    return 1\n                else\n            \
    \        return 0\n    end\nend\n</cell>\n<text>\nget_max_triples(5) == 1 \n \
    \   Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple\
    \ is (1, 7, 13).\n        \nget_max_triples(6) == 1 \n    Explanation: \n    \
    \    a = [1, 3, 7, 13, 21, 35, 49]\n        The only valid triple is (35, 7, 13).\n\
    \        \nget_max_triples(7) == 1 \n    Explanation: \n        a = [1, 3, 7,\
    \ 13, 21, 35, 49, 61]\n        The only valid triple is (35, 7, 13).\n       \
    \ \nget_max_triples(8) == 1 \n    Explanation: \n        a = [1, 3, 7, 13, 21,\
    \ 35, 49, 61, 81]\n        The only valid triple is (35, 7, 13).\n        \nget_max_triples(9)\
    \ == 1 \n    Explanation: \n        a = [1, 3, 7, 13, 21, 35, 49, 61, 81, 100]\n\
    \        The only valid triple is (35, 7, 13).\n        \nget_max_triples(10)\
    \ == 0 \n    Explanation: \n        a = [1, 3, 7, 13, 21, 35, 49, 61, 81, 100,\
    \ 107]\n        No triples are valid. \n    \"\"\"", "    a = sort(collect(1:n))\n\
    \    i = a[1]\n    j = a[end-1]\n    k = a[-1]\n    return ifelse(i+j+k %3 > 0,\
    \ (i+j+k) % 3 , 0)\nend", "    a=Int64[]\n    for i in 1:n\n        if (a==[])\n\
    \            push!(a[i], i * i - i + 1)\n        else\n            if i==1 ||\
    \ a[i] == a[1]\n                push!(a[i], i * i - i + 1)\n            else\n\
    \                push!(a[i], max(a[i-1], a[i], a[i-1]))\n        end\n    end\n\
    \    return length(a)\nend", "    \n    result <- 0", "    a::Array{Int64,1} =\
    \ Array.new(0) # Vector of length n\n    for i = 1:n\n        a[i] = i * i - i\
    \ + 1\n    end\n    \n    triple = similar(a)\n    for i = 1:n\n        for j\
    \ = 1:n\n            for k = 1:n\n                triple[i] = triple[i] + triple[j]\
    \ + triple[k] \n                if triple[i] % 3 == 0\n                    triple[i]\
    \ = 0\n                    triple[j] = 0\n                    triple[k] = 0\n\
    \                end\n            end\n        end\n    end\n    \n    triple\
    \ == 0\nend", "    if n < 3 \n        return 0 \n    if n == 0 \n        return\
    \ 0 \n    if n == 1 \n        return 1 \n    \n    answer = get_max_triples(n-1)\
    \ \n    if n % 2 == 0 \n        answer += get_max_triples(n-2) \n    \n    return\
    \ answer \n</code>\n<|/ a tags=math,algorithm,dynamic-programming,python dscore=1\
    \ |>\n<| a dscore=1 tags=math,algorithm,dynamic-programming,python |>\nThe following\
    \ solution runs in O(n*log(n)) time and O(n) space, and uses hash tables (dictionaries)\
    \ to store the answers.\n<code>\nimport math", "    \"\"\"\n    You are given\
    \ a positive integer n. You have to create an integer vector a of length n.\n\
    \        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n\
    \        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\
    \ \n    and a[i] + a[j] + a[k] is a multiple of 3.", "    a_vector = Array.zeros(Int64,\
    \ n)\n    a_vector[1] = 2*n\n    a_vector[2] = 2*n+1\n    a_vector[3] = 2*n+2\n\
    \    a_vector[4] = 2*n+3\n    \n    for i in a_vector\n        if i < n\n    \
    \        if a_vector[i] % 3 != 0\n                println(\"We are out of bounds\"\
    )\n                return(0)\n            end\n        end\n    end\n    \n  \
    \  for i in a_vector\n        if i <= n\n            if a_vector[i] % 3 == 0\n\
    \                println(\"We are out of bounds\")\n                return(0)\n\
    \            end\n        end\n    end\n    \n    return 1\nend\n</cell>\n<code\
    \ language=julia-1.4>\nget_max_triples(5)\n</cell>\n<text>\nExercise 1\nWrite\
    \ a function called calculate_average, which takes two parameters, a vector, and\
    \ a number.\nThe function should calculate the average of the numbers in the vector\
    \ and return a number.", "    \n    if n < 1 \n        throw(ArgumentError(\"\
    n should be positive integer greater or equal than 1.\"))\n    \n    if n % 2\
    \ == 0 \n        throw(ArgumentError(\"n should be an even positive integer.\"\
    ))\n    \n    a = zeros(Int64, n, 1)\n    a[1] = n-1\n    \n    for i = 3 .* (n-2)\n\
    \        if i % 2 == 0\n            a[i] = a[i-2] + i - 2\n        \n        \
    \    \n    elseif n % 3 == 0\n        a[i%2] = n-2\n    \n    else \n        a[(n-1)%2]\
    \ = n-2\n    \n    return maximum(a...)\nend", "    \"\"\" This function calculates\
    \ the number of triples (a[i], a[j], a[k]) of a where i < j < k\n        and a[i]\
    \ + a[j] + a[k] is a multiple of 3. It returns the number of triples (a[i], a[j],\
    \ a[k])\n    \"\"\"\n    if n==0 \n        return 0 \n    \n    a=rep(1,n)\n \
    \   for i::Int64 in 1:n-1\n        a[i]=i*i-1+1\n    end\n    if n>1\n       \
    \ return maximum((a[i],a[i+1],a[i+2]) for i in 2:(n-2))\n    else\n        return\
    \ maximum((a[i],a[i+1],a[i+2]) for i in 1:(n-2))\n    end\nend", "    \"\"\"\n\
    \    Get the number of triples of length 3 from a of length n.", "    # Write\
    \ your code in o(n) runtime \n    # Write your code here\n    \n    # write your\
    \ code in o(n) runtime \n    # Write your code here\n    \n    return \n</cell>\n\
    <cell>\nget_max_triples(5)\n</cell>\n<text>\nProblem 5 (6 Points)\nGiven a vector\
    \ v of length n, where n is greater than 0, find the maximum value in the vector\
    \ v. \nYou can assume that v is sorted in ascending order.", "    if n<3 return\
    \ 0\n    else \n        result=0\n        for i in 1..n do\n            for j\
    \ in (i+1..n) do \n                for k in (i+2..n) do\n                    if\
    \ i+j+k==n and i*i+j*j+k*k==n && (i==j or i==k or j==k) then \n              \
    \          result+=1\n                        end\n                end\n     \
    \       end\n        end\n        return result\nend\n</cell>\n<text>\nQuestion\
    \ 3: What will be the complexity of the function get_max_triples?", "    if (n\
    \ < 3)\n        return 0\n    \n    ans = n \n    for (i in 1:n)\n        ans\
    \ = (ans * ans - i + 1) // 3\n    end\n    return ans\nend", "    \"\"\"\n   \
    \ You are given a positive integer n. You have to create an integer vector a of\
    \ length n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i *\
    \ i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where\
    \ i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.", "\"\"\"\n    You\
    \ are given a positive integer n. You have to create an integer vector a of length\
    \ n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i\
    \ + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i <\
    \ j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.", "    count = 0\n \
    \   for _ in 0..n-1 do\n        if (a[_], a[_+1], a[_+2]) == (a[_], a[_+1], a[_+2])\
    \ then\n            count += 1\n        end\n    end\n    return count\nend\n\
    </cell>\n<code language=julia-1.5>", "    \n    return sum([a*a for a in triples(n)])\n\
    \    \nend\n</cell>\n<code language=julia-1.5>", "    a = [Int64](n)\n    a[1]\
    \ = 1\n    for i = 2; i <= n\n        push!(a,i*i-1)\n        a[i] += i\n    end\n\
    \    \n    return length(filter(x -> x >= 3, a))\nend", "    \n    trip_count\
    \ = 0\n    for trip in combination(1:n-1,3)\n        if trip[1]+trip[2]+trip[3]\
    \ % 3 == 0\n            trip_count = trip_count+1\n        end\n    end\n    return\
    \ trip_count\nend\n</cell>\n<code language=julia-1.4>\n# Test it on a couple of\
    \ test cases\n@assert get_max_triples(10) == 5\n@assert get_max_triples(12) ==\
    \ 4\n@assert get_max_triples(13) == 3\n@assert get_max_triples(25) == 2\n@assert\
    \ get_max_triples(30) == 0\n@assert get_max_triples(31) == 1\n</cell>\n<text>\n\
    A triple is a triplet of the form (a[i], a[j], a[k]), where i < j < k.\nThe sum\
    \ of a triplet is a multiple of 3.\nThe triples of a are generated by choosing\
    \ three indices i,j,k from 1 \u2264 i \u2264 n, and placing them in order:", " \
    \   mutable a::Vector{Int64} = Array{Int64}(0) \n    for i = 1:n \n        a[i]\
    \ = i*i-i+1 \n    end\n    mutable count::Int64 = 0\n    for i = 1:n-1 \n    \
    \    for j = i+1:n \n            if a[i] && a[j] && a[j] % 3 == 0 \n         \
    \       count += 1\n            end\n        end\n    end\n    count\nend\n</cell>\n\
    <code language=julia-1.5>\nget_max_triples(5)\n</cell>\n<text>\nExercise 9\nImplement\
    \ the function get_max_triple_sum() that returns the sum of the triples (a, b,\
    \ c) of a where a < b < c.\nFor example, with n = 6 and a = [1, 2, 3, 4] and b\
    \ = [5, 6, 7] the function should return 7.", "    count = 0\n    i = 0\n    a\
    \ = [0 for i in 1..n]\n    for _x in 1..n\n        if a[i] < _x \n           \
    \ count += 1\n            a[i] = _i\n            i += 1\n        else\n      \
    \      a[_x] += _i\n    end\n    return count\nend\n\"\"\"\n    You are given\
    \ a positive integer n and an integer k where 1 < k < n.\n    You have to find\
    \ and print the sum of all even numbers from 1 to k (inclusive).\n    If k > n,\
    \ output the sum of all numbers from 1 to n.", '    return count_triples(get_triples(n),
    n)', "    if n < 2 then return 0\n    vec = [1i] ++ map (*x) (0..n-1)\n    sum\
    \ = 0\n    for ix in 0..(n-1)\n        sum += (vec[ix]+vec[ix+1]+vec[ix+2])*3\n\
    \    return sum\nend", "    triple = 0\n    aux = 1\n    for i in 1:n\n      \
    \  if i < (n -1) \n        then\n            triple += (aux * (aux * (aux * (aux\
    \ + 1) + 1) + 1) + 1)\n            aux = i\n        end\n    end\n    return triple\n\
    end", "    if (n==0)\n        return 0 \n    local i = 1\n    local j = 1\n  \
    \  local k = 1\n    local count = 0\n    while i < n do\n        while j<n do\
    \ \n            if k >= i and k+j < n and k+j+i < n and (i+k+j)%3 == 0 then \n\
    \                count += 1\n            end\n            j += 1\n        end\n\
    \        i += 1\n        k += 1\n    end\n    return count\nend\n</cell>\n<text>\n\
    Problem 13\nWrite a Julia function called triples, that takes in an integer vector\
    \ a and an integer m and returns the number of triples in which a[i] > a[j] and\
    \ a[j] > a[k]. The input vector a is sorted lexicographically in ascending order.",
  "    if n == 1\n        return 1\n    \n    a = [0] * n\n    a[0] = 1\n    \n  \
    \  for i in 2..n\n        a[i] = a[i-1] + i\n        \n    for i in 1..n\n   \
    \     for j in 1..n\n            if a[i] == 0\n                return 0\n    \
    \        if a[j] == 0\n                return 0\n            \n            if\
    \ a[i] < a[j] and a[i] < a[k]\n                return 0\n            if a[j] <\
    \ a[i] and a[j] < a[k]\n                return 0\n            if a[i] > a[j] and\
    \ a[i] > a[k]\n                return 0\n            if a[k] > a[i] and a[k] >\
    \ a[j]\n                return 0\n    \n    return 1", "    if n < 2 \n    then\
    \ \n        return 0\n    else \n        cnt = 0\n        for i in 1:n\n     \
    \   cnt::Int64 = cnt + (i * i - i + 1)\n        for i in 1:n\n            cnt::Int64\
    \ = cnt + (i * i - i + 1)\n        return cnt % 3\n</code>\n<|/ a tags=algorithm,math\
    \ |>\n<| c |>\nIt's not \"wrong\", it's just an inefficient solution. You'd be\
    \ better off just computing the sum of the first `n` numbers, then adding the\
    \ `n-1` numbers. In the limit of n up to 100, it's as fast as you can get, since\
    \ there are only 10 numbers up to 100 to sum.\n<|/ c |>\n<| a tags=algorithm,math\
    \ dscore=0 |>\nI like what Jakub says in his solution with memoization, but I'd\
    \ like to offer a different approach for solving this problem:\n<code>", "   \
    \ ans = Int64(0)\n    for i = 1:n\n        for j = i+1:n\n            for k =\
    \ j+1:n\n                if i*i*i + j*j*j + k*k*k == Int(i*j*k*3.0)\n        \
    \            ans += 1\n    end\n    return ans\nend\n</cell>\n<code language=julia-0.6>\n\
    @time @show(get_max_triples(10000));\n</cell>\n<text>\nNow let's try to optimize\
    \ our algorithm. Recall that we want to know how many triplets (i, j, k) exists\
    \ where i < j < k.\nWe want to avoid computing a[i] and a[j] and a[k]\nTo do this,\
    \ we notice that we can compute a[i * i] and a[j * j] and a[k * k] by computing\
    \ a[i] and a[j] and a[k].\nWe can compute a[i * i] + a[j * j] + a[k * k] by computing\
    \ a[i] + a[j] + a[k].\nThen the sum of theses four values is i * i * i + j * j\
    \ * j + k * k * k.\nAnd it follows that we can compute the value of a[i * i] +\
    \ a[j * j] + a[k * k] by computing a[i] + a[j] + a[k]\nby computing a[i * i] +\
    \ a[j] + a[k].\nReminder:\nLet a[i * i] = a[i], and a[j * j] = a[j], and a[k *\
    \ k] = a[k]. Then:\na[i * i] + a[j * j] + a[k * k] = a[i] + a[j] + a[k].\nWe can\
    \ compute a[i * i] + a[j] + a[k] by computing a[i] and a[j].\nAnd now that we\
    \ have a[i] and a[j], we can, using the formula above, compute a[i * i] + a[j]\
    \ + a[k]\nby computing a[i] and a[j].", "    # your code goes here\n    # Write\
    \ your code in Julia here\n    # return answer\n    return count_triple_multiples(n)\
    \ == 3 && count_triple_multiples(n-1) == 3", "    if n < 2 \n        return 0\
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    ", "        a_len = Array{Int64,1}(undef,n)\n\
    \        for i = 1:n\n            a_len[i] = (i * i - i + 1)\n        end\n  \
    \      tri = Array{Int64,1}(undef,0)\n        for i = 1:n\n            for j =\
    \ 1:n\n                for k = 1:n\n                    if(i < j && j<k && a_len[i]\
    \ + a_len[j] + a_len[k] == i*j*k)\n                        push!(tri,[i,j,k])\n\
    \                    end\n                end\n            end\n        end\n\
    \        tri = unique(tri)\n        return length(tri)\n    end", "    a = []\n\
    \    for i in 1:n\n        a[i] = i * i - i + 1 \n    return count_triples(a)\n\
    end", "    count = 0\n    for j in 1:n-1\n        if isprime(j*j)\n          \
    \  count += 1\n        end\n    end\n    return count\nend", "    sum = 0\n  \
    \  i = 0\n    while i <= n\n        sum += a[i] + a[j] + a[k]\n        i += 1\n\
    \        j = (i + 1)%n\n        k = (j+1)%n\n    end\n    return sum % 3", "\"\"\
    \"\n    You are given a positive integer n. You have to create an integer vector\
    \ a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i]\
    \ = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of\
    \ a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.", "  a =\
    \ [1..n+1]\n  for i in a \n    if a[i] == a[i-1] + 1 && a[i-2] + a[i-1] == 2*a[i-2]\n\
    \      a[i-2] = None\n    end\n  end\n  if a[end] in a\n    a[end] = None\n  end\n\
    \  for i in a\n    if a[i] == i\n      return i\n    end\n  end\n  return 0\n\
    end\n</cell>\n<code language=julia-1.5>\n# Run this cell to check if you passed\
    \ the test\nget_max_triples(10)\n</cell>\n<text>\n3.4 Exercise - Find All Triples\
    \ Without Repeating Elements\nNow let's try to find all triples without repeating\
    \ elements. \nYou can find a solution with only linear complexity.", "    a =\
    \ Int64[(n+1)]\n    for i in 1:(n+1) \n        a[i] = i * i - i + 1\n    return\
    \ sum(Int64[(a[i], a[j], a[k]) for i in 1:(n) for j in (i+1):(n) for k in (i+1):(n)\
    \ if a[i] > a[j] and a[j] > a[k]])\nend\n</cell>\n<code language=julia-1.3>\n\
    get_max_triples(5)\n</cell>\n<code language=julia-1.3>", "    a = []\n    for\
    \ i in 1..n\n        push!(a ,i*i-i+1)\n    maximum(a)\nend", "    a = [Int64](n)\
    \ # create an empty array \n    for i in 1:n \n        a[i] = i*i - i + 1\n  \
    \  \n    max_triples = Int64(0)\n    for i in 1:n\n        for j in 1:n\n    \
    \        for k in 1:n\n                if i != j && j != k && k != i && a[i] +\
    \ a[j] + a[k] == (a[i] + 2*a[j] + 3*a[k]) and a[i] % 3 == 0 and a[j] % 3 == 0\
    \ and a[k] % 3 == 0 \n                    max_triples += 1\n    end\n    return\
    \ max_triples\nend\n</cell>\n<code language=julia-1.5>\nget_max_triples(6)\n</cell>\n\
    <code language=julia-1.5>\n\"\"\"\n    You are given an array arr of n distinct\
    \ integers and you have to find out whether \n        there are two elements in\
    \ arr such that their sum is exactly k.\n        arr is represented as an array\
    \ of integers and arr[i] is the i'th element of arr.\n        Return true if the\
    \ sum is exactly k, otherwise return false.\n        Complexity : O(n).\n\"\"\"",
  "    a = [Int64]()\n    for _ in 1 .. n do \n        push!(a, Int64(_ * _ + _ +\
    \ 1))\n    return count_triple_a(a, 1)", "    \"\"\"Solves the problem of finding\
    \ the maximum number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  \
    \  and a[i] + a[j] + a[k] is a multiple of 3. \n    \n    The solution uses the\
    \ property that a[i] + a[j] + a[k] is a multiple of 3\n    if a[i] > a[j] and\
    \ a[i] > a[k], and a[j] > a[k].\n    \n    Input:\n        n: the length of the\
    \ input vector\n    Output:\n        solution: the number of triples (a[i], a[j],\
    \ a[k]) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3\n    \n\
    \    Example :\n    >>> get_max_triples(5)\n    1\n        Explanation: \n   \
    \     a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n  \
    \  \"\"\"\n    \n    a::Vector{Int} = Vector{Int}(undef, n)\n    for i=1:n\n \
    \       a[i] = i * i - i + 1\n    end\n    \n    #get a[i] > a[j] and a[i] > a[k]\
    \ \n    a::Vector{Int} = Vector{Int}(undef, n)\n    a[1::2]::Vector{Int} = sort(a[1::2])\n\
    \    a[1::2]::Vector{Int} = sort(a[1::2])\n    \n    solution::Int64 = 0\n   \
    \ \n    for i=1:n \n        for j=1:n \n            for k=1:n \n             \
    \   if (i + j + k) == (a[i] + a[j] + a[k]) \n                    solution::Int64\
    \ = solution + 1\n                end\n            end\n        end\n    end\n\
    \    \n    return solution\nend", "    let \n        sum_triples = 0 \n      \
    \  for i in 1 .. n \n        for j in 1 .. i \n        for k in 1 .. j \n    \
    \    if i*i + j*j + k*k == 3*i \n            sum_triples = sum_triples + 1 \n\
    \    end\n    sum_triples\nend\n</cell>\n<code language=julia-1.5>", "    a =\
    \ [Int64](n)\n    i = Int64(1)\n    j = Int64(1)\n    k = Int64(1)\n    while\
    \ true\n        if i < j \n            a[i] = i * i - i + 1\n            i +=\
    \ 1\n        else\n            i += 1\n            if j < k \n               \
    \ a[j] = i * i - j + 1\n                j += 1\n            else\n           \
    \     j += 1\n                if k <= n \n                    a[k] = i * i - k\
    \ + 1\n                    k += 1\n                else\n                    k\
    \ += 1\n                    a[k] = i * i - k + 1\n        end\n        if i >\
    \ j\n            i += 1\n            if k < n \n                a[k] = i * i -\
    \ k + 1\n                k += 1\n            else\n                k += 1\n  \
    \              a[k] = i * i - k + 1\n        end\n        if j > k\n         \
    \   j += 1\n            if i < n \n                a[k] = i * i - k + 1\n    \
    \            k += 1\n            else\n                k += 1\n              \
    \  a[k] = i * i - k + 1\n        end\n        if k < n\n            a[k] = i *\
    \ i - k + 1\n            k += 1\n        end\n        if i == j\n            a[i]\
    \ = i * i - i + 1\n            i += 1\n        end\n        if k == n\n      \
    \      a[k] = i * i - k + 1\n            k += 1\n        end\n        if i =<\
    \ j\n            i += 1\n            if k < n \n                a[k] = i * i -\
    \ k + 1\n                k += 1\n            else\n                k += 1\n  \
    \              a[k] = i * i - k + 1\n        end\n        if k < n\n         \
    \   a[k] = i * i - k + 1\n            k += 1\n        end\n        if j <= k\n\
    \            j += 1\n            if i < n \n                a[k] = i * i - k +\
    \ 1\n                k += 1\n            else\n                k += 1\n      \
    \          a[k] = i * i - k + 1\n        end\n        if i < k\n            i\
    \ += 1\n            if k < n \n                a[k] = i * i - k + 1\n        \
    \        k += 1\n            else\n                k += 1\n                a[k]\
    \ = i * i - k + 1\n        end\n        if k < n\n            a[k] = i * i - k\
    \ + 1\n            k += 1\n        end\n    end\n    return a[k]\nend\nget_max_triples(Int64(5))",
  "    a, l = zeros(Int64, n), 1\n    for i in 1:n\n        a[i] = i * i - i + 1\n\
    \        l += a[i] + a[i] + a[i]\n    return l\nend", "    return 1 + 1 + 1 +\
    \ 1 + 1 + 1 + 1 + 1\nend\n</cell>\n<code language=julia-1.0>\nget_max_triples(3)\n\
    </cell>\n<text>\nExercise 9: Sum all the elements in an array", "    if n < 1\
    \ \n        error(\"n must be positive\")\n    \n    a::Int64[] = Int64[](n+1)\n\
    \    a[1] = 1\n    for i in 2 to n \n        a[i] = i*i - i + 1 \n    \n    j::Int64\
    \ = 1\n    while j < n\n        if a[j] + a[j+1] + a[j+2] >= 3 \n            return\
    \ j\n        j += 1\n    \n    return -1 \nend", "    cnt_triples = 0 \n    for\
    \ i = 0:i< n \n        for j = 0:i< n \n            if i+j > n then \n       \
    \         cnt_triples <- cnt_triples + 1 \n            else \n               \
    \ for k = 0:i< n \n                    if i+j+k > n then \n                  \
    \      cnt_triples <- cnt_triples + 1 \n                    break \n    return\
    \ cnt_triples \n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe algorithm is correct\
    \ but you have some errors in your code. One is in your conditional statement\
    \ where `i+j > n` should be `i+j > i+k` (and similarly for `k` and `j`)\n<|/ c\
    \ |>\n<| c |>\nAh. Thanks. Fixed it.\n<|/ c |>\n<| a |>\n<code>\nvar maxTriples\
    \ = 1;\nfor (var i=0; i<n; i++){\n    for (var j=0; j<n; j++){\n        for (var\
    \ k=0; k<n; k++){\n            if (i+j+k == n){\n                maxTriples++;\n\
    \                break;\n            }\n        }\n    }\n}\nconsole.log(maxTriples);\n\
    </code>\n<|/ a tags=algorithm,arrays,language-agnostic dscore=1 |>\n<| a |>\n\
    <code>\n#include <stdio.h>", "    if n < 3 return 0\n    cnt = 0\n    for i in\
    \ 1..n do\n        for j in (i+1)..n do\n            for k in (i+1)..n do\n  \
    \              if i*i + j*j + k*k == i*i*k*k then cnt += 1\n    \n    return cnt\n\
    </code>\n<|/ a tags=performance,algorithm,for-loop,vectorization,math |>\n<| c\
    \ |>\nI believe your solution is correct but I am not sure how it works. Can you\
    \ explain it ?\n<|/ c |>\n<| a dscore=1 |>\nI believe this is the most efficient\
    \ and fastest algorithm for you problem:\n<code>", "\"\"\"\n    You are given\
    \ a positive integer n. You have to create an integer vector a of length n.\n\
    \        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n\
    \        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\
    \ \n    and a[i] + a[j] + a[k] is a multiple of 3.", "    result <- 0\n    for\
    \ i in 1 .. n\n        result <- max(result, (i * i - i + 1) * (i + 1) * (i -\
    \ 1))\n    return result\nend", "    a = [1, 3, 7, 13, 21]\n    for i in (a..a.last)\n\
    \        for j in (i..a.last)\n            for k in (j..a.last)\n            \
    \    if i+j+k == a[j+k]+a[k]+a[i] && a[j+k] == a[k]+a[i] && a[j+k] == a[i]+a[j]\n\
    \                   && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] ==\
    \ a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j]\
    \ && a[j+k] == a[i]+a[j]\n                   && a[j+k] == a[i]+a[j] && a[j+k]\
    \ == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j]\
    \ && a[j+k] == a[i]+a[j]\n                   && a[j+k] == a[i]+a[j] && a[j+k]\
    \ == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j]\
    \ && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j]\n                   && a[j+k]\
    \ == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j]\
    \ && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j]\n     \
    \              && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j]\
    \ && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k]\
    \ == a[i]+a[j]\n                   && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j]\
    \ && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k]\
    \ == a[i]+a[j] && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+a[j]\n               \
    \    && a[j+k] == a[i]+a[j] && a[j+k] == a[i]+", "    if n == 0\n        return\
    \ 0 \n    \n    a = Array.zeros(Int64, n)\n    for k in 1:n\n        for j in\
    \ 1:n\n            for i in 1:n\n                if i < j < k\n              \
    \      a[i] = a[i] + a[j] + a[k]\n                    if a[i] % 3 == 0\n     \
    \                   return i\n        return k\n    \n    return 0\nend", "  \
    \  a_prime = Int64[]\n    for k in (Int64 1 .. n)\n        if isPrime(k)\n   \
    \         push!(a_prime, k)\n    end\n    \n    count = 0\n    for i in a_prime\n\
    \        for j in a_prime\n            if j > i\n                count += a[i]\
    \ + a[j] + a[k]\n            end\n        end\n    end\n    return count\nend\n\
    </cell>\n<code language=julia-1.4>\n@time a = get_max_triples(1_000_000)\n</cell>\n\
    <text>\nQ. Create a function that prints the triple pairs in a given array, where\
    \ 1 < k < n, and if the triplet (a[i], a[j], a[k]) of a where i < j < k is a multiple\
    \ of 3.", "    \n    \n\"\"\"\n    You are given a positive integer n. You have\
    \ to create a vector a of length n.\n        You can only move left, right or\
    \ stay in the same place. \n        For example, if the number of stones is given\
    \ as 3, then the only valid moves are \n        \n        \n        * Move right\n\
    \        * Move left\n        * Stay in the same place\n        \n        You\
    \ are given an integer array a of length n. \n        The value of a[i] represents\
    \ the number of stones in a column i.\n    \n    Write an efficient algorithm\
    \ for the following questions:", "    if n == 1 \n        1\n    else\n      \
    \  let a::Int64 = Int64(1)\n        for i in 2..n\n            a.*=(3-(i*i))\n\
    \        end\n        1\n    end\nend\n</cell>\n<code language=julia-1.4>\nget_max_triples(4)\n\
    </cell>\n<text>\n4.7 Solution Triples", "\"\"\"\n    You are given a positive\
    \ integer n. You have to create an integer vector a of length n.\n        For\
    \ each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return\
    \ the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i]\
    \ + a[j] + a[k] is a multiple of 3.", "    if n < 2 return 0\n    if n == 1 return\
    \ 1\n    \n    let mut a = [1 .. n]\n    let mut max_triples = 0\n    let mut\
    \ max_triple = 0\n    \n    for i in 1 .. n {\n        for j in 1 .. i {\n   \
    \         max_triple = max(a[i], a[j])\n            if max_triple > max_triples\
    \ max_triples = max_triple\n            max_triple = 0\n        }\n    }\n   \
    \ \n    return max_triples\nend\n</cell>\n<code language=julia-1.0>\nget_max_triples(5)\n\
    </cell>\n<text>\nExercise 4", "    \n    a = [n for _n in 1 .. n] \n    for i\
    \ in 1 .. n \n        local j = 1\n        local k = 1\n        while j <i &&\
    \ k < i \n            if a[i] + a[j] + a[k] == 3\n                then return\
    \ 1\n            else \n                j = j + 1\n                k = k + 1\n\
    \            end\n        end\n    end\n    return 0\nend\n</cell>\n<code language=julia-1.5>\n\
    get_max_triples(5)\n</cell>\n<text>\nExercice 13 : get_max_triples(n)\nExersice\
    \ 13 \nWrite a function that returns the number of triples (a[i], a[j], a[k])\
    \ of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.", "    a\
    \ = []\n    for i in 1:n\n        a[i] = i * i - i + 1 \n        \n    for k in\
    \ (1:n)\n        if (a[k] + a[k-1] + a[k-2]) % 3 != 0 then \n            return\
    \ 0 \n        end\n    end\n    return 1 \nend\n</cell>\n<code language=julia-1.5>\n\
    # ok\nget_max_triples(5)\n</cell>\n<text>\nProblem 3\nWrite a Julia function count_triples(n)\
    \ that returns the number of triples (a[i], a[j], a[k]) of a where i < j < k,\
    \ \n    and a[i] + a[j] + a[k] is a multiple of 3.", "    ans = 0 \n    for i\
    \ = 1:n\n        for j=i+1:n\n            for k=j+1:n\n                if i!=j\
    \ and i!=k and j!=k\n                    ans+=1\n    return ans\nend\n</cell>\n\
    <code language=julia-1.0>", "    if n==1 || n==2 || n==3\n        return n\n \
    \   \n    a_vec=Array{Int64}(undef,n)\n    for i in 1:n\n        a_vec[i]=i*i-1+i\n\
    \    end", "    if n < 0\n        error(\"n must be positive integer\")\n    return\
    \ find_triple(n)\nend\n</cell>\n<code language=julia-0.5>\n# %load ./src/get_max_triples.jl\n\
    \"\"\"\n    You are given a positive integer n. You have to create an integer\
    \ vector a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of\
    \ a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k])\
    \ of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.", " \
    \   a = [Int64]()\n    a[1] = Int64(n - 1) * Int64(n - 1) + Int64(n - 2)\n   \
    \ for i in 2:(n-1)\n        a[i] = (a[i-1] + a[i-2]) * (Int64(2) + (i < (n-1)))\n\
    \    return a.max_by(|a| (a|) == (a|).max())\nend", "\"\"\"\n    You are given\
    \ a positive integer n. You have to create an integer vector a of length n.\n\
    \        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n\
    \        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\
    \ \n    and a[i] + a[j] + a[k] is a multiple of 3.", "    if n < 3 return 0\n\
    \    \n    count = 0\n    vec = [1 for _ in 1:n]\n    for i in 1:n\n        for\
    \ j in i+1:n\n            for k in j:n\n                if vec[i] == vec[j] +\
    \ vec[k]\n                    count += 1\n    \n    return count\nend", "\"\"\"\
    \n    You are given a positive integer n. You have to create an integer vector\
    \ a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i]\
    \ = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of\
    \ a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.", "    #your\
    \ code here\n    a = [1 .. n]\n    cnt = 0\n    for i in a\n        for j in a\n\
    \            for k in a\n                if i < j and j < k and i < k\n      \
    \              cnt += 1\n    return cnt\nend\n</cell>\n<text>\nLet's now see how\
    \ we can improve the performance of the function get_max_triples. We will use\
    \ the Julia programming language to implement our solution.", "    sum = zeros(Int,\
    \ n)\n    for i in 1:n\n        sum[i] = i * i - i + 1\n    return sum.max()\n\
    end", "    if n < 1 \n        return 0 \n    else \n        triples = 0 \n   \
    \     if n <= 3 \n            return 1 \n        else \n            for i \u2208\
    \ 0 .. n-2 \n                for j \u2208 0 .. n-2 \n                    if j\
    \ > i \n                        for k \u2208 0 .. n-2 \n                     \
    \       if k > j \n                                if i+k > j+k \n           \
    \                         triples += 1 \n                        else \n     \
    \                       triples += 1 \n    end \nend \n</cell>\n<code language=julia-1.4>\n\
    # solution 1\nget_max_triples(5) == 3\n</cell>\n<text>\nProblem 3 : Get max and\
    \ min numbers in an array\nThe function get_min_and_max(x::AbstractArray) should\
    \ return two integers, the first one being the minimum number in the array, and\
    \ the second one being the maximum number in the array.", "    a::Array{Int64,1}\
    \ = Array{Int64,1}(undef, n)\n    for i in 1:n\n        for j in i+1:n\n     \
    \       a[i] = i*i - i + j\n        end\n    end\n    for i in 1:n\n        for\
    \ j in i+1:n\n            for k in j+1:n\n                if (a[j] + a[k] + a[i]\
    \ ) % 3 == 0 \n                    return 1\n                end\n           \
    \ end\n        end\n    end\n    return 0\nend\n</cell>\n<code language=julia-1.5>",
  "    if n == 0 return 0\n    if n % 2 == 0 return get_max_triples(n/2) + 1\n   \
    \ if n % 3 == 0 return get_max_triples(n/3) + 1\n    \n    count = Int64(0)\n\
    \    \n    for i \u2208 1:(n-1)\n        count += i + (i + 1) * i + 1 \n    \n\
    \    return count\nend", "    answer = 1\n    for a in a:\n        if a < 0 or\
    \ a%3 != a:\n            answer += 1\n    return answer", "    if (n==0)\n   \
    \     0\n    else if (n==1)\n        1\n    else\n        3*get_max_triples(n-1)\
    \ + get_max_triples(n-2) + get_max_triples(n-3)\nend\n</cell>\n<code language=julia-1.2>\n\
    # Run this cell to load your get_max_triples function in the notebook.", "   \
    \ if n < 3 \n    else \n        for (a, (i, j), k) in triples(n) \n          \
    \  if i + j + k == 3*a\n    end\nend\n</code>\n<|/ a tags=julia,loops,if-statement\
    \ |>\n<| c |>\nThanks for answering your question so quickly :)\n<|/ c |>\n<|\
    \ c |>\nI added a version for your second question. Also note that I changed my\
    \ code to handle negative values of n\n<|/ c |>\n<| c |>\nI updated my code with\
    \ a more elegant solution that also handles negative values of n\n<|/ c |>\n<|\
    \ c |>\nThanks so much for your help. I added an additional question and added\
    \ a more elaborate description of what I want to do. Would be awesome if you could\
    \ take a look at that :)\n<|/ c |>\n<| c |>\nI updated my answer to handle the\
    \ new question. By the way you have a really high rate of accepted answers so\
    \ I guess you don't really care about my efforts. Maybe you could accept my answer\
    \ now :). Welcome to StackOverflow and have a nice day!\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is another solution, using only a for loop and an if statement :\n\
    <code>", "    \n    \n    \"\"\"\n    You have to create an integer vector a of\
    \ length n.\n    For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i -\
    \ i + 1.\n    Return the number of triples (a[i], a[j], a[k]) of a where i < j\
    \ < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.", "    if n < 0 \n   \
    \     error(\"n must be positive.\")\n        \n    a = (1..n)\n    triple_count\
    \ = 0\n    triples = map ((a .- 1) .* a .+ 1 .* a .+ 1 .* a)\n    triples = filter\
    \ ((a .== triple_count) . (a .< n), triples)\n    \n    \n    for (_,i,j,k) in\
    \ triples \n        if i + j + k == n \n            return triple_count \n   \
    \     else \n            triple_count += (i + j + k) \n    return triple_count\n\
    </code>\n<|/ a dscore=1 tags=julia,performance |>\n<| a tags=julia,performance\
    \ |>\nHere's a solution that does not require creating an array. \nIt works by\
    \ using Int64's Bitwise-And operator (&) to create an array which contains a 1-bit\
    \ for every triple of indices, and a 2-bit for every triple-pair (i, j), where\
    \ i and j are different elements. \nWe then check how many of these 2-bit arrays\
    \ are nonzero. \n<code>", "    if n < 3 return 0\n    x <- 3 \n    for i in 3..n-1\
    \ do \n        x <- x + 3*((x+1)^2 - (x+1)^3)\n        if x mod 3 != 0 return\
    \ 0\n    return 1\nend\n</cell>\n<code language=julia-1.2>", "    if n == 1 \n\
    \        1\n    else \n        1 + get_max_triples(n - 1)\n    end\nend", "  \
    \  if n < 3 return 0\n    a.push(0)\n    i = 2\n    a.push(1)\n    while i < n\
    \ \n        if a[i] + a[j] + a[k] > 9*3 \n            return 1 + get_max_triples(i)\
    \ + get_max_triples(j) + get_max_triples(k)\n        else\n            i = i +\
    \ 1\n            a.push(i*i - i + 1)\n        end\n    end\n    return 1\nend",
  "    \"\"\"\n    You are given a positive integer n. You have to create an integer\
    \ vector a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of\
    \ a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k])\
    \ of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.", " \
    \   \n    count = 0\n    a = Vector{Int64}(n)\n    for i in 1:n\n        a[i]\
    \ = i*i-1+i\n    end\n    for i in 1:n\n        for j in i+1:n\n            for\
    \ k in j+1:n\n                if a[i] < a[j] && a[j] < a[k]\n                \
    \    count += 1\n                end\n            end\n        end\n    end\n\
    \    return count\nend\n</cell>\n<code language=julia-1.1>", "    if n < 3 \n\
    \        0\n    else \n        sum(3 * i^2 for i in [1..n-1]) - 3 * (n-1) + 3\n\
    \    end\nend\n</cell>\n<code language=julia-1.5>", "    \n    count = 0\n   \
    \ \n    for index in 1..n \n        if index % 3 == 0 && index % 7 == 0 && index\
    \ % 13 == 0\n            count += 1\n        end\n    end\n    \n    return count\n\
    end", '    return sum(isTriple(a) | isTriple((a,b), (a,b), (a,b)) | isTriple((a,b),
    (a,b), (c,d)) | isTriple((a,b), (a,b), (a,c)) | isTriple((b,a), (b,a), (c,d))
    | isTriple((b,a), (b,a), (a,c)) | isTriple((b,a), (b,a), (a,d)) | isTriple((b,a),
    (c,a), (c,d)) | isTriple((b,a), (c,a), (a,d)) | isTriple((b,a), (c,a), (a,c))
    | isTriple((b,a), (c,a), (a,b)) | isTriple((b,a), (c,b), (a,c)) | isTriple((b,a),
    (c,b), (a,d)) | isTriple((b,a), (c,b), (a,b)) | isTriple((b,a), (c,b), (a,c))
    | isTriple((b,a), (c,b), (a,b)) | isTriple((b,a), (c,c), (a,d)) | isTriple((b,a),
    (c,c), (a,b)) | isTriple((b,a), (c,c), (a,c)) | isTriple((b,a), (c,c), (a,b))
    | isTriple((b,a), (c,d), (a,b)) | isTriple((b,a), (c,d), (a,c)) | isTriple((b,a),
    (c,d), (a,d)) | isTriple((b,a), (c,d), (a,b)) | isTriple((b,a), (c,d), (a,c))
    | isTriple((b,a), (c,d), (a,b)) | isTriple((b,a), (c,d), (a,c)) | isTriple((b,a),
    (c,e), (a,b)) | isTriple((b,a), (c,e), (a,c)) | isTriple((b,a), (c,e), (a,d))
    | isTriple((b,a), (c,e), (a,e)) | isTriple((b,a), (c,e), (a,b)) | isTriple((b,a),
    (c,e), (a,c)) | isTriple((b,a), (c,e), (a,d)) | isTriple((b,a), (c,e', "    \n\
    \    cnt = 0\n    \n    for x in a where x < n\n        cnt += x^3\n    \n   \
    \ return cnt\n    \n    \n\"\"\"\n    You are given a positive integer n. You\
    \ have to create an integer vector a of length n.\n        For each i (1 \u2264\
    \ i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number of\
    \ triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k]\
    \ is a multiple of 3.", "    # Write your code here\n    \n    if n == 1:\n  \
    \      return 1 \n    if n%3 != 0: \n        return 0\n    \n    a = [1 for i\
    \ in range(n)]\n    count = 0\n    for i in a:\n        for j in a:\n        \
    \    for k in a:\n                count += i * j + j * k + k * a[i] \n    return\
    \ count \n</cell>\n<text>\nQuestion 10\nWrite a function max_triples(n) that returns\
    \ the number of triples (i, j, k) of a where i < j < k, \nand a[i] + a[j] + a[k]\
    \ is a multiple of 3.", "    \"\"\"\n    You are given a positive integer n. You\
    \ have to create an integer vector a of length n.\n        For each i (1 \u2264\
    \ i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number of\
    \ triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k]\
    \ is a multiple of 3.", "    a=Array{Int64,1}(undef,n)\n    for i in 1:n\n   \
    \     a[i]=i*i-i+1\n    end\n    triple_count = 0\n    for i in 1:n\n        for\
    \ j in i+1:n\n            for k in j+1:n\n                if a[i+j+k] % 3 == 0\n\
    \                    triple_count = triple_count+1\n                end\n    \
    \        end\n        end\n    end\n    return triple_count\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    return sum(triple_of_primes(n) for _ in 1:n)\nend\n\
    </cell>\n<code language=julia-1.6>\nget_max_triples(4)\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function that returns the number of positive integers that their\
    \ sum is less than n.", "    if n < 1 \n        error(\"The given integer must\
    \ be positive.\") \n    else \n        count = 0\n        for i in 1 .. n \n \
    \           for j in i + 1 .. n \n                for (k <- j + 1 .. n) \n   \
    \                 if (i*i - i + 1) + (j*j - j + 1) + (k*k - k + 1) % 3 == 0 \n\
    \                        count += 1\n                        break;\n    end\n\
    \    return count\nend\n</cell>\n<code language=julia-0.4>\nget_max_triples(5)\n\
    </cell>\n<code language=julia-0.4>\n@time get_max_triples(5)\n</cell>\n<code language=julia-0.4>\n\
    @time get_max_triples(10^8)\n</cell>\n<code language=julia-0.4>\n@time get_max_triples(10^9)\n\
    </cell>\n<text>\n3. Sum Roots", "    sum = 0\n    for i in 1:n\n        for j\
    \ in (i+1):n\n            for k in (j+1):n\n                if i==j && i==k &&\
    \ j==k\n                sum+=1 \n                end\n            end\n      \
    \  end\n    end\n    sum\nend", "    \n    a, b = [0], [0]\n    for i in 1..n\
    \ do \n        b.push(a[i-1] + a[i-1])\n        a.push(i*i - i + 1)\n        if\
    \ a[i] % 3 == 0 then \n            if a[i-1] < b[i-1] then b[i-1] = a[i]\n   \
    \         a.push(a[i])\n        end\n    end\n    return b.length - 3\nend\n</cell>\n\
    <code language=julia-1.5>\n@time get_max_triples(100)\n</cell>\n<code language=julia-1.5>",
  "    a = [1,3,7,13,21]\n    for i in 2:n-1\n        flag = true\n        for j in\
    \ i:n\n            if j > i\n                flag = false \n                break\n\
    \        for k = i:n\n            if k > i\n                break\n          \
    \  flag = false \n            if k + j > n\n                break\n          \
    \  if k + j + 1 > n\n                flag = false \n                break\n  \
    \          if a[i] < i + j\n                break\n            if a[i + j] < i\
    \ + k + j\n                break\n            if a[i + j + 1] < i + k\n      \
    \          break\n            if a[i + k] < i + j + 1\n                break\n\
    \            if a[i + k + 1] < i + k + j + 1\n                break\n        \
    \    if a[i] < j + k + j + 1\n                break\n            if a[j] < j +\
    \ k\n                break\n            if a[j + 1] < j + k + 1\n            \
    \    break\n            if a[j + k] < j + j + 1\n                break\n     \
    \       if a[j + k + 1] < j + k + j + 1\n                break\n            if\
    \ a[k] < j + k + j\n                break\n            if a[k + 1] < j + k\n \
    \               break\n            if a[k + j] < j + j + k\n                break\n\
    \            if a[k + j + 1] < j + j + k + 1\n                break\n        \
    \    if a[k] > i + j + k + j + k + 1\n                break\n            if a[k\
    \ + 1] > i + j + k + j + k\n                break\n            if a[k + j] > i\
    \ + j + k + j + j + k\n                break\n            if a[k + j + 1] > i\
    \ + j + k + j + j + k + 1\n                break\n            if a[k] > j + j\
    \ + k + j + k + 1\n                break\n            if a[k + 1] > j + j + k\
    \ + j + k\n                break\n            if a[k + j] > j + j + k + j + j\
    \ + k\n                break\n            if a[k + j + 1] > j + j + k + j + j\
    \ + k + 1\n                break\n            if a[k] > j + k + j + j + k\n  \
    \              break\n            if a[k + 1] > j + k + j + k + 1\n          \
    \      break\n            if a[k + j] > j + k + j + j + k\n                break\n\
    \            if a[k + j + 1] > j + k + j + j + k + 1\n                break\n\
    \            if a[k] > k + j + j + j + k\n                break\n            if\
    \ a[k + 1] > k + j + j + k + 1\n                break\n            if a[k + j]\
    \ > k + j + j + ", "    \n    \"\"\"\n    You are given a positive integer n.\
    \ You have to create an integer vector a of length n.\n        For each i (1 \u2264\
    \ i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number of\
    \ triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k]\
    \ is a multiple of 3.", "    mutable a = Vector{Int64}(length(n))\n    for i=1:n\n\
    \        a[i] = i * i - i + 1 \n    end\n    return sum(a .< a.min())\nend\n</cell>\n\
    <code language=julia-1.0>\n@assert get_max_triples(5) == 4\n@assert get_max_triples(1)\
    \ == 3\n</cell>\n<code language=julia-1.0>", "    if n < 3\n        return n\n\
    \    for i in [1..n]\n        for j in [1..n]\n        for k in [1..n]\n     \
    \       if i * i + j * j + k * k == 3 * i * j\n                return i\n    return\
    \ 0\nend", "    return sum(is_triple(Int64, i, j, k)\n        for (i, j, k) in\
    \ combinations(1:n, 3)\n        where i <= j)\nend", "    \n    a = [1..n]\n \
    \   for i in a\n        local k = 2\n        local j = 0\n        while j < k\n\
    \            if a[j] % 3 == 0\n                k = j\n            else \n    \
    \            j = k + 1\n            end\n        end\n        if k > 1\n     \
    \       a[k], a[1], a[2] = a[1], a[2], a[k]\n        end\n    end\n    local count\
    \ = 1\n    for i in a\n        if a[i] % 3 == 0\n            count = count + 1\n\
    \        end\n    end\n    return count\nend", "    if n == 0 \n        == 0 \n\
    \    else \n        == 0\nend", "    if n == 0\n        return 0\n    \n    a\
    \ = zeros(Int64, n)", "    if n==0 || n==1 \n        return 1\n    else \n   \
    \     let a = sort([1..n])\n        let i = 3\n        let j = 3\n        let\
    \ k = 2\n        let n = 3\n        while i <= n \n            && (j > i || k\
    \ > i) \n            && (j > k) \n            && (k > n) \n            && (a[i]\
    \ < a[j] || a[i] < a[k]) \n            && (a[i] < a[k] || a[k] < a[j]) \n    \
    \        && (a[k] < a[j]) \n            do \n                i := i+1 \n     \
    \           j := j+1 \n                k := k+1 \n                n := n+1 \n\
    \        return n \nend", "    \n    if n <= 0\n        error(\"n <= 0\")\n  \
    \  \n    \n    max_triples = Int64(0)\n    \n    for i in (1:n)\n        for j\
    \ in (1:n-i)\n            if i != j\n                for k in (1:n-j-1)\n    \
    \                if j != k\n                        if i+j+k == n\n          \
    \                  if i+k+j == n\n                                if k+j+i ==\
    \ n\n                                    max_triples += 3\n                  \
    \              end\n                            end\n                        end\n\
    \                    end\n                end\n            end\n        end\n\
    \    end\n    \n    return max_triples\nend", "    a = Array{Int64,1}(undef, n)\n\
    \    for i in 1:n\n        for j in 1:n\n            for k in 1:n\n          \
    \      if i<j && i<k && a[i]<a[j] && a[j]<a[k]\n                    push!(a, (i,\
    \ j, k))\n                end\n            end\n        end\n    end\n    return\
    \ count(a==3)\nend\n</cell>\n<code language=julia-1.5>", "    if n < 3 || n >=\
    \ Int64(1e5)\n        return n\n    \n    triple ::Int64 = get_max_triples(n-1)\n\
    \    triple = triple + get_max_triples(n-2)\n    triple = triple + get_max_triples(n-3)\n\
    \    \n    triple = triple + get_max_triples(n-4)\n    triple = triple + get_max_triples(n-5)\n\
    \    \n    return triple\nend", "    a=Vector{Int64}(undef,n)\n    for i in 1:n\n\
    \        a[i]=i*i-i+1\n    end\n    sum=0\n    for i in 1:n-1\n        for j in\
    \ i+1:n\n            sum+=a[i]+a[j]+a[k]\n            end\n        end\n    end\n\
    \    return sum%3==0\nend\n</cell>\n<code language=julia-0.6>", "    get_max_triples(n,\
    \ [])\nend ", "    a::Vector{Int64} = ones(n) * 0\n    for i in 1:n\n        a[i]\
    \ = i\n    end\n    count = 0\n    triples = Array{Tuple{Int64, Int64, Int64}}(undef,\
    \ 3)\n    for i in 1:n\n        for j in i+1:n\n            triples += (a[i],\
    \ a[j], a[k])\n        end\n    end\n    for i in 1:n\n        for j in i+1:n\n\
    \            for k in j+1:n\n                count = count + 3 if a[i] + a[j]\
    \ + a[k] == 0\n            end\n        end\n    end\n    return count\nend\n\
    </cell>\n<code language=julia-1.0>", "    cnt = 0\n    for i in 1 .. n \n    \
    \    if (a[i] mod 3) /= 0 \n            cnt += 1 \n    return cnt \nend\n</cell>\n\
    <code language=julia-1.5>\nget_max_triples(5)\n</cell>\n<text>\nThe same thing\
    \ can be done using recursion", "    return Int64(0)\nend", "    #Your code here\n\
    end\n</cell>\n<code language=julia-0.6>\n#Solution", "    a = [i for i in 0:n]\n\
    \    for i in (a):\n        for j in (a):\n            if i!=j:\n            \
    \    a[i] = a[i] + a[j] + a[k]\n            else:\n                return a\n\
    \    return 0\nend", "    a = [Int64(i) for i in 1:n] \n    count = 0\n    for\
    \ i in 1..n\n        for j in (i+1)..n\n            k = n-1\n            while\
    \ k > j\n                while a[i] < a[j]\n                    a[i] += 1\n  \
    \              while a[k] < a[j]\n                    a[k] += 1\n            \
    \    count += 1\n                k -= 1\n            end\n        end\n    end\n\
    \    return count\nend\n</cell>\n<code language=julia-1.5>\nget_max_triples(5)\n\
    </cell>\n<text>\nExercise 5", "    if n < 1 \n        return 0 \n    a = Array.fill(Int(1),\
    \ n)(0) \n    for i in 1..n \n        a[i] = i * i - i + 1 \n    for i in 1..n\
    \ \n        for j in 1..n \n            if i != j \n                if a[i] ==\
    \ a[j] && a[i] + a[j] % 3 == 0 \n                    return 1 + get_max_triples(n\
    \ - i - 1) \n    return 0 ", "    if n < 0 \n        error(\"get_max_triples:\
    \ n must be positive\") \n    n >= 1 | return 0\n    \n    let mut a = [1] * n\n\
    \    for i in 1..n-1 do \n        let mut j = i - 1\n        let mut k = n - 1\n\
    \        while j < k and a[j] > 0 do \n            let mut t = a[j]\n        \
    \    a[j] = a[k]\n            a[k] = t\n            j -= 1\n            k -= 1\n\
    \    \n    for i in 1..n do \n        if a[i] % 3 == 0 \n            a[i] -= 3\n\
    \    return a.len()\nend ", "    arr = [1 .. n] \n    count = 0\n    for i in\
    \ arr \n        for j in arr \n            for k in arr \n                if i+j+k\
    \ mod 3 == 0\n                    count += 1\n    return count", "\"\"\"\n   \
    \ You are given a positive integer n. You have to create an integer vector a of\
    \ length n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i *\
    \ i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where\
    \ i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.", "    a_array =\
    \ Array(Any,n)\n    for i in 1:n\n        a_array[i] = i*i-1+i\n    end\n    count\
    \ = 0\n    for i in 1:n\n        for j in i+1:n\n            for k in j+1:n\n\
    \                if a_array[i] + a_array[j] + a_array[k] == 3*i\n            \
    \        count += 1\n                end\n            end\n        end\n    end\n\
    \    return count\nend\n</cell>\n<text>\nSolution 3", "    a = [(i * i - i + 1)\
    \ for i in 1:n] \n    for i in 2:(n-1)\n        for j in i:(n-i)\n           \
    \ if i + j + k == 3 && a[i+j+k] == a[i] && a[i+j+k] == a[j] && a[i+j+k] == a[k]\n\
    \                return i+j+k\n    end\n    return 0\nend\n\"\"\"\n    You are\
    \ given a positive integer n and an integer k from 1 to n. You have to create\
    \ a vector\n        of length n containing elements from 1 to k.\n        For\
    \ each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Your\
    \ task is to remove duplicates from this vector and return the vector with all\
    \ \n        duplicates removed. The returned vector should not contain any leading\
    \ or trailing \n        duplicates. \n        In other words, no element should\
    \ appear more than once in the returned vector.", "    n=Int(n)\n    count=0\n\
    \    for i=1:n\n        for j=i+1:n\n            for k=j+1:n\n               \
    \ if(i+j+k==n and i*j*k==n*n)\n                count+=1\n    end\n    return count\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease explain your code, or give a\
    \ link to a source that does.\n<|/ c |>\n<| a tags=julia,for-loop,arrays,performance,loops\
    \ |>\nI did some time comparison between different methods. I wanted to compare\
    \ the performances of different programming languages. I used different techniques.\
    \ I used Julia, R, and C. Julia is my favourite one as it is much faster. You\
    \ can download it here.\n<code>\nusing BenchmarkTools", "    if n < 1 \n     \
    \   then return 0\n    \n    else \n        return get_triples(n) \nend", "  \
    \  if n==0 || n==1\n        return 1\n    else if n==2\n        return 3\n   \
    \ else if n % 2 == 0\n        return get_max_triples(n-1) + get_max_triples(n-2)\
    \ \n    else\n        return get_max_triples(n-1) + 3*get_max_triples(n-2)\n \
    \   end\nend\n</cell>\n<text>\nget_max_tripples(3)\n</cell>\n<code language=julia-1.5>\n\
    get_max_triples(3)\n</cell>\n<text>\nSolution using Dynamic Programming", "  \
    \  a = []\n    for  i in 1:n\n        a[i] = i * i - i + 1\n    \n    for i in\
    \ 2:n\n        j = i\n        k = i - 1\n        while  j <  k\n            if\
    \ a[i] + a[j] + a[k] == 0\n                return 0\n            else\n      \
    \          j += 1\n            end\n            k += 1\n        end\n    end\n\
    \    return 1\nend\n</cell>\n<code language=julia-1.3>\nget_max_triples(5)\n</cell>\n\
    <text>\nTask 4.2\nWrite a Julia function that returns the number of integers (not\
    \ floats!) that are factors of n. The function should take one argument, n, and\
    \ return an Int64.", "    \n    a = [1,3,7,13,21]\n    cnt = 0\n    \n    for\
    \ i in 1..n\n        for j in i+1..n\n            for k in j+1..n\n          \
    \      if a[i] == a[j] + a[k]\n                    cnt += 1\n    \n    return\
    \ cnt\nend ", "    a_vec = Vector{Int}(undef, n)\n    for i in 1:n\n        a_vec[i]\
    \ = i * i - i + 1\n    end\n    for i in 1:n\n        for j in 1:i\n         \
    \   for k in 1:j\n                if a_vec[i] + a_vec[j] + a_vec[k] % 3 == 0\n\
    \                else\n                    return 0\n                end\n   \
    \         end\n        end\n    end\n    return 1\nend\n</cell>\n<text>\n2. Test\
    \ your code\nRun the cell below to test get_max_triples function defined above.\
    \ Make sure it returns the right value.", "    \n    get_max_triples_count = 0.0\n\
    \    for i in 0..n-1\n        for j in (i+1)..n\n            get_max_triples_count\
    \ += (a[i], a[j], a[k]) where i < j < k\n    end\n    get_max_triples_count\n\
    end\n</cell>\n<text>\nLet's try it.", "\"\"\"\n    You are given a positive integer\
    \ n. You have to create an integer vector a of length n.\n        For each i (1\
    \ \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number\
    \ of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] +\
    \ a[k] is a multiple of 3.", "    \"\"\"\n    >>> get_max_triples(5)\n    1\n\
    \        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid\
    \ triple is (1, 7, 13).\n    \"\"\"\n    \n    count = 0\n    for i in 1:n\n \
    \       for j in 1:i\n            if i==j\n                count += 1\n      \
    \      else\n                count += 1\n        end\n    end\n    return count\n\
    end", "    if n == 0 \n        return 0 \n    if n == 1 \n        return 1 \n\
    \    a = [1 for i in 1..n] \n    for i in 2..n \n        j = n - i - 1 \n    \
    \    if a[i] == 0 \n            a[i] = i * i - i + 1 \n        else \n       \
    \     a[i] = a[i] + a[j] \n    if a[1] \n        return 1 \n    return a[1] +\
    \ a[2] + a[3] \nend\n</cell>\n<text>\nThis code is from the book: \n \n \n \n\
    \ \n ", "    count = 0\n    l = Vector{Int64}(undef,n)\n    for i in 1:n\n   \
    \     l[i] = i * i - i + 1\n    end\n    for a in l\n        if (a[1] + a[2] +\
    \ a[3]) == 0 && (a[1] + a[3] + a[4]) == 0 && (a[2] + a[3] + a[5]) == 0 && (a[3]\
    \ + a[4] + a[5]) == 0\n            count += 1\n        end\n    end\n    return\
    \ count\nend\n</cell>\n<code language=julia-1.5>\nget_max_triples(5)\n</cell>\n\
    <text>\nWe have all the ingredients to solve the problem! We now just need to\
    \ implement a basic function to create the vector a and use the functions we developed\
    \ in the previous cells to do it."]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
